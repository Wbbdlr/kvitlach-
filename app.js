(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/topbar/topbar.min.js
  var require_topbar_min = __commonJS({
    "node_modules/topbar/topbar.min.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        !function() {
          for (var lastTime = 0, vendors = ["ms", "moz", "webkit", "o"], x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x)
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"], window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          window2.requestAnimationFrame || (window2.requestAnimationFrame = function(callback, element) {
            var currTime = (/* @__PURE__ */ new Date()).getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window2.setTimeout(function() {
              callback(currTime + timeToCall);
            }, timeToCall);
            return lastTime = currTime + timeToCall, id;
          }), window2.cancelAnimationFrame || (window2.cancelAnimationFrame = function(id) {
            clearTimeout(id);
          });
        }();
        function repaint() {
          canvas.width = window2.innerWidth, canvas.height = 5 * options.barThickness;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur, ctx.shadowColor = options.shadowColor;
          var stop, lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness, ctx.beginPath(), ctx.moveTo(0, options.barThickness / 2), ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2), ctx.strokeStyle = lineGradient, ctx.stroke();
        }
        var canvas, progressTimerId, fadeTimerId, currentProgress, showing, options = { autoRun: true, barThickness: 3, barColors: { 0: "rgba(26,  188, 156, .9)", ".25": "rgba(52,  152, 219, .9)", ".50": "rgba(241, 196, 15,  .9)", ".75": "rgba(230, 126, 34,  .9)", "1.0": "rgba(211, 84,  0,   .9)" }, shadowBlur: 10, shadowColor: "rgba(0,   0,   0,   .6)", className: null }, topbar2 = { config: function(opts) {
          for (var key in opts)
            options.hasOwnProperty(key) && (options[key] = opts[key]);
        }, show: function() {
          var type, handler3, elem;
          showing || (showing = true, null !== fadeTimerId && window2.cancelAnimationFrame(fadeTimerId), canvas || ((elem = (canvas = document2.createElement("canvas")).style).position = "fixed", elem.top = elem.left = elem.right = elem.margin = elem.padding = 0, elem.zIndex = 100001, elem.display = "none", options.className && canvas.classList.add(options.className), document2.body.appendChild(canvas), type = "resize", handler3 = repaint, (elem = window2).addEventListener ? elem.addEventListener(type, handler3, false) : elem.attachEvent ? elem.attachEvent("on" + type, handler3) : elem["on" + type] = handler3), canvas.style.opacity = 1, canvas.style.display = "block", topbar2.progress(0), options.autoRun && function loop3() {
            progressTimerId = window2.requestAnimationFrame(loop3), topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
          }());
        }, progress: function(to) {
          return void 0 === to || ("string" == typeof to && (to = (0 <= to.indexOf("+") || 0 <= to.indexOf("-") ? currentProgress : 0) + parseFloat(to)), currentProgress = 1 < to ? 1 : to, repaint()), currentProgress;
        }, hide: function() {
          showing && (showing = false, null != progressTimerId && (window2.cancelAnimationFrame(progressTimerId), progressTimerId = null), function loop3() {
            return 1 <= topbar2.progress("+.1") && (canvas.style.opacity -= 0.05, canvas.style.opacity <= 0.05) ? (canvas.style.display = "none", void (fadeTimerId = null)) : void (fadeTimerId = window2.requestAnimationFrame(loop3));
          }());
        } };
        "object" == typeof module && "object" == typeof module.exports ? module.exports = topbar2 : "function" == typeof define && define.amd ? define(function() {
          return topbar2;
        }) : this.topbar = topbar2;
      }).call(exports, window, document);
    }
  });

  // node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js
  var require_AgoraRTC_N_production = __commonJS({
    "node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js"(exports, module) {
      !function(e, t) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();
      }(exports, function() {
        "use strict";
        function e(e2, t2) {
          return t2.forEach(function(t3) {
            t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach(function(i2) {
              if ("default" !== i2 && !(i2 in e2)) {
                var n2 = Object.getOwnPropertyDescriptor(t3, i2);
                Object.defineProperty(e2, i2, n2.get ? n2 : { enumerable: true, get: function() {
                  return t3[i2];
                } });
              }
            });
          }), Object.freeze(e2);
        }
        let t = true, i = true;
        function n(e2, t2, i2) {
          const n2 = e2.match(t2);
          return n2 && n2.length >= i2 && parseInt(n2[i2], 10);
        }
        function r(e2, t2, i2) {
          if (!e2.RTCPeerConnection)
            return;
          const n2 = e2.RTCPeerConnection.prototype, r2 = n2.addEventListener;
          n2.addEventListener = function(e3, n3) {
            if (e3 !== t2)
              return r2.apply(this, arguments);
            const s3 = (e4) => {
              const t3 = i2(e4);
              t3 && (n3.handleEvent ? n3.handleEvent(t3) : n3(t3));
            };
            return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(n3, s3), r2.apply(this, [e3, s3]);
          };
          const s2 = n2.removeEventListener;
          n2.removeEventListener = function(e3, i3) {
            if (e3 !== t2 || !this._eventMap || !this._eventMap[t2])
              return s2.apply(this, arguments);
            if (!this._eventMap[t2].has(i3))
              return s2.apply(this, arguments);
            const n3 = this._eventMap[t2].get(i3);
            return this._eventMap[t2].delete(i3), 0 === this._eventMap[t2].size && delete this._eventMap[t2], 0 === Object.keys(this._eventMap).length && delete this._eventMap, s2.apply(this, [e3, n3]);
          }, Object.defineProperty(n2, "on" + t2, { get() {
            return this["_on" + t2];
          }, set(e3) {
            this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
          }, enumerable: true, configurable: true });
        }
        function s(e2) {
          return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (t = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
        }
        function o(e2) {
          return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (i = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
        }
        function a() {
          if ("object" == typeof window) {
            if (t)
              return;
            "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
          }
        }
        function c(e2, t2) {
          i && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
        }
        function d(e2) {
          return "[object Object]" === Object.prototype.toString.call(e2);
        }
        function l(e2) {
          return d(e2) ? Object.keys(e2).reduce(function(t2, i2) {
            const n2 = d(e2[i2]), r2 = n2 ? l(e2[i2]) : e2[i2], s2 = n2 && !Object.keys(r2).length;
            return void 0 === r2 || s2 ? t2 : Object.assign(t2, { [i2]: r2 });
          }, {}) : e2;
        }
        function h(e2, t2, i2) {
          t2 && !i2.has(t2.id) && (i2.set(t2.id, t2), Object.keys(t2).forEach((n2) => {
            n2.endsWith("Id") ? h(e2, e2.get(t2[n2]), i2) : n2.endsWith("Ids") && t2[n2].forEach((t3) => {
              h(e2, e2.get(t3), i2);
            });
          }));
        }
        function u(e2, t2, i2) {
          const n2 = i2 ? "outbound-rtp" : "inbound-rtp", r2 = /* @__PURE__ */ new Map();
          if (null === t2)
            return r2;
          const s2 = [];
          return e2.forEach((e3) => {
            "track" === e3.type && e3.trackIdentifier === t2.id && s2.push(e3);
          }), s2.forEach((t3) => {
            e2.forEach((i3) => {
              i3.type === n2 && i3.trackId === t3.id && h(e2, i3, r2);
            });
          }), r2;
        }
        const p = a;
        function _(e2, t2) {
          const i2 = e2 && e2.navigator;
          if (!i2.mediaDevices)
            return;
          const n2 = function(e3) {
            if ("object" != typeof e3 || e3.mandatory || e3.optional)
              return e3;
            const t3 = {};
            return Object.keys(e3).forEach((i3) => {
              if ("require" === i3 || "advanced" === i3 || "mediaSource" === i3)
                return;
              const n3 = "object" == typeof e3[i3] ? e3[i3] : { ideal: e3[i3] };
              void 0 !== n3.exact && "number" == typeof n3.exact && (n3.min = n3.max = n3.exact);
              const r3 = function(e4, t4) {
                return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
              };
              if (void 0 !== n3.ideal) {
                t3.optional = t3.optional || [];
                let e4 = {};
                "number" == typeof n3.ideal ? (e4[r3("min", i3)] = n3.ideal, t3.optional.push(e4), e4 = {}, e4[r3("max", i3)] = n3.ideal, t3.optional.push(e4)) : (e4[r3("", i3)] = n3.ideal, t3.optional.push(e4));
              }
              void 0 !== n3.exact && "number" != typeof n3.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3("", i3)] = n3.exact) : ["min", "max"].forEach((e4) => {
                void 0 !== n3[e4] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3(e4, i3)] = n3[e4]);
              });
            }), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
          }, r2 = function(e3, r3) {
            if (t2.version >= 61)
              return r3(e3);
            if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
              const t3 = function(e4, t4, i3) {
                t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
              };
              t3((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t3(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = n2(e3.audio);
            }
            if (e3 && "object" == typeof e3.video) {
              let s3 = e3.video.facingMode;
              s3 = s3 && ("object" == typeof s3 ? s3 : { ideal: s3 });
              const o2 = t2.version < 66;
              if (s3 && ("user" === s3.exact || "environment" === s3.exact || "user" === s3.ideal || "environment" === s3.ideal) && (!i2.mediaDevices.getSupportedConstraints || !i2.mediaDevices.getSupportedConstraints().facingMode || o2)) {
                let t3;
                if (delete e3.video.facingMode, "environment" === s3.exact || "environment" === s3.ideal ? t3 = ["back", "rear"] : "user" !== s3.exact && "user" !== s3.ideal || (t3 = ["front"]), t3)
                  return i2.mediaDevices.enumerateDevices().then((i3) => {
                    let o3 = (i3 = i3.filter((e4) => "videoinput" === e4.kind)).find((e4) => t3.some((t4) => e4.label.toLowerCase().includes(t4)));
                    return !o3 && i3.length && t3.includes("back") && (o3 = i3[i3.length - 1]), o3 && (e3.video.deviceId = s3.exact ? { exact: o3.deviceId } : { ideal: o3.deviceId }), e3.video = n2(e3.video), p("chrome: " + JSON.stringify(e3)), r3(e3);
                  });
              }
              e3.video = n2(e3.video);
            }
            return p("chrome: " + JSON.stringify(e3)), r3(e3);
          }, s2 = function(e3) {
            return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
              return this.name + (this.message && ": ") + this.message;
            } };
          };
          if (i2.getUserMedia = function(e3, t3, n3) {
            r2(e3, (e4) => {
              i2.webkitGetUserMedia(e4, t3, (e5) => {
                n3 && n3(s2(e5));
              });
            });
          }.bind(i2), i2.mediaDevices.getUserMedia) {
            const e3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
            i2.mediaDevices.getUserMedia = function(t3) {
              return r2(t3, (t4) => e3(t4).then((e4) => {
                if (t4.audio && !e4.getAudioTracks().length || t4.video && !e4.getVideoTracks().length)
                  throw e4.getTracks().forEach((e5) => {
                    e5.stop();
                  }), new DOMException("", "NotFoundError");
                return e4;
              }, (e4) => Promise.reject(s2(e4))));
            };
          }
        }
        function E(e2) {
          e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
        }
        function m(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
            Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
              return this._ontrack;
            }, set(e3) {
              this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
            }, enumerable: true, configurable: true });
            const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
            e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
              return this._ontrackpoly || (this._ontrackpoly = (t3) => {
                t3.stream.addEventListener("addtrack", (i2) => {
                  let n2;
                  n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.track.id) : { track: i2.track };
                  const r2 = new Event("track");
                  r2.track = i2.track, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
                }), t3.stream.getTracks().forEach((i2) => {
                  let n2;
                  n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.id) : { track: i2 };
                  const r2 = new Event("track");
                  r2.track = i2, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
                });
              }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
            };
          } else
            r(e2, "track", (e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3));
        }
        function f(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
            const t2 = function(e3, t3) {
              return { track: t3, get dtmf() {
                return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
              }, _pc: e3 };
            };
            if (!e2.RTCPeerConnection.prototype.getSenders) {
              e2.RTCPeerConnection.prototype.getSenders = function() {
                return this._senders = this._senders || [], this._senders.slice();
              };
              const i3 = e2.RTCPeerConnection.prototype.addTrack;
              e2.RTCPeerConnection.prototype.addTrack = function(e3, n4) {
                let r2 = i3.apply(this, arguments);
                return r2 || (r2 = t2(this, e3), this._senders.push(r2)), r2;
              };
              const n3 = e2.RTCPeerConnection.prototype.removeTrack;
              e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
                n3.apply(this, arguments);
                const t3 = this._senders.indexOf(e3);
                -1 !== t3 && this._senders.splice(t3, 1);
              };
            }
            const i2 = e2.RTCPeerConnection.prototype.addStream;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              this._senders = this._senders || [], i2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
                this._senders.push(t2(this, e4));
              });
            };
            const n2 = e2.RTCPeerConnection.prototype.removeStream;
            e2.RTCPeerConnection.prototype.removeStream = function(e3) {
              this._senders = this._senders || [], n2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
                const t3 = this._senders.find((t4) => t4.track === e4);
                t3 && this._senders.splice(this._senders.indexOf(t3), 1);
              });
            };
          } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
            const t2 = e2.RTCPeerConnection.prototype.getSenders;
            e2.RTCPeerConnection.prototype.getSenders = function() {
              const e3 = t2.apply(this, []);
              return e3.forEach((e4) => e4._pc = this), e3;
            }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
              return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
            } });
          }
        }
        function g(e2) {
          if (!e2.RTCPeerConnection)
            return;
          const t2 = e2.RTCPeerConnection.prototype.getStats;
          e2.RTCPeerConnection.prototype.getStats = function() {
            const [e3, i2, n2] = arguments;
            if (arguments.length > 0 && "function" == typeof e3)
              return t2.apply(this, arguments);
            if (0 === t2.length && (0 === arguments.length || "function" != typeof e3))
              return t2.apply(this, []);
            const r2 = function(e4) {
              const t3 = {};
              return e4.result().forEach((e5) => {
                const i3 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
                e5.names().forEach((t4) => {
                  i3[t4] = e5.stat(t4);
                }), t3[i3.id] = i3;
              }), t3;
            }, s2 = function(e4) {
              return new Map(Object.keys(e4).map((t3) => [t3, e4[t3]]));
            };
            if (arguments.length >= 2) {
              const n3 = function(e4) {
                i2(s2(r2(e4)));
              };
              return t2.apply(this, [n3, e3]);
            }
            return new Promise((e4, i3) => {
              t2.apply(this, [function(t3) {
                e4(s2(r2(t3)));
              }, i3]);
            }).then(i2, n2);
          };
        }
        function T(e2) {
          if (!("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver))
            return;
          if (!("getStats" in e2.RTCRtpSender.prototype)) {
            const t3 = e2.RTCPeerConnection.prototype.getSenders;
            t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
              const e3 = t3.apply(this, []);
              return e3.forEach((e4) => e4._pc = this), e3;
            });
            const i2 = e2.RTCPeerConnection.prototype.addTrack;
            i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
              const e3 = i2.apply(this, arguments);
              return e3._pc = this, e3;
            }), e2.RTCRtpSender.prototype.getStats = function() {
              const e3 = this;
              return this._pc.getStats().then((t4) => u(t4, e3.track, true));
            };
          }
          if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
            const t3 = e2.RTCPeerConnection.prototype.getReceivers;
            t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
              const e3 = t3.apply(this, []);
              return e3.forEach((e4) => e4._pc = this), e3;
            }), r(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
              const e3 = this;
              return this._pc.getStats().then((t4) => u(t4, e3.track, false));
            };
          }
          if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype))
            return;
          const t2 = e2.RTCPeerConnection.prototype.getStats;
          e2.RTCPeerConnection.prototype.getStats = function() {
            if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
              const e3 = arguments[0];
              let t3, i2, n2;
              return this.getSenders().forEach((i3) => {
                i3.track === e3 && (t3 ? n2 = true : t3 = i3);
              }), this.getReceivers().forEach((t4) => (t4.track === e3 && (i2 ? n2 = true : i2 = t4), t4.track === e3)), n2 || t3 && i2 ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : i2 ? i2.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
            }
            return t2.apply(this, arguments);
          };
        }
        function S(e2) {
          e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e3) => this._shimmedLocalStreams[e3][0]);
          };
          const t2 = e2.RTCPeerConnection.prototype.addTrack;
          e2.RTCPeerConnection.prototype.addTrack = function(e3, i3) {
            if (!i3)
              return t2.apply(this, arguments);
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            const n3 = t2.apply(this, arguments);
            return this._shimmedLocalStreams[i3.id] ? -1 === this._shimmedLocalStreams[i3.id].indexOf(n3) && this._shimmedLocalStreams[i3.id].push(n3) : this._shimmedLocalStreams[i3.id] = [i3, n3], n3;
          };
          const i2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach((e4) => {
              if (this.getSenders().find((t4) => t4.track === e4))
                throw new DOMException("Track already exists.", "InvalidAccessError");
            });
            const t3 = this.getSenders();
            i2.apply(this, arguments);
            const n3 = this.getSenders().filter((e4) => -1 === t3.indexOf(e4));
            this._shimmedLocalStreams[e3.id] = [e3].concat(n3);
          };
          const n2 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], n2.apply(this, arguments);
          };
          const r2 = e2.RTCPeerConnection.prototype.removeTrack;
          e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach((t3) => {
              const i3 = this._shimmedLocalStreams[t3].indexOf(e3);
              -1 !== i3 && this._shimmedLocalStreams[t3].splice(i3, 1), 1 === this._shimmedLocalStreams[t3].length && delete this._shimmedLocalStreams[t3];
            }), r2.apply(this, arguments);
          };
        }
        function R(e2, t2) {
          if (!e2.RTCPeerConnection)
            return;
          if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65)
            return S(e2);
          const i2 = e2.RTCPeerConnection.prototype.getLocalStreams;
          e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            const e3 = i2.apply(this);
            return this._reverseStreams = this._reverseStreams || {}, e3.map((e4) => this._reverseStreams[e4.id]);
          };
          const n2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(t3) {
            if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach((e3) => {
              if (this.getSenders().find((t4) => t4.track === e3))
                throw new DOMException("Track already exists.", "InvalidAccessError");
            }), !this._reverseStreams[t3.id]) {
              const i3 = new e2.MediaStream(t3.getTracks());
              this._streams[t3.id] = i3, this._reverseStreams[i3.id] = t3, t3 = i3;
            }
            n2.apply(this, [t3]);
          };
          const r2 = e2.RTCPeerConnection.prototype.removeStream;
          function s2(e3, t3) {
            let i3 = t3.sdp;
            return Object.keys(e3._reverseStreams || []).forEach((t4) => {
              const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
              i3 = i3.replace(new RegExp(r3.id, "g"), n3.id);
            }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
          }
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
          }, e2.RTCPeerConnection.prototype.addTrack = function(t3, i3) {
            if ("closed" === this.signalingState)
              throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
            const n3 = [].slice.call(arguments, 1);
            if (1 !== n3.length || !n3[0].getTracks().find((e3) => e3 === t3))
              throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
            if (this.getSenders().find((e3) => e3.track === t3))
              throw new DOMException("Track already exists.", "InvalidAccessError");
            this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
            const r3 = this._streams[i3.id];
            if (r3)
              r3.addTrack(t3), Promise.resolve().then(() => {
                this.dispatchEvent(new Event("negotiationneeded"));
              });
            else {
              const n4 = new e2.MediaStream([t3]);
              this._streams[i3.id] = n4, this._reverseStreams[n4.id] = i3, this.addStream(n4);
            }
            return this.getSenders().find((e3) => e3.track === t3);
          }, ["createOffer", "createAnswer"].forEach(function(t3) {
            const i3 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
              const e3 = arguments;
              return arguments.length && "function" == typeof arguments[0] ? i3.apply(this, [(t4) => {
                const i4 = s2(this, t4);
                e3[0].apply(null, [i4]);
              }, (t4) => {
                e3[1] && e3[1].apply(null, t4);
              }, arguments[2]]) : i3.apply(this, arguments).then((e4) => s2(this, e4));
            } };
            e2.RTCPeerConnection.prototype[t3] = n3[t3];
          });
          const o2 = e2.RTCPeerConnection.prototype.setLocalDescription;
          e2.RTCPeerConnection.prototype.setLocalDescription = function() {
            return arguments.length && arguments[0].type ? (arguments[0] = function(e3, t3) {
              let i3 = t3.sdp;
              return Object.keys(e3._reverseStreams || []).forEach((t4) => {
                const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
                i3 = i3.replace(new RegExp(n3.id, "g"), r3.id);
              }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
            }(this, arguments[0]), o2.apply(this, arguments)) : o2.apply(this, arguments);
          };
          const a2 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
          Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
            const e3 = a2.get.apply(this);
            return "" === e3.type ? e3 : s2(this, e3);
          } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
            if ("closed" === this.signalingState)
              throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
            if (!e3._pc)
              throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
            if (!(e3._pc === this))
              throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
            let t3;
            this._streams = this._streams || {}, Object.keys(this._streams).forEach((i3) => {
              this._streams[i3].getTracks().find((t4) => e3.track === t4) && (t3 = this._streams[i3]);
            }), t3 && (1 === t3.getTracks().length ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
          };
        }
        function C(e2, t2) {
          !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
            const i2 = e2.RTCPeerConnection.prototype[t3], n2 = { [t3]() {
              return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i2.apply(this, arguments);
            } };
            e2.RTCPeerConnection.prototype[t3] = n2[t3];
          });
        }
        function v(e2, t2) {
          r(e2, "negotiationneeded", (e3) => {
            const i2 = e3.target;
            if (!(t2.version < 72 || i2.getConfiguration && "plan-b" === i2.getConfiguration().sdpSemantics) || "stable" === i2.signalingState)
              return e3;
          });
        }
        var I = Object.freeze({ __proto__: null, fixNegotiationNeeded: v, shimAddTrackRemoveTrack: R, shimAddTrackRemoveTrackWithNative: S, shimGetDisplayMedia: function(e2, t2) {
          e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && ("function" == typeof t2 ? e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
            return t2(i2).then((t3) => {
              const n2 = i2.video && i2.video.width, r2 = i2.video && i2.video.height, s2 = i2.video && i2.video.frameRate;
              return i2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: s2 || 3 } }, n2 && (i2.video.mandatory.maxWidth = n2), r2 && (i2.video.mandatory.maxHeight = r2), e2.navigator.mediaDevices.getUserMedia(i2);
            });
          } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
        }, shimGetSendersWithDtmf: f, shimGetStats: g, shimGetUserMedia: _, shimMediaStream: E, shimOnTrack: m, shimPeerConnection: C, shimSenderReceiverGetStats: T });
        function y(e2, t2) {
          const i2 = e2 && e2.navigator, n2 = e2 && e2.MediaStreamTrack;
          if (i2.getUserMedia = function(e3, t3, n3) {
            c("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i2.mediaDevices.getUserMedia(e3).then(t3, n3);
          }, !(t2.version > 55 && "autoGainControl" in i2.mediaDevices.getSupportedConstraints())) {
            const e3 = function(e4, t4, i3) {
              t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
            }, t3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
            if (i2.mediaDevices.getUserMedia = function(i3) {
              return "object" == typeof i3 && "object" == typeof i3.audio && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3.audio, "autoGainControl", "mozAutoGainControl"), e3(i3.audio, "noiseSuppression", "mozNoiseSuppression")), t3(i3);
            }, n2 && n2.prototype.getSettings) {
              const t4 = n2.prototype.getSettings;
              n2.prototype.getSettings = function() {
                const i3 = t4.apply(this, arguments);
                return e3(i3, "mozAutoGainControl", "autoGainControl"), e3(i3, "mozNoiseSuppression", "noiseSuppression"), i3;
              };
            }
            if (n2 && n2.prototype.applyConstraints) {
              const t4 = n2.prototype.applyConstraints;
              n2.prototype.applyConstraints = function(i3) {
                return "audio" === this.kind && "object" == typeof i3 && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3, "autoGainControl", "mozAutoGainControl"), e3(i3, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [i3]);
              };
            }
          }
        }
        function A(e2) {
          "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
            return { receiver: this.receiver };
          } });
        }
        function b(e2, t2) {
          if ("object" != typeof e2 || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection)
            return;
          !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
            const i3 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
              return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
            } };
            e2.RTCPeerConnection.prototype[t3] = n3[t3];
          });
          const i2 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n2 = e2.RTCPeerConnection.prototype.getStats;
          e2.RTCPeerConnection.prototype.getStats = function() {
            const [e3, r2, s2] = arguments;
            return n2.apply(this, [e3 || null]).then((e4) => {
              if (t2.version < 53 && !r2)
                try {
                  e4.forEach((e5) => {
                    e5.type = i2[e5.type] || e5.type;
                  });
                } catch (t3) {
                  if ("TypeError" !== t3.name)
                    throw t3;
                  e4.forEach((t4, n3) => {
                    e4.set(n3, Object.assign({}, t4, { type: i2[t4.type] || t4.type }));
                  });
                }
              return e4;
            }).then(r2, s2);
          };
        }
        function w(e2) {
          if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
            return;
          if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype)
            return;
          const t2 = e2.RTCPeerConnection.prototype.getSenders;
          t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t2.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          });
          const i2 = e2.RTCPeerConnection.prototype.addTrack;
          i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
            const e3 = i2.apply(this, arguments);
            return e3._pc = this, e3;
          }), e2.RTCRtpSender.prototype.getStats = function() {
            return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
          };
        }
        function O(e2) {
          if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
            return;
          if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype)
            return;
          const t2 = e2.RTCPeerConnection.prototype.getReceivers;
          t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
            const e3 = t2.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }), r(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
            return this._pc.getStats(this.track);
          };
        }
        function N(e2) {
          e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            c("removeStream", "removeTrack"), this.getSenders().forEach((t2) => {
              t2.track && e3.getTracks().includes(t2.track) && this.removeTrack(t2);
            });
          });
        }
        function D(e2) {
          e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
        }
        function P(e2) {
          if ("object" != typeof e2 || !e2.RTCPeerConnection)
            return;
          const t2 = e2.RTCPeerConnection.prototype.addTransceiver;
          t2 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
            this.setParametersPromises = [];
            let e3 = arguments[1] && arguments[1].sendEncodings;
            void 0 === e3 && (e3 = []), e3 = [...e3];
            const i2 = e3.length > 0;
            i2 && e3.forEach((e4) => {
              if ("rid" in e4) {
                if (!/^[a-z0-9]{0,16}$/i.test(e4.rid))
                  throw new TypeError("Invalid RID value provided.");
              }
              if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1))
                throw new RangeError("scale_resolution_down_by must be >= 1.0");
              if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0))
                throw new RangeError("max_framerate must be >= 0.0");
            });
            const n2 = t2.apply(this, arguments);
            if (i2) {
              const { sender: t3 } = n2, i3 = t3.getParameters();
              (!("encodings" in i3) || 1 === i3.encodings.length && 0 === Object.keys(i3.encodings[0]).length) && (i3.encodings = e3, t3.sendEncodings = e3, this.setParametersPromises.push(t3.setParameters(i3).then(() => {
                delete t3.sendEncodings;
              }).catch(() => {
                delete t3.sendEncodings;
              })));
            }
            return n2;
          });
        }
        function L(e2) {
          if ("object" != typeof e2 || !e2.RTCRtpSender)
            return;
          const t2 = e2.RTCRtpSender.prototype.getParameters;
          t2 && (e2.RTCRtpSender.prototype.getParameters = function() {
            const e3 = t2.apply(this, arguments);
            return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
          });
        }
        function k(e2) {
          if ("object" != typeof e2 || !e2.RTCPeerConnection)
            return;
          const t2 = e2.RTCPeerConnection.prototype.createOffer;
          e2.RTCPeerConnection.prototype.createOffer = function() {
            return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
              this.setParametersPromises = [];
            }) : t2.apply(this, arguments);
          };
        }
        function M(e2) {
          if ("object" != typeof e2 || !e2.RTCPeerConnection)
            return;
          const t2 = e2.RTCPeerConnection.prototype.createAnswer;
          e2.RTCPeerConnection.prototype.createAnswer = function() {
            return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
              this.setParametersPromises = [];
            }) : t2.apply(this, arguments);
          };
        }
        var U = Object.freeze({ __proto__: null, shimAddTransceiver: P, shimCreateAnswer: M, shimCreateOffer: k, shimGetDisplayMedia: function(e2, t2) {
          e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
            if (!i2 || !i2.video) {
              const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
              return e3.name = "NotFoundError", e3.code = 8, Promise.reject(e3);
            }
            return true === i2.video ? i2.video = { mediaSource: t2 } : i2.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(i2);
          });
        }, shimGetParameters: L, shimGetUserMedia: y, shimOnTrack: A, shimPeerConnection: b, shimRTCDataChannel: D, shimReceiverGetStats: O, shimRemoveStream: N, shimSenderGetStats: w });
        function x(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection) {
            if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
              return this._localStreams || (this._localStreams = []), this._localStreams;
            }), !("addStream" in e2.RTCPeerConnection.prototype)) {
              const t2 = e2.RTCPeerConnection.prototype.addTrack;
              e2.RTCPeerConnection.prototype.addStream = function(e3) {
                this._localStreams || (this._localStreams = []), this._localStreams.includes(e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach((i2) => t2.call(this, i2, e3)), e3.getVideoTracks().forEach((i2) => t2.call(this, i2, e3));
              }, e2.RTCPeerConnection.prototype.addTrack = function(e3, ...i2) {
                return i2 && i2.forEach((e4) => {
                  this._localStreams ? this._localStreams.includes(e4) || this._localStreams.push(e4) : this._localStreams = [e4];
                }), t2.apply(this, arguments);
              };
            }
            "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
              this._localStreams || (this._localStreams = []);
              const t2 = this._localStreams.indexOf(e3);
              if (-1 === t2)
                return;
              this._localStreams.splice(t2, 1);
              const i2 = e3.getTracks();
              this.getSenders().forEach((e4) => {
                i2.includes(e4.track) && this.removeTrack(e4);
              });
            });
          }
        }
        function V(e2) {
          if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
            return this._remoteStreams ? this._remoteStreams : [];
          }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
            Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
              return this._onaddstream;
            }, set(e3) {
              this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
                e4.streams.forEach((e5) => {
                  if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e5))
                    return;
                  this._remoteStreams.push(e5);
                  const t3 = new Event("addstream");
                  t3.stream = e5, this.dispatchEvent(t3);
                });
              });
            } });
            const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
            e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
              const e3 = this;
              return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
                t3.streams.forEach((t4) => {
                  if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t4) >= 0)
                    return;
                  e3._remoteStreams.push(t4);
                  const i2 = new Event("addstream");
                  i2.stream = t4, e3.dispatchEvent(i2);
                });
              }), t2.apply(e3, arguments);
            };
          }
        }
        function F(e2) {
          if ("object" != typeof e2 || !e2.RTCPeerConnection)
            return;
          const t2 = e2.RTCPeerConnection.prototype, i2 = t2.createOffer, n2 = t2.createAnswer, r2 = t2.setLocalDescription, s2 = t2.setRemoteDescription, o2 = t2.addIceCandidate;
          t2.createOffer = function(e3, t3) {
            const n3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = i2.apply(this, [n3]);
            return t3 ? (r3.then(e3, t3), Promise.resolve()) : r3;
          }, t2.createAnswer = function(e3, t3) {
            const i3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = n2.apply(this, [i3]);
            return t3 ? (r3.then(e3, t3), Promise.resolve()) : r3;
          };
          let a2 = function(e3, t3, i3) {
            const n3 = r2.apply(this, [e3]);
            return i3 ? (n3.then(t3, i3), Promise.resolve()) : n3;
          };
          t2.setLocalDescription = a2, a2 = function(e3, t3, i3) {
            const n3 = s2.apply(this, [e3]);
            return i3 ? (n3.then(t3, i3), Promise.resolve()) : n3;
          }, t2.setRemoteDescription = a2, a2 = function(e3, t3, i3) {
            const n3 = o2.apply(this, [e3]);
            return i3 ? (n3.then(t3, i3), Promise.resolve()) : n3;
          }, t2.addIceCandidate = a2;
        }
        function B(e2) {
          const t2 = e2 && e2.navigator;
          if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
            const e3 = t2.mediaDevices, i2 = e3.getUserMedia.bind(e3);
            t2.mediaDevices.getUserMedia = (e4) => i2(j(e4));
          }
          !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = function(e3, i2, n2) {
            t2.mediaDevices.getUserMedia(e3).then(i2, n2);
          }.bind(t2));
        }
        function j(e2) {
          return e2 && void 0 !== e2.video ? Object.assign({}, e2, { video: l(e2.video) }) : e2;
        }
        function G(e2) {
          if (!e2.RTCPeerConnection)
            return;
          const t2 = e2.RTCPeerConnection;
          e2.RTCPeerConnection = function(e3, i2) {
            if (e3 && e3.iceServers) {
              const t3 = [];
              for (let i3 = 0; i3 < e3.iceServers.length; i3++) {
                let n2 = e3.iceServers[i3];
                !n2.hasOwnProperty("urls") && n2.hasOwnProperty("url") ? (c("RTCIceServer.url", "RTCIceServer.urls"), n2 = JSON.parse(JSON.stringify(n2)), n2.urls = n2.url, delete n2.url, t3.push(n2)) : t3.push(e3.iceServers[i3]);
              }
              e3.iceServers = t3;
            }
            return new t2(e3, i2);
          }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
        }
        function W(e2) {
          "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
            return { receiver: this.receiver };
          } });
        }
        function H(e2) {
          const t2 = e2.RTCPeerConnection.prototype.createOffer;
          e2.RTCPeerConnection.prototype.createOffer = function(e3) {
            if (e3) {
              void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
              const t3 = this.getTransceivers().find((e4) => "audio" === e4.receiver.track.kind);
              false === e3.offerToReceiveAudio && t3 ? "sendrecv" === t3.direction ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : "recvonly" === t3.direction && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : true !== e3.offerToReceiveAudio || t3 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
              const i2 = this.getTransceivers().find((e4) => "video" === e4.receiver.track.kind);
              false === e3.offerToReceiveVideo && i2 ? "sendrecv" === i2.direction ? i2.setDirection ? i2.setDirection("sendonly") : i2.direction = "sendonly" : "recvonly" === i2.direction && (i2.setDirection ? i2.setDirection("inactive") : i2.direction = "inactive") : true !== e3.offerToReceiveVideo || i2 || this.addTransceiver("video", { direction: "recvonly" });
            }
            return t2.apply(this, arguments);
          };
        }
        function K(e2) {
          "object" != typeof e2 || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
        }
        var Y = Object.freeze({ __proto__: null, shimAudioContext: K, shimCallbacksAPI: F, shimConstraints: j, shimCreateOfferLegacy: H, shimGetUserMedia: B, shimLocalStreamsAPI: x, shimRTCIceServerUrls: G, shimRemoteStreamsAPI: V, shimTrackEventTransceiver: W }), q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
        function J(e2) {
          return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
        }
        var z = { exports: {} };
        !function(e2) {
          const t2 = { generateIdentifier: function() {
            return Math.random().toString(36).substring(2, 12);
          } };
          t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
            return e3.trim().split("\n").map((e4) => e4.trim());
          }, t2.splitSections = function(e3) {
            return e3.split("\nm=").map((e4, t3) => (t3 > 0 ? "m=" + e4 : e4).trim() + "\r\n");
          }, t2.getDescription = function(e3) {
            const i2 = t2.splitSections(e3);
            return i2 && i2[0];
          }, t2.getMediaSections = function(e3) {
            const i2 = t2.splitSections(e3);
            return i2.shift(), i2;
          }, t2.matchPrefix = function(e3, i2) {
            return t2.splitLines(e3).filter((e4) => 0 === e4.indexOf(i2));
          }, t2.parseCandidate = function(e3) {
            let t3;
            t3 = 0 === e3.indexOf("a=candidate:") ? e3.substring(12).split(" ") : e3.substring(10).split(" ");
            const i2 = { foundation: t3[0], component: { 1: "rtp", 2: "rtcp" }[t3[1]] || t3[1], protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] };
            for (let e4 = 8; e4 < t3.length; e4 += 2)
              switch (t3[e4]) {
                case "raddr":
                  i2.relatedAddress = t3[e4 + 1];
                  break;
                case "rport":
                  i2.relatedPort = parseInt(t3[e4 + 1], 10);
                  break;
                case "tcptype":
                  i2.tcpType = t3[e4 + 1];
                  break;
                case "ufrag":
                  i2.ufrag = t3[e4 + 1], i2.usernameFragment = t3[e4 + 1];
                  break;
                default:
                  void 0 === i2[t3[e4]] && (i2[t3[e4]] = t3[e4 + 1]);
              }
            return i2;
          }, t2.writeCandidate = function(e3) {
            const t3 = [];
            t3.push(e3.foundation);
            const i2 = e3.component;
            "rtp" === i2 ? t3.push(1) : "rtcp" === i2 ? t3.push(2) : t3.push(i2), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
            const n2 = e3.type;
            return t3.push("typ"), t3.push(n2), "host" !== n2 && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && "tcp" === e3.protocol.toLowerCase() && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
          }, t2.parseIceOptions = function(e3) {
            return e3.substring(14).split(" ");
          }, t2.parseRtpMap = function(e3) {
            let t3 = e3.substring(9).split(" ");
            const i2 = { payloadType: parseInt(t3.shift(), 10) };
            return t3 = t3[0].split("/"), i2.name = t3[0], i2.clockRate = parseInt(t3[1], 10), i2.channels = 3 === t3.length ? parseInt(t3[2], 10) : 1, i2.numChannels = i2.channels, i2;
          }, t2.writeRtpMap = function(e3) {
            let t3 = e3.payloadType;
            void 0 !== e3.preferredPayloadType && (t3 = e3.preferredPayloadType);
            const i2 = e3.channels || e3.numChannels || 1;
            return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (1 !== i2 ? "/" + i2 : "") + "\r\n";
          }, t2.parseExtmap = function(e3) {
            const t3 = e3.substring(9).split(" ");
            return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1], attributes: t3.slice(2).join(" ") };
          }, t2.writeExtmap = function(e3) {
            return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && "sendrecv" !== e3.direction ? "/" + e3.direction : "") + " " + e3.uri + (e3.attributes ? " " + e3.attributes : "") + "\r\n";
          }, t2.parseFmtp = function(e3) {
            const t3 = {};
            let i2;
            const n2 = e3.substring(e3.indexOf(" ") + 1).split(";");
            for (let e4 = 0; e4 < n2.length; e4++)
              i2 = n2[e4].trim().split("="), t3[i2[0].trim()] = i2[1];
            return t3;
          }, t2.writeFmtp = function(e3) {
            let t3 = "", i2 = e3.payloadType;
            if (void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
              const n2 = [];
              Object.keys(e3.parameters).forEach((t4) => {
                void 0 !== e3.parameters[t4] ? n2.push(t4 + "=" + e3.parameters[t4]) : n2.push(t4);
              }), t3 += "a=fmtp:" + i2 + " " + n2.join(";") + "\r\n";
            }
            return t3;
          }, t2.parseRtcpFb = function(e3) {
            const t3 = e3.substring(e3.indexOf(" ") + 1).split(" ");
            return { type: t3.shift(), parameter: t3.join(" ") };
          }, t2.writeRtcpFb = function(e3) {
            let t3 = "", i2 = e3.payloadType;
            return void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach((e4) => {
              t3 += "a=rtcp-fb:" + i2 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
            }), t3;
          }, t2.parseSsrcMedia = function(e3) {
            const t3 = e3.indexOf(" "), i2 = { ssrc: parseInt(e3.substring(7, t3), 10) }, n2 = e3.indexOf(":", t3);
            return n2 > -1 ? (i2.attribute = e3.substring(t3 + 1, n2), i2.value = e3.substring(n2 + 1)) : i2.attribute = e3.substring(t3 + 1), i2;
          }, t2.parseSsrcGroup = function(e3) {
            const t3 = e3.substring(13).split(" ");
            return { semantics: t3.shift(), ssrcs: t3.map((e4) => parseInt(e4, 10)) };
          }, t2.getMid = function(e3) {
            const i2 = t2.matchPrefix(e3, "a=mid:")[0];
            if (i2)
              return i2.substring(6);
          }, t2.parseFingerprint = function(e3) {
            const t3 = e3.substring(14).split(" ");
            return { algorithm: t3[0].toLowerCase(), value: t3[1].toUpperCase() };
          }, t2.getDtlsParameters = function(e3, i2) {
            return { role: "auto", fingerprints: t2.matchPrefix(e3 + i2, "a=fingerprint:").map(t2.parseFingerprint) };
          }, t2.writeDtlsParameters = function(e3, t3) {
            let i2 = "a=setup:" + t3 + "\r\n";
            return e3.fingerprints.forEach((e4) => {
              i2 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
            }), i2;
          }, t2.parseCryptoLine = function(e3) {
            const t3 = e3.substring(9).split(" ");
            return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
          }, t2.writeCryptoLine = function(e3) {
            return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + ("object" == typeof e3.keyParams ? t2.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
          }, t2.parseCryptoKeyParams = function(e3) {
            if (0 !== e3.indexOf("inline:"))
              return null;
            const t3 = e3.substring(7).split("|");
            return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
          }, t2.writeCryptoKeyParams = function(e3) {
            return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
          }, t2.getCryptoParameters = function(e3, i2) {
            return t2.matchPrefix(e3 + i2, "a=crypto:").map(t2.parseCryptoLine);
          }, t2.getIceParameters = function(e3, i2) {
            const n2 = t2.matchPrefix(e3 + i2, "a=ice-ufrag:")[0], r2 = t2.matchPrefix(e3 + i2, "a=ice-pwd:")[0];
            return n2 && r2 ? { usernameFragment: n2.substring(12), password: r2.substring(10) } : null;
          }, t2.writeIceParameters = function(e3) {
            let t3 = "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
            return e3.iceLite && (t3 += "a=ice-lite\r\n"), t3;
          }, t2.parseRtpParameters = function(e3) {
            const i2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n2 = t2.splitLines(e3)[0].split(" ");
            i2.profile = n2[2];
            for (let r3 = 3; r3 < n2.length; r3++) {
              const s2 = n2[r3], o2 = t2.matchPrefix(e3, "a=rtpmap:" + s2 + " ")[0];
              if (o2) {
                const n3 = t2.parseRtpMap(o2), r4 = t2.matchPrefix(e3, "a=fmtp:" + s2 + " ");
                switch (n3.parameters = r4.length ? t2.parseFmtp(r4[0]) : {}, n3.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + s2 + " ").map(t2.parseRtcpFb), i2.codecs.push(n3), n3.name.toUpperCase()) {
                  case "RED":
                  case "ULPFEC":
                    i2.fecMechanisms.push(n3.name.toUpperCase());
                }
              }
            }
            t2.matchPrefix(e3, "a=extmap:").forEach((e4) => {
              i2.headerExtensions.push(t2.parseExtmap(e4));
            });
            const r2 = t2.matchPrefix(e3, "a=rtcp-fb:* ").map(t2.parseRtcpFb);
            return i2.codecs.forEach((e4) => {
              r2.forEach((t3) => {
                e4.rtcpFeedback.find((e5) => e5.type === t3.type && e5.parameter === t3.parameter) || e4.rtcpFeedback.push(t3);
              });
            }), i2;
          }, t2.writeRtpDescription = function(e3, i2) {
            let n2 = "";
            n2 += "m=" + e3 + " ", n2 += i2.codecs.length > 0 ? "9" : "0", n2 += " " + (i2.profile || "UDP/TLS/RTP/SAVPF") + " ", n2 += i2.codecs.map((e4) => void 0 !== e4.preferredPayloadType ? e4.preferredPayloadType : e4.payloadType).join(" ") + "\r\n", n2 += "c=IN IP4 0.0.0.0\r\n", n2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i2.codecs.forEach((e4) => {
              n2 += t2.writeRtpMap(e4), n2 += t2.writeFmtp(e4), n2 += t2.writeRtcpFb(e4);
            });
            let r2 = 0;
            return i2.codecs.forEach((e4) => {
              e4.maxptime > r2 && (r2 = e4.maxptime);
            }), r2 > 0 && (n2 += "a=maxptime:" + r2 + "\r\n"), i2.headerExtensions && i2.headerExtensions.forEach((e4) => {
              n2 += t2.writeExtmap(e4);
            }), n2;
          }, t2.parseRtpEncodingParameters = function(e3) {
            const i2 = [], n2 = t2.parseRtpParameters(e3), r2 = -1 !== n2.fecMechanisms.indexOf("RED"), s2 = -1 !== n2.fecMechanisms.indexOf("ULPFEC"), o2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute), a2 = o2.length > 0 && o2[0].ssrc;
            let c2;
            const d2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map((e4) => e4.substring(17).split(" ").map((e5) => parseInt(e5, 10)));
            d2.length > 0 && d2[0].length > 1 && d2[0][0] === a2 && (c2 = d2[0][1]), n2.codecs.forEach((e4) => {
              if ("RTX" === e4.name.toUpperCase() && e4.parameters.apt) {
                let t3 = { ssrc: a2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
                a2 && c2 && (t3.rtx = { ssrc: c2 }), i2.push(t3), r2 && (t3 = JSON.parse(JSON.stringify(t3)), t3.fec = { ssrc: a2, mechanism: s2 ? "red+ulpfec" : "red" }, i2.push(t3));
              }
            }), 0 === i2.length && a2 && i2.push({ ssrc: a2 });
            let l2 = t2.matchPrefix(e3, "b=");
            return l2.length && (l2 = 0 === l2[0].indexOf("b=TIAS:") ? parseInt(l2[0].substring(7), 10) : 0 === l2[0].indexOf("b=AS:") ? 1e3 * parseInt(l2[0].substring(5), 10) * 0.95 - 16e3 : void 0, i2.forEach((e4) => {
              e4.maxBitrate = l2;
            })), i2;
          }, t2.parseRtcpParameters = function(e3) {
            const i2 = {}, n2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute)[0];
            n2 && (i2.cname = n2.value, i2.ssrc = n2.ssrc);
            const r2 = t2.matchPrefix(e3, "a=rtcp-rsize");
            i2.reducedSize = r2.length > 0, i2.compound = 0 === r2.length;
            const s2 = t2.matchPrefix(e3, "a=rtcp-mux");
            return i2.mux = s2.length > 0, i2;
          }, t2.writeRtcpParameters = function(e3) {
            let t3 = "";
            return e3.reducedSize && (t3 += "a=rtcp-rsize\r\n"), e3.mux && (t3 += "a=rtcp-mux\r\n"), void 0 !== e3.ssrc && e3.cname && (t3 += "a=ssrc:" + e3.ssrc + " cname:" + e3.cname + "\r\n"), t3;
          }, t2.parseMsid = function(e3) {
            let i2;
            const n2 = t2.matchPrefix(e3, "a=msid:");
            if (1 === n2.length)
              return i2 = n2[0].substring(7).split(" "), { stream: i2[0], track: i2[1] };
            const r2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "msid" === e4.attribute);
            return r2.length > 0 ? (i2 = r2[0].value.split(" "), { stream: i2[0], track: i2[1] }) : void 0;
          }, t2.parseSctpDescription = function(e3) {
            const i2 = t2.parseMLine(e3), n2 = t2.matchPrefix(e3, "a=max-message-size:");
            let r2;
            n2.length > 0 && (r2 = parseInt(n2[0].substring(19), 10)), isNaN(r2) && (r2 = 65536);
            const s2 = t2.matchPrefix(e3, "a=sctp-port:");
            if (s2.length > 0)
              return { port: parseInt(s2[0].substring(12), 10), protocol: i2.fmt, maxMessageSize: r2 };
            const o2 = t2.matchPrefix(e3, "a=sctpmap:");
            if (o2.length > 0) {
              const e4 = o2[0].substring(10).split(" ");
              return { port: parseInt(e4[0], 10), protocol: e4[1], maxMessageSize: r2 };
            }
          }, t2.writeSctpDescription = function(e3, t3) {
            let i2 = [];
            return i2 = "DTLS/SCTP" !== e3.protocol ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], void 0 !== t3.maxMessageSize && i2.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), i2.join("");
          }, t2.generateSessionId = function() {
            return Math.random().toString().substr(2, 22);
          }, t2.writeSessionBoilerplate = function(e3, i2, n2) {
            let r2;
            const s2 = void 0 !== i2 ? i2 : 2;
            r2 = e3 || t2.generateSessionId();
            return "v=0\r\no=" + (n2 || "thisisadapterortc") + " " + r2 + " " + s2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
          }, t2.getDirection = function(e3, i2) {
            const n2 = t2.splitLines(e3);
            for (let e4 = 0; e4 < n2.length; e4++)
              switch (n2[e4]) {
                case "a=sendrecv":
                case "a=sendonly":
                case "a=recvonly":
                case "a=inactive":
                  return n2[e4].substring(2);
              }
            return i2 ? t2.getDirection(i2) : "sendrecv";
          }, t2.getKind = function(e3) {
            return t2.splitLines(e3)[0].split(" ")[0].substring(2);
          }, t2.isRejected = function(e3) {
            return "0" === e3.split(" ", 2)[1];
          }, t2.parseMLine = function(e3) {
            const i2 = t2.splitLines(e3)[0].substring(2).split(" ");
            return { kind: i2[0], port: parseInt(i2[1], 10), protocol: i2[2], fmt: i2.slice(3).join(" ") };
          }, t2.parseOLine = function(e3) {
            const i2 = t2.matchPrefix(e3, "o=")[0].substring(2).split(" ");
            return { username: i2[0], sessionId: i2[1], sessionVersion: parseInt(i2[2], 10), netType: i2[3], addressType: i2[4], address: i2[5] };
          }, t2.isValidSDP = function(e3) {
            if ("string" != typeof e3 || 0 === e3.length)
              return false;
            const i2 = t2.splitLines(e3);
            for (let e4 = 0; e4 < i2.length; e4++)
              if (i2[e4].length < 2 || "=" !== i2[e4].charAt(1))
                return false;
            return true;
          }, e2.exports = t2;
        }(z);
        var X = z.exports, Q = J(X), Z = e({ __proto__: null, default: Q }, [X]);
        function $(e2) {
          if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype)
            return;
          const t2 = e2.RTCIceCandidate;
          e2.RTCIceCandidate = function(e3) {
            if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
              const i2 = new t2(e3), n2 = Q.parseCandidate(e3.candidate), r2 = Object.assign(i2, n2);
              return r2.toJSON = function() {
                return { candidate: r2.candidate, sdpMid: r2.sdpMid, sdpMLineIndex: r2.sdpMLineIndex, usernameFragment: r2.usernameFragment };
              }, r2;
            }
            return new t2(e3);
          }, e2.RTCIceCandidate.prototype = t2.prototype, r(e2, "icecandidate", (t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3));
        }
        function ee(e2) {
          !e2.RTCIceCandidate || e2.RTCIceCandidate && "relayProtocol" in e2.RTCIceCandidate.prototype || r(e2, "icecandidate", (e3) => {
            if (e3.candidate) {
              const t2 = Q.parseCandidate(e3.candidate.candidate);
              "relay" === t2.type && (e3.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t2.priority >> 24]);
            }
            return e3;
          });
        }
        function te(e2, t2) {
          if (!e2.RTCPeerConnection)
            return;
          "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
            return void 0 === this._sctp ? null : this._sctp;
          } });
          const i2 = function(e3) {
            if (!e3 || !e3.sdp)
              return false;
            const t3 = Q.splitSections(e3.sdp);
            return t3.shift(), t3.some((e4) => {
              const t4 = Q.parseMLine(e4);
              return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
            });
          }, n2 = function(e3) {
            const t3 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
            if (null === t3 || t3.length < 2)
              return -1;
            const i3 = parseInt(t3[1], 10);
            return i3 != i3 ? -1 : i3;
          }, r2 = function(e3) {
            let i3 = 65536;
            return "firefox" === t2.browser && (i3 = t2.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), i3;
          }, s2 = function(e3, i3) {
            let n3 = 65536;
            "firefox" === t2.browser && 57 === t2.version && (n3 = 65535);
            const r3 = Q.matchPrefix(e3.sdp, "a=max-message-size:");
            return r3.length > 0 ? n3 = parseInt(r3[0].substr(19), 10) : "firefox" === t2.browser && -1 !== i3 && (n3 = 2147483637), n3;
          }, o2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            if (this._sctp = null, "chrome" === t2.browser && t2.version >= 76) {
              const { sdpSemantics: e3 } = this.getConfiguration();
              "plan-b" === e3 && Object.defineProperty(this, "sctp", { get() {
                return void 0 === this._sctp ? null : this._sctp;
              }, enumerable: true, configurable: true });
            }
            if (i2(arguments[0])) {
              const e3 = n2(arguments[0]), t3 = r2(e3), i3 = s2(arguments[0], e3);
              let o3;
              o3 = 0 === t3 && 0 === i3 ? Number.POSITIVE_INFINITY : 0 === t3 || 0 === i3 ? Math.max(t3, i3) : Math.min(t3, i3);
              const a2 = {};
              Object.defineProperty(a2, "maxMessageSize", { get: () => o3 }), this._sctp = a2;
            }
            return o2.apply(this, arguments);
          };
        }
        function ie(e2) {
          if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype))
            return;
          function t2(e3, t3) {
            const i3 = e3.send;
            e3.send = function() {
              const n2 = arguments[0], r2 = n2.length || n2.size || n2.byteLength;
              if ("open" === e3.readyState && t3.sctp && r2 > t3.sctp.maxMessageSize)
                throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
              return i3.apply(e3, arguments);
            };
          }
          const i2 = e2.RTCPeerConnection.prototype.createDataChannel;
          e2.RTCPeerConnection.prototype.createDataChannel = function() {
            const e3 = i2.apply(this, arguments);
            return t2(e3, this), e3;
          }, r(e2, "datachannel", (e3) => (t2(e3.channel, e3.target), e3));
        }
        function ne(e2) {
          if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype)
            return;
          const t2 = e2.RTCPeerConnection.prototype;
          Object.defineProperty(t2, "connectionState", { get() {
            return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
          }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
            return this._onconnectionstatechange || null;
          }, set(e3) {
            this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
          }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e3) => {
            const i2 = t2[e3];
            t2[e3] = function() {
              return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
                const t3 = e4.target;
                if (t3._lastConnectionState !== t3.connectionState) {
                  t3._lastConnectionState = t3.connectionState;
                  const i3 = new Event("connectionstatechange", e4);
                  t3.dispatchEvent(i3);
                }
                return e4;
              }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i2.apply(this, arguments);
            };
          });
        }
        function re(e2, t2) {
          if (!e2.RTCPeerConnection)
            return;
          if ("chrome" === t2.browser && t2.version >= 71)
            return;
          if ("safari" === t2.browser && t2.version >= 605)
            return;
          const i2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
            if (t3 && t3.sdp && -1 !== t3.sdp.indexOf("\na=extmap-allow-mixed")) {
              const i3 = t3.sdp.split("\n").filter((e3) => "a=extmap-allow-mixed" !== e3.trim()).join("\n");
              e2.RTCSessionDescription && t3 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t3.type, sdp: i3 }) : t3.sdp = i3;
            }
            return i2.apply(this, arguments);
          };
        }
        function se(e2, t2) {
          if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
            return;
          const i2 = e2.RTCPeerConnection.prototype.addIceCandidate;
          i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
            return arguments[0] ? ("chrome" === t2.browser && t2.version < 78 || "firefox" === t2.browser && t2.version < 68 || "safari" === t2.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : i2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
          });
        }
        function oe(e2, t2) {
          if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
            return;
          const i2 = e2.RTCPeerConnection.prototype.setLocalDescription;
          i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.setLocalDescription = function() {
            let e3 = arguments[0] || {};
            if ("object" != typeof e3 || e3.type && e3.sdp)
              return i2.apply(this, arguments);
            if (e3 = { type: e3.type, sdp: e3.sdp }, !e3.type)
              switch (this.signalingState) {
                case "stable":
                case "have-local-offer":
                case "have-remote-pranswer":
                  e3.type = "offer";
                  break;
                default:
                  e3.type = "answer";
              }
            if (e3.sdp || "offer" !== e3.type && "answer" !== e3.type)
              return i2.apply(this, [e3]);
            return ("offer" === e3.type ? this.createOffer : this.createAnswer).apply(this).then((e4) => i2.apply(this, [e4]));
          });
        }
        var ae = Object.freeze({ __proto__: null, removeExtmapAllowMixed: re, shimAddIceCandidateNullOrEmpty: se, shimConnectionState: ne, shimMaxMessageSize: te, shimParameterlessSetLocalDescription: oe, shimRTCIceCandidate: $, shimRTCIceCandidateRelayProtocol: ee, shimSendThrowTypeError: ie });
        !function({ window: e2 } = {}, t2 = { shimChrome: true, shimFirefox: true, shimSafari: true }) {
          const i2 = a, r2 = function(e3) {
            const t3 = { browser: null, version: null };
            if (void 0 === e3 || !e3.navigator)
              return t3.browser = "Not a browser.", t3;
            const { navigator: i3 } = e3;
            if (i3.mozGetUserMedia)
              t3.browser = "firefox", t3.version = n(i3.userAgent, /Firefox\/(\d+)\./, 1);
            else if (i3.webkitGetUserMedia || false === e3.isSecureContext && e3.webkitRTCPeerConnection)
              t3.browser = "chrome", t3.version = n(i3.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
            else {
              if (!e3.RTCPeerConnection || !i3.userAgent.match(/AppleWebKit\/(\d+)\./))
                return t3.browser = "Not a supported browser.", t3;
              t3.browser = "safari", t3.version = n(i3.userAgent, /AppleWebKit\/(\d+)\./, 1), t3.supportsUnifiedPlan = e3.RTCRtpTransceiver && "currentDirection" in e3.RTCRtpTransceiver.prototype;
            }
            return t3;
          }(e2), c2 = { browserDetails: r2, commonShim: ae, extractVersion: n, disableLog: s, disableWarnings: o, sdp: Z };
          switch (r2.browser) {
            case "chrome":
              if (!I || !C || !t2.shimChrome)
                return i2("Chrome shim is not included in this adapter release."), c2;
              if (null === r2.version)
                return i2("Chrome shim can not determine version, not shimming."), c2;
              i2("adapter.js shimming chrome."), c2.browserShim = I, se(e2, r2), oe(e2), _(e2, r2), E(e2), C(e2, r2), m(e2), R(e2, r2), f(e2), g(e2), T(e2), v(e2, r2), $(e2), ee(e2), ne(e2), te(e2, r2), ie(e2), re(e2, r2);
              break;
            case "firefox":
              if (!U || !b || !t2.shimFirefox)
                return i2("Firefox shim is not included in this adapter release."), c2;
              i2("adapter.js shimming firefox."), c2.browserShim = U, se(e2, r2), oe(e2), y(e2, r2), b(e2, r2), A(e2), N(e2), w(e2), O(e2), D(e2), P(e2), L(e2), k(e2), M(e2), $(e2), ne(e2), te(e2, r2), ie(e2);
              break;
            case "safari":
              if (!Y || !t2.shimSafari)
                return i2("Safari shim is not included in this adapter release."), c2;
              i2("adapter.js shimming safari."), c2.browserShim = Y, se(e2, r2), oe(e2), G(e2), H(e2), F(e2), x(e2), V(e2), W(e2), B(e2), K(e2), $(e2), ee(e2), te(e2, r2), ie(e2), re(e2, r2);
              break;
            default:
              i2("Unsupported browser!");
          }
        }({ window: "undefined" == typeof window ? void 0 : window });
        var ce = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        }, de = !ce(function() {
          var e2 = function() {
          }.bind();
          return "function" != typeof e2 || e2.hasOwnProperty("prototype");
        }), le = de, he = Function.prototype, ue = he.call, pe = le && he.bind.bind(ue, ue), _e = le ? pe : function(e2) {
          return function() {
            return ue.apply(e2, arguments);
          };
        }, Ee = _e({}.isPrototypeOf), me = function(e2) {
          return e2 && e2.Math == Math && e2;
        }, fe = me("object" == typeof globalThis && globalThis) || me("object" == typeof window && window) || me("object" == typeof self && self) || me("object" == typeof q && q) || function() {
          return this;
        }() || q || Function("return this")(), ge = de, Te = Function.prototype, Se = Te.apply, Re = Te.call, Ce = "object" == typeof Reflect && Reflect.apply || (ge ? Re.bind(Se) : function() {
          return Re.apply(Se, arguments);
        }), ve = _e, Ie = ve({}.toString), ye = ve("".slice), Ae = function(e2) {
          return ye(Ie(e2), 8, -1);
        }, be = Ae, we = _e, Oe = function(e2) {
          if ("Function" === be(e2))
            return we(e2);
        }, Ne = "object" == typeof document && document.all, De = { all: Ne, IS_HTMLDDA: void 0 === Ne && void 0 !== Ne }, Pe = De.all, Le = De.IS_HTMLDDA ? function(e2) {
          return "function" == typeof e2 || e2 === Pe;
        } : function(e2) {
          return "function" == typeof e2;
        }, ke = {}, Me = !ce(function() {
          return 7 != Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1];
        }), Ue = de, xe = Function.prototype.call, Ve = Ue ? xe.bind(xe) : function() {
          return xe.apply(xe, arguments);
        }, Fe = {}, Be = {}.propertyIsEnumerable, je = Object.getOwnPropertyDescriptor, Ge = je && !Be.call({ 1: 2 }, 1);
        Fe.f = Ge ? function(e2) {
          var t2 = je(this, e2);
          return !!t2 && t2.enumerable;
        } : Be;
        var We, He, Ke = function(e2, t2) {
          return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
        }, Ye = ce, qe = Ae, Je = Object, ze = _e("".split), Xe = Ye(function() {
          return !Je("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return "String" == qe(e2) ? ze(e2, "") : Je(e2);
        } : Je, Qe = function(e2) {
          return null == e2;
        }, Ze = Qe, $e = TypeError, et = function(e2) {
          if (Ze(e2))
            throw $e("Can't call method on " + e2);
          return e2;
        }, tt = Xe, it = et, nt = function(e2) {
          return tt(it(e2));
        }, rt = Le, st = De.all, ot = De.IS_HTMLDDA ? function(e2) {
          return "object" == typeof e2 ? null !== e2 : rt(e2) || e2 === st;
        } : function(e2) {
          return "object" == typeof e2 ? null !== e2 : rt(e2);
        }, at = {}, ct = at, dt = fe, lt = Le, ht = function(e2) {
          return lt(e2) ? e2 : void 0;
        }, ut = function(e2, t2) {
          return arguments.length < 2 ? ht(ct[e2]) || ht(dt[e2]) : ct[e2] && ct[e2][t2] || dt[e2] && dt[e2][t2];
        }, pt = "undefined" != typeof navigator && String(navigator.userAgent) || "", _t = fe, Et = pt, mt = _t.process, ft = _t.Deno, gt = mt && mt.versions || ft && ft.version, Tt = gt && gt.v8;
        Tt && (He = (We = Tt.split("."))[0] > 0 && We[0] < 4 ? 1 : +(We[0] + We[1])), !He && Et && (!(We = Et.match(/Edge\/(\d+)/)) || We[1] >= 74) && (We = Et.match(/Chrome\/(\d+)/)) && (He = +We[1]);
        var St = He, Rt = St, Ct = ce, vt = fe.String, It = !!Object.getOwnPropertySymbols && !Ct(function() {
          var e2 = Symbol();
          return !vt(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && Rt && Rt < 41;
        }), yt = It && !Symbol.sham && "symbol" == typeof Symbol.iterator, At = ut, bt = Le, wt = Ee, Ot = Object, Nt = yt ? function(e2) {
          return "symbol" == typeof e2;
        } : function(e2) {
          var t2 = At("Symbol");
          return bt(t2) && wt(t2.prototype, Ot(e2));
        }, Dt = String, Pt = function(e2) {
          try {
            return Dt(e2);
          } catch (e3) {
            return "Object";
          }
        }, Lt = Le, kt = Pt, Mt = TypeError, Ut = function(e2) {
          if (Lt(e2))
            return e2;
          throw Mt(kt(e2) + " is not a function");
        }, xt = Ut, Vt = Qe, Ft = function(e2, t2) {
          var i2 = e2[t2];
          return Vt(i2) ? void 0 : xt(i2);
        }, Bt = Ve, jt = Le, Gt = ot, Wt = TypeError, Ht = { exports: {} }, Kt = fe, Yt = Object.defineProperty, qt = function(e2, t2) {
          try {
            Yt(Kt, e2, { value: t2, configurable: true, writable: true });
          } catch (i2) {
            Kt[e2] = t2;
          }
          return t2;
        }, Jt = "__core-js_shared__", zt = fe[Jt] || qt(Jt, {}), Xt = zt;
        (Ht.exports = function(e2, t2) {
          return Xt[e2] || (Xt[e2] = void 0 !== t2 ? t2 : {});
        })("versions", []).push({ version: "3.31.1", mode: "pure", copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE", source: "https://github.com/zloirock/core-js" });
        var Qt = Ht.exports, Zt = et, $t = Object, ei = function(e2) {
          return $t(Zt(e2));
        }, ti = ei, ii = _e({}.hasOwnProperty), ni = Object.hasOwn || function(e2, t2) {
          return ii(ti(e2), t2);
        }, ri = _e, si = 0, oi = Math.random(), ai = ri(1 .toString), ci = function(e2) {
          return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + ai(++si + oi, 36);
        }, di = Qt, li = ni, hi = ci, ui = It, pi = yt, _i = fe.Symbol, Ei = di("wks"), mi = pi ? _i.for || _i : _i && _i.withoutSetter || hi, fi = function(e2) {
          return li(Ei, e2) || (Ei[e2] = ui && li(_i, e2) ? _i[e2] : mi("Symbol." + e2)), Ei[e2];
        }, gi = Ve, Ti = ot, Si = Nt, Ri = Ft, Ci = function(e2, t2) {
          var i2, n2;
          if ("string" === t2 && jt(i2 = e2.toString) && !Gt(n2 = Bt(i2, e2)))
            return n2;
          if (jt(i2 = e2.valueOf) && !Gt(n2 = Bt(i2, e2)))
            return n2;
          if ("string" !== t2 && jt(i2 = e2.toString) && !Gt(n2 = Bt(i2, e2)))
            return n2;
          throw Wt("Can't convert object to primitive value");
        }, vi = TypeError, Ii = fi("toPrimitive"), yi = function(e2, t2) {
          if (!Ti(e2) || Si(e2))
            return e2;
          var i2, n2 = Ri(e2, Ii);
          if (n2) {
            if (void 0 === t2 && (t2 = "default"), i2 = gi(n2, e2, t2), !Ti(i2) || Si(i2))
              return i2;
            throw vi("Can't convert object to primitive value");
          }
          return void 0 === t2 && (t2 = "number"), Ci(e2, t2);
        }, Ai = Nt, bi = function(e2) {
          var t2 = yi(e2, "string");
          return Ai(t2) ? t2 : t2 + "";
        }, wi = ot, Oi = fe.document, Ni = wi(Oi) && wi(Oi.createElement), Di = function(e2) {
          return Ni ? Oi.createElement(e2) : {};
        }, Pi = Di, Li = !Me && !ce(function() {
          return 7 != Object.defineProperty(Pi("div"), "a", { get: function() {
            return 7;
          } }).a;
        }), ki = Me, Mi = Ve, Ui = Fe, xi = Ke, Vi = nt, Fi = bi, Bi = ni, ji = Li, Gi = Object.getOwnPropertyDescriptor;
        ke.f = ki ? Gi : function(e2, t2) {
          if (e2 = Vi(e2), t2 = Fi(t2), ji)
            try {
              return Gi(e2, t2);
            } catch (e3) {
            }
          if (Bi(e2, t2))
            return xi(!Mi(Ui.f, e2, t2), e2[t2]);
        };
        var Wi = ce, Hi = Le, Ki = /#|\.prototype\./, Yi = function(e2, t2) {
          var i2 = Ji[qi(e2)];
          return i2 == Xi || i2 != zi && (Hi(t2) ? Wi(t2) : !!t2);
        }, qi = Yi.normalize = function(e2) {
          return String(e2).replace(Ki, ".").toLowerCase();
        }, Ji = Yi.data = {}, zi = Yi.NATIVE = "N", Xi = Yi.POLYFILL = "P", Qi = Yi, Zi = Ut, $i = de, en = Oe(Oe.bind), tn = function(e2, t2) {
          return Zi(e2), void 0 === t2 ? e2 : $i ? en(e2, t2) : function() {
            return e2.apply(t2, arguments);
          };
        }, nn = {}, rn = Me && ce(function() {
          return 42 != Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype;
        }), sn = ot, on2 = String, an = TypeError, cn = function(e2) {
          if (sn(e2))
            return e2;
          throw an(on2(e2) + " is not an object");
        }, dn = Me, ln = Li, hn = rn, un = cn, pn = bi, _n = TypeError, En = Object.defineProperty, mn = Object.getOwnPropertyDescriptor, fn = "enumerable", gn = "configurable", Tn = "writable";
        nn.f = dn ? hn ? function(e2, t2, i2) {
          if (un(e2), t2 = pn(t2), un(i2), "function" == typeof e2 && "prototype" === t2 && "value" in i2 && Tn in i2 && !i2[Tn]) {
            var n2 = mn(e2, t2);
            n2 && n2[Tn] && (e2[t2] = i2.value, i2 = { configurable: gn in i2 ? i2[gn] : n2[gn], enumerable: fn in i2 ? i2[fn] : n2[fn], writable: false });
          }
          return En(e2, t2, i2);
        } : En : function(e2, t2, i2) {
          if (un(e2), t2 = pn(t2), un(i2), ln)
            try {
              return En(e2, t2, i2);
            } catch (e3) {
            }
          if ("get" in i2 || "set" in i2)
            throw _n("Accessors not supported");
          return "value" in i2 && (e2[t2] = i2.value), e2;
        };
        var Sn = nn, Rn = Ke, Cn = Me ? function(e2, t2, i2) {
          return Sn.f(e2, t2, Rn(1, i2));
        } : function(e2, t2, i2) {
          return e2[t2] = i2, e2;
        }, vn = fe, In = Ce, yn = Oe, An = Le, bn = ke.f, wn = Qi, On = at, Nn = tn, Dn = Cn, Pn = ni, Ln = function(e2) {
          var t2 = function(i2, n2, r2) {
            if (this instanceof t2) {
              switch (arguments.length) {
                case 0:
                  return new e2();
                case 1:
                  return new e2(i2);
                case 2:
                  return new e2(i2, n2);
              }
              return new e2(i2, n2, r2);
            }
            return In(e2, this, arguments);
          };
          return t2.prototype = e2.prototype, t2;
        }, kn = function(e2, t2) {
          var i2, n2, r2, s2, o2, a2, c2, d2, l2, h2 = e2.target, u2 = e2.global, p2 = e2.stat, _2 = e2.proto, E2 = u2 ? vn : p2 ? vn[h2] : (vn[h2] || {}).prototype, m2 = u2 ? On : On[h2] || Dn(On, h2, {})[h2], f2 = m2.prototype;
          for (s2 in t2)
            n2 = !(i2 = wn(u2 ? s2 : h2 + (p2 ? "." : "#") + s2, e2.forced)) && E2 && Pn(E2, s2), a2 = m2[s2], n2 && (c2 = e2.dontCallGetSet ? (l2 = bn(E2, s2)) && l2.value : E2[s2]), o2 = n2 && c2 ? c2 : t2[s2], n2 && typeof a2 == typeof o2 || (d2 = e2.bind && n2 ? Nn(o2, vn) : e2.wrap && n2 ? Ln(o2) : _2 && An(o2) ? yn(o2) : o2, (e2.sham || o2 && o2.sham || a2 && a2.sham) && Dn(d2, "sham", true), Dn(m2, s2, d2), _2 && (Pn(On, r2 = h2 + "Prototype") || Dn(On, r2, {}), Dn(On[r2], s2, o2), e2.real && f2 && (i2 || !f2[s2]) && Dn(f2, s2, o2)));
        }, Mn = Math.ceil, Un = Math.floor, xn = Math.trunc || function(e2) {
          var t2 = +e2;
          return (t2 > 0 ? Un : Mn)(t2);
        }, Vn = function(e2) {
          var t2 = +e2;
          return t2 != t2 || 0 === t2 ? 0 : xn(t2);
        }, Fn = Vn, Bn = Math.max, jn = Math.min, Gn = function(e2, t2) {
          var i2 = Fn(e2);
          return i2 < 0 ? Bn(i2 + t2, 0) : jn(i2, t2);
        }, Wn = Vn, Hn = Math.min, Kn = function(e2) {
          return e2 > 0 ? Hn(Wn(e2), 9007199254740991) : 0;
        }, Yn = function(e2) {
          return Kn(e2.length);
        }, qn = nt, Jn = Gn, zn = Yn, Xn = function(e2) {
          return function(t2, i2, n2) {
            var r2, s2 = qn(t2), o2 = zn(s2), a2 = Jn(n2, o2);
            if (e2 && i2 != i2) {
              for (; o2 > a2; )
                if ((r2 = s2[a2++]) != r2)
                  return true;
            } else
              for (; o2 > a2; a2++)
                if ((e2 || a2 in s2) && s2[a2] === i2)
                  return e2 || a2 || 0;
            return !e2 && -1;
          };
        }, Qn = { includes: Xn(true), indexOf: Xn(false) }, Zn = Qn.includes;
        kn({ target: "Array", proto: true, forced: ce(function() {
          return !Array(1).includes();
        }) }, { includes: function(e2) {
          return Zn(this, e2, arguments.length > 1 ? arguments[1] : void 0);
        } });
        var $n = at, er = function(e2) {
          return $n[e2 + "Prototype"];
        }, tr = er("Array").includes, ir = ot, nr = Ae, rr = fi("match"), sr = function(e2) {
          var t2;
          return ir(e2) && (void 0 !== (t2 = e2[rr]) ? !!t2 : "RegExp" == nr(e2));
        }, or = TypeError, ar = {};
        ar[fi("toStringTag")] = "z";
        var cr = "[object z]" === String(ar), dr = cr, lr = Le, hr = Ae, ur = fi("toStringTag"), pr = Object, _r = "Arguments" == hr(function() {
          return arguments;
        }()), Er = dr ? hr : function(e2) {
          var t2, i2, n2;
          return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = function(e3, t3) {
            try {
              return e3[t3];
            } catch (e4) {
            }
          }(t2 = pr(e2), ur)) ? i2 : _r ? hr(t2) : "Object" == (n2 = hr(t2)) && lr(t2.callee) ? "Arguments" : n2;
        }, mr = Er, fr = String, gr = function(e2) {
          if ("Symbol" === mr(e2))
            throw TypeError("Cannot convert a Symbol value to a string");
          return fr(e2);
        }, Tr = fi("match"), Sr = kn, Rr = function(e2) {
          if (sr(e2))
            throw or("The method doesn't accept regular expressions");
          return e2;
        }, Cr = et, vr = gr, Ir = function(e2) {
          var t2 = /./;
          try {
            "/./"[e2](t2);
          } catch (i2) {
            try {
              return t2[Tr] = false, "/./"[e2](t2);
            } catch (e3) {
            }
          }
          return false;
        }, yr = _e("".indexOf);
        Sr({ target: "String", proto: true, forced: !Ir("includes") }, { includes: function(e2) {
          return !!~yr(vr(Cr(this)), vr(Rr(e2)), arguments.length > 1 ? arguments[1] : void 0);
        } });
        var Ar = er("String").includes, br = Ee, wr = tr, Or = Ar, Nr = Array.prototype, Dr = String.prototype, Pr = J(function(e2) {
          var t2 = e2.includes;
          return e2 === Nr || br(Nr, e2) && t2 === Nr.includes ? wr : "string" == typeof e2 || e2 === Dr || br(Dr, e2) && t2 === Dr.includes ? Or : t2;
        }), Lr = { exports: {} }, kr = kn, Mr = Me, Ur = nn.f;
        kr({ target: "Object", stat: true, forced: Object.defineProperty !== Ur, sham: !Mr }, { defineProperty: Ur });
        var xr = at.Object, Vr = Lr.exports = function(e2, t2, i2) {
          return xr.defineProperty(e2, t2, i2);
        };
        xr.defineProperty.sham && (Vr.sham = true);
        var Fr = J(Lr.exports), Br = Ae, jr = Array.isArray || function(e2) {
          return "Array" == Br(e2);
        }, Gr = TypeError, Wr = bi, Hr = nn, Kr = Ke, Yr = function(e2, t2, i2) {
          var n2 = Wr(t2);
          n2 in e2 ? Hr.f(e2, n2, Kr(0, i2)) : e2[n2] = i2;
        }, qr = Le, Jr = zt, zr = _e(Function.toString);
        qr(Jr.inspectSource) || (Jr.inspectSource = function(e2) {
          return zr(e2);
        });
        var Xr = Jr.inspectSource, Qr = _e, Zr = ce, $r = Le, es = Er, ts = Xr, is = function() {
        }, ns = [], rs = ut("Reflect", "construct"), ss = /^\s*(?:class|function)\b/, os = Qr(ss.exec), as = !ss.exec(is), cs = function(e2) {
          if (!$r(e2))
            return false;
          try {
            return rs(is, ns, e2), true;
          } catch (e3) {
            return false;
          }
        }, ds = function(e2) {
          if (!$r(e2))
            return false;
          switch (es(e2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return as || !!os(ss, ts(e2));
          } catch (e3) {
            return true;
          }
        };
        ds.sham = true;
        var ls = !rs || Zr(function() {
          var e2;
          return cs(cs.call) || !cs(Object) || !cs(function() {
            e2 = true;
          }) || e2;
        }) ? ds : cs, hs = jr, us = ls, ps = ot, _s = fi("species"), Es = Array, ms = function(e2) {
          var t2;
          return hs(e2) && (t2 = e2.constructor, (us(t2) && (t2 === Es || hs(t2.prototype)) || ps(t2) && null === (t2 = t2[_s])) && (t2 = void 0)), void 0 === t2 ? Es : t2;
        }, fs = function(e2, t2) {
          return new (ms(e2))(0 === t2 ? 0 : t2);
        }, gs = ce, Ts = St, Ss = fi("species"), Rs = kn, Cs = ce, vs = jr, Is = ot, ys = ei, As = Yn, bs = function(e2) {
          if (e2 > 9007199254740991)
            throw Gr("Maximum allowed index exceeded");
          return e2;
        }, ws = Yr, Os = fs, Ns = function(e2) {
          return Ts >= 51 || !gs(function() {
            var t2 = [];
            return (t2.constructor = {})[Ss] = function() {
              return { foo: 1 };
            }, 1 !== t2[e2](Boolean).foo;
          });
        }, Ds = St, Ps = fi("isConcatSpreadable"), Ls = Ds >= 51 || !Cs(function() {
          var e2 = [];
          return e2[Ps] = false, e2.concat()[0] !== e2;
        }), ks = function(e2) {
          if (!Is(e2))
            return false;
          var t2 = e2[Ps];
          return void 0 !== t2 ? !!t2 : vs(e2);
        };
        Rs({ target: "Array", proto: true, arity: 1, forced: !Ls || !Ns("concat") }, { concat: function(e2) {
          var t2, i2, n2, r2, s2, o2 = ys(this), a2 = Os(o2, 0), c2 = 0;
          for (t2 = -1, n2 = arguments.length; t2 < n2; t2++)
            if (ks(s2 = -1 === t2 ? o2 : arguments[t2]))
              for (r2 = As(s2), bs(c2 + r2), i2 = 0; i2 < r2; i2++, c2++)
                i2 in s2 && ws(a2, c2, s2[i2]);
            else
              bs(c2 + 1), ws(a2, c2++, s2);
          return a2.length = c2, a2;
        } });
        var Ms = {}, Us = {}, xs = ni, Vs = nt, Fs = Qn.indexOf, Bs = Us, js = _e([].push), Gs = function(e2, t2) {
          var i2, n2 = Vs(e2), r2 = 0, s2 = [];
          for (i2 in n2)
            !xs(Bs, i2) && xs(n2, i2) && js(s2, i2);
          for (; t2.length > r2; )
            xs(n2, i2 = t2[r2++]) && (~Fs(s2, i2) || js(s2, i2));
          return s2;
        }, Ws = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Hs = Gs, Ks = Ws, Ys = Object.keys || function(e2) {
          return Hs(e2, Ks);
        }, qs = Me, Js = rn, zs = nn, Xs = cn, Qs = nt, Zs = Ys;
        Ms.f = qs && !Js ? Object.defineProperties : function(e2, t2) {
          Xs(e2);
          for (var i2, n2 = Qs(t2), r2 = Zs(t2), s2 = r2.length, o2 = 0; s2 > o2; )
            zs.f(e2, i2 = r2[o2++], n2[i2]);
          return e2;
        };
        var $s, eo = ut("document", "documentElement"), to = ci, io = Qt("keys"), no = function(e2) {
          return io[e2] || (io[e2] = to(e2));
        }, ro = cn, so = Ms, oo = Ws, ao = Us, co = eo, lo = Di, ho = "prototype", uo = "script", po = no("IE_PROTO"), _o = function() {
        }, Eo = function(e2) {
          return "<" + uo + ">" + e2 + "</" + uo + ">";
        }, mo = function(e2) {
          e2.write(Eo("")), e2.close();
          var t2 = e2.parentWindow.Object;
          return e2 = null, t2;
        }, fo = function() {
          try {
            $s = new ActiveXObject("htmlfile");
          } catch (e3) {
          }
          var e2, t2, i2;
          fo = "undefined" != typeof document ? document.domain && $s ? mo($s) : (t2 = lo("iframe"), i2 = "java" + uo + ":", t2.style.display = "none", co.appendChild(t2), t2.src = String(i2), (e2 = t2.contentWindow.document).open(), e2.write(Eo("document.F=Object")), e2.close(), e2.F) : mo($s);
          for (var n2 = oo.length; n2--; )
            delete fo[ho][oo[n2]];
          return fo();
        };
        ao[po] = true;
        var go = Object.create || function(e2, t2) {
          var i2;
          return null !== e2 ? (_o[ho] = ro(e2), i2 = new _o(), _o[ho] = null, i2[po] = e2) : i2 = fo(), void 0 === t2 ? i2 : so.f(i2, t2);
        }, To = {}, So = Gs, Ro = Ws.concat("length", "prototype");
        To.f = Object.getOwnPropertyNames || function(e2) {
          return So(e2, Ro);
        };
        var Co = {}, vo = Gn, Io = Yn, yo = Yr, Ao = Array, bo = Math.max, wo = function(e2, t2, i2) {
          for (var n2 = Io(e2), r2 = vo(t2, n2), s2 = vo(void 0 === i2 ? n2 : i2, n2), o2 = Ao(bo(s2 - r2, 0)), a2 = 0; r2 < s2; r2++, a2++)
            yo(o2, a2, e2[r2]);
          return o2.length = a2, o2;
        }, Oo = Ae, No = nt, Do = To.f, Po = wo, Lo = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        Co.f = function(e2) {
          return Lo && "Window" == Oo(e2) ? function(e3) {
            try {
              return Do(e3);
            } catch (e4) {
              return Po(Lo);
            }
          }(e2) : Do(No(e2));
        };
        var ko = {};
        ko.f = Object.getOwnPropertySymbols;
        var Mo = Cn, Uo = function(e2, t2, i2, n2) {
          return n2 && n2.enumerable ? e2[t2] = i2 : Mo(e2, t2, i2), e2;
        }, xo = nn, Vo = function(e2, t2, i2) {
          return xo.f(e2, t2, i2);
        }, Fo = {}, Bo = fi;
        Fo.f = Bo;
        var jo, Go, Wo, Ho = at, Ko = ni, Yo = Fo, qo = nn.f, Jo = function(e2) {
          var t2 = Ho.Symbol || (Ho.Symbol = {});
          Ko(t2, e2) || qo(t2, e2, { value: Yo.f(e2) });
        }, zo = Ve, Xo = ut, Qo = fi, Zo = Uo, $o = function() {
          var e2 = Xo("Symbol"), t2 = e2 && e2.prototype, i2 = t2 && t2.valueOf, n2 = Qo("toPrimitive");
          t2 && !t2[n2] && Zo(t2, n2, function(e3) {
            return zo(i2, this);
          }, { arity: 1 });
        }, ea = Er, ta = cr ? {}.toString : function() {
          return "[object " + ea(this) + "]";
        }, ia = cr, na = nn.f, ra = Cn, sa = ni, oa = ta, aa = fi("toStringTag"), ca = function(e2, t2, i2, n2) {
          if (e2) {
            var r2 = i2 ? e2 : e2.prototype;
            sa(r2, aa) || na(r2, aa, { configurable: true, value: t2 }), n2 && !ia && ra(r2, "toString", oa);
          }
        }, da = Le, la = fe.WeakMap, ha = da(la) && /native code/.test(String(la)), ua = fe, pa = ot, _a = Cn, Ea = ni, ma = zt, fa = no, ga = Us, Ta = "Object already initialized", Sa = ua.TypeError, Ra = ua.WeakMap;
        if (ha || ma.state) {
          var Ca = ma.state || (ma.state = new Ra());
          Ca.get = Ca.get, Ca.has = Ca.has, Ca.set = Ca.set, jo = function(e2, t2) {
            if (Ca.has(e2))
              throw Sa(Ta);
            return t2.facade = e2, Ca.set(e2, t2), t2;
          }, Go = function(e2) {
            return Ca.get(e2) || {};
          }, Wo = function(e2) {
            return Ca.has(e2);
          };
        } else {
          var va = fa("state");
          ga[va] = true, jo = function(e2, t2) {
            if (Ea(e2, va))
              throw Sa(Ta);
            return t2.facade = e2, _a(e2, va, t2), t2;
          }, Go = function(e2) {
            return Ea(e2, va) ? e2[va] : {};
          }, Wo = function(e2) {
            return Ea(e2, va);
          };
        }
        var Ia = { set: jo, get: Go, has: Wo, enforce: function(e2) {
          return Wo(e2) ? Go(e2) : jo(e2, {});
        }, getterFor: function(e2) {
          return function(t2) {
            var i2;
            if (!pa(t2) || (i2 = Go(t2)).type !== e2)
              throw Sa("Incompatible receiver, " + e2 + " required");
            return i2;
          };
        } }, ya = tn, Aa = Xe, ba = ei, wa = Yn, Oa = fs, Na = _e([].push), Da = function(e2) {
          var t2 = 1 == e2, i2 = 2 == e2, n2 = 3 == e2, r2 = 4 == e2, s2 = 6 == e2, o2 = 7 == e2, a2 = 5 == e2 || s2;
          return function(c2, d2, l2, h2) {
            for (var u2, p2, _2 = ba(c2), E2 = Aa(_2), m2 = ya(d2, l2), f2 = wa(E2), g2 = 0, T2 = h2 || Oa, S2 = t2 ? T2(c2, f2) : i2 || o2 ? T2(c2, 0) : void 0; f2 > g2; g2++)
              if ((a2 || g2 in E2) && (p2 = m2(u2 = E2[g2], g2, _2), e2))
                if (t2)
                  S2[g2] = p2;
                else if (p2)
                  switch (e2) {
                    case 3:
                      return true;
                    case 5:
                      return u2;
                    case 6:
                      return g2;
                    case 2:
                      Na(S2, u2);
                  }
                else
                  switch (e2) {
                    case 4:
                      return false;
                    case 7:
                      Na(S2, u2);
                  }
            return s2 ? -1 : n2 || r2 ? r2 : S2;
          };
        }, Pa = { forEach: Da(0), map: Da(1), filter: Da(2), some: Da(3), every: Da(4), find: Da(5), findIndex: Da(6), filterReject: Da(7) }, La = kn, ka = fe, Ma = Ve, Ua = _e, xa = Me, Va = It, Fa = ce, Ba = ni, ja = Ee, Ga = cn, Wa = nt, Ha = bi, Ka = gr, Ya = Ke, qa = go, Ja = Ys, za = To, Xa = Co, Qa = ko, Za = ke, $a = nn, ec = Ms, tc = Fe, ic = Uo, nc = Vo, rc = Qt, sc = Us, oc = ci, ac = fi, cc = Fo, dc = Jo, lc = $o, hc = ca, uc = Ia, pc = Pa.forEach, _c = no("hidden"), Ec = "Symbol", mc = "prototype", fc = uc.set, gc = uc.getterFor(Ec), Tc = Object[mc], Sc = ka.Symbol, Rc = Sc && Sc[mc], Cc = ka.TypeError, vc = ka.QObject, Ic = Za.f, yc = $a.f, Ac = Xa.f, bc = tc.f, wc = Ua([].push), Oc = rc("symbols"), Nc = rc("op-symbols"), Dc = rc("wks"), Pc = !vc || !vc[mc] || !vc[mc].findChild, Lc = xa && Fa(function() {
          return 7 != qa(yc({}, "a", { get: function() {
            return yc(this, "a", { value: 7 }).a;
          } })).a;
        }) ? function(e2, t2, i2) {
          var n2 = Ic(Tc, t2);
          n2 && delete Tc[t2], yc(e2, t2, i2), n2 && e2 !== Tc && yc(Tc, t2, n2);
        } : yc, kc = function(e2, t2) {
          var i2 = Oc[e2] = qa(Rc);
          return fc(i2, { type: Ec, tag: e2, description: t2 }), xa || (i2.description = t2), i2;
        }, Mc = function(e2, t2, i2) {
          e2 === Tc && Mc(Nc, t2, i2), Ga(e2);
          var n2 = Ha(t2);
          return Ga(i2), Ba(Oc, n2) ? (i2.enumerable ? (Ba(e2, _c) && e2[_c][n2] && (e2[_c][n2] = false), i2 = qa(i2, { enumerable: Ya(0, false) })) : (Ba(e2, _c) || yc(e2, _c, Ya(1, {})), e2[_c][n2] = true), Lc(e2, n2, i2)) : yc(e2, n2, i2);
        }, Uc = function(e2, t2) {
          Ga(e2);
          var i2 = Wa(t2), n2 = Ja(i2).concat(Bc(i2));
          return pc(n2, function(t3) {
            xa && !Ma(xc, i2, t3) || Mc(e2, t3, i2[t3]);
          }), e2;
        }, xc = function(e2) {
          var t2 = Ha(e2), i2 = Ma(bc, this, t2);
          return !(this === Tc && Ba(Oc, t2) && !Ba(Nc, t2)) && (!(i2 || !Ba(this, t2) || !Ba(Oc, t2) || Ba(this, _c) && this[_c][t2]) || i2);
        }, Vc = function(e2, t2) {
          var i2 = Wa(e2), n2 = Ha(t2);
          if (i2 !== Tc || !Ba(Oc, n2) || Ba(Nc, n2)) {
            var r2 = Ic(i2, n2);
            return !r2 || !Ba(Oc, n2) || Ba(i2, _c) && i2[_c][n2] || (r2.enumerable = true), r2;
          }
        }, Fc = function(e2) {
          var t2 = Ac(Wa(e2)), i2 = [];
          return pc(t2, function(e3) {
            Ba(Oc, e3) || Ba(sc, e3) || wc(i2, e3);
          }), i2;
        }, Bc = function(e2) {
          var t2 = e2 === Tc, i2 = Ac(t2 ? Nc : Wa(e2)), n2 = [];
          return pc(i2, function(e3) {
            !Ba(Oc, e3) || t2 && !Ba(Tc, e3) || wc(n2, Oc[e3]);
          }), n2;
        };
        Va || (Sc = function() {
          if (ja(Rc, this))
            throw Cc("Symbol is not a constructor");
          var e2 = arguments.length && void 0 !== arguments[0] ? Ka(arguments[0]) : void 0, t2 = oc(e2), i2 = function(e3) {
            this === Tc && Ma(i2, Nc, e3), Ba(this, _c) && Ba(this[_c], t2) && (this[_c][t2] = false), Lc(this, t2, Ya(1, e3));
          };
          return xa && Pc && Lc(Tc, t2, { configurable: true, set: i2 }), kc(t2, e2);
        }, ic(Rc = Sc[mc], "toString", function() {
          return gc(this).tag;
        }), ic(Sc, "withoutSetter", function(e2) {
          return kc(oc(e2), e2);
        }), tc.f = xc, $a.f = Mc, ec.f = Uc, Za.f = Vc, za.f = Xa.f = Fc, Qa.f = Bc, cc.f = function(e2) {
          return kc(ac(e2), e2);
        }, xa && nc(Rc, "description", { configurable: true, get: function() {
          return gc(this).description;
        } })), La({ global: true, constructor: true, wrap: true, forced: !Va, sham: !Va }, { Symbol: Sc }), pc(Ja(Dc), function(e2) {
          dc(e2);
        }), La({ target: Ec, stat: true, forced: !Va }, { useSetter: function() {
          Pc = true;
        }, useSimple: function() {
          Pc = false;
        } }), La({ target: "Object", stat: true, forced: !Va, sham: !xa }, { create: function(e2, t2) {
          return void 0 === t2 ? qa(e2) : Uc(qa(e2), t2);
        }, defineProperty: Mc, defineProperties: Uc, getOwnPropertyDescriptor: Vc }), La({ target: "Object", stat: true, forced: !Va }, { getOwnPropertyNames: Fc }), lc(), hc(Sc, Ec), sc[_c] = true;
        var jc = It && !!Symbol.for && !!Symbol.keyFor, Gc = kn, Wc = ut, Hc = ni, Kc = gr, Yc = Qt, qc = jc, Jc = Yc("string-to-symbol-registry"), zc = Yc("symbol-to-string-registry");
        Gc({ target: "Symbol", stat: true, forced: !qc }, { for: function(e2) {
          var t2 = Kc(e2);
          if (Hc(Jc, t2))
            return Jc[t2];
          var i2 = Wc("Symbol")(t2);
          return Jc[t2] = i2, zc[i2] = t2, i2;
        } });
        var Xc = kn, Qc = ni, Zc = Nt, $c = Pt, ed = jc, td = Qt("symbol-to-string-registry");
        Xc({ target: "Symbol", stat: true, forced: !ed }, { keyFor: function(e2) {
          if (!Zc(e2))
            throw TypeError($c(e2) + " is not a symbol");
          if (Qc(td, e2))
            return td[e2];
        } });
        var id = _e([].slice), nd = jr, rd = Le, sd = Ae, od = gr, ad = _e([].push), cd = kn, dd = ut, ld = Ce, hd = Ve, ud = _e, pd = ce, _d = Le, Ed = Nt, md = id, fd = function(e2) {
          if (rd(e2))
            return e2;
          if (nd(e2)) {
            for (var t2 = e2.length, i2 = [], n2 = 0; n2 < t2; n2++) {
              var r2 = e2[n2];
              "string" == typeof r2 ? ad(i2, r2) : "number" != typeof r2 && "Number" != sd(r2) && "String" != sd(r2) || ad(i2, od(r2));
            }
            var s2 = i2.length, o2 = true;
            return function(e3, t3) {
              if (o2)
                return o2 = false, t3;
              if (nd(this))
                return t3;
              for (var n3 = 0; n3 < s2; n3++)
                if (i2[n3] === e3)
                  return t3;
            };
          }
        }, gd = It, Td = String, Sd = dd("JSON", "stringify"), Rd = ud(/./.exec), Cd = ud("".charAt), vd = ud("".charCodeAt), Id = ud("".replace), yd = ud(1 .toString), Ad = /[\uD800-\uDFFF]/g, bd = /^[\uD800-\uDBFF]$/, wd = /^[\uDC00-\uDFFF]$/, Od = !gd || pd(function() {
          var e2 = dd("Symbol")();
          return "[null]" != Sd([e2]) || "{}" != Sd({ a: e2 }) || "{}" != Sd(Object(e2));
        }), Nd = pd(function() {
          return '"\\udf06\\ud834"' !== Sd("\uDF06\uD834") || '"\\udead"' !== Sd("\uDEAD");
        }), Dd = function(e2, t2) {
          var i2 = md(arguments), n2 = fd(t2);
          if (_d(n2) || void 0 !== e2 && !Ed(e2))
            return i2[1] = function(e3, t3) {
              if (_d(n2) && (t3 = hd(n2, this, Td(e3), t3)), !Ed(t3))
                return t3;
            }, ld(Sd, null, i2);
        }, Pd = function(e2, t2, i2) {
          var n2 = Cd(i2, t2 - 1), r2 = Cd(i2, t2 + 1);
          return Rd(bd, e2) && !Rd(wd, r2) || Rd(wd, e2) && !Rd(bd, n2) ? "\\u" + yd(vd(e2, 0), 16) : e2;
        };
        Sd && cd({ target: "JSON", stat: true, arity: 3, forced: Od || Nd }, { stringify: function(e2, t2, i2) {
          var n2 = md(arguments), r2 = ld(Od ? Dd : Sd, null, n2);
          return Nd && "string" == typeof r2 ? Id(r2, Ad, Pd) : r2;
        } });
        var Ld = ko, kd = ei;
        kn({ target: "Object", stat: true, forced: !It || ce(function() {
          Ld.f(1);
        }) }, { getOwnPropertySymbols: function(e2) {
          var t2 = Ld.f;
          return t2 ? t2(kd(e2)) : [];
        } }), Jo("asyncIterator"), Jo("hasInstance"), Jo("isConcatSpreadable"), Jo("iterator"), Jo("match"), Jo("matchAll"), Jo("replace"), Jo("search"), Jo("species"), Jo("split");
        var Md = $o;
        Jo("toPrimitive"), Md();
        var Ud = ut, xd = ca;
        Jo("toStringTag"), xd(Ud("Symbol"), "Symbol"), Jo("unscopables"), ca(fe.JSON, "JSON", true);
        var Vd, Fd, Bd, jd = at.Symbol, Gd = {}, Wd = Me, Hd = ni, Kd = Function.prototype, Yd = Wd && Object.getOwnPropertyDescriptor, qd = Hd(Kd, "name"), Jd = { EXISTS: qd, PROPER: qd && "something" === function() {
        }.name, CONFIGURABLE: qd && (!Wd || Wd && Yd(Kd, "name").configurable) }, zd = !ce(function() {
          function e2() {
          }
          return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
        }), Xd = ni, Qd = Le, Zd = ei, $d = zd, el = no("IE_PROTO"), tl = Object, il = tl.prototype, nl = $d ? tl.getPrototypeOf : function(e2) {
          var t2 = Zd(e2);
          if (Xd(t2, el))
            return t2[el];
          var i2 = t2.constructor;
          return Qd(i2) && t2 instanceof i2 ? i2.prototype : t2 instanceof tl ? il : null;
        }, rl = ce, sl = Le, ol = ot, al = go, cl = nl, dl = Uo, ll = fi("iterator"), hl = false;
        [].keys && ("next" in (Bd = [].keys()) ? (Fd = cl(cl(Bd))) !== Object.prototype && (Vd = Fd) : hl = true);
        var ul = !ol(Vd) || rl(function() {
          var e2 = {};
          return Vd[ll].call(e2) !== e2;
        });
        sl((Vd = ul ? {} : al(Vd))[ll]) || dl(Vd, ll, function() {
          return this;
        });
        var pl = { IteratorPrototype: Vd, BUGGY_SAFARI_ITERATORS: hl }, _l = pl.IteratorPrototype, El = go, ml = Ke, fl = ca, gl = Gd, Tl = function() {
          return this;
        }, Sl = _e, Rl = Ut, Cl = Le, vl = String, Il = TypeError, yl = function(e2, t2, i2) {
          try {
            return Sl(Rl(Object.getOwnPropertyDescriptor(e2, t2)[i2]));
          } catch (e3) {
          }
        }, Al = cn, bl = function(e2) {
          if ("object" == typeof e2 || Cl(e2))
            return e2;
          throw Il("Can't set " + vl(e2) + " as a prototype");
        }, wl = Object.setPrototypeOf || ("__proto__" in {} ? function() {
          var e2, t2 = false, i2 = {};
          try {
            (e2 = yl(Object.prototype, "__proto__", "set"))(i2, []), t2 = i2 instanceof Array;
          } catch (e3) {
          }
          return function(i3, n2) {
            return Al(i3), bl(n2), t2 ? e2(i3, n2) : i3.__proto__ = n2, i3;
          };
        }() : void 0), Ol = kn, Nl = Ve, Dl = Jd, Pl = function(e2, t2, i2, n2) {
          var r2 = t2 + " Iterator";
          return e2.prototype = El(_l, { next: ml(+!n2, i2) }), fl(e2, r2, false, true), gl[r2] = Tl, e2;
        }, Ll = nl, kl = ca, Ml = Uo, Ul = Gd, xl = pl, Vl = Dl.PROPER, Fl = xl.BUGGY_SAFARI_ITERATORS, Bl = fi("iterator"), jl = "keys", Gl = "values", Wl = "entries", Hl = function() {
          return this;
        }, Kl = function(e2, t2, i2, n2, r2, s2, o2) {
          Pl(i2, t2, n2);
          var a2, c2, d2, l2 = function(e3) {
            if (e3 === r2 && E2)
              return E2;
            if (!Fl && e3 in p2)
              return p2[e3];
            switch (e3) {
              case jl:
              case Gl:
              case Wl:
                return function() {
                  return new i2(this, e3);
                };
            }
            return function() {
              return new i2(this);
            };
          }, h2 = t2 + " Iterator", u2 = false, p2 = e2.prototype, _2 = p2[Bl] || p2["@@iterator"] || r2 && p2[r2], E2 = !Fl && _2 || l2(r2), m2 = "Array" == t2 && p2.entries || _2;
          if (m2 && (a2 = Ll(m2.call(new e2()))) !== Object.prototype && a2.next && (kl(a2, h2, true, true), Ul[h2] = Hl), Vl && r2 == Gl && _2 && _2.name !== Gl && (u2 = true, E2 = function() {
            return Nl(_2, this);
          }), r2)
            if (c2 = { values: l2(Gl), keys: s2 ? E2 : l2(jl), entries: l2(Wl) }, o2)
              for (d2 in c2)
                (Fl || u2 || !(d2 in p2)) && Ml(p2, d2, c2[d2]);
            else
              Ol({ target: t2, proto: true, forced: Fl || u2 }, c2);
          return o2 && p2[Bl] !== E2 && Ml(p2, Bl, E2, { name: r2 }), Ul[t2] = E2, c2;
        }, Yl = function(e2, t2) {
          return { value: e2, done: t2 };
        }, ql = nt, Jl = Gd, zl = Ia;
        nn.f;
        var Xl = Kl, Ql = Yl, Zl = "Array Iterator", $l = zl.set, eh = zl.getterFor(Zl);
        Xl(Array, "Array", function(e2, t2) {
          $l(this, { type: Zl, target: ql(e2), index: 0, kind: t2 });
        }, function() {
          var e2 = eh(this), t2 = e2.target, i2 = e2.kind, n2 = e2.index++;
          return !t2 || n2 >= t2.length ? (e2.target = void 0, Ql(void 0, true)) : Ql("keys" == i2 ? n2 : "values" == i2 ? t2[n2] : [n2, t2[n2]], false);
        }, "values"), Jl.Arguments = Jl.Array;
        var th = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, ih = fe, nh = Er, rh = Cn, sh = Gd, oh = fi("toStringTag");
        for (var ah in th) {
          var ch = ih[ah], dh = ch && ch.prototype;
          dh && nh(dh) !== oh && rh(dh, oh, ah), sh[ah] = sh.Array;
        }
        var lh = jd, hh = fi, uh = nn.f, ph = hh("metadata"), _h = Function.prototype;
        void 0 === _h[ph] && uh(_h, ph, { value: null }), Jo("dispose"), Jo("metadata");
        var Eh = lh;
        Jo("asyncDispose");
        var mh = _e, fh = ut("Symbol"), gh = fh.keyFor, Th = mh(fh.prototype.valueOf), Sh = fh.isRegisteredSymbol || function(e2) {
          try {
            return void 0 !== gh(Th(e2));
          } catch (e3) {
            return false;
          }
        };
        kn({ target: "Symbol", stat: true }, { isRegisteredSymbol: Sh });
        for (var Rh = Qt, Ch = ut, vh = _e, Ih = Nt, yh = fi, Ah = Ch("Symbol"), bh = Ah.isWellKnownSymbol, wh = Ch("Object", "getOwnPropertyNames"), Oh = vh(Ah.prototype.valueOf), Nh = Rh("wks"), Dh = 0, Ph = wh(Ah), Lh = Ph.length; Dh < Lh; Dh++)
          try {
            var kh = Ph[Dh];
            Ih(Ah[kh]) && yh(kh);
          } catch (e2) {
          }
        var Mh = function(e2) {
          if (bh && bh(e2))
            return true;
          try {
            for (var t2 = Oh(e2), i2 = 0, n2 = wh(Nh), r2 = n2.length; i2 < r2; i2++)
              if (Nh[n2[i2]] == t2)
                return true;
          } catch (e3) {
          }
          return false;
        };
        kn({ target: "Symbol", stat: true, forced: true }, { isWellKnownSymbol: Mh }), Jo("matcher"), Jo("observable"), kn({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, { isRegistered: Sh }), kn({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, { isWellKnown: Mh }), Jo("metadataKey"), Jo("patternMatch"), Jo("replaceAll");
        var Uh = J(Eh), xh = _e, Vh = Vn, Fh = gr, Bh = et, jh = xh("".charAt), Gh = xh("".charCodeAt), Wh = xh("".slice), Hh = function(e2) {
          return function(t2, i2) {
            var n2, r2, s2 = Fh(Bh(t2)), o2 = Vh(i2), a2 = s2.length;
            return o2 < 0 || o2 >= a2 ? e2 ? "" : void 0 : (n2 = Gh(s2, o2)) < 55296 || n2 > 56319 || o2 + 1 === a2 || (r2 = Gh(s2, o2 + 1)) < 56320 || r2 > 57343 ? e2 ? jh(s2, o2) : n2 : e2 ? Wh(s2, o2, o2 + 2) : r2 - 56320 + (n2 - 55296 << 10) + 65536;
          };
        }, Kh = { codeAt: Hh(false), charAt: Hh(true) }.charAt, Yh = gr, qh = Ia, Jh = Kl, zh = Yl, Xh = "String Iterator", Qh = qh.set, Zh = qh.getterFor(Xh);
        Jh(String, "String", function(e2) {
          Qh(this, { type: Xh, string: Yh(e2), index: 0 });
        }, function() {
          var e2, t2 = Zh(this), i2 = t2.string, n2 = t2.index;
          return n2 >= i2.length ? zh(void 0, true) : (e2 = Kh(i2, n2), t2.index += e2.length, zh(e2, false));
        });
        var $h = J(Fo.f("iterator"));
        function eu(e2) {
          return eu = "function" == typeof Uh && "symbol" == typeof $h ? function(e3) {
            return typeof e3;
          } : function(e3) {
            return e3 && "function" == typeof Uh && e3.constructor === Uh && e3 !== Uh.prototype ? "symbol" : typeof e3;
          }, eu(e2);
        }
        var tu = J(Fo.f("toPrimitive"));
        function iu(e2) {
          var t2 = function(e3, t3) {
            if ("object" !== eu(e3) || null === e3)
              return e3;
            var i2 = e3[tu];
            if (void 0 !== i2) {
              var n2 = i2.call(e3, t3 || "default");
              if ("object" !== eu(n2))
                return n2;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === t3 ? String : Number)(e3);
          }(e2, "string");
          return "symbol" === eu(t2) ? t2 : String(t2);
        }
        function nu(e2, t2, i2) {
          return (t2 = iu(t2)) in e2 ? Fr(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
        }
        var ru = er("Array").keys, su = Er, ou = ni, au = Ee, cu = ru, du = Array.prototype, lu = { DOMTokenList: true, NodeList: true }, hu = J(function(e2) {
          var t2 = e2.keys;
          return e2 === du || au(du, e2) && t2 === du.keys || ou(lu, su(e2)) ? cu : t2;
        }), uu = Pt, pu = TypeError, _u = wo, Eu = Math.floor, mu = function(e2, t2) {
          var i2 = e2.length, n2 = Eu(i2 / 2);
          return i2 < 8 ? fu(e2, t2) : gu(e2, mu(_u(e2, 0, n2), t2), mu(_u(e2, n2), t2), t2);
        }, fu = function(e2, t2) {
          for (var i2, n2, r2 = e2.length, s2 = 1; s2 < r2; ) {
            for (n2 = s2, i2 = e2[s2]; n2 && t2(e2[n2 - 1], i2) > 0; )
              e2[n2] = e2[--n2];
            n2 !== s2++ && (e2[n2] = i2);
          }
          return e2;
        }, gu = function(e2, t2, i2, n2) {
          for (var r2 = t2.length, s2 = i2.length, o2 = 0, a2 = 0; o2 < r2 || a2 < s2; )
            e2[o2 + a2] = o2 < r2 && a2 < s2 ? n2(t2[o2], i2[a2]) <= 0 ? t2[o2++] : i2[a2++] : o2 < r2 ? t2[o2++] : i2[a2++];
          return e2;
        }, Tu = mu, Su = ce, Ru = function(e2, t2) {
          var i2 = [][e2];
          return !!i2 && Su(function() {
            i2.call(null, t2 || function() {
              return 1;
            }, 1);
          });
        }, Cu = pt.match(/firefox\/(\d+)/i), vu = !!Cu && +Cu[1], Iu = /MSIE|Trident/.test(pt), yu = pt.match(/AppleWebKit\/(\d+)\./), Au = !!yu && +yu[1], bu = kn, wu = _e, Ou = Ut, Nu = ei, Du = Yn, Pu = function(e2, t2) {
          if (!delete e2[t2])
            throw pu("Cannot delete property " + uu(t2) + " of " + uu(e2));
        }, Lu = gr, ku = ce, Mu = Tu, Uu = Ru, xu = vu, Vu = Iu, Fu = St, Bu = Au, ju = [], Gu = wu(ju.sort), Wu = wu(ju.push), Hu = ku(function() {
          ju.sort(void 0);
        }), Ku = ku(function() {
          ju.sort(null);
        }), Yu = Uu("sort"), qu = !ku(function() {
          if (Fu)
            return Fu < 70;
          if (!(xu && xu > 3)) {
            if (Vu)
              return true;
            if (Bu)
              return Bu < 603;
            var e2, t2, i2, n2, r2 = "";
            for (e2 = 65; e2 < 76; e2++) {
              switch (t2 = String.fromCharCode(e2), e2) {
                case 66:
                case 69:
                case 70:
                case 72:
                  i2 = 3;
                  break;
                case 68:
                case 71:
                  i2 = 4;
                  break;
                default:
                  i2 = 2;
              }
              for (n2 = 0; n2 < 47; n2++)
                ju.push({ k: t2 + n2, v: i2 });
            }
            for (ju.sort(function(e3, t3) {
              return t3.v - e3.v;
            }), n2 = 0; n2 < ju.length; n2++)
              t2 = ju[n2].k.charAt(0), r2.charAt(r2.length - 1) !== t2 && (r2 += t2);
            return "DGBEFHACIJK" !== r2;
          }
        });
        bu({ target: "Array", proto: true, forced: Hu || !Ku || !Yu || !qu }, { sort: function(e2) {
          void 0 !== e2 && Ou(e2);
          var t2 = Nu(this);
          if (qu)
            return void 0 === e2 ? Gu(t2) : Gu(t2, e2);
          var i2, n2, r2 = [], s2 = Du(t2);
          for (n2 = 0; n2 < s2; n2++)
            n2 in t2 && Wu(r2, t2[n2]);
          for (Mu(r2, function(e3) {
            return function(t3, i3) {
              return void 0 === i3 ? -1 : void 0 === t3 ? 1 : void 0 !== e3 ? +e3(t3, i3) || 0 : Lu(t3) > Lu(i3) ? 1 : -1;
            };
          }(e2)), i2 = Du(r2), n2 = 0; n2 < i2; )
            t2[n2] = r2[n2++];
          for (; n2 < s2; )
            Pu(t2, n2++);
          return t2;
        } });
        var Ju = er("Array").sort, zu = Ee, Xu = Ju, Qu = Array.prototype, Zu = J(function(e2) {
          var t2 = e2.sort;
          return e2 === Qu || zu(Qu, e2) && t2 === Qu.sort ? Xu : t2;
        }), $u = ut, ep = To, tp = ko, ip = cn, np = _e([].concat), rp = $u("Reflect", "ownKeys") || function(e2) {
          var t2 = ep.f(ip(e2)), i2 = tp.f;
          return i2 ? np(t2, i2(e2)) : t2;
        }, sp = ni, op = rp, ap = ke, cp = nn, dp = ot, lp = Cn, hp = Error, up = _e("".replace), pp = String(hp("zxcasd").stack), _p = /\n\s*at [^:]*:[^\n]*/, Ep = _p.test(pp), mp = Ke, fp = !ce(function() {
          var e2 = Error("a");
          return !("stack" in e2) || (Object.defineProperty(e2, "stack", mp(1, 7)), 7 !== e2.stack);
        }), gp = Cn, Tp = function(e2, t2) {
          if (Ep && "string" == typeof e2 && !hp.prepareStackTrace)
            for (; t2--; )
              e2 = up(e2, _p, "");
          return e2;
        }, Sp = fp, Rp = Error.captureStackTrace, Cp = Gd, vp = fi("iterator"), Ip = Array.prototype, yp = Er, Ap = Ft, bp = Qe, wp = Gd, Op = fi("iterator"), Np = function(e2) {
          if (!bp(e2))
            return Ap(e2, Op) || Ap(e2, "@@iterator") || wp[yp(e2)];
        }, Dp = Ve, Pp = Ut, Lp = cn, kp = Pt, Mp = Np, Up = TypeError, xp = Ve, Vp = cn, Fp = Ft, Bp = tn, jp = Ve, Gp = cn, Wp = Pt, Hp = function(e2) {
          return void 0 !== e2 && (Cp.Array === e2 || Ip[vp] === e2);
        }, Kp = Yn, Yp = Ee, qp = function(e2, t2) {
          var i2 = arguments.length < 2 ? Mp(e2) : t2;
          if (Pp(i2))
            return Lp(Dp(i2, e2));
          throw Up(kp(e2) + " is not iterable");
        }, Jp = Np, zp = function(e2, t2, i2) {
          var n2, r2;
          Vp(e2);
          try {
            if (!(n2 = Fp(e2, "return"))) {
              if ("throw" === t2)
                throw i2;
              return i2;
            }
            n2 = xp(n2, e2);
          } catch (e3) {
            r2 = true, n2 = e3;
          }
          if ("throw" === t2)
            throw i2;
          if (r2)
            throw n2;
          return Vp(n2), i2;
        }, Xp = TypeError, Qp = function(e2, t2) {
          this.stopped = e2, this.result = t2;
        }, Zp = Qp.prototype, $p = function(e2, t2, i2) {
          var n2, r2, s2, o2, a2, c2, d2, l2 = i2 && i2.that, h2 = !(!i2 || !i2.AS_ENTRIES), u2 = !(!i2 || !i2.IS_RECORD), p2 = !(!i2 || !i2.IS_ITERATOR), _2 = !(!i2 || !i2.INTERRUPTED), E2 = Bp(t2, l2), m2 = function(e3) {
            return n2 && zp(n2, "normal", e3), new Qp(true, e3);
          }, f2 = function(e3) {
            return h2 ? (Gp(e3), _2 ? E2(e3[0], e3[1], m2) : E2(e3[0], e3[1])) : _2 ? E2(e3, m2) : E2(e3);
          };
          if (u2)
            n2 = e2.iterator;
          else if (p2)
            n2 = e2;
          else {
            if (!(r2 = Jp(e2)))
              throw Xp(Wp(e2) + " is not iterable");
            if (Hp(r2)) {
              for (s2 = 0, o2 = Kp(e2); o2 > s2; s2++)
                if ((a2 = f2(e2[s2])) && Yp(Zp, a2))
                  return a2;
              return new Qp(false);
            }
            n2 = qp(e2, r2);
          }
          for (c2 = u2 ? e2.next : n2.next; !(d2 = jp(c2, n2)).done; ) {
            try {
              a2 = f2(d2.value);
            } catch (e3) {
              zp(n2, "throw", e3);
            }
            if ("object" == typeof a2 && a2 && Yp(Zp, a2))
              return a2;
          }
          return new Qp(false);
        }, e_ = gr, t_ = kn, i_ = Ee, n_ = nl, r_ = wl, s_ = function(e2, t2, i2) {
          for (var n2 = op(t2), r2 = cp.f, s2 = ap.f, o2 = 0; o2 < n2.length; o2++) {
            var a2 = n2[o2];
            sp(e2, a2) || i2 && sp(i2, a2) || r2(e2, a2, s2(t2, a2));
          }
        }, o_ = go, a_ = Cn, c_ = Ke, d_ = function(e2, t2) {
          dp(t2) && "cause" in t2 && lp(e2, "cause", t2.cause);
        }, l_ = function(e2, t2, i2, n2) {
          Sp && (Rp ? Rp(e2, t2) : gp(e2, "stack", Tp(i2, n2)));
        }, h_ = $p, u_ = function(e2, t2) {
          return void 0 === e2 ? arguments.length < 2 ? "" : t2 : e_(e2);
        }, p_ = fi("toStringTag"), __ = Error, E_ = [].push, m_ = function(e2, t2) {
          var i2, n2 = i_(f_, this);
          r_ ? i2 = r_(__(), n2 ? n_(this) : f_) : (i2 = n2 ? this : o_(f_), a_(i2, p_, "Error")), void 0 !== t2 && a_(i2, "message", u_(t2)), l_(i2, m_, i2.stack, 1), arguments.length > 2 && d_(i2, arguments[2]);
          var r2 = [];
          return h_(e2, E_, { that: r2 }), a_(i2, "errors", r2), i2;
        };
        r_ ? r_(m_, __) : s_(m_, __, { name: true });
        var f_ = m_.prototype = o_(__.prototype, { constructor: c_(1, m_), message: c_(1, ""), name: c_(1, "AggregateError") });
        t_({ global: true, constructor: true, arity: 2 }, { AggregateError: m_ });
        var g_, T_, S_, R_, C_ = "undefined" != typeof process && "process" == Ae(process), v_ = ut, I_ = Vo, y_ = Me, A_ = fi("species"), b_ = Ee, w_ = TypeError, O_ = ls, N_ = Pt, D_ = TypeError, P_ = cn, L_ = function(e2) {
          if (O_(e2))
            return e2;
          throw D_(N_(e2) + " is not a constructor");
        }, k_ = Qe, M_ = fi("species"), U_ = function(e2, t2) {
          var i2, n2 = P_(e2).constructor;
          return void 0 === n2 || k_(i2 = P_(n2)[M_]) ? t2 : L_(i2);
        }, x_ = TypeError, V_ = /(?:ipad|iphone|ipod).*applewebkit/i.test(pt), F_ = fe, B_ = Ce, j_ = tn, G_ = Le, W_ = ni, H_ = ce, K_ = eo, Y_ = id, q_ = Di, J_ = function(e2, t2) {
          if (e2 < t2)
            throw x_("Not enough arguments");
          return e2;
        }, z_ = V_, X_ = C_, Q_ = F_.setImmediate, Z_ = F_.clearImmediate, $_ = F_.process, eE = F_.Dispatch, tE = F_.Function, iE = F_.MessageChannel, nE = F_.String, rE = 0, sE = {}, oE = "onreadystatechange";
        H_(function() {
          g_ = F_.location;
        });
        var aE = function(e2) {
          if (W_(sE, e2)) {
            var t2 = sE[e2];
            delete sE[e2], t2();
          }
        }, cE = function(e2) {
          return function() {
            aE(e2);
          };
        }, dE = function(e2) {
          aE(e2.data);
        }, lE = function(e2) {
          F_.postMessage(nE(e2), g_.protocol + "//" + g_.host);
        };
        Q_ && Z_ || (Q_ = function(e2) {
          J_(arguments.length, 1);
          var t2 = G_(e2) ? e2 : tE(e2), i2 = Y_(arguments, 1);
          return sE[++rE] = function() {
            B_(t2, void 0, i2);
          }, T_(rE), rE;
        }, Z_ = function(e2) {
          delete sE[e2];
        }, X_ ? T_ = function(e2) {
          $_.nextTick(cE(e2));
        } : eE && eE.now ? T_ = function(e2) {
          eE.now(cE(e2));
        } : iE && !z_ ? (R_ = (S_ = new iE()).port2, S_.port1.onmessage = dE, T_ = j_(R_.postMessage, R_)) : F_.addEventListener && G_(F_.postMessage) && !F_.importScripts && g_ && "file:" !== g_.protocol && !H_(lE) ? (T_ = lE, F_.addEventListener("message", dE, false)) : T_ = oE in q_("script") ? function(e2) {
          K_.appendChild(q_("script"))[oE] = function() {
            K_.removeChild(this), aE(e2);
          };
        } : function(e2) {
          setTimeout(cE(e2), 0);
        });
        var hE = { set: Q_, clear: Z_ }, uE = function() {
          this.head = null, this.tail = null;
        };
        uE.prototype = { add: function(e2) {
          var t2 = { item: e2, next: null }, i2 = this.tail;
          i2 ? i2.next = t2 : this.head = t2, this.tail = t2;
        }, get: function() {
          var e2 = this.head;
          if (e2)
            return null === (this.head = e2.next) && (this.tail = null), e2.item;
        } };
        var pE, _E, EE, mE, fE, gE = uE, TE = /ipad|iphone|ipod/i.test(pt) && "undefined" != typeof Pebble, SE = /web0s(?!.*chrome)/i.test(pt), RE = fe, CE = tn, vE = ke.f, IE = hE.set, yE = gE, AE = V_, bE = TE, wE = SE, OE = C_, NE = RE.MutationObserver || RE.WebKitMutationObserver, DE = RE.document, PE = RE.process, LE = RE.Promise, kE = vE(RE, "queueMicrotask"), ME = kE && kE.value;
        if (!ME) {
          var UE = new yE(), xE = function() {
            var e2, t2;
            for (OE && (e2 = PE.domain) && e2.exit(); t2 = UE.get(); )
              try {
                t2();
              } catch (e3) {
                throw UE.head && pE(), e3;
              }
            e2 && e2.enter();
          };
          AE || OE || wE || !NE || !DE ? !bE && LE && LE.resolve ? ((mE = LE.resolve(void 0)).constructor = LE, fE = CE(mE.then, mE), pE = function() {
            fE(xE);
          }) : OE ? pE = function() {
            PE.nextTick(xE);
          } : (IE = CE(IE, RE), pE = function() {
            IE(xE);
          }) : (_E = true, EE = DE.createTextNode(""), new NE(xE).observe(EE, { characterData: true }), pE = function() {
            EE.data = _E = !_E;
          }), ME = function(e2) {
            UE.head || pE(), UE.add(e2);
          };
        }
        var VE = ME, FE = function(e2) {
          try {
            return { error: false, value: e2() };
          } catch (e3) {
            return { error: true, value: e3 };
          }
        }, BE = fe.Promise, jE = "object" == typeof Deno && Deno && "object" == typeof Deno.version, GE = !jE && !C_ && "object" == typeof window && "object" == typeof document, WE = fe, HE = BE, KE = Le, YE = Qi, qE = Xr, JE = fi, zE = GE, XE = jE, QE = St, ZE = HE && HE.prototype, $E = JE("species"), em = false, tm = KE(WE.PromiseRejectionEvent), im = YE("Promise", function() {
          var e2 = qE(HE), t2 = e2 !== String(HE);
          if (!t2 && 66 === QE)
            return true;
          if (!ZE.catch || !ZE.finally)
            return true;
          if (!QE || QE < 51 || !/native code/.test(e2)) {
            var i2 = new HE(function(e3) {
              e3(1);
            }), n2 = function(e3) {
              e3(function() {
              }, function() {
              });
            };
            if ((i2.constructor = {})[$E] = n2, !(em = i2.then(function() {
            }) instanceof n2))
              return true;
          }
          return !t2 && (zE || XE) && !tm;
        }), nm = { CONSTRUCTOR: im, REJECTION_EVENT: tm, SUBCLASSING: em }, rm = {}, sm = Ut, om = TypeError, am = function(e2) {
          var t2, i2;
          this.promise = new e2(function(e3, n2) {
            if (void 0 !== t2 || void 0 !== i2)
              throw om("Bad Promise constructor");
            t2 = e3, i2 = n2;
          }), this.resolve = sm(t2), this.reject = sm(i2);
        };
        rm.f = function(e2) {
          return new am(e2);
        };
        var cm, dm, lm = kn, hm = C_, um = fe, pm = Ve, _m = Uo, Em = ca, mm = function(e2) {
          var t2 = v_(e2);
          y_ && t2 && !t2[A_] && I_(t2, A_, { configurable: true, get: function() {
            return this;
          } });
        }, fm = Ut, gm = Le, Tm = ot, Sm = function(e2, t2) {
          if (b_(t2, e2))
            return e2;
          throw w_("Incorrect invocation");
        }, Rm = U_, Cm = hE.set, vm = VE, Im = function(e2, t2) {
          try {
            1 == arguments.length ? console.error(e2) : console.error(e2, t2);
          } catch (e3) {
          }
        }, ym = FE, Am = gE, bm = Ia, wm = BE, Om = nm, Nm = rm, Dm = "Promise", Pm = Om.CONSTRUCTOR, Lm = Om.REJECTION_EVENT, km = bm.getterFor(Dm), Mm = bm.set, Um = wm && wm.prototype, xm = wm, Vm = Um, Fm = um.TypeError, Bm = um.document, jm = um.process, Gm = Nm.f, Wm = Gm, Hm = !!(Bm && Bm.createEvent && um.dispatchEvent), Km = "unhandledrejection", Ym = function(e2) {
          var t2;
          return !(!Tm(e2) || !gm(t2 = e2.then)) && t2;
        }, qm = function(e2, t2) {
          var i2, n2, r2, s2 = t2.value, o2 = 1 == t2.state, a2 = o2 ? e2.ok : e2.fail, c2 = e2.resolve, d2 = e2.reject, l2 = e2.domain;
          try {
            a2 ? (o2 || (2 === t2.rejection && Zm(t2), t2.rejection = 1), true === a2 ? i2 = s2 : (l2 && l2.enter(), i2 = a2(s2), l2 && (l2.exit(), r2 = true)), i2 === e2.promise ? d2(Fm("Promise-chain cycle")) : (n2 = Ym(i2)) ? pm(n2, i2, c2, d2) : c2(i2)) : d2(s2);
          } catch (e3) {
            l2 && !r2 && l2.exit(), d2(e3);
          }
        }, Jm = function(e2, t2) {
          e2.notified || (e2.notified = true, vm(function() {
            for (var i2, n2 = e2.reactions; i2 = n2.get(); )
              qm(i2, e2);
            e2.notified = false, t2 && !e2.rejection && Xm(e2);
          }));
        }, zm = function(e2, t2, i2) {
          var n2, r2;
          Hm ? ((n2 = Bm.createEvent("Event")).promise = t2, n2.reason = i2, n2.initEvent(e2, false, true), um.dispatchEvent(n2)) : n2 = { promise: t2, reason: i2 }, !Lm && (r2 = um["on" + e2]) ? r2(n2) : e2 === Km && Im("Unhandled promise rejection", i2);
        }, Xm = function(e2) {
          pm(Cm, um, function() {
            var t2, i2 = e2.facade, n2 = e2.value;
            if (Qm(e2) && (t2 = ym(function() {
              hm ? jm.emit("unhandledRejection", n2, i2) : zm(Km, i2, n2);
            }), e2.rejection = hm || Qm(e2) ? 2 : 1, t2.error))
              throw t2.value;
          });
        }, Qm = function(e2) {
          return 1 !== e2.rejection && !e2.parent;
        }, Zm = function(e2) {
          pm(Cm, um, function() {
            var t2 = e2.facade;
            hm ? jm.emit("rejectionHandled", t2) : zm("rejectionhandled", t2, e2.value);
          });
        }, $m = function(e2, t2, i2) {
          return function(n2) {
            e2(t2, n2, i2);
          };
        }, ef = function(e2, t2, i2) {
          e2.done || (e2.done = true, i2 && (e2 = i2), e2.value = t2, e2.state = 2, Jm(e2, true));
        }, tf = function(e2, t2, i2) {
          if (!e2.done) {
            e2.done = true, i2 && (e2 = i2);
            try {
              if (e2.facade === t2)
                throw Fm("Promise can't be resolved itself");
              var n2 = Ym(t2);
              n2 ? vm(function() {
                var i3 = { done: false };
                try {
                  pm(n2, t2, $m(tf, i3, e2), $m(ef, i3, e2));
                } catch (t3) {
                  ef(i3, t3, e2);
                }
              }) : (e2.value = t2, e2.state = 1, Jm(e2, false));
            } catch (t3) {
              ef({ done: false }, t3, e2);
            }
          }
        };
        Pm && (Vm = (xm = function(e2) {
          Sm(this, Vm), fm(e2), pm(cm, this);
          var t2 = km(this);
          try {
            e2($m(tf, t2), $m(ef, t2));
          } catch (e3) {
            ef(t2, e3);
          }
        }).prototype, (cm = function(e2) {
          Mm(this, { type: Dm, done: false, notified: false, parent: false, reactions: new Am(), rejection: false, state: 0, value: void 0 });
        }).prototype = _m(Vm, "then", function(e2, t2) {
          var i2 = km(this), n2 = Gm(Rm(this, xm));
          return i2.parent = true, n2.ok = !gm(e2) || e2, n2.fail = gm(t2) && t2, n2.domain = hm ? jm.domain : void 0, 0 == i2.state ? i2.reactions.add(n2) : vm(function() {
            qm(n2, i2);
          }), n2.promise;
        }), dm = function() {
          var e2 = new cm(), t2 = km(e2);
          this.promise = e2, this.resolve = $m(tf, t2), this.reject = $m(ef, t2);
        }, Nm.f = Gm = function(e2) {
          return e2 === xm || void 0 === e2 ? new dm(e2) : Wm(e2);
        }), lm({ global: true, constructor: true, wrap: true, forced: Pm }, { Promise: xm }), Em(xm, Dm, false, true), mm(Dm);
        var nf = fi("iterator"), rf = false;
        try {
          var sf = 0, of = { next: function() {
            return { done: !!sf++ };
          }, return: function() {
            rf = true;
          } };
          of[nf] = function() {
            return this;
          }, Array.from(of, function() {
            throw 2;
          });
        } catch (e2) {
        }
        var af = BE, cf = function(e2, t2) {
          if (!t2 && !rf)
            return false;
          var i2 = false;
          try {
            var n2 = {};
            n2[nf] = function() {
              return { next: function() {
                return { done: i2 = true };
              } };
            }, e2(n2);
          } catch (e3) {
          }
          return i2;
        }, df = nm.CONSTRUCTOR || !cf(function(e2) {
          af.all(e2).then(void 0, function() {
          });
        }), lf = Ve, hf = Ut, uf = rm, pf = FE, _f = $p;
        kn({ target: "Promise", stat: true, forced: df }, { all: function(e2) {
          var t2 = this, i2 = uf.f(t2), n2 = i2.resolve, r2 = i2.reject, s2 = pf(function() {
            var i3 = hf(t2.resolve), s3 = [], o2 = 0, a2 = 1;
            _f(e2, function(e3) {
              var c2 = o2++, d2 = false;
              a2++, lf(i3, t2, e3).then(function(e4) {
                d2 || (d2 = true, s3[c2] = e4, --a2 || n2(s3));
              }, r2);
            }), --a2 || n2(s3);
          });
          return s2.error && r2(s2.value), i2.promise;
        } });
        var Ef = kn, mf = nm.CONSTRUCTOR;
        BE && BE.prototype, Ef({ target: "Promise", proto: true, forced: mf, real: true }, { catch: function(e2) {
          return this.then(void 0, e2);
        } });
        var ff = Ve, gf = Ut, Tf = rm, Sf = FE, Rf = $p;
        kn({ target: "Promise", stat: true, forced: df }, { race: function(e2) {
          var t2 = this, i2 = Tf.f(t2), n2 = i2.reject, r2 = Sf(function() {
            var r3 = gf(t2.resolve);
            Rf(e2, function(e3) {
              ff(r3, t2, e3).then(i2.resolve, n2);
            });
          });
          return r2.error && n2(r2.value), i2.promise;
        } });
        var Cf = Ve, vf = rm;
        kn({ target: "Promise", stat: true, forced: nm.CONSTRUCTOR }, { reject: function(e2) {
          var t2 = vf.f(this);
          return Cf(t2.reject, void 0, e2), t2.promise;
        } });
        var If = cn, yf = ot, Af = rm, bf = function(e2, t2) {
          if (If(e2), yf(t2) && t2.constructor === e2)
            return t2;
          var i2 = Af.f(e2);
          return (0, i2.resolve)(t2), i2.promise;
        }, wf = kn, Of = BE, Nf = nm.CONSTRUCTOR, Df = bf, Pf = ut("Promise"), Lf = !Nf;
        wf({ target: "Promise", stat: true, forced: true }, { resolve: function(e2) {
          return Df(Lf && this === Pf ? Of : this, e2);
        } });
        var kf = Ve, Mf = Ut, Uf = rm, xf = FE, Vf = $p;
        kn({ target: "Promise", stat: true, forced: df }, { allSettled: function(e2) {
          var t2 = this, i2 = Uf.f(t2), n2 = i2.resolve, r2 = i2.reject, s2 = xf(function() {
            var i3 = Mf(t2.resolve), r3 = [], s3 = 0, o2 = 1;
            Vf(e2, function(e3) {
              var a2 = s3++, c2 = false;
              o2++, kf(i3, t2, e3).then(function(e4) {
                c2 || (c2 = true, r3[a2] = { status: "fulfilled", value: e4 }, --o2 || n2(r3));
              }, function(e4) {
                c2 || (c2 = true, r3[a2] = { status: "rejected", reason: e4 }, --o2 || n2(r3));
              });
            }), --o2 || n2(r3);
          });
          return s2.error && r2(s2.value), i2.promise;
        } });
        var Ff = Ve, Bf = Ut, jf = ut, Gf = rm, Wf = FE, Hf = $p, Kf = "No one promise resolved";
        kn({ target: "Promise", stat: true, forced: df }, { any: function(e2) {
          var t2 = this, i2 = jf("AggregateError"), n2 = Gf.f(t2), r2 = n2.resolve, s2 = n2.reject, o2 = Wf(function() {
            var n3 = Bf(t2.resolve), o3 = [], a2 = 0, c2 = 1, d2 = false;
            Hf(e2, function(e3) {
              var l2 = a2++, h2 = false;
              c2++, Ff(n3, t2, e3).then(function(e4) {
                h2 || d2 || (d2 = true, r2(e4));
              }, function(e4) {
                h2 || d2 || (h2 = true, o3[l2] = e4, --c2 || s2(new i2(o3, Kf)));
              });
            }), --c2 || s2(new i2(o3, Kf));
          });
          return o2.error && s2(o2.value), n2.promise;
        } });
        var Yf = kn, qf = BE, Jf = ce, zf = ut, Xf = Le, Qf = U_, Zf = bf, $f = qf && qf.prototype;
        Yf({ target: "Promise", proto: true, real: true, forced: !!qf && Jf(function() {
          $f.finally.call({ then: function() {
          } }, function() {
          });
        }) }, { finally: function(e2) {
          var t2 = Qf(this, zf("Promise")), i2 = Xf(e2);
          return this.then(i2 ? function(i3) {
            return Zf(t2, e2()).then(function() {
              return i3;
            });
          } : e2, i2 ? function(i3) {
            return Zf(t2, e2()).then(function() {
              throw i3;
            });
          } : e2);
        } });
        var eg = at.Promise, tg = J(eg);
        const ig = () => {
        };
        function ng() {
          const e2 = { promise: void 0, isResolved: false, isRejected: false, isFinished: false, resolve: void 0, reject: void 0, cancel: ig };
          return e2.promise = new tg((t2, i2) => {
            e2.resolve = (i3) => {
              e2.isFinished || (e2.isResolved = true, e2.isFinished = true, t2(i3), e2.value = i3);
            }, e2.reject = (t3) => {
              e2.isFinished || (e2.isRejected = true, e2.isFinished = true, i2(t3));
            };
          }), e2;
        }
        const rg = /* @__PURE__ */ new Map(), sg = /* @__PURE__ */ new Map(), og = /* @__PURE__ */ new Map();
        var ag, cg;
        !function(e2) {
          e2.WIN_10 = "Windows 10", e2.WIN_81 = "Windows 8.1", e2.WIN_8 = "Windows 8", e2.WIN_7 = "Windows 7", e2.WIN_VISTA = "Windows Vista", e2.WIN_SERVER_2003 = "Windows Server 2003", e2.WIN_XP = "Windows XP", e2.WIN_2000 = "Windows 2000", e2.ANDROID = "Android", e2.HARMONY_OS = "HarmonyOS", e2.OPEN_BSD = "Open BSD", e2.SUN_OS = "Sun OS", e2.LINUX = "Linux", e2.IOS = "iOS", e2.MAC_OS = "Mac OS", e2.QNX = "QNX", e2.UNIX = "UNIX", e2.BEOS = "BeOS", e2.OS_2 = "OS/2", e2.SEARCH_BOT = "Search Bot";
        }(ag || (ag = {})), function(e2) {
          e2.CHROME = "Chrome", e2.SAFARI = "Safari", e2.EDGE = "Edge", e2.FIREFOX = "Firefox", e2.OPERA = "OPR", e2.QQ = "QQBrowser", e2.WECHAT = "MicroMessenger";
        }(cg || (cg = {}));
        var dg = { exports: {} };
        !function(e2, t2) {
          !function(i2, n2) {
            var r2 = "function", s2 = "undefined", o2 = "object", a2 = "string", c2 = "major", d2 = "model", l2 = "name", h2 = "type", u2 = "vendor", p2 = "version", _2 = "architecture", E2 = "console", m2 = "mobile", f2 = "tablet", g2 = "smarttv", T2 = "wearable", S2 = "embedded", R2 = "Amazon", C2 = "Apple", v2 = "ASUS", I2 = "BlackBerry", y2 = "Browser", A2 = "Chrome", b2 = "Firefox", w2 = "Google", O2 = "Huawei", N2 = "LG", D2 = "Microsoft", P2 = "Motorola", L2 = "Opera", k2 = "Samsung", M2 = "Sharp", U2 = "Sony", x2 = "Xiaomi", V2 = "Zebra", F2 = "Facebook", B2 = "Chromium OS", j2 = "Mac OS", G2 = function(e3) {
              for (var t3 = {}, i3 = 0; i3 < e3.length; i3++)
                t3[e3[i3].toUpperCase()] = e3[i3];
              return t3;
            }, W2 = function(e3, t3) {
              return typeof e3 === a2 && -1 !== H2(t3).indexOf(H2(e3));
            }, H2 = function(e3) {
              return e3.toLowerCase();
            }, K2 = function(e3, t3) {
              if (typeof e3 === a2)
                return e3 = e3.replace(/^\s\s*/, ""), typeof t3 === s2 ? e3 : e3.substring(0, 350);
            }, Y2 = function(e3, t3) {
              for (var i3, s3, a3, c3, d3, l3, h3 = 0; h3 < t3.length && !d3; ) {
                var u3 = t3[h3], p3 = t3[h3 + 1];
                for (i3 = s3 = 0; i3 < u3.length && !d3 && u3[i3]; )
                  if (d3 = u3[i3++].exec(e3))
                    for (a3 = 0; a3 < p3.length; a3++)
                      l3 = d3[++s3], typeof (c3 = p3[a3]) === o2 && c3.length > 0 ? 2 === c3.length ? typeof c3[1] == r2 ? this[c3[0]] = c3[1].call(this, l3) : this[c3[0]] = c3[1] : 3 === c3.length ? typeof c3[1] !== r2 || c3[1].exec && c3[1].test ? this[c3[0]] = l3 ? l3.replace(c3[1], c3[2]) : n2 : this[c3[0]] = l3 ? c3[1].call(this, l3, c3[2]) : n2 : 4 === c3.length && (this[c3[0]] = l3 ? c3[3].call(this, l3.replace(c3[1], c3[2])) : n2) : this[c3] = l3 || n2;
                h3 += 2;
              }
            }, q2 = function(e3, t3) {
              for (var i3 in t3)
                if (typeof t3[i3] === o2 && t3[i3].length > 0) {
                  for (var r3 = 0; r3 < t3[i3].length; r3++)
                    if (W2(t3[i3][r3], e3))
                      return "?" === i3 ? n2 : i3;
                } else if (W2(t3[i3], e3))
                  return "?" === i3 ? n2 : i3;
              return e3;
            }, J2 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, z2 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [p2, [l2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [p2, [l2, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [l2, p2], [/opios[\/ ]+([\w\.]+)/i], [p2, [l2, L2 + " Mini"]], [/\bopr\/([\w\.]+)/i], [p2, [l2, L2]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [l2, p2], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [p2, [l2, "UC" + y2]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [p2, [l2, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [p2, [l2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [p2, [l2, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [p2, [l2, "IE"]], [/yabrowser\/([\w\.]+)/i], [p2, [l2, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[l2, /(.+)/, "$1 Secure " + y2], p2], [/\bfocus\/([\w\.]+)/i], [p2, [l2, b2 + " Focus"]], [/\bopt\/([\w\.]+)/i], [p2, [l2, L2 + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [p2, [l2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [p2, [l2, "Dolphin"]], [/coast\/([\w\.]+)/i], [p2, [l2, L2 + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [p2, [l2, "MIUI " + y2]], [/fxios\/([-\w\.]+)/i], [p2, [l2, b2]], [/\bqihu|(qi?ho?o?|360)browser/i], [[l2, "360 " + y2]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[l2, /(.+)/, "$1 " + y2], p2], [/(comodo_dragon)\/([\w\.]+)/i], [[l2, /_/g, " "], p2], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [l2, p2], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [l2], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[l2, F2], p2], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [l2, p2], [/\bgsa\/([\w\.]+) .*safari\//i], [p2, [l2, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [p2, [l2, A2 + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[l2, A2 + " WebView"], p2], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [p2, [l2, "Android " + y2]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [l2, p2], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [p2, [l2, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [p2, l2], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [l2, [p2, q2, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [l2, p2], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[l2, "Netscape"], p2], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [p2, [l2, b2 + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [l2, p2], [/(cobalt)\/([\w\.]+)/i], [l2, [p2, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[_2, "amd64"]], [/(ia32(?=;))/i], [[_2, H2]], [/((?:i[346]|x)86)[;\)]/i], [[_2, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[_2, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[_2, "armhf"]], [/windows (ce|mobile); ppc;/i], [[_2, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[_2, /ower/, "", H2]], [/(sun4\w)[;\)]/i], [[_2, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[_2, H2]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d2, [u2, k2], [h2, f2]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [d2, [u2, k2], [h2, m2]], [/\((ip(?:hone|od)[\w ]*);/i], [d2, [u2, C2], [h2, m2]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d2, [u2, C2], [h2, f2]], [/(macintosh);/i], [d2, [u2, C2]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d2, [u2, M2], [h2, m2]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d2, [u2, O2], [h2, f2]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d2, [u2, O2], [h2, m2]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[d2, /_/g, " "], [u2, x2], [h2, m2]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d2, /_/g, " "], [u2, x2], [h2, f2]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d2, [u2, "OPPO"], [h2, m2]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d2, [u2, "Vivo"], [h2, m2]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [d2, [u2, "Realme"], [h2, m2]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d2, [u2, P2], [h2, m2]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d2, [u2, P2], [h2, f2]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d2, [u2, N2], [h2, f2]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d2, [u2, N2], [h2, m2]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d2, [u2, "Lenovo"], [h2, f2]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d2, /_/g, " "], [u2, "Nokia"], [h2, m2]], [/(pixel c)\b/i], [d2, [u2, w2], [h2, f2]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d2, [u2, w2], [h2, m2]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d2, [u2, U2], [h2, m2]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d2, "Xperia Tablet"], [u2, U2], [h2, f2]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d2, [u2, "OnePlus"], [h2, m2]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d2, [u2, R2], [h2, f2]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d2, /(.+)/g, "Fire Phone $1"], [u2, R2], [h2, m2]], [/(playbook);[-\w\),; ]+(rim)/i], [d2, u2, [h2, f2]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d2, [u2, I2], [h2, m2]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d2, [u2, v2], [h2, f2]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d2, [u2, v2], [h2, m2]], [/(nexus 9)/i], [d2, [u2, "HTC"], [h2, f2]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [u2, [d2, /_/g, " "], [h2, m2]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d2, [u2, "Acer"], [h2, f2]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d2, [u2, "Meizu"], [h2, m2]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [u2, d2, [h2, m2]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [u2, d2, [h2, f2]], [/(surface duo)/i], [d2, [u2, D2], [h2, f2]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d2, [u2, "Fairphone"], [h2, m2]], [/(u304aa)/i], [d2, [u2, "AT&T"], [h2, m2]], [/\bsie-(\w*)/i], [d2, [u2, "Siemens"], [h2, m2]], [/\b(rct\w+) b/i], [d2, [u2, "RCA"], [h2, f2]], [/\b(venue[\d ]{2,7}) b/i], [d2, [u2, "Dell"], [h2, f2]], [/\b(q(?:mv|ta)\w+) b/i], [d2, [u2, "Verizon"], [h2, f2]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d2, [u2, "Barnes & Noble"], [h2, f2]], [/\b(tm\d{3}\w+) b/i], [d2, [u2, "NuVision"], [h2, f2]], [/\b(k88) b/i], [d2, [u2, "ZTE"], [h2, f2]], [/\b(nx\d{3}j) b/i], [d2, [u2, "ZTE"], [h2, m2]], [/\b(gen\d{3}) b.+49h/i], [d2, [u2, "Swiss"], [h2, m2]], [/\b(zur\d{3}) b/i], [d2, [u2, "Swiss"], [h2, f2]], [/\b((zeki)?tb.*\b) b/i], [d2, [u2, "Zeki"], [h2, f2]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[u2, "Dragon Touch"], d2, [h2, f2]], [/\b(ns-?\w{0,9}) b/i], [d2, [u2, "Insignia"], [h2, f2]], [/\b((nxa|next)-?\w{0,9}) b/i], [d2, [u2, "NextBook"], [h2, f2]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[u2, "Voice"], d2, [h2, m2]], [/\b(lvtel\-)?(v1[12]) b/i], [[u2, "LvTel"], d2, [h2, m2]], [/\b(ph-1) /i], [d2, [u2, "Essential"], [h2, m2]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d2, [u2, "Envizen"], [h2, f2]], [/\b(trio[-\w\. ]+) b/i], [d2, [u2, "MachSpeed"], [h2, f2]], [/\btu_(1491) b/i], [d2, [u2, "Rotor"], [h2, f2]], [/(shield[\w ]+) b/i], [d2, [u2, "Nvidia"], [h2, f2]], [/(sprint) (\w+)/i], [u2, d2, [h2, m2]], [/(kin\.[onetw]{3})/i], [[d2, /\./g, " "], [u2, D2], [h2, m2]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d2, [u2, V2], [h2, f2]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d2, [u2, V2], [h2, m2]], [/smart-tv.+(samsung)/i], [u2, [h2, g2]], [/hbbtv.+maple;(\d+)/i], [[d2, /^/, "SmartTV"], [u2, k2], [h2, g2]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[u2, N2], [h2, g2]], [/(apple) ?tv/i], [u2, [d2, C2 + " TV"], [h2, g2]], [/crkey/i], [[d2, A2 + "cast"], [u2, w2], [h2, g2]], [/droid.+aft(\w)( bui|\))/i], [d2, [u2, R2], [h2, g2]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d2, [u2, M2], [h2, g2]], [/(bravia[\w ]+)( bui|\))/i], [d2, [u2, U2], [h2, g2]], [/(mitv-\w{5}) bui/i], [d2, [u2, x2], [h2, g2]], [/Hbbtv.*(technisat) (.*);/i], [u2, d2, [h2, g2]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[u2, K2], [d2, K2], [h2, g2]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[h2, g2]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [u2, d2, [h2, E2]], [/droid.+; (shield) bui/i], [d2, [u2, "Nvidia"], [h2, E2]], [/(playstation [345portablevi]+)/i], [d2, [u2, U2], [h2, E2]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d2, [u2, D2], [h2, E2]], [/((pebble))app/i], [u2, d2, [h2, T2]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d2, [u2, C2], [h2, T2]], [/droid.+; (glass) \d/i], [d2, [u2, w2], [h2, T2]], [/droid.+; (wt63?0{2,3})\)/i], [d2, [u2, V2], [h2, T2]], [/(quest( 2| pro)?)/i], [d2, [u2, F2], [h2, T2]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [u2, [h2, S2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [d2, [h2, m2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d2, [h2, f2]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[h2, f2]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[h2, m2]], [/(android[-\w\. ]{0,9});.+buil/i], [d2, [u2, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [p2, [l2, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [p2, [l2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [l2, p2], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [p2, l2]], os: [[/microsoft (windows) (vista|xp)/i], [l2, p2], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [l2, [p2, q2, J2]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[l2, "Windows"], [p2, q2, J2]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[p2, /_/g, "."], [l2, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[l2, j2], [p2, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [p2, l2], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [l2, p2], [/\(bb(10);/i], [p2, [l2, I2]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [p2, [l2, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [p2, [l2, b2 + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [p2, [l2, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [p2, [l2, "watchOS"]], [/crkey\/([\d\.]+)/i], [p2, [l2, A2 + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[l2, B2], p2], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [l2, p2], [/(sunos) ?([\w\.\d]*)/i], [[l2, "Solaris"], p2], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [l2, p2]] }, X2 = function(e3, t3) {
              if (typeof e3 === o2 && (t3 = e3, e3 = n2), !(this instanceof X2))
                return new X2(e3, t3).getResult();
              var E3 = typeof i2 !== s2 && i2.navigator ? i2.navigator : n2, g3 = e3 || (E3 && E3.userAgent ? E3.userAgent : ""), T3 = E3 && E3.userAgentData ? E3.userAgentData : n2, S3 = t3 ? function(e4, t4) {
                var i3 = {};
                for (var n3 in e4)
                  t4[n3] && t4[n3].length % 2 == 0 ? i3[n3] = t4[n3].concat(e4[n3]) : i3[n3] = e4[n3];
                return i3;
              }(z2, t3) : z2;
              return this.getBrowser = function() {
                var e4 = {};
                return e4[l2] = n2, e4[p2] = n2, Y2.call(e4, g3, S3.browser), e4[c2] = function(e5) {
                  return typeof e5 === a2 ? e5.replace(/[^\d\.]/g, "").split(".")[0] : n2;
                }(e4[p2]), E3 && E3.brave && typeof E3.brave.isBrave == r2 && (e4[l2] = "Brave"), e4;
              }, this.getCPU = function() {
                var e4 = {};
                return e4[_2] = n2, Y2.call(e4, g3, S3.cpu), e4;
              }, this.getDevice = function() {
                var e4 = {};
                return e4[u2] = n2, e4[d2] = n2, e4[h2] = n2, Y2.call(e4, g3, S3.device), !e4[h2] && T3 && T3.mobile && (e4[h2] = m2), "Macintosh" == e4[d2] && E3 && typeof E3.standalone !== s2 && E3.maxTouchPoints && E3.maxTouchPoints > 2 && (e4[d2] = "iPad", e4[h2] = f2), e4;
              }, this.getEngine = function() {
                var e4 = {};
                return e4[l2] = n2, e4[p2] = n2, Y2.call(e4, g3, S3.engine), e4;
              }, this.getOS = function() {
                var e4 = {};
                return e4[l2] = n2, e4[p2] = n2, Y2.call(e4, g3, S3.os), !e4[l2] && T3 && "Unknown" != T3.platform && (e4[l2] = T3.platform.replace(/chrome os/i, B2).replace(/macos/i, j2)), e4;
              }, this.getResult = function() {
                return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
              }, this.getUA = function() {
                return g3;
              }, this.setUA = function(e4) {
                return g3 = typeof e4 === a2 && e4.length > 350 ? K2(e4, 350) : e4, this;
              }, this.setUA(g3), this;
            };
            X2.VERSION = "0.7.34", X2.BROWSER = G2([l2, p2, c2]), X2.CPU = G2([_2]), X2.DEVICE = G2([d2, u2, h2, E2, m2, g2, f2, T2, S2]), X2.ENGINE = X2.OS = G2([l2, p2]), e2.exports && (t2 = e2.exports = X2), t2.UAParser = X2;
            var Q2 = typeof i2 !== s2 && (i2.jQuery || i2.Zepto);
            if (Q2 && !Q2.ua) {
              var Z2 = new X2();
              Q2.ua = Z2.getResult(), Q2.ua.get = function() {
                return Z2.getUA();
              }, Q2.ua.set = function(e3) {
                Z2.setUA(e3);
                var t3 = Z2.getResult();
                for (var i3 in t3)
                  Q2.ua[i3] = t3[i3];
              };
            }
          }("object" == typeof window ? window : q);
        }(dg, dg.exports);
        const lg = new (J(dg.exports))();
        let hg = lg.getResult(), ug = null;
        function pg(e2) {
          if (!ug) {
            e2 && lg.setUA(e2), hg = lg.getResult();
            const t2 = function(e3) {
              if ("Blink" === e3.engine.name && "WeChat" !== e3.browser.name)
                return cg.CHROME;
              switch (e3.browser.name) {
                case "Chrome Headless":
                case "Chrome":
                case "Chromium":
                  return cg.CHROME;
                case "Safari":
                case "Mobile Safari":
                  return cg.SAFARI;
                case "Edge":
                  return cg.EDGE;
                case "Firefox":
                  return cg.FIREFOX;
                case "QQBrowser":
                  return cg.QQ;
                case "Opera":
                  return cg.OPERA;
                case "WeChat":
                  return cg.WECHAT;
                default:
                  return e3.browser.name || "";
              }
            }(hg), i2 = function(e3) {
              let t3;
              t3 = "Blink" === e3.engine.name ? e3.engine.version || "" : e3.browser.version || "";
              return t3.split(".")[0];
            }(hg), n2 = function(e3) {
              if ("Windows" === e3.os.name)
                return e3.os.version ? e3.os.name + " " + e3.os.version : e3.os.name;
              return e3.os.name || "";
            }(hg), r2 = hg.os.version;
            if (!(t2 && i2 && n2 && r2))
              return { name: t2, version: i2, os: n2, osVersion: r2 };
            ug = { name: t2, version: i2, os: n2, osVersion: r2 };
          }
          return ug;
        }
        function _g() {
          return pg().os;
        }
        function Eg() {
          const e2 = pg();
          return "".concat(e2.os, " ").concat(e2.osVersion);
        }
        function mg() {
          const e2 = pg();
          return !!("WebKit" === hg.engine.name && e2.os === ag.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e2.name !== cg.SAFARI || Cg() && e2.name !== cg.SAFARI);
        }
        function fg() {
          const e2 = pg();
          if (mg()) {
            if (e2.os === ag.MAC_OS)
              return true;
            if (e2.os === ag.IOS) {
              const e3 = hg.os.version && hg.os.version.split(".");
              if (e3 && 14 === Number(e3[0]) && e3[1] && Number(e3[1]) >= 3)
                return true;
              if (e3 && Number(e3[0]) > 14)
                return true;
            }
          }
          return false;
        }
        function gg() {
          return "WebKit" === hg.engine.name;
        }
        function Tg() {
          return pg().name === cg.CHROME;
        }
        function Sg() {
          return pg().name === cg.SAFARI;
        }
        function Rg() {
          return pg().name === cg.FIREFOX;
        }
        function Cg() {
          return pg().os === ag.IOS;
        }
        function vg(e2) {
          const t2 = pg();
          return !(t2.name !== cg.CHROME || !t2.osVersion) && Number(t2.version) >= e2;
        }
        function Ig(e2) {
          const t2 = pg();
          return !(t2.name !== cg.EDGE || !t2.osVersion) && Number(t2.version) >= e2;
        }
        function yg(e2) {
          const t2 = pg();
          return !(t2.name !== cg.OPERA || !t2.osVersion) && Number(t2.version) >= e2;
        }
        function Ag() {
          const e2 = pg();
          return !(e2.name !== cg.CHROME || !e2.osVersion) && Number(e2.version) <= 90;
        }
        function bg() {
          const e2 = pg();
          if (e2.os !== ag.IOS || !e2.osVersion)
            return false;
          const t2 = e2.osVersion.split(".");
          return Number(t2[0]) < 14 || 14 === Number(t2[0]) && Number(t2[1]) <= 6;
        }
        function wg() {
          const e2 = pg();
          if (e2.os !== ag.IOS || !e2.osVersion)
            return false;
          const t2 = e2.osVersion.split(".");
          return 15 === Number(t2[0]);
        }
        function Og() {
          const e2 = pg();
          if (e2.os !== ag.IOS || !e2.osVersion)
            return false;
          const t2 = e2.osVersion.split(".");
          return 16 === Number(t2[0]);
        }
        function Ng() {
          const e2 = pg();
          if (e2.os !== ag.IOS || !e2.osVersion)
            return false;
          const t2 = e2.osVersion.split(".");
          return 15 === Number(t2[0]) && Number(t2[1]) >= 1;
        }
        function Dg() {
          return Sg() && navigator.maxTouchPoints > 0;
        }
        function Pg() {
          return pg().name === cg.WECHAT;
        }
        function Lg() {
          return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
        }
        function kg() {
          const e2 = pg();
          if (e2.name === cg.EDGE || e2.name === cg.SAFARI)
            return false;
          return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
        }
        function Mg() {
          return _g() === ag.ANDROID;
        }
        function Ug() {
          const e2 = pg();
          return Mg() && (e2.name === cg.CHROME || e2.name === cg.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
        }
        var xg;
        !function(e2) {
          e2.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e2.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e2.TIMEOUT = "TIMEOUT", e2.INVALID_PARAMS = "INVALID_PARAMS", e2.NOT_READABLE = "NOT_READABLE", e2.NOT_SUPPORTED = "NOT_SUPPORTED", e2.INVALID_OPERATION = "INVALID_OPERATION", e2.OPERATION_ABORTED = "OPERATION_ABORTED", e2.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e2.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e2.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED", e2.DATACHANNEL_FAILED = "DATACHANNEL_FAILED", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e2.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e2.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e2.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e2.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e2.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e2.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e2.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e2.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e2.PERMISSION_DENIED = "PERMISSION_DENIED", e2.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e2.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e2.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e2.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e2.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e2.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e2.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e2.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e2.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e2.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e2.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e2.UID_CONFLICT = "UID_CONFLICT", e2.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e2.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e2.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e2.INVALID_TRACK = "INVALID_TRACK", e2.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e2.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e2.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e2.ICE_FAILED = "ICE_FAILED", e2.PC_CLOSED = "PC_CLOSED", e2.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e2.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e2.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e2.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e2.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e2.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e2.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e2.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e2.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e2.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e2.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e2.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e2.WS_ABORT = "WS_ABORT", e2.WS_DISCONNECT = "WS_DISCONNECT", e2.WS_ERR = "WS_ERR", e2.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e2.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e2.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e2.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e2.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e2.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e2.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e2.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e2.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e2.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e2.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e2.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e2.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e2.INVALID_PLUGIN = "INVALID_PLUGIN", e2.DISCONNECT_P2P = "DISCONNECT_P2P", e2.INIT_WEBSOCKET_TIMEOUT = "INIT_WEBSOCKET_TIMEOUT", e2.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e2.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e2.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e2.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e2.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED";
        }(xg || (xg = {}));
        let Vg = class extends Error {
          constructor(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i2 = arguments.length > 2 ? arguments[2] : void 0;
            super(t2), nu(this, "code", void 0), nu(this, "message", void 0), nu(this, "data", void 0), nu(this, "name", "AgoraRTCException"), this.code = e2, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t2), this.data = i2;
          }
          toString() {
            return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack);
          }
          print() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error", t2 = arguments.length > 1 ? arguments[1] : void 0;
            return "error" === e2 && (t2 || console).error(this.toString()), "warning" === e2 && (t2 || console).warn(this.toString()), this;
          }
          throw(e2) {
            throw this.print("error", e2), this;
          }
        };
        function Fg(e2, t2) {
          if ("boolean" != typeof e2)
            throw new Vg(xg.INVALID_PARAMS, "Invalid ".concat(t2, ": The value is of the boolean type."));
        }
        function Bg(e2, t2, i2) {
          if (Pr(i2).call(i2, e2))
            return;
          throw new Vg(xg.INVALID_PARAMS, "".concat(t2, " can only be set as ").concat(JSON.stringify(i2)));
        }
        function jg(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;
          if (e2 < i2 || e2 > n2 || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !function(e3) {
            return "number" == typeof e3 && e3 % 1 == 0;
          }(e2)) {
            throw new Vg(xg.INVALID_PARAMS, "invalid ".concat(t2, ": the value range is [").concat(i2, ", ").concat(n2, "]. integer only"));
          }
        }
        function Gg(e2, t2) {
          if ("number" != typeof e2) {
            if (!(e2.min || e2.max || e2.ideal || e2.exact)) {
              throw new Vg(xg.INVALID_PARAMS, "".concat(t2, " is not a valid ConstrainLong"));
            }
            void 0 !== e2.min && jg(e2.min, "".concat(t2, ".min"), 0, 1 / 0), void 0 !== e2.max && jg(e2.max, "".concat(t2, ".max"), 1, 1 / 0), void 0 !== e2.exact && jg(e2.exact, "".concat(t2, ".exact"), 1, 1 / 0), void 0 !== e2.ideal && jg(e2.ideal, "".concat(t2, ".ideal"), 1, 1 / 0);
          } else
            jg(e2, t2, 1, 1 / 0);
        }
        function Wg(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
          if (null == e2)
            throw new Vg(xg.INVALID_PARAMS, "".concat(t2 || "param", " cannot be empty"));
          if (!Yg(e2, i2, n2, r2))
            throw new Vg(xg.INVALID_PARAMS, "Invalid ".concat(t2 || "string param", ": Length of the string: [").concat(i2, ",").concat(n2, "].").concat(r2 ? " ASCII characters only." : ""));
        }
        function Hg(e2, t2) {
          if (!Array.isArray(e2))
            throw new Vg(xg.INVALID_PARAMS, "".concat(t2, " should be an array"));
        }
        function Kg(e2) {
          return null == e2;
        }
        function Yg(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, n2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
          return "string" == typeof e2 && e2.length <= i2 && e2.length >= t2 && (!n2 || function(e3) {
            if ("string" != typeof e3)
              return false;
            for (let t3 = 0; t3 < e3.length; t3 += 1) {
              const i3 = e3.charCodeAt(t3);
              if (i3 < 0 || i3 > 255)
                return false;
            }
            return true;
          }(e2));
        }
        function qg(e2, t2, i2) {
          if ("getBigUint64" in DataView.prototype)
            return e2.getBigUint64(t2, i2);
          const n2 = e2.getUint32(t2, i2), r2 = e2.getUint32(t2 + 4, i2), s2 = Number(!!i2), o2 = Number(!i2);
          return BigInt(n2 * o2 + r2 * s2) << BigInt(32) | BigInt(n2 * s2 + r2 * o2);
        }
        function Jg(e2, t2, i2, n2) {
          if ("setBigUint64" in DataView.prototype)
            return e2.setBigUint64(t2, i2, n2);
          const r2 = Number(i2 >> BigInt(32)), s2 = Number(i2 & BigInt(4294967295));
          n2 ? (e2.setUint32(t2 + 4, r2, n2), e2.setUint32(t2, s2, n2)) : (e2.setUint32(t2, r2, n2), e2.setUint32(t2 + 4, s2, n2));
        }
        var zg, Xg;
        !function(e2) {
          e2.COVERED = "COVERED", e2.POSITION = "POSITION", e2.SIZE = "SIZE", e2.STYLE = "STYLE";
        }(zg || (zg = {})), function(e2) {
          e2.UNMOUNTED = "UNMOUNTED", e2.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT";
        }(Xg || (Xg = {}));
        const Qg = new class {
          constructor() {
            nu(this, "_clientSize", null), nu(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), nu(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), nu(this, "getStyle", (e2) => window.getComputedStyle(e2, null)), nu(this, "checkCssVisibleProperty", (e2) => {
              var t2;
              let i2 = true;
              const n2 = this.getStyle(e2), { display: r2, visibility: s2, opacity: o2, filter: a2 } = n2;
              if (("none" === r2 || Pr(t2 = ["hidden", "collapse"]).call(t2, s2) || Number(o2) < 0.1) && (i2 = false), !i2)
                return false;
              if (a2) {
                a2.split(" ").filter((e3) => {
                  var t3;
                  const i3 = e3.split("(")[0];
                  return Pr(t3 = ["brightness", "blur", "opacity"]).call(t3, i3);
                }).map((e3) => {
                  const [t3, i3] = e3.split(/\(|\)/);
                  return [t3, Number(i3.match(/^[0-9\.]+/))];
                }).forEach((e3) => {
                  const [t3, n3] = e3;
                  switch (t3) {
                    case "brightness":
                      (n3 < 0.1 || n3 > 3) && (i2 = false);
                      break;
                    case "blur":
                      n3 > 3 && (i2 = false);
                      break;
                    case "opacity":
                      n3 < 0.1 && (i2 = false);
                  }
                });
              }
              return i2;
            }), nu(this, "checkPropertyUpToAllParentNodes", (e2, t2) => {
              let i2 = true, n2 = true;
              const r2 = (e3) => t2(e3);
              let s2 = e2;
              for (; s2 && n2; ) {
                r2(s2) || (i2 = false, n2 = false), s2 = s2.parentElement, s2 || (n2 = false);
              }
              return i2;
            }), nu(this, "checkActualCssVisibleIncludeInherit", (e2) => this.checkPropertyUpToAllParentNodes(e2, this.checkCssVisibleProperty)), nu(this, "getSizeAboutClient", (e2) => {
              const { width: t2, height: i2, left: n2, right: r2, top: s2, bottom: o2 } = e2.getBoundingClientRect(), a2 = this.getClientWidth(), c2 = this.getClientHeight();
              return { width: t2, height: i2, left: n2, right: r2, top: s2, bottom: o2, clientWidth: a2, clientHeight: c2, clientMin: Math.min(a2, c2) };
            }), nu(this, "checkActualSize", () => {
              const { width: e2, height: t2, clientMin: i2 } = this._clientSize;
              return this.checkSizeIsVisible(e2, t2, i2);
            }), nu(this, "elementFromPoint", (e2, t2) => document.elementFromPoint ? document.elementFromPoint(e2, t2) : null), nu(this, "checkCoverForAPoint", (e2, t2, i2) => {
              const n2 = this.elementFromPoint(e2, t2);
              return null !== n2 && n2 !== i2;
            }), nu(this, "getPointPositionList", () => {
              const { width: e2, height: t2, left: i2, top: n2 } = this._clientSize, r2 = e2 / 6, s2 = t2 / 6, o2 = [], a2 = 10 ** 6;
              for (let e3 = 0; e3 < 5; e3++)
                for (let t3 = 0; t3 < 5; t3++) {
                  const c2 = (i2 * a2 + (0 === e3 ? 0.1 : 4 === e3 ? (r2 * e3 * a2 - 1e5) / a2 : r2 * e3) * a2) / a2, d2 = (n2 * a2 + (0 === t3 ? 0.1 : 4 === t3 ? (s2 * t3 * a2 - 1e5) / a2 : s2 * t3) * a2) / a2;
                  o2.push({ x: c2, y: d2 });
                }
              return [...o2];
            }), nu(this, "checkElementCover", (e2) => this.getPointPositionList().map((t2) => this.checkCoverForAPoint(t2.x, t2.y, e2)).filter((e3) => !!e3).length > 6), nu(this, "checkSizeIsVisible", (e2, t2, i2) => (e2 > 50 || i2 / e2 <= 10) && (t2 > 50 || i2 / t2 <= 10)), nu(this, "checkSizeOfPartInClient", () => {
              const { left: e2, right: t2, top: i2, bottom: n2, clientHeight: r2, clientWidth: s2, clientMin: o2 } = this._clientSize;
              let a2, c2, d2, l2;
              if (e2 < 0)
                a2 = 0;
              else {
                if (!(e2 < s2))
                  return false;
                a2 = e2;
              }
              if (t2 < 0)
                return false;
              if (c2 = t2 < s2 ? t2 : s2, i2 < 0)
                d2 = 0;
              else {
                if (!(i2 < r2))
                  return false;
                d2 = i2;
              }
              if (n2 < 0)
                return false;
              l2 = n2 < r2 ? n2 : r2;
              const h2 = c2 - a2, u2 = l2 - d2;
              return this.checkSizeIsVisible(h2, u2, o2);
            }), nu(this, "returnHiddenResult", (e2) => (this._clientSize = null, { visible: false, reason: e2 })), nu(this, "checkOneElementVisible", (e2) => {
              if (e2 instanceof HTMLElement) {
                if (this.checkElementIsMountedOnDom(e2)) {
                  if (this.checkActualCssVisibleIncludeInherit(e2)) {
                    if (this._clientSize = this.getSizeAboutClient(e2), this.checkElementCover(e2))
                      return this.returnHiddenResult(zg.COVERED);
                    {
                      const e3 = this.checkActualSize(), t2 = this.checkSizeOfPartInClient();
                      return e3 && !t2 ? this.returnHiddenResult(zg.POSITION) : e3 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(zg.SIZE);
                    }
                  }
                  return this.returnHiddenResult(zg.STYLE);
                }
                return this.returnHiddenResult(Xg.UNMOUNTED);
              }
              return this.returnHiddenResult(Xg.INVALID_HTML_ELEMENT);
            }), nu(this, "checkElementIsMountedOnDom", (e2) => this.checkPropertyUpToAllParentNodes(e2, (e3) => "HTML" !== e3.nodeName.toUpperCase() ? null !== e3.parentElement : !!document.documentElement));
          }
        }();
        function Zg(e2) {
          return new TextEncoder().encode(e2);
        }
        const $g = function(e2, t2) {
          const i2 = new Uint8Array(e2.byteLength + t2.byteLength);
          return i2.set(new Uint8Array(e2), 0), i2.set(new Uint8Array(t2), e2.byteLength), i2;
        };
        const eT = async (e2) => {
          const t2 = function(e3) {
            const t3 = window.atob(e3), i3 = new Uint8Array(new ArrayBuffer(t3.length));
            for (let e4 = 0; e4 < t3.length; e4 += 1)
              i3[e4] = t3.charCodeAt(e4);
            return i3;
          }("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i2 = await window.crypto.subtle.importKey("spki", t2, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), n2 = Zg(e2), r2 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i2, n2);
          return function(e3) {
            let t3 = "";
            for (let i3 = 0; i3 < e3.length; i3 += 1)
              t3 += String.fromCharCode(e3[i3]);
            return window.btoa(t3);
          }(new Uint8Array(r2));
        }, tT = async (e2) => function(e3, t2) {
          let i2 = "";
          return new Uint8Array(e3).forEach((e4) => {
            i2 += e4.toString(t2).padStart(2, "0");
          }), i2;
        }(await crypto.subtle.digest("SHA-256", Zg(e2)), 16);
        class iT {
          constructor() {
            nu(this, "_events", {}), nu(this, "addListener", this.on);
          }
          getListeners(e2) {
            return this._events[e2] ? this._events[e2].map((e3) => e3.listener) : [];
          }
          on(e2, t2) {
            this._events[e2] || (this._events[e2] = []);
            const i2 = this._events[e2];
            -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: false });
          }
          once(e2, t2) {
            this._events[e2] || (this._events[e2] = []);
            const i2 = this._events[e2];
            -1 === this._indexOfListener(i2, t2) && i2.push({ listener: t2, once: true });
          }
          off(e2, t2) {
            if (!this._events[e2])
              return;
            const i2 = this._events[e2], n2 = this._indexOfListener(i2, t2);
            -1 !== n2 && i2.splice(n2, 1), 0 === this._events[e2].length && delete this._events[e2];
          }
          removeAllListeners(e2) {
            e2 ? delete this._events[e2] : this._events = {};
          }
          emit(e2) {
            this._events[e2] || (this._events[e2] = []);
            const t2 = this._events[e2].map((e3) => e3);
            for (var i2 = arguments.length, n2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++)
              n2[r2 - 1] = arguments[r2];
            for (let i3 = 0; i3 < t2.length; i3 += 1) {
              const r3 = t2[i3];
              r3.once && this.off(e2, r3.listener), r3.listener.apply(this, n2 || []);
            }
          }
          safeEmit(e2) {
            for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
              i2[n2 - 1] = arguments[n2];
            [...this._events[e2] || []].forEach((t3) => {
              t3.once && this.off(e2, t3.listener);
              try {
                t3.listener.apply(this, i2);
              } catch (t4) {
                console.error("safeEmit event:".concat(e2, " error ").concat(null == t4 ? void 0 : t4.toString()));
              }
            });
          }
          _indexOfListener(e2, t2) {
            let i2 = e2.length;
            for (; i2--; )
              if (e2[i2].listener === t2)
                return i2;
            return -1;
          }
        }
        let nT = null;
        function rT() {
          if (nT)
            return nT;
          if (window.electron)
            return nT = window.electron;
          if (!window.require)
            return null;
          try {
            return nT = window.require("electron"), nT;
          } catch (e2) {
            return null;
          }
        }
        var sT, oT, aT, cT, dT, lT, hT, uT;
        function pT(e2) {
          return jg(e2.timeout, "config.timeout", 0, 1e5), jg(e2.timeoutFactor, "config.timeoutFactor", 0, 100, false), jg(e2.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), jg(e2.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
        }
        function _T(e2) {
          if (!Array.isArray(e2) || e2.length < 1)
            return false;
          try {
            e2.forEach((e3) => {
              if (!e3.urls)
                throw Error();
            });
          } catch (e3) {
            return false;
          }
          return true;
        }
        function ET(e2) {
          return Wg(e2.turnServerURL, "turnServerURL"), Wg(e2.username, "username"), Wg(e2.password, "password"), e2.udpport && jg(e2.udpport, "udpport", 1, 99999, true), e2.forceturn && Fg(e2.forceturn, "forceturn"), e2.security && Fg(e2.security, "security"), e2.tcpport && jg(e2.tcpport, "tcpport", 1, 99999, true), true;
        }
        function mT(e2) {
          return void 0 !== e2.level && Bg(e2.level, "level", [1, 2, 3]), void 0 !== e2.delay && jg(e2.delay, "delay", 0, 3e3, true), true;
        }
        function fT(e2, t2) {
          for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++)
            n2[r2 - 2] = arguments[r2];
          return 0 === e2.getListeners(t2).length ? tg.reject(new Vg(xg.UNEXPECTED_ERROR, "can not emit promise")) : new tg((i3, r3) => {
            e2.emit(t2, ...n2, i3, r3);
          });
        }
        function gT(e2, t2) {
          if (0 === e2.getListeners(t2).length)
            return tg.resolve();
          for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++)
            n2[r2 - 2] = arguments[r2];
          return fT(e2, t2, ...n2);
        }
        function TT(e2, t2) {
          if (0 === e2.getListeners(t2).length)
            return null;
          for (var i2 = arguments.length, n2 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++)
            n2[r2 - 2] = arguments[r2];
          return ST(e2, t2, ...n2);
        }
        function ST(e2, t2) {
          let i2 = null, n2 = null;
          for (var r2 = arguments.length, s2 = new Array(r2 > 2 ? r2 - 2 : 0), o2 = 2; o2 < r2; o2++)
            s2[o2 - 2] = arguments[o2];
          if (e2.emit(t2, ...s2, (e3) => {
            i2 = e3;
          }, (e3) => {
            n2 = e3;
          }), null !== n2)
            throw n2;
          if (null === i2)
            throw new Vg(xg.UNEXPECTED_ERROR, "handler is not sync");
          return i2;
        }
        !function(e2) {
          e2.CREATE_CLIENT = "createClient", e2.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e2.SET_AREA = "setArea", e2.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e2.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e2.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e2.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e2.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e2.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e2.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e2.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e2.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e2.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e2.START_PROXY_SERVER = "Client.startProxyServer", e2.STOP_PROXY_SERVER = "Client.stopProxyServer", e2.SET_PROXY_SERVER = "Client.setProxyServer", e2.SET_TURN_SERVER = "Client.setTurnServer", e2.SET_CLIENT_ROLE = "Client.setClientRole", e2.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e2.ENABLE_DUAL_STREAM = "Client.enableDualStream", e2.DISABLE_DUAL_STREAM = "Client.disableDualStream", e2.JOIN = "Client.join", e2.LEAVE = "Client.leave", e2.PUBLISH = "Client.publish", e2.UNPUBLISH = "Client.unpublish", e2.SUBSCRIBE = "Client.subscribe", e2.MASS_SUBSCRIBE = "Client.massSubscribe", e2.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e2.UNSUBSCRIBE = "Client.unsubscribe", e2.RENEW_TOKEN = "Client.renewToken", e2.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e2.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e2.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e2.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e2.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e2.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e2.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e2.DATACHANNEL_FAILBACK = "Client._datachannelFailback", e2.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e2.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e2.START_LIVE_STREAMING = "Client.startLiveStreaming", e2.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e2.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e2.ADD_INJECT_STREAM_URL = "Client.addInjectStreamUrl", e2.REMOVE_INJECT_STREAM_URL = "Client.removeInjectStreamUrl", e2.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e2.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e2.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e2.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e2.SET_CONFIG_DISTRIBUTE = "_configDistribute", e2.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e2.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e2.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e2.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e2.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e2.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e2.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e2.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e2.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e2.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e2.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e2.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e2.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e2.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e2.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e2.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e2.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e2.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e2.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e2.STREAM_TYPE_CHANGE = "streamTypeChange", e2.CONNECTION_STATE_CHANGE = "connectionStateChange", e2.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e2.IMAGE_MODERATION_UPLOAD = "imageModerationUpload";
        }(sT || (sT = {})), function(e2) {
          e2.TRACER = "tracer";
        }(oT || (oT = {})), function(e2) {
          e2[e2.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY";
        }(aT || (aT = {})), function(e2) {
          e2.LEAVE = "LEAVE", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.UID_BANNED = "UID_BANNED", e2.IP_BANNED = "IP_BANNED", e2.CHANNEL_BANNED = "CHANNEL_BANNED", e2.FALLBACK = "FALLBACK", e2.LICENSE_MISSING = "LICENSE_MISSING", e2.LICENSE_EXPIRED = "LICENSE_EXPIRED", e2.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e2.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e2.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e2.LICENSE_ILLEGAL = "LICENSE_ILLEGAL", e2.TOKEN_EXPIRE = "TOKEN_EXPIRE";
        }(cT || (cT = {})), function(e2) {
          e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.MEDIA_RECONNECT_START = "media-reconnect-start", e2.MEDIA_RECONNECT_END = "media-reconnect-end", e2.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e2.USER_JOINED = "user-joined", e2.USER_LEAVED = "user-left", e2.USER_PUBLISHED = "user-published", e2.USER_UNPUBLISHED = "user-unpublished", e2.USER_INFO_UPDATED = "user-info-updated", e2.CLIENT_BANNED = "client-banned", e2.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e2.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e2.VOLUME_INDICATOR = "volume-indicator", e2.CRYPT_ERROR = "crypt-error", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGED = "stream-type-changed", e2.STREAM_FALLBACK = "stream-fallback", e2.RECEIVE_METADATA = "receive-metadata", e2.STREAM_MESSAGE = "stream-message", e2.LIVE_STREAMING_ERROR = "live-streaming-error", e2.LIVE_STREAMING_WARNING = "live-streaming-warning", e2.INJECT_STREAM_STATUS = "stream-inject-status", e2.EXCEPTION = "exception", e2.ERROR = "error", e2.P2P_LOST = "p2p_lost", e2.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e2.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e2.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e2.PUBLISHED_USER_LIST = "published-user-list", e2.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e2.CONTENT_INSPECT_ERROR = "content-inspect-error", e2.CONTENT_INSPECT_RESULT = "content-inspect-result", e2.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change";
        }(dT || (dT = {})), function(e2) {
          e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
        }(lT || (lT = {})), function(e2) {
          e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
        }(hT || (hT = {})), function(e2) {
          e2.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
        }(uT || (uT = {}));
        const RT = new class extends iT {
          set networkState(e2) {
            this.emit(uT.NETWORK_STATE_CHANGE, e2, this._networkState), e2 === hT.ONLINE ? this.emit(uT.ONLINE) : e2 === hT.OFFLINE && (this.onlineWaiter = new tg((e3) => {
              this.once(uT.ONLINE, () => {
                this.onlineWaiter = void 0, e3(hT.ONLINE);
              });
            }), this.emit(uT.OFFLINE)), this._networkState = e2;
          }
          get networkState() {
            return this._networkState;
          }
          get isOnline() {
            return this._networkState === hT.ONLINE;
          }
          constructor() {
            super(), nu(this, "_moduleName", "network-indicator"), nu(this, "_networkState", hT.ONLINE), nu(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
              this.networkState = hT.ONLINE;
            }), window.addEventListener("offline", () => {
              this.networkState = hT.OFFLINE;
            });
          }
        }();
        function CT(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function vT(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? CT(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : CT(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        function IT(e2, t2) {
          const i2 = e2.indexOf(t2);
          -1 !== i2 && e2.splice(i2, 1);
        }
        function yT(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            -1 === t2.indexOf(e3) && t2.push(e3);
          }), t2;
        }
        function AT(e2) {
          void 0 !== tg ? tg.resolve().then(e2) : setTimeout(e2, 0);
        }
        function bT(e2) {
          return JSON.parse(JSON.stringify(e2));
        }
        function wT(e2) {
          try {
            return bT(e2);
          } catch (t2) {
            return e2;
          }
        }
        const OT = {};
        function NT(e2, t2) {
          OT[t2] || (OT[t2] = true, e2());
        }
        function DT(e2) {
          const t2 = window.atob(e2), i2 = new Uint8Array(new ArrayBuffer(t2.length));
          for (let e3 = 0; e3 < t2.length; e3 += 1)
            i2[e3] = t2.charCodeAt(e3);
          return i2;
        }
        function PT(e2) {
          let t2 = "";
          for (let i2 = 0; i2 < e2.length; i2 += 1)
            t2 += String.fromCharCode(e2[i2]);
          return window.btoa(t2);
        }
        function LT(e2) {
          return window.TextEncoder ? new TextEncoder().encode(e2).length : e2.length;
        }
        function kT(e2) {
          let t2 = 0;
          return /DingTalk/i.test(navigator.userAgent) && e2.realFormData && (e2 = e2.realFormData), e2.forEach((e3) => {
            t2 += "string" == typeof e3 ? LT(e3) : e3.size;
          }), t2 + 138;
        }
        function MT(e2) {
          const t2 = new Vg(xg.TIMEOUT, "timeout");
          return new tg((i2, n2) => {
            window.setTimeout(() => n2(t2), e2);
          });
        }
        function UT(e2) {
          return new tg((t2) => {
            window.setTimeout(t2, e2);
          });
        }
        function xT() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t2 = arguments.length > 1 ? arguments[1] : void 0;
          const i2 = Math.random().toString(16).substr(2, e2).toLowerCase();
          return i2.length === e2 ? "".concat(t2).concat(i2) : "".concat(t2).concat(i2) + xT(e2 - i2.length, "");
        }
        function VT() {
          return xT(32, "").toUpperCase();
        }
        const FT = () => {
        };
        const BT = new class {
          constructor() {
            nu(this, "fnMap", /* @__PURE__ */ new Map());
          }
          throttleByKey(e2, t2, i2, n2) {
            for (var r2 = arguments.length, s2 = new Array(r2 > 4 ? r2 - 4 : 0), o2 = 4; o2 < r2; o2++)
              s2[o2 - 4] = arguments[o2];
            if (this.fnMap.has(t2)) {
              const r3 = this.fnMap.get(t2);
              if (r3.threshold !== i2) {
                r3.fn(...r3.args), clearTimeout(r3.timer);
                const o3 = window.setTimeout(() => {
                  const e3 = this.fnMap.get(t2);
                  e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
                }, i2);
                this.fnMap.set(t2, { fn: e2, threshold: i2, timer: o3, args: s2, skipFn: n2 });
              } else
                r3.skipFn && r3.skipFn(...r3.args), this.fnMap.set(t2, vT(vT({}, r3), {}, { fn: e2, args: s2, skipFn: n2 }));
            } else {
              const r3 = window.setTimeout(() => {
                const e3 = this.fnMap.get(t2);
                e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
              }, i2);
              this.fnMap.set(t2, { fn: e2, threshold: i2, timer: r3, args: s2, skipFn: n2 });
            }
          }
        }(), jT = BT.throttleByKey.bind(BT);
        function GT(e2) {
          return "object" == typeof e2 && null !== e2 && !(e2 instanceof RegExp);
        }
        function WT(e2, t2) {
          if (!GT(e2) || !GT(t2))
            return t2;
          if (Array.isArray(e2) && !Array.isArray(t2) || !Array.isArray(e2) && Array.isArray(t2))
            return t2;
          if (Array.isArray(t2) && Array.isArray(e2)) {
            const i2 = [...e2];
            for (let n2 = 0; n2 < t2.length; n2++)
              i2[n2] = WT(e2[n2], t2[n2]);
            return i2;
          }
          {
            const i2 = vT({}, e2);
            for (const n2 in t2)
              Object.prototype.hasOwnProperty.call(t2, n2) && (Object.prototype.hasOwnProperty.call(e2, n2) ? i2[n2] = WT(e2[n2], t2[n2]) : i2[n2] = t2[n2]);
            return i2;
          }
        }
        let HT = 1, KT = console;
        class YT {
          static setLogger(e2) {
            KT = e2;
          }
          constructor(e2) {
            nu(this, "lockingPromise", tg.resolve()), nu(this, "locks", 0), nu(this, "name", ""), nu(this, "lockId", void 0), this.lockId = HT++, e2 && (this.name = e2), KT.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."));
          }
          get isLocked() {
            return this.locks > 0;
          }
          lock(e2) {
            let t2;
            this.locks += 1, KT.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e2 ? e2 : ""));
            const i2 = new tg((i3) => {
              t2 = () => {
                this.locks -= 1, KT.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e2 ? e2 : "")), i3();
              };
            }), n2 = this.lockingPromise.then(() => t2);
            return this.lockingPromise = this.lockingPromise.then(() => i2), n2;
          }
        }
        function qT(e2, t2) {
          return function(i2, n2, r2) {
            const s2 = r2.value;
            if ("function" != typeof s2)
              throw new Error("Cannot use mutex on object property.");
            return r2.value = async function() {
              const i3 = this[t2];
              if (!i3)
                throw new Error("mutex property key ".concat(t2, " doesn't exist on ").concat(e2));
              const r3 = await i3.lock("From ".concat(e2, ".").concat(n2));
              try {
                for (var o2 = arguments.length, a2 = new Array(o2), c2 = 0; c2 < o2; c2++)
                  a2[c2] = arguments[c2];
                return await s2.apply(this, a2);
              } finally {
                r3();
              }
            }, r2;
          };
        }
        const JT = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
        function zT(e2, t2) {
          const i2 = Math.floor(t2.timeout * Math.pow(t2.timeoutFactor, e2));
          return Math.min(t2.maxRetryTimeout, i2);
        }
        function XT(e2, t2, i2, n2) {
          const r2 = Object.assign({}, JT, n2);
          let s2 = r2.timeout;
          const o2 = async () => {
            await function(e3) {
              return new tg((t3) => {
                window.setTimeout(t3, e3);
              });
            }(s2), s2 *= r2.timeoutFactor, s2 = Math.min(r2.maxRetryTimeout, s2);
          };
          let a2 = false;
          const c2 = new tg(async (n3, s3) => {
            t2 = t2 || (() => false), i2 = i2 || (() => true);
            for (let c3 = 0; c3 < r2.maxRetryCount; c3 += 1) {
              if (a2)
                return s3(new Vg(xg.OPERATION_ABORTED));
              try {
                const i3 = await e2();
                if (!t2(i3, c3))
                  return n3(i3);
                if (c3 + 1 === r2.maxRetryCount)
                  return n3(i3);
                await o2();
              } catch (e3) {
                if (!i2(e3, c3))
                  return s3(e3);
                if (c3 + 1 === r2.maxRetryCount)
                  return s3(e3);
                await o2();
              }
            }
          });
          return c2.cancel = () => a2 = true, c2;
        }
        var QT = Ut, ZT = ei, $T = Xe, eS = Yn, tS = TypeError, iS = function(e2) {
          return function(t2, i2, n2, r2) {
            QT(i2);
            var s2 = ZT(t2), o2 = $T(s2), a2 = eS(s2), c2 = e2 ? a2 - 1 : 0, d2 = e2 ? -1 : 1;
            if (n2 < 2)
              for (; ; ) {
                if (c2 in o2) {
                  r2 = o2[c2], c2 += d2;
                  break;
                }
                if (c2 += d2, e2 ? c2 < 0 : a2 <= c2)
                  throw tS("Reduce of empty array with no initial value");
              }
            for (; e2 ? c2 >= 0 : a2 > c2; c2 += d2)
              c2 in o2 && (r2 = i2(r2, o2[c2], c2, s2));
            return r2;
          };
        }, nS = { left: iS(false), right: iS(true) }.left;
        kn({ target: "Array", proto: true, forced: !C_ && St > 79 && St < 83 || !Ru("reduce") }, { reduce: function(e2) {
          var t2 = arguments.length;
          return nS(this, e2, t2, t2 > 1 ? arguments[1] : void 0);
        } });
        var rS = er("Array").reduce, sS = Ee, oS = rS, aS = Array.prototype, cS = J(function(e2) {
          var t2 = e2.reduce;
          return e2 === aS || sS(aS, e2) && t2 === aS.reduce ? oS : t2;
        });
        let dS = class {
          constructor(e2) {
            nu(this, "input", []), nu(this, "size", void 0), this.size = e2;
          }
          add(e2) {
            this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
          }
          mean() {
            var e2;
            return 0 === this.input.length ? 0 : cS(e2 = this.input).call(e2, (e3, t2) => e3 + t2) / this.input.length;
          }
        };
        var lS, hS = { exports: {} }, uS = function(e2, t2) {
          return function() {
            for (var i2 = new Array(arguments.length), n2 = 0; n2 < i2.length; n2++)
              i2[n2] = arguments[n2];
            return e2.apply(t2, i2);
          };
        }, pS = uS, _S = Object.prototype.toString, ES = (lS = /* @__PURE__ */ Object.create(null), function(e2) {
          var t2 = _S.call(e2);
          return lS[t2] || (lS[t2] = t2.slice(8, -1).toLowerCase());
        });
        function mS(e2) {
          return e2 = e2.toLowerCase(), function(t2) {
            return ES(t2) === e2;
          };
        }
        function fS(e2) {
          return Array.isArray(e2);
        }
        function gS(e2) {
          return void 0 === e2;
        }
        var TS = mS("ArrayBuffer");
        function SS(e2) {
          return null !== e2 && "object" == typeof e2;
        }
        function RS(e2) {
          if ("object" !== ES(e2))
            return false;
          var t2 = Object.getPrototypeOf(e2);
          return null === t2 || t2 === Object.prototype;
        }
        var CS = mS("Date"), vS = mS("File"), IS = mS("Blob"), yS = mS("FileList");
        function AS(e2) {
          return "[object Function]" === _S.call(e2);
        }
        var bS = mS("URLSearchParams");
        function wS(e2, t2) {
          if (null != e2)
            if ("object" != typeof e2 && (e2 = [e2]), fS(e2))
              for (var i2 = 0, n2 = e2.length; i2 < n2; i2++)
                t2.call(null, e2[i2], i2, e2);
            else
              for (var r2 in e2)
                Object.prototype.hasOwnProperty.call(e2, r2) && t2.call(null, e2[r2], r2, e2);
        }
        var OS, NS = (OS = "undefined" != typeof Uint8Array && Object.getPrototypeOf(Uint8Array), function(e2) {
          return OS && e2 instanceof OS;
        }), DS = { isArray: fS, isArrayBuffer: TS, isBuffer: function(e2) {
          return null !== e2 && !gS(e2) && null !== e2.constructor && !gS(e2.constructor) && "function" == typeof e2.constructor.isBuffer && e2.constructor.isBuffer(e2);
        }, isFormData: function(e2) {
          var t2 = "[object FormData]";
          return e2 && ("function" == typeof FormData && e2 instanceof FormData || _S.call(e2) === t2 || AS(e2.toString) && e2.toString() === t2);
        }, isArrayBufferView: function(e2) {
          return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && TS(e2.buffer);
        }, isString: function(e2) {
          return "string" == typeof e2;
        }, isNumber: function(e2) {
          return "number" == typeof e2;
        }, isObject: SS, isPlainObject: RS, isUndefined: gS, isDate: CS, isFile: vS, isBlob: IS, isFunction: AS, isStream: function(e2) {
          return SS(e2) && AS(e2.pipe);
        }, isURLSearchParams: bS, isStandardBrowserEnv: function() {
          return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document);
        }, forEach: wS, merge: function e2() {
          var t2 = {};
          function i2(i3, n3) {
            RS(t2[n3]) && RS(i3) ? t2[n3] = e2(t2[n3], i3) : RS(i3) ? t2[n3] = e2({}, i3) : fS(i3) ? t2[n3] = i3.slice() : t2[n3] = i3;
          }
          for (var n2 = 0, r2 = arguments.length; n2 < r2; n2++)
            wS(arguments[n2], i2);
          return t2;
        }, extend: function(e2, t2, i2) {
          return wS(t2, function(t3, n2) {
            e2[n2] = i2 && "function" == typeof t3 ? pS(t3, i2) : t3;
          }), e2;
        }, trim: function(e2) {
          return e2.trim ? e2.trim() : e2.replace(/^\s+|\s+$/g, "");
        }, stripBOM: function(e2) {
          return 65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)), e2;
        }, inherits: function(e2, t2, i2, n2) {
          e2.prototype = Object.create(t2.prototype, n2), e2.prototype.constructor = e2, i2 && Object.assign(e2.prototype, i2);
        }, toFlatObject: function(e2, t2, i2) {
          var n2, r2, s2, o2 = {};
          t2 = t2 || {};
          do {
            for (r2 = (n2 = Object.getOwnPropertyNames(e2)).length; r2-- > 0; )
              o2[s2 = n2[r2]] || (t2[s2] = e2[s2], o2[s2] = true);
            e2 = Object.getPrototypeOf(e2);
          } while (e2 && (!i2 || i2(e2, t2)) && e2 !== Object.prototype);
          return t2;
        }, kindOf: ES, kindOfTest: mS, endsWith: function(e2, t2, i2) {
          e2 = String(e2), (void 0 === i2 || i2 > e2.length) && (i2 = e2.length), i2 -= t2.length;
          var n2 = e2.indexOf(t2, i2);
          return -1 !== n2 && n2 === i2;
        }, toArray: function(e2) {
          if (!e2)
            return null;
          var t2 = e2.length;
          if (gS(t2))
            return null;
          for (var i2 = new Array(t2); t2-- > 0; )
            i2[t2] = e2[t2];
          return i2;
        }, isTypedArray: NS, isFileList: yS }, PS = DS;
        function LS(e2) {
          return encodeURIComponent(e2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        }
        var kS = function(e2, t2, i2) {
          if (!t2)
            return e2;
          var n2;
          if (i2)
            n2 = i2(t2);
          else if (PS.isURLSearchParams(t2))
            n2 = t2.toString();
          else {
            var r2 = [];
            PS.forEach(t2, function(e3, t3) {
              null != e3 && (PS.isArray(e3) ? t3 += "[]" : e3 = [e3], PS.forEach(e3, function(e4) {
                PS.isDate(e4) ? e4 = e4.toISOString() : PS.isObject(e4) && (e4 = JSON.stringify(e4)), r2.push(LS(t3) + "=" + LS(e4));
              }));
            }), n2 = r2.join("&");
          }
          if (n2) {
            var s2 = e2.indexOf("#");
            -1 !== s2 && (e2 = e2.slice(0, s2)), e2 += (-1 === e2.indexOf("?") ? "?" : "&") + n2;
          }
          return e2;
        }, MS = DS;
        function US() {
          this.handlers = [];
        }
        US.prototype.use = function(e2, t2, i2) {
          return this.handlers.push({ fulfilled: e2, rejected: t2, synchronous: !!i2 && i2.synchronous, runWhen: i2 ? i2.runWhen : null }), this.handlers.length - 1;
        }, US.prototype.eject = function(e2) {
          this.handlers[e2] && (this.handlers[e2] = null);
        }, US.prototype.forEach = function(e2) {
          MS.forEach(this.handlers, function(t2) {
            null !== t2 && e2(t2);
          });
        };
        var xS, VS, FS = US, BS = DS;
        function jS() {
          if (VS)
            return xS;
          VS = 1;
          var e2 = DS;
          function t2(e3, t3, i3, n3, r2) {
            Error.call(this), this.message = e3, this.name = "AxiosError", t3 && (this.code = t3), i3 && (this.config = i3), n3 && (this.request = n3), r2 && (this.response = r2);
          }
          e2.inherits(t2, Error, { toJSON: function() {
            return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
          } });
          var i2 = t2.prototype, n2 = {};
          return ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(e3) {
            n2[e3] = { value: e3 };
          }), Object.defineProperties(t2, n2), Object.defineProperty(i2, "isAxiosError", { value: true }), t2.from = function(n3, r2, s2, o2, a2, c2) {
            var d2 = Object.create(i2);
            return e2.toFlatObject(n3, d2, function(e3) {
              return e3 !== Error.prototype;
            }), t2.call(d2, n3.message, r2, s2, o2, a2), d2.name = n3.name, c2 && Object.assign(d2, c2), d2;
          }, xS = t2;
        }
        var GS, WS, HS, KS, YS, qS, JS2 = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false };
        function zS() {
          if (WS)
            return GS;
          WS = 1;
          var e2 = DS;
          return GS = function(t2, i2) {
            i2 = i2 || new FormData();
            var n2 = [];
            function r2(t3) {
              return null === t3 ? "" : e2.isDate(t3) ? t3.toISOString() : e2.isArrayBuffer(t3) || e2.isTypedArray(t3) ? "function" == typeof Blob ? new Blob([t3]) : Buffer.from(t3) : t3;
            }
            return function t3(s2, o2) {
              if (e2.isPlainObject(s2) || e2.isArray(s2)) {
                if (-1 !== n2.indexOf(s2))
                  throw Error("Circular reference detected in " + o2);
                n2.push(s2), e2.forEach(s2, function(n3, s3) {
                  if (!e2.isUndefined(n3)) {
                    var a2, c2 = o2 ? o2 + "." + s3 : s3;
                    if (n3 && !o2 && "object" == typeof n3) {
                      if (e2.endsWith(s3, "{}"))
                        n3 = JSON.stringify(n3);
                      else if (e2.endsWith(s3, "[]") && (a2 = e2.toArray(n3)))
                        return void a2.forEach(function(t4) {
                          !e2.isUndefined(t4) && i2.append(c2, r2(t4));
                        });
                    }
                    t3(n3, c2);
                  }
                }), n2.pop();
              } else
                i2.append(o2, r2(s2));
            }(t2), i2;
          }, GS;
        }
        function XS() {
          if (KS)
            return HS;
          KS = 1;
          var e2 = jS();
          return HS = function(t2, i2, n2) {
            var r2 = n2.config.validateStatus;
            n2.status && r2 && !r2(n2.status) ? i2(new e2("Request failed with status code " + n2.status, [e2.ERR_BAD_REQUEST, e2.ERR_BAD_RESPONSE][Math.floor(n2.status / 100) - 4], n2.config, n2.request, n2)) : t2(n2);
          };
        }
        function QS() {
          if (qS)
            return YS;
          qS = 1;
          var e2 = DS;
          return YS = e2.isStandardBrowserEnv() ? { write: function(t2, i2, n2, r2, s2, o2) {
            var a2 = [];
            a2.push(t2 + "=" + encodeURIComponent(i2)), e2.isNumber(n2) && a2.push("expires=" + new Date(n2).toGMTString()), e2.isString(r2) && a2.push("path=" + r2), e2.isString(s2) && a2.push("domain=" + s2), true === o2 && a2.push("secure"), document.cookie = a2.join("; ");
          }, read: function(e3) {
            var t2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e3 + ")=([^;]*)"));
            return t2 ? decodeURIComponent(t2[3]) : null;
          }, remove: function(e3) {
            this.write(e3, "", Date.now() - 864e5);
          } } : { write: function() {
          }, read: function() {
            return null;
          }, remove: function() {
          } }, YS;
        }
        var ZS, $S, eR, tR, iR, nR, rR, sR, oR, aR, cR, dR, lR = function(e2) {
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e2);
        }, hR = function(e2, t2) {
          return t2 ? e2.replace(/\/+$/, "") + "/" + t2.replace(/^\/+/, "") : e2;
        }, uR = function(e2, t2) {
          return e2 && !lR(t2) ? hR(e2, t2) : t2;
        };
        function pR() {
          if ($S)
            return ZS;
          $S = 1;
          var e2 = DS, t2 = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
          return ZS = function(i2) {
            var n2, r2, s2, o2 = {};
            return i2 ? (e2.forEach(i2.split("\n"), function(i3) {
              if (s2 = i3.indexOf(":"), n2 = e2.trim(i3.substr(0, s2)).toLowerCase(), r2 = e2.trim(i3.substr(s2 + 1)), n2) {
                if (o2[n2] && t2.indexOf(n2) >= 0)
                  return;
                o2[n2] = "set-cookie" === n2 ? (o2[n2] ? o2[n2] : []).concat([r2]) : o2[n2] ? o2[n2] + ", " + r2 : r2;
              }
            }), o2) : o2;
          }, ZS;
        }
        function _R() {
          if (tR)
            return eR;
          tR = 1;
          var e2 = DS;
          return eR = e2.isStandardBrowserEnv() ? function() {
            var t2, i2 = /(msie|trident)/i.test(navigator.userAgent), n2 = document.createElement("a");
            function r2(e3) {
              var t3 = e3;
              return i2 && (n2.setAttribute("href", t3), t3 = n2.href), n2.setAttribute("href", t3), { href: n2.href, protocol: n2.protocol ? n2.protocol.replace(/:$/, "") : "", host: n2.host, search: n2.search ? n2.search.replace(/^\?/, "") : "", hash: n2.hash ? n2.hash.replace(/^#/, "") : "", hostname: n2.hostname, port: n2.port, pathname: "/" === n2.pathname.charAt(0) ? n2.pathname : "/" + n2.pathname };
            }
            return t2 = r2(window.location.href), function(i3) {
              var n3 = e2.isString(i3) ? r2(i3) : i3;
              return n3.protocol === t2.protocol && n3.host === t2.host;
            };
          }() : function() {
            return true;
          };
        }
        function ER() {
          if (nR)
            return iR;
          nR = 1;
          var e2 = jS();
          function t2(t3) {
            e2.call(this, null == t3 ? "canceled" : t3, e2.ERR_CANCELED), this.name = "CanceledError";
          }
          return DS.inherits(t2, e2, { __CANCEL__: true }), iR = t2;
        }
        function mR() {
          return sR || (sR = 1, rR = function(e2) {
            var t2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e2);
            return t2 && t2[1] || "";
          }), rR;
        }
        function fR() {
          if (aR)
            return oR;
          aR = 1;
          var e2 = DS, t2 = XS(), i2 = QS(), n2 = kS, r2 = uR, s2 = pR(), o2 = _R(), a2 = JS2, c2 = jS(), d2 = ER(), l2 = mR();
          return oR = function(h2) {
            return new Promise(function(u2, p2) {
              var _2, E2 = h2.data, m2 = h2.headers, f2 = h2.responseType;
              function g2() {
                h2.cancelToken && h2.cancelToken.unsubscribe(_2), h2.signal && h2.signal.removeEventListener("abort", _2);
              }
              e2.isFormData(E2) && e2.isStandardBrowserEnv() && delete m2["Content-Type"];
              var T2 = new XMLHttpRequest();
              if (h2.auth) {
                var S2 = h2.auth.username || "", R2 = h2.auth.password ? unescape(encodeURIComponent(h2.auth.password)) : "";
                m2.Authorization = "Basic " + btoa(S2 + ":" + R2);
              }
              var C2 = r2(h2.baseURL, h2.url);
              function v2() {
                if (T2) {
                  var e3 = "getAllResponseHeaders" in T2 ? s2(T2.getAllResponseHeaders()) : null, i3 = { data: f2 && "text" !== f2 && "json" !== f2 ? T2.response : T2.responseText, status: T2.status, statusText: T2.statusText, headers: e3, config: h2, request: T2 };
                  t2(function(e4) {
                    u2(e4), g2();
                  }, function(e4) {
                    p2(e4), g2();
                  }, i3), T2 = null;
                }
              }
              if (T2.open(h2.method.toUpperCase(), n2(C2, h2.params, h2.paramsSerializer), true), T2.timeout = h2.timeout, "onloadend" in T2 ? T2.onloadend = v2 : T2.onreadystatechange = function() {
                T2 && 4 === T2.readyState && (0 !== T2.status || T2.responseURL && 0 === T2.responseURL.indexOf("file:")) && setTimeout(v2);
              }, T2.onabort = function() {
                T2 && (p2(new c2("Request aborted", c2.ECONNABORTED, h2, T2)), T2 = null);
              }, T2.onerror = function() {
                p2(new c2("Network Error", c2.ERR_NETWORK, h2, T2, T2)), T2 = null;
              }, T2.ontimeout = function() {
                var e3 = h2.timeout ? "timeout of " + h2.timeout + "ms exceeded" : "timeout exceeded", t3 = h2.transitional || a2;
                h2.timeoutErrorMessage && (e3 = h2.timeoutErrorMessage), p2(new c2(e3, t3.clarifyTimeoutError ? c2.ETIMEDOUT : c2.ECONNABORTED, h2, T2)), T2 = null;
              }, e2.isStandardBrowserEnv()) {
                var I2 = (h2.withCredentials || o2(C2)) && h2.xsrfCookieName ? i2.read(h2.xsrfCookieName) : void 0;
                I2 && (m2[h2.xsrfHeaderName] = I2);
              }
              "setRequestHeader" in T2 && e2.forEach(m2, function(e3, t3) {
                void 0 === E2 && "content-type" === t3.toLowerCase() ? delete m2[t3] : T2.setRequestHeader(t3, e3);
              }), e2.isUndefined(h2.withCredentials) || (T2.withCredentials = !!h2.withCredentials), f2 && "json" !== f2 && (T2.responseType = h2.responseType), "function" == typeof h2.onDownloadProgress && T2.addEventListener("progress", h2.onDownloadProgress), "function" == typeof h2.onUploadProgress && T2.upload && T2.upload.addEventListener("progress", h2.onUploadProgress), (h2.cancelToken || h2.signal) && (_2 = function(e3) {
                T2 && (p2(!e3 || e3 && e3.type ? new d2() : e3), T2.abort(), T2 = null);
              }, h2.cancelToken && h2.cancelToken.subscribe(_2), h2.signal && (h2.signal.aborted ? _2() : h2.signal.addEventListener("abort", _2))), E2 || (E2 = null);
              var y2 = l2(C2);
              y2 && -1 === ["http", "https", "file"].indexOf(y2) ? p2(new c2("Unsupported protocol " + y2 + ":", c2.ERR_BAD_REQUEST, h2)) : T2.send(E2);
            });
          }, oR;
        }
        var gR = DS, TR = function(e2, t2) {
          BS.forEach(e2, function(i2, n2) {
            n2 !== t2 && n2.toUpperCase() === t2.toUpperCase() && (e2[t2] = i2, delete e2[n2]);
          });
        }, SR = jS(), RR = JS2, CR = zS(), vR = { "Content-Type": "application/x-www-form-urlencoded" };
        function IR(e2, t2) {
          !gR.isUndefined(e2) && gR.isUndefined(e2["Content-Type"]) && (e2["Content-Type"] = t2);
        }
        var yR, AR = { transitional: RR, adapter: (("undefined" != typeof XMLHttpRequest || "undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process)) && (yR = fR()), yR), transformRequest: [function(e2, t2) {
          if (TR(t2, "Accept"), TR(t2, "Content-Type"), gR.isFormData(e2) || gR.isArrayBuffer(e2) || gR.isBuffer(e2) || gR.isStream(e2) || gR.isFile(e2) || gR.isBlob(e2))
            return e2;
          if (gR.isArrayBufferView(e2))
            return e2.buffer;
          if (gR.isURLSearchParams(e2))
            return IR(t2, "application/x-www-form-urlencoded;charset=utf-8"), e2.toString();
          var i2, n2 = gR.isObject(e2), r2 = t2 && t2["Content-Type"];
          if ((i2 = gR.isFileList(e2)) || n2 && "multipart/form-data" === r2) {
            var s2 = this.env && this.env.FormData;
            return CR(i2 ? { "files[]": e2 } : e2, s2 && new s2());
          }
          return n2 || "application/json" === r2 ? (IR(t2, "application/json"), function(e3, t3, i3) {
            if (gR.isString(e3))
              try {
                return (t3 || JSON.parse)(e3), gR.trim(e3);
              } catch (e4) {
                if ("SyntaxError" !== e4.name)
                  throw e4;
              }
            return (i3 || JSON.stringify)(e3);
          }(e2)) : e2;
        }], transformResponse: [function(e2) {
          var t2 = this.transitional || AR.transitional, i2 = t2 && t2.silentJSONParsing, n2 = t2 && t2.forcedJSONParsing, r2 = !i2 && "json" === this.responseType;
          if (r2 || n2 && gR.isString(e2) && e2.length)
            try {
              return JSON.parse(e2);
            } catch (e3) {
              if (r2) {
                if ("SyntaxError" === e3.name)
                  throw SR.from(e3, SR.ERR_BAD_RESPONSE, this, null, this.response);
                throw e3;
              }
            }
          return e2;
        }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: dR ? cR : (dR = 1, cR = null) }, validateStatus: function(e2) {
          return e2 >= 200 && e2 < 300;
        }, headers: { common: { Accept: "application/json, text/plain, */*" } } };
        gR.forEach(["delete", "get", "head"], function(e2) {
          AR.headers[e2] = {};
        }), gR.forEach(["post", "put", "patch"], function(e2) {
          AR.headers[e2] = gR.merge(vR);
        });
        var bR, wR, OR = AR, NR = DS, DR = OR;
        function PR() {
          return wR ? bR : (wR = 1, bR = function(e2) {
            return !(!e2 || !e2.__CANCEL__);
          });
        }
        var LR = DS, kR = function(e2, t2, i2) {
          var n2 = this || DR;
          return NR.forEach(i2, function(i3) {
            e2 = i3.call(n2, e2, t2);
          }), e2;
        }, MR = PR(), UR = OR, xR = ER();
        function VR(e2) {
          if (e2.cancelToken && e2.cancelToken.throwIfRequested(), e2.signal && e2.signal.aborted)
            throw new xR();
        }
        var FR, BR, jR = DS, GR = function(e2, t2) {
          t2 = t2 || {};
          var i2 = {};
          function n2(e3, t3) {
            return jR.isPlainObject(e3) && jR.isPlainObject(t3) ? jR.merge(e3, t3) : jR.isPlainObject(t3) ? jR.merge({}, t3) : jR.isArray(t3) ? t3.slice() : t3;
          }
          function r2(i3) {
            return jR.isUndefined(t2[i3]) ? jR.isUndefined(e2[i3]) ? void 0 : n2(void 0, e2[i3]) : n2(e2[i3], t2[i3]);
          }
          function s2(e3) {
            if (!jR.isUndefined(t2[e3]))
              return n2(void 0, t2[e3]);
          }
          function o2(i3) {
            return jR.isUndefined(t2[i3]) ? jR.isUndefined(e2[i3]) ? void 0 : n2(void 0, e2[i3]) : n2(void 0, t2[i3]);
          }
          function a2(i3) {
            return i3 in t2 ? n2(e2[i3], t2[i3]) : i3 in e2 ? n2(void 0, e2[i3]) : void 0;
          }
          var c2 = { url: s2, method: s2, data: s2, baseURL: o2, transformRequest: o2, transformResponse: o2, paramsSerializer: o2, timeout: o2, timeoutMessage: o2, withCredentials: o2, adapter: o2, responseType: o2, xsrfCookieName: o2, xsrfHeaderName: o2, onUploadProgress: o2, onDownloadProgress: o2, decompress: o2, maxContentLength: o2, maxBodyLength: o2, beforeRedirect: o2, transport: o2, httpAgent: o2, httpsAgent: o2, cancelToken: o2, socketPath: o2, responseEncoding: o2, validateStatus: a2 };
          return jR.forEach(Object.keys(e2).concat(Object.keys(t2)), function(e3) {
            var t3 = c2[e3] || r2, n3 = t3(e3);
            jR.isUndefined(n3) && t3 !== a2 || (i2[e3] = n3);
          }), i2;
        };
        function WR() {
          return BR ? FR : (BR = 1, FR = { version: "0.27.2" });
        }
        var HR = WR().version, KR = jS(), YR = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(e2, t2) {
          YR[e2] = function(i2) {
            return typeof i2 === e2 || "a" + (t2 < 1 ? "n " : " ") + e2;
          };
        });
        var qR = {};
        YR.transitional = function(e2, t2, i2) {
          function n2(e3, t3) {
            return "[Axios v" + HR + "] Transitional option '" + e3 + "'" + t3 + (i2 ? ". " + i2 : "");
          }
          return function(i3, r2, s2) {
            if (false === e2)
              throw new KR(n2(r2, " has been removed" + (t2 ? " in " + t2 : "")), KR.ERR_DEPRECATED);
            return t2 && !qR[r2] && (qR[r2] = true, console.warn(n2(r2, " has been deprecated since v" + t2 + " and will be removed in the near future"))), !e2 || e2(i3, r2, s2);
          };
        };
        var JR, zR, XR, QR, ZR, $R, eC = { assertOptions: function(e2, t2, i2) {
          if ("object" != typeof e2)
            throw new KR("options must be an object", KR.ERR_BAD_OPTION_VALUE);
          for (var n2 = Object.keys(e2), r2 = n2.length; r2-- > 0; ) {
            var s2 = n2[r2], o2 = t2[s2];
            if (o2) {
              var a2 = e2[s2], c2 = void 0 === a2 || o2(a2, s2, e2);
              if (true !== c2)
                throw new KR("option " + s2 + " must be " + c2, KR.ERR_BAD_OPTION_VALUE);
            } else if (true !== i2)
              throw new KR("Unknown option " + s2, KR.ERR_BAD_OPTION);
          }
        }, validators: YR }, tC = DS, iC = kS, nC = FS, rC = function(e2) {
          return VR(e2), e2.headers = e2.headers || {}, e2.data = kR.call(e2, e2.data, e2.headers, e2.transformRequest), e2.headers = LR.merge(e2.headers.common || {}, e2.headers[e2.method] || {}, e2.headers), LR.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(t2) {
            delete e2.headers[t2];
          }), (e2.adapter || UR.adapter)(e2).then(function(t2) {
            return VR(e2), t2.data = kR.call(e2, t2.data, t2.headers, e2.transformResponse), t2;
          }, function(t2) {
            return MR(t2) || (VR(e2), t2 && t2.response && (t2.response.data = kR.call(e2, t2.response.data, t2.response.headers, e2.transformResponse))), Promise.reject(t2);
          });
        }, sC = GR, oC = uR, aC = eC, cC = aC.validators;
        function dC(e2) {
          this.defaults = e2, this.interceptors = { request: new nC(), response: new nC() };
        }
        dC.prototype.request = function(e2, t2) {
          "string" == typeof e2 ? (t2 = t2 || {}).url = e2 : t2 = e2 || {}, (t2 = sC(this.defaults, t2)).method ? t2.method = t2.method.toLowerCase() : this.defaults.method ? t2.method = this.defaults.method.toLowerCase() : t2.method = "get";
          var i2 = t2.transitional;
          void 0 !== i2 && aC.assertOptions(i2, { silentJSONParsing: cC.transitional(cC.boolean), forcedJSONParsing: cC.transitional(cC.boolean), clarifyTimeoutError: cC.transitional(cC.boolean) }, false);
          var n2 = [], r2 = true;
          this.interceptors.request.forEach(function(e3) {
            "function" == typeof e3.runWhen && false === e3.runWhen(t2) || (r2 = r2 && e3.synchronous, n2.unshift(e3.fulfilled, e3.rejected));
          });
          var s2, o2 = [];
          if (this.interceptors.response.forEach(function(e3) {
            o2.push(e3.fulfilled, e3.rejected);
          }), !r2) {
            var a2 = [rC, void 0];
            for (Array.prototype.unshift.apply(a2, n2), a2 = a2.concat(o2), s2 = Promise.resolve(t2); a2.length; )
              s2 = s2.then(a2.shift(), a2.shift());
            return s2;
          }
          for (var c2 = t2; n2.length; ) {
            var d2 = n2.shift(), l2 = n2.shift();
            try {
              c2 = d2(c2);
            } catch (e3) {
              l2(e3);
              break;
            }
          }
          try {
            s2 = rC(c2);
          } catch (e3) {
            return Promise.reject(e3);
          }
          for (; o2.length; )
            s2 = s2.then(o2.shift(), o2.shift());
          return s2;
        }, dC.prototype.getUri = function(e2) {
          e2 = sC(this.defaults, e2);
          var t2 = oC(e2.baseURL, e2.url);
          return iC(t2, e2.params, e2.paramsSerializer);
        }, tC.forEach(["delete", "get", "head", "options"], function(e2) {
          dC.prototype[e2] = function(t2, i2) {
            return this.request(sC(i2 || {}, { method: e2, url: t2, data: (i2 || {}).data }));
          };
        }), tC.forEach(["post", "put", "patch"], function(e2) {
          function t2(t3) {
            return function(i2, n2, r2) {
              return this.request(sC(r2 || {}, { method: e2, headers: t3 ? { "Content-Type": "multipart/form-data" } : {}, url: i2, data: n2 }));
            };
          }
          dC.prototype[e2] = t2(), dC.prototype[e2 + "Form"] = t2(true);
        });
        var lC = DS, hC = uS, uC = dC, pC = GR;
        var _C = function e2(t2) {
          var i2 = new uC(t2), n2 = hC(uC.prototype.request, i2);
          return lC.extend(n2, uC.prototype, i2), lC.extend(n2, i2), n2.create = function(i3) {
            return e2(pC(t2, i3));
          }, n2;
        }(OR);
        _C.Axios = uC, _C.CanceledError = ER(), _C.CancelToken = function() {
          if (zR)
            return JR;
          zR = 1;
          var e2 = ER();
          function t2(t3) {
            if ("function" != typeof t3)
              throw new TypeError("executor must be a function.");
            var i2;
            this.promise = new Promise(function(e3) {
              i2 = e3;
            });
            var n2 = this;
            this.promise.then(function(e3) {
              if (n2._listeners) {
                var t4, i3 = n2._listeners.length;
                for (t4 = 0; t4 < i3; t4++)
                  n2._listeners[t4](e3);
                n2._listeners = null;
              }
            }), this.promise.then = function(e3) {
              var t4, i3 = new Promise(function(e4) {
                n2.subscribe(e4), t4 = e4;
              }).then(e3);
              return i3.cancel = function() {
                n2.unsubscribe(t4);
              }, i3;
            }, t3(function(t4) {
              n2.reason || (n2.reason = new e2(t4), i2(n2.reason));
            });
          }
          return t2.prototype.throwIfRequested = function() {
            if (this.reason)
              throw this.reason;
          }, t2.prototype.subscribe = function(e3) {
            this.reason ? e3(this.reason) : this._listeners ? this._listeners.push(e3) : this._listeners = [e3];
          }, t2.prototype.unsubscribe = function(e3) {
            if (this._listeners) {
              var t3 = this._listeners.indexOf(e3);
              -1 !== t3 && this._listeners.splice(t3, 1);
            }
          }, t2.source = function() {
            var e3;
            return { token: new t2(function(t3) {
              e3 = t3;
            }), cancel: e3 };
          }, JR = t2;
        }(), _C.isCancel = PR(), _C.VERSION = WR().version, _C.toFormData = zS(), _C.AxiosError = jS(), _C.Cancel = _C.CanceledError, _C.all = function(e2) {
          return Promise.all(e2);
        }, _C.spread = QR ? XR : (QR = 1, XR = function(e2) {
          return function(t2) {
            return e2.apply(null, t2);
          };
        }), _C.isAxiosError = function() {
          if ($R)
            return ZR;
          $R = 1;
          var e2 = DS;
          return ZR = function(t2) {
            return e2.isObject(t2) && true === t2.isAxiosError;
          };
        }(), hS.exports = _C, hS.exports.default = _C;
        var EC = J(hS.exports);
        function mC(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function fC(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? mC(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : mC(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        let gC, TC = 0, SC = 0;
        function RC(e2, t2, i2, n2) {
          return new tg((r2, s2) => {
            t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), TC += LT(t2.data)) : i2 && (t2.data.size ? TC += t2.data.size : t2.data instanceof FormData ? TC += kT(t2.data) : TC += LT(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, EC.request(t2).then((e3) => {
              "string" == typeof e3.data ? SC += LT(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? SC += e3.data.byteLength : SC += LT(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
            }).catch((e3) => {
              EC.isCancel(e3) ? s2(new Vg(xg.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? s2(new Vg(xg.NETWORK_TIMEOUT, e3.message)) : e3.response ? s2(new Vg(xg.NETWORK_RESPONSE_ERROR, e3.response.status)) : s2(new Vg(xg.NETWORK_ERROR, e3.message));
            });
          });
        }
        async function CC(e2, t2) {
          const i2 = new Blob([t2.data], { type: "buffer" });
          return await RC(e2, fC(fC({}, t2), {}, { data: i2, headers: { "Content-Type": "application/octet-stream" } }), true);
        }
        const vC = () => "HTTPS" === (gC || gC || (gC = (window.location.protocol.split(":")[0] || "").toUpperCase(), gC)), IC = () => void 0 !== window.isSecureContext;
        function yC(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function AC(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? yC(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yC(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        var bC;
        !function(e2) {
          e2.SET_SESSION_ID = "SET_SESSION_ID", e2.SET_P2P_ID = "SET_P2P_id", e2.SET_DC_ID = "SET_DC_id", e2.SET_UID = "SET_UID", e2.SET_PUB_ID = "SET_PUB_ID", e2.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e2.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e2.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e2.AVOID_JOIN_START = "AVOID_JOIN_START", e2.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e2.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e2.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e2.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e2.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e2.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e2.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e2.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e2.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e2.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e2.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e2.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e2.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e2.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e2.RESET_KEY_METRICS = "RESET_KEY_METRICS", e2.SET_USE_DATACHANNEL = "SET_USE_DATACHANNEL", e2.SET_USE_P2P = "SET_USE_P2P";
        }(bC || (bC = {}));
        class wC {
          constructor(e2, t2, i2, n2) {
            nu(this, "state", void 0), this.state = { codec: e2, audioCodec: t2, mode: i2, clientId: n2, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useDataChannel: false, useP2P: false };
          }
          dispatch(e2) {
            this.state = function(e3, t2) {
              switch (t2.type) {
                case bC.SET_SESSION_ID:
                  return AC(AC({}, e3), {}, { sessionId: t2.sessionId });
                case bC.SET_P2P_ID:
                  return AC(AC({}, e3), {}, { p2pId: t2.p2pId });
                case bC.SET_UID:
                  return AC(AC({}, e3), {}, { uid: t2.uid });
                case bC.SET_PUB_ID:
                  return AC(AC({}, e3), {}, { pubId: t2.pubId });
                case bC.KEY_METRIC_CLIENT_CREATED:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { clientCreated: t2.metric }) });
                case bC.KEY_METRIC_JOIN_START:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { joinStart: t2.metric }) });
                case bC.AVOID_JOIN_START:
                  return AC(AC({}, e3), {}, { avoidJoinStart: t2.avoidJoinStart });
                case bC.KEY_METRIC_JOIN_END:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { joinEnd: t2.metric }) });
                case bC.KEY_METRIC_REQUEST_AP_START:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { requestAPStart: t2.metric }) });
                case bC.KEY_METRIC_REQUEST_AP_END:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { requestAPEnd: t2.metric }) });
                case bC.KEY_METRIC_JOIN_GATEWAY_START:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { joinGatewayStart: t2.metric }) });
                case bC.KEY_METRIC_JOIN_GATEWAY_END:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { joinGatewayEnd: t2.metric }) });
                case bC.KEY_METRIC_PEER_CONNECTION_START:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { peerConnectionStart: t2.metric }) });
                case bC.KEY_METRIC_PEER_CONNECTION_END:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { peerConnectionEnd: t2.metric }) });
                case bC.KEY_METRIC_DESCRIPTION_START:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { descriptionStart: t2.metric }) });
                case bC.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { signalChannelOpen: t2.metric }) });
                case bC.KEY_METRIC_ICE_CONNECTION_END:
                  return AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { iceConnectionEnd: t2.metric }) });
                case bC.KEY_METRIC_PUBLISH: {
                  const i2 = e3.keyMetrics.publish, n2 = i2.findIndex((e4) => e4.trackId === t2.metric.trackId);
                  return -1 !== n2 ? (i2[n2] = AC(AC({}, i2[n2]), t2.metric), AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { publish: [...i2] }) })) : AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { publish: [...e3.keyMetrics.publish, t2.metric] }) });
                }
                case bC.KEY_METRIC_SUBSCRIBE: {
                  const i2 = e3.keyMetrics.subscribe, n2 = i2.findIndex((e4) => e4.userId === t2.metric.userId && e4.type === t2.metric.type);
                  return -1 !== n2 ? (i2[n2] = AC(AC({}, i2[n2]), t2.metric), AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { subscribe: [...i2] }) })) : AC(AC({}, e3), {}, { keyMetrics: AC(AC({}, e3.keyMetrics), {}, { subscribe: [...e3.keyMetrics.subscribe, t2.metric] }) });
                }
                case bC.SET_CLOUD_PROXY_SERVER_MODE:
                  return e3.cloudProxyServerMode = t2.mode, e3;
                case bC.RECORD_JOIN_CHANNEL_SERVICE:
                  return "number" != typeof t2.index ? e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords, t2.record] : (e3.joinChannelServiceRecords[t2.index] = AC(AC({}, e3.joinChannelServiceRecords[t2.index]), t2.record), e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords]), e3;
                case bC.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                  return e3.joinChannelServiceRecords = [], e3;
                case bC.RESET_KEY_METRICS:
                  return e3.keyMetrics = { publish: [], subscribe: [] }, e3;
                case bC.SET_USE_DATACHANNEL:
                  return AC(AC({}, e3), {}, { useDataChannel: t2.val });
                case bC.SET_USE_P2P:
                  return AC(AC({}, e3), {}, { useP2P: t2.val });
                default:
                  return e3;
              }
            }(this.state, e2);
          }
          set sessionId(e2) {
            this.dispatch({ type: bC.SET_SESSION_ID, sessionId: e2 });
          }
          get sessionId() {
            return this.state.sessionId;
          }
          set codec(e2) {
            this.state.codec = e2;
          }
          get codec() {
            return this.state.codec;
          }
          get audioCodec() {
            return this.state.audioCodec;
          }
          get clientId() {
            return this.state.clientId;
          }
          set p2pId(e2) {
            this.dispatch({ type: bC.SET_P2P_ID, p2pId: e2 });
          }
          get p2pId() {
            return this.state.p2pId;
          }
          set dcId(e2) {
            this.dispatch({ type: bC.SET_DC_ID, dcId: e2 });
          }
          get dcId() {
            return this.state.dcId;
          }
          set uid(e2) {
            this.dispatch({ type: bC.SET_UID, uid: e2 });
          }
          get uid() {
            return this.state.uid;
          }
          set pubId(e2) {
            this.dispatch({ type: bC.SET_PUB_ID, pubId: e2 });
          }
          get pubId() {
            return this.state.pubId;
          }
          set cloudProxyServerMode(e2) {
            this.dispatch({ type: bC.SET_CLOUD_PROXY_SERVER_MODE, mode: e2 });
          }
          get cloudProxyServerMode() {
            return this.state.cloudProxyServerMode;
          }
          set useDataChannel(e2) {
            this.dispatch({ type: bC.SET_USE_DATACHANNEL, val: e2 });
          }
          get useDataChannel() {
            return this.state.useDataChannel;
          }
          set useP2P(e2) {
            this.dispatch({ type: bC.SET_USE_P2P, val: e2 });
          }
          get useP2P() {
            return this.state.useP2P;
          }
          clientCreated() {
            this.dispatch({ type: bC.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
          }
          joinStart() {
            this.dispatch({ type: bC.KEY_METRIC_JOIN_START, metric: Date.now() });
          }
          joinEnd() {
            this.dispatch({ type: bC.KEY_METRIC_JOIN_END, metric: Date.now() });
          }
          requestAPStart() {
            this.dispatch({ type: bC.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
          }
          requestAPEnd() {
            this.dispatch({ type: bC.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
          }
          joinGatewayStart() {
            this.dispatch({ type: bC.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
          }
          joinGatewayEnd() {
            this.dispatch({ type: bC.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
          }
          peerConnectionStart() {
            this.dispatch({ type: bC.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
          }
          peerConnectionEnd() {
            this.dispatch({ type: bC.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
          }
          descriptionStart() {
            this.dispatch({ type: bC.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
          }
          signalChannelOpen() {
            this.dispatch({ type: bC.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
          }
          iceConnectionEnd() {
            this.dispatch({ type: bC.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
          }
          publish(e2, t2, i2, n2) {
            this.dispatch({ type: bC.KEY_METRIC_PUBLISH, metric: AC(AC({ trackId: e2, type: t2 }, i2 && { publishStart: i2 }), n2 && { publishEnd: n2 }) });
          }
          subscribe(e2, t2, i2, n2, r2, s2, o2) {
            this.dispatch({ type: bC.KEY_METRIC_SUBSCRIBE, metric: AC(AC(AC(AC(AC({ userId: e2, type: t2 }, i2 && { subscribeStart: i2 }), n2 && { subscribeEnd: n2 }), r2 && { firstFrame: r2 }), s2 && { streamAdded: s2 }), o2 && { firstDecoded: o2 }) });
          }
          massSubscribe(e2, t2, i2, n2) {
            e2.forEach((e3) => {
              this.dispatch({ type: bC.KEY_METRIC_SUBSCRIBE, metric: AC(AC(AC({ userId: e3.userId, type: e3.type }, t2 && { subscribeStart: t2 }), i2 && { subscribeEnd: i2 }), n2 && { firstFrame: n2 }) });
            });
          }
          get keyMetrics() {
            return this.state.keyMetrics;
          }
          recordJoinChannelService(e2, t2) {
            "gateway" === e2.service && Array.isArray(e2.urls) && (e2.urls = e2.urls.map((e3) => e3.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
            try {
              return "number" != typeof t2 ? (this.dispatch({ type: bC.RECORD_JOIN_CHANNEL_SERVICE, record: AC(AC({}, e2), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t2 < 0 || t2 >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: bC.RECORD_JOIN_CHANNEL_SERVICE, record: e2, index: t2 }), t2);
            } catch (e3) {
              return 0;
            }
          }
          resetJoinChannelServiceRecords() {
            this.dispatch({ type: bC.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
          }
          resetKeyMetrics() {
            this.dispatch({ type: bC.RESET_KEY_METRICS });
          }
          get joinChannelServiceRecords() {
            try {
              return this.state.joinChannelServiceRecords;
            } catch (e2) {
              return [];
            }
          }
          get avoidJoinStart() {
            return this.state.avoidJoinStart;
          }
          set avoidJoinStart(e2) {
            this.dispatch({ type: bC.AVOID_JOIN_START, avoidJoinStart: e2 });
          }
        }
        const OC = function(e2) {
          if (e2.match(/[0-9]+\.[0-9]+\.[0-9]+$/))
            return e2;
          const t2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);
          if (t2 && t2[1] && t2[2]) {
            const e3 = t2[1], i3 = t2[2];
            return "".concat(e3, ".").concat(i3);
          }
          const i2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);
          if (i2 && i2[1] && i2[2]) {
            const e3 = i2[1], t3 = i2[2];
            return "".concat(e3, ".").concat(100 * (Number(t3) + 1));
          }
          return "4.0.0.999";
        }("4.19.3"), NC = function() {
          try {
            return true === JSON.parse("true");
          } catch (e2) {
            return true;
          }
        }(), DC = "v4.19.3-0-gb2ca8ca7(11/2/2023, 2:57:33 PM)", PC = { PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: true, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], SUBSCRIBE_TWCC: false, PUBLISH_TWCC: false, PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, USE_PUB_RTX: false, USE_SUB_RTX: false, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, CHECK_LOCAL_STATS_INTERVAL: 100, PROFILE_SWITCH_INTERVAL: 2e3, UNSUPPORTED_VIDEO_CODEC: [], ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_MAX_CONCURRENCY: 6, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3, JOIN_GATEWAY_USE_443PORT_ONLY: false, JOIN_GATEWAY_USE_DUAL_DOMAIN: true, JOIN_GATEWAY_FALLBACK_PORT: 443, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: true, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: {}, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, DISABLE_FEC: void 0, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, DISABLE_DUAL_STREAM_USE_ENCODING: false, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, NEW_ICE_RESTART: false, ENABLE_USER_LICENSE_CHECK: true, SIGNAL_CHANNEL: 0, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: false, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, AP_AREA: true, SVC: [], ENABLE_ENCODED_TRANSFORM: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, SHOW_GLOBAL_CLIENT_LIST: false, RTM2_FLAG: void 0, AP_RTM: false, ENABLE_DATASTREAM_2: false, DATASTREAM_MAX_RETRANSMITS: 10, ENABLE_USER_AUTO_REBALANCE_CHECK: true, ENABLE_INSTANT_VIDEO: false, ENABLE_NTP_REPORT: false, USE_XR: false, TCP_CANDIDATE_ONLY: false, EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 1e4, P2P: false, SHOW_P2P_LOG: false, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, FILTER_VIDEO_CODEC: [] };
        function LC(e2, t2, i2) {
          var n2, r2;
          Pr(n2 = Object.keys(PC)).call(n2, e2) && (!i2 && Pr(r2 = Object.keys(MC)).call(r2, e2) || (PC[e2] = t2));
        }
        function kC(e2) {
          return PC[e2];
        }
        const MC = {};
        var UC, xC;
        !function(e2) {
          e2.h264 = "h264", e2.h265 = "h265", e2.vp8 = "vp8", e2.vp9 = "vp9", e2.av1 = "av1";
        }(UC || (UC = {})), function(e2) {
          e2.opus = "opus", e2.pcma = "pcma", e2.pcmu = "pcmu", e2.g722 = "g722";
        }(xC || (xC = {}));
        const VC = new class extends iT {
          reportLogUploadError(e2) {
            this.emit("REPORT_LOG_UPLOAD", e2);
          }
        }();
        class FC {
          constructor(e2) {
            nu(this, "logger", void 0), nu(this, "prefixLists", []), this.logger = e2;
          }
          debug() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            this.logger.debug(...this.prefixLists, ...t2);
          }
          info() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            this.logger.info(...this.prefixLists, ...t2);
          }
          warning() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            this.logger.warning(...this.prefixLists, ...t2);
          }
          error() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            this.logger.error(...this.prefixLists, ...t2);
          }
          prefix(e2) {
            return this.prefixLists.push(e2), this;
          }
          popPrefix() {
            return this.prefixLists.pop(), this;
          }
        }
        function BC() {
          const e2 = /* @__PURE__ */ new Date();
          return e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
        }
        function jC() {
          const e2 = /* @__PURE__ */ new Date(), t2 = /((\d+:){2}\d+)/.exec((/* @__PURE__ */ new Date()).toUTCString());
          return t2 ? (null == t2 ? void 0 : t2[0]) + ":" + e2.getUTCMilliseconds() : e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
        }
        const GC = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, WC = Date.now(), HC = (e2) => {
          for (const t2 in GC)
            if (Object.prototype.hasOwnProperty.call(GC, t2) && GC[t2] === e2)
              return t2;
          return "DEFAULT";
        };
        const KC = new class {
          constructor() {
            nu(this, "proxyServerURL", void 0), nu(this, "logLevel", GC.DEBUG), nu(this, "uploadState", "collecting"), nu(this, "uploadLogWaitingList", []), nu(this, "uploadLogUploadingList", []), nu(this, "uploadErrorCount", 0), nu(this, "currentLogID", 0), nu(this, "url", void 0), nu(this, "extLog", (e2, t2) => {
              this.appendLogToWaitingList(e2, ...t2);
            });
          }
          debug() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            const n2 = [GC.DEBUG].concat(t2);
            this.log.apply(this, n2);
          }
          info() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            const n2 = [GC.INFO].concat(t2);
            this.log.apply(this, n2);
          }
          warning() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            const n2 = [GC.WARNING].concat(t2);
            this.log.apply(this, n2);
          }
          warn() {
            this.warning(...arguments);
          }
          error() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            const n2 = [GC.ERROR].concat(t2);
            this.log.apply(this, n2);
          }
          upload() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            const n2 = [GC.DEBUG].concat(t2);
            this.uploadLog.apply(this, n2);
          }
          setLogLevel(e2) {
            e2 = Math.min(Math.max(0, e2), 4), this.logLevel = e2;
          }
          enableLogUpload() {
            LC("UPLOAD_LOG", true);
          }
          disableLogUpload() {
            LC("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
          }
          setProxyServer(e2) {
            this.proxyServerURL = e2;
          }
          prefix(e2) {
            return new FC(this).prefix(e2);
          }
          log() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            if (Date.now() - WC < 100)
              return void setTimeout(() => {
                this.log(...t2);
              }, Date.now() - WC);
            const n2 = Math.max(0, Math.min(4, t2[0]));
            if (t2[0] = BC() + " Agora-SDK [".concat(HC(n2), "]:"), this.appendLogToWaitingList(n2, ...t2), n2 < this.logLevel)
              return;
            const r2 = BC() + " %cAgora-SDK [".concat(HC(n2), "]:");
            let s2 = [];
            if (!kC("USE_NEW_LOG"))
              switch (n2) {
                case GC.DEBUG:
                  s2 = [r2, "color: #64B5F6;"].concat(t2.slice(1)), console.log.apply(console, s2);
                  break;
                case GC.INFO:
                  s2 = [r2, "color: #1E88E5; font-weight: bold;"].concat(t2.slice(1)), console.log.apply(console, s2);
                  break;
                case GC.WARNING:
                  s2 = [r2, "color: #FB8C00; font-weight: bold;"].concat(t2.slice(1)), console.warn.apply(console, s2);
                  break;
                case GC.ERROR:
                  s2 = [r2, "color: #B00020; font-weight: bold;"].concat(t2.slice(1)), console.error.apply(console, s2);
              }
          }
          uploadLog() {
            for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
              t2[i2] = arguments[i2];
            if (Date.now() - WC < 100)
              return void setTimeout(() => {
                this.uploadLog(...t2);
              }, Date.now() - WC);
            const n2 = Math.max(0, Math.min(4, t2[0]));
            t2[0] = BC() + " Agora-SDK [".concat(HC(n2), "]:"), this.appendLogToWaitingList(n2, ...t2);
          }
          appendLogToWaitingList(e2) {
            if (!kC("UPLOAD_LOG"))
              return;
            for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
              i2[n2 - 1] = arguments[n2];
            Array.isArray(i2[0]) ? i2[0][0] = jC() + " Agora-SDK [".concat(HC(e2), "]:") : i2[0] = jC() + " Agora-SDK [".concat(HC(e2), "]:");
            let r2 = "";
            i2.forEach((e3) => {
              "object" == typeof e3 && (e3 = JSON.stringify(e3)), r2 += "".concat(e3, " ");
            }), this.uploadLogWaitingList.push({ payload_str: r2, log_level: e2, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
          }
          startUpload() {
            this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
          }
          async uploadLogs() {
            const e2 = this.uploadLogUploadingList, t2 = { sdk_version: OC, process_id: kC("PROCESS_ID"), payload: JSON.stringify(e2) };
            return XT(async () => {
              const e3 = await EC.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(kC("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(kC("LOG_UPLOAD_SERVER"), "/upload/v1")), t2, { responseType: "text" });
              if ("OK" !== e3.data) {
                const t3 = new Error("unexpected upload log response");
                throw t3.response = e3, t3;
              }
            }, () => (this.uploadLogUploadingList = [], false), (e3) => (e3.response ? VC.reportLogUploadError({ status: e3.response.status, data: e3.response.data, headers: e3.response.headers, message: e3.message }) : e3.request ? VC.reportLogUploadError({ status: e3.request.status, message: e3.message }) : VC.reportLogUploadError({ status: -1, message: e3.message }), true), { timeout: kC("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: kC("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
          }
          uploadLogInterval() {
            0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, kC("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
              this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), kC("UPLOAD_LOG_INTERVAL"));
            }).catch((e2) => {
              this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), kC("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), kC("UPLOAD_LOG_RETRY_INTERVAL_V1"));
            }));
          }
        }();
        var YC, qC;
        function JC(e2) {
          return Wg(e2.reportId, "params.reportId", 0, 100, false), Wg(e2.category, "params.category", 0, 100, false), Wg(e2.event, "params.event", 0, 100, false), Wg(e2.label, "params.label", 0, 100, false), jg(e2.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
        }
        !function(e2) {
          e2.FREE = "free", e2.UPLOADING = "uploading";
        }(YC || (YC = {})), function(e2) {
          e2[e2.MISC = 0] = "MISC", e2[e2.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e2[e2.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e2[e2.WEB_EVENT = 3] = "WEB_EVENT", e2[e2.INTERNAL_API = 4] = "INTERNAL_API", e2[e2.WEB_API = 5] = "WEB_API", e2[e2.PUBLIC_API = 6] = "PUBLIC_API";
        }(qC || (qC = {}));
        const zC = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
        var XC, QC, ZC, $C;
        function ev(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function tv(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? ev(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ev(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        !function(e2) {
          e2.PUBLISH = "publish", e2.SUBSCRIBE = "subscribe", e2.WS_COMPRESSOR_INIT = "ws_compressor_init", e2.SESSION_INIT = "session_init", e2.JOIN_CHOOSE_SERVER = "join_choose_server", e2.REQ_USER_ACCOUNT = "req_user_account", e2.JOIN_GATEWAY = "join_gateway", e2.REJOIN_GATEWAY = "rejoin_gateway", e2.STREAM_SWITCH = "stream_switch", e2.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e2.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e2.FIRST_VIDEO_RECEIVED = "first_video_received", e2.FIRST_AUDIO_RECEIVED = "first_audio_received", e2.FIRST_VIDEO_DECODE = "first_video_decode", e2.FIRST_AUDIO_DECODE = "first_audio_decode", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_UPDATE_STREAM = "on_update_stream", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.USER_ANALYTICS = "req_user_analytics", e2.PC_STATS = "pc_stats";
        }(XC || (XC = {})), function(e2) {
          e2.SESSION = "io.agora.pb.Wrtc.Session", e2.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e2.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e2.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e2.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e2.PUBLISH = "io.agora.pb.Wrtc.Publish", e2.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e2.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e2.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e2.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e2.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e2.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e2.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e2.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e2.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e2.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e2.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e2.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e2.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e2.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e2.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e2.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e2.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e2.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e2.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e2.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e2.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e2.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e2.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e2.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e2.PC_STATS = "io.agora.pb.Wrtc.PCStats";
        }(QC || (QC = {})), function(e2) {
          e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
        }(ZC || (ZC = {})), function(e2) {
          e2[e2.SESSION = 26] = "SESSION", e2[e2.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e2[e2.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e2[e2.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e2[e2.PUBLISH = 30] = "PUBLISH", e2[e2.SUBSCRIBE = 29] = "SUBSCRIBE", e2[e2.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e2[e2.STREAM_SWITCH = 32] = "STREAM_SWITCH", e2[e2.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e2[e2.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e2[e2.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e2[e2.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e2[e2.API_INVOKE = 41] = "API_INVOKE", e2[e2.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e2[e2.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e2[e2.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e2[e2.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e2[e2.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e2[e2.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e2[e2.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e2[e2.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e2[e2.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e2[e2.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e2[e2.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e2[e2.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e2[e2.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e2[e2.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED";
        }($C || ($C = {}));
        class iv {
          constructor() {
            nu(this, "baseInfoMap", /* @__PURE__ */ new Map()), nu(this, "proxyServer", void 0), nu(this, "eventUploadTimer", void 0), nu(this, "setSessionIdTimer", void 0), nu(this, "url", void 0), nu(this, "backupUrl", void 0), nu(this, "_appId", void 0), nu(this, "keyEventUploadPendingItems", []), nu(this, "normalEventUploadPendingItems", []), nu(this, "apiInvokeUploadPendingItems", []), nu(this, "apiInvokeCount", 0), nu(this, "ltsList", []), nu(this, "lastSendNormalEventTime", Date.now()), nu(this, "customReportCounterTimer", void 0), nu(this, "customReportCount", 0), nu(this, "extApiInvoke", async (e2) => {
              for (const t2 of e2) {
                const e3 = tv(tv({}, t2), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: oT.TRACER });
                this.sendApiInvoke(e3);
              }
            }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), kC("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), kC("EVENT_REPORT_SEND_INTERVAL"));
          }
          getBaseInfoBySessionId(e2) {
            return this.baseInfoMap.get(e2);
          }
          adjustSessionStartTime(e2) {
            if (!this.baseInfoMap.has(e2) && !this.baseInfoMap.get(e2))
              return void KC.error("adjust session ".concat(e2, " start time, sid is not exist or info is undefined"));
            const t2 = this.baseInfoMap.get(e2), i2 = Date.now(), n2 = t2.startTime;
            t2.startTime = i2, KC.debug("rewrite session ".concat(e2, " startTime: ").concat(i2, " , ").concat(i2 - n2, "ms")), this.baseInfoMap.set(e2, t2);
          }
          setAppId(e2) {
            this._appId = e2;
          }
          reportApiInvoke(e2, t2, i2) {
            t2.timeout = t2.timeout || 6e4, t2.reportResult = void 0 === t2.reportResult || t2.reportResult;
            const n2 = Date.now();
            this.apiInvokeCount += 1;
            const r2 = this.apiInvokeCount, s2 = () => ({ tag: t2.tag, invokeId: r2, sid: e2, name: t2.name, apiInvokeTime: n2, options: t2.options, states: t2.states || null }), o2 = !!kC("SHOW_REPORT_INVOKER_LOG");
            o2 && KC.info("".concat(t2.name, " start"), t2.options);
            let a2 = false;
            UT(t2.timeout).then(() => {
              a2 || (this.sendApiInvoke(tv(tv({}, s2()), {}, { error: xg.API_INVOKE_TIMEOUT, success: false })), KC.debug("".concat(t2.name, " timeout")));
            });
            const c2 = new Vg(xg.UNEXPECTED_ERROR, "".concat(t2.name, ": this api invoke is end"));
            return { onSuccess: (e3) => {
              const n3 = () => {
                if (a2)
                  throw c2;
                return a2 = true, this.sendApiInvoke(tv(tv({}, s2()), {}, { success: true }, t2.reportResult && { result: e3 })), o2 && KC.info("".concat(t2.name, " onSuccess")), e3;
              };
              return i2 ? jT(n3, t2.name + "Success", i2, () => a2 = true) : n3();
            }, onError: (e3) => {
              const n3 = () => {
                if (a2)
                  throw e3;
                a2 = true, this.sendApiInvoke(tv(tv({}, s2()), {}, { success: false, error: e3 })), o2 && KC.info("".concat(t2.name, " onFailure"), e3.toString());
              };
              return i2 ? jT(n3, t2.name + "Error", i2, () => a2 = true) : n3();
            } };
          }
          sessionInit(e2, t2) {
            if (this.baseInfoMap.has(e2))
              return;
            const i2 = Date.now(), n2 = this.createBaseInfo(e2, i2);
            n2.cname = t2.cname;
            const r2 = Object.assign({}, { willUploadConsoleLog: kC("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: NC ? "global" : "oversea", areas: kC("AREAS") && kC("AREAS").join(",") }, t2.extend), s2 = Date.now(), o2 = tv(tv({}, n2), {}, { eventType: XC.SESSION_INIT, appid: t2.appid, browser: navigator.userAgent, build: DC, lts: s2, elapse: s2 - i2, extend: JSON.stringify(r2), mode: t2.mode, process: kC("PROCESS_ID"), appType: kC("APP_TYPE"), success: true, version: OC });
            this.send({ type: QC.SESSION, data: o2 }, true);
          }
          joinChooseServer(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv({}, n2), {}, { eventType: XC.JOIN_CHOOSE_SERVER, lts: r2, eventElapse: r2 - t2.lts, chooseServerAddr: t2.csAddr, errorCode: t2.ec, elapse: r2 - i2.startTime, success: t2.succ, chooseServerAddrList: JSON.stringify(t2.serverList), uid: t2.uid ? parseInt(t2.uid) : null, cid: t2.cid ? parseInt(t2.cid) : null, chooseServerIp: t2.csIp || "", opid: t2.opid, unilbsServerIds: t2.unilbsServerIds, extend: t2.extend || void 0, isHttp3: t2.isHttp3 });
            this.send({ type: QC.JOIN_CHOOSE_SERVER, data: s2 }, true);
          }
          reqUserAccount(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv({}, n2), {}, { eventType: XC.REQ_USER_ACCOUNT, lts: r2, success: t2.success, serverAddress: t2.serverAddr, stringUid: t2.stringUid, uid: t2.uid, errorCode: t2.errorCode, elapse: r2 - i2.startTime, eventElapse: r2 - t2.lts, extend: JSON.stringify(t2.extend) });
            this.send({ type: QC.REQ_USER_ACCOUNT, data: s2 }, true);
          }
          joinGateway(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info;
            t2.vid && (n2.vid = t2.vid), n2.uid = t2.uid, n2.cid = t2.cid;
            const r2 = Date.now(), { firstSuccess: s2, avoidJoinStartTime: o2, isProxy: a2, addr: c2 } = t2, d2 = r2 - (s2 && o2 ? o2 : i2.startTime), l2 = tv(tv({}, n2), {}, { eventType: XC.JOIN_GATEWAY, lts: r2, gatewayAddr: t2.addr, success: t2.succ, errorCode: t2.ec, elapse: d2, eventElapse: r2 - t2.lts, firstSuccess: s2, signalChannel: t2.signalChannel }), h2 = l2.success ? 1 : 0;
            if (t2.succ && (i2.lastJoinSuccessTime = r2), s2)
              this.send({ type: QC.JOIN_GATEWAY, data: l2 }, true);
            else {
              let e3;
              if (c2)
                if (a2) {
                  const t4 = c2.match(/h=(\d{1,3}-){3}\d{1,3}/g), i3 = c2.match(/p=[0-9]{1,6}/g);
                  e3 = { isSuccess: h2, gatewayIp: t4 && t4.length ? t4[0].split("=")[1].replace(/-/g, ".") : "", port: i3 && i3.length ? i3[0].split("=")[1] : "", isProxy: a2 ? 1 : 0 };
                } else {
                  const t4 = c2.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), i3 = c2.match(/(:|p=)[0-9]{1,6}/g);
                  e3 = { isSuccess: h2, gatewayIp: t4 && t4.length ? t4[0].split("//")[1].replace(/-/g, ".") : "", port: i3 && i3.length ? i3[0].split(/:|p=/g)[1] : "", isProxy: a2 ? 1 : 0 };
                }
              else
                e3 = { isSuccess: h2, gatewayIp: "", port: "", isProxy: a2 ? 1 : 0 };
              delete l2.success, delete l2.eventType, delete l2.firstSuccess, l2.vid = Number(l2.vid);
              const t3 = Object.assign({}, l2, e3, { eventType: XC.REJOIN_GATEWAY });
              this.send({ type: QC.RE_JOIN_GATEWAY, data: t3 }, true);
            }
          }
          joinChannelTimeout(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = Date.now(), r2 = tv(tv({}, i2.info), {}, { lts: n2, timeout: t2, elapse: n2 - i2.startTime });
            this.send({ type: QC.JOIN_CHANNEL_TIMEOUT, data: r2 }, true);
          }
          publish(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv({}, n2), {}, { eventType: XC.PUBLISH, lts: r2, eventElapse: t2.eventElapse, elapse: r2 - i2.startTime, success: t2.succ, errorCode: t2.ec, videoName: t2.videoName, audioName: t2.audioName, screenName: t2.screenName, screenshare: t2.screenshare, audio: t2.audio, video: t2.video, p2pid: t2.p2pid, publishRequestid: t2.publishRequestid });
            this.send({ type: QC.PUBLISH, data: s2 }, true);
          }
          subscribe(e2, t2, i2) {
            const n2 = this.baseInfoMap.get(e2);
            if (!n2)
              return;
            const r2 = n2.info, s2 = Date.now(), o2 = tv(tv({}, r2), {}, { eventType: XC.SUBSCRIBE, lts: s2, eventElapse: t2.eventElapse, elapse: s2 - n2.startTime, success: t2.succ, errorCode: t2.ec, video: t2.video, audio: t2.audio, subscribeRequestid: t2.subscribeRequestid, p2pid: t2.p2pid }, i2 && { extend: JSON.stringify({ isMassSubscribe: true }) });
            "string" == typeof t2.peerid ? o2.peerSuid = t2.peerid : o2.peer = t2.peerid, this.send({ type: QC.SUBSCRIBE, data: o2 }, true);
          }
          wsCompressorInit(e2) {
            var t2;
            const i2 = [...hu(t2 = this.baseInfoMap).call(t2)], n2 = i2.length ? i2[0] : "UnableToGetSid", r2 = this.baseInfoMap.get(n2);
            if (!r2)
              return;
            const s2 = r2.info, o2 = Date.now(), a2 = tv(tv({}, s2), {}, { eventType: XC.WS_COMPRESSOR_INIT, lts: o2, eventElapse: e2.eventElapse, elapse: o2 - r2.startTime, status: e2.status ? 1 : 2 });
            this.send({ type: QC.WS_COMPRESSOR_INIT, data: a2 }, true);
          }
          firstRemoteVideoDecode(e2, t2, i2, n2) {
            const r2 = this.baseInfoMap.get(e2);
            if (!r2)
              return;
            const s2 = r2.info, o2 = Date.now(), a2 = tv(tv(tv({}, s2), n2), {}, { elapse: o2 - r2.startTime, eventType: t2, lts: o2, firstDecodeFrame: Math.max(o2 - r2.startTime, 0), apEnd: Math.max(n2.apEnd - r2.startTime, 0), apStart: Math.max(n2.apStart - r2.startTime, 0), joinGwEnd: Math.max(n2.joinGwEnd - r2.startTime, 0), joinGwStart: Math.max(n2.joinGwStart - r2.startTime, 0), pcEnd: Math.max(n2.pcEnd - r2.startTime, 0), pcStart: Math.max(n2.pcStart - r2.startTime, 0), subscriberEnd: Math.max(n2.subscriberEnd - r2.startTime, 0), subscriberStart: Math.max(n2.subscriberStart - r2.startTime, 0), videoAddNotify: Math.max(n2.videoAddNotify - r2.startTime, 0) });
            this.send({ type: i2, data: a2 }, true);
          }
          firstRemoteFrame(e2, t2, i2, n2) {
            const r2 = this.baseInfoMap.get(e2);
            if (!r2)
              return;
            const s2 = r2.info, o2 = Date.now(), a2 = tv(tv(tv({}, s2), n2), {}, { elapse: o2 - r2.startTime, eventType: t2, lts: o2 });
            this.send({ type: i2, data: a2 }, true);
          }
          pcStats(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv(tv({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), elapse: r2 - i2.startTime, eventType: XC.PC_STATS, lts: r2 });
            this.send({ type: QC.PC_STATS, data: s2 }, true);
          }
          updateRemoteRTPCapabilities(e2, t2) {
            this.reportApiInvoke(e2, { name: "Client.updateRemoteRTPCapabilities", options: t2, tag: oT.TRACER }).onSuccess();
          }
          onGatewayStream(e2, t2, i2, n2) {
            const r2 = this.baseInfoMap.get(e2);
            if (!r2)
              return;
            const s2 = r2.info, o2 = Date.now(), a2 = tv(tv(tv({}, s2), n2), {}, { eventType: t2, lts: o2 });
            this.send({ type: i2, data: a2 }, true);
          }
          streamSwitch(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv({}, n2), {}, { eventType: XC.STREAM_SWITCH, lts: r2, isDual: t2.isdual, elapse: r2 - i2.startTime, success: t2.succ });
            this.send({ type: QC.STREAM_SWITCH, data: s2 }, true);
          }
          requestProxyAppCenter(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv({}, n2), {}, { eventType: XC.REQUEST_PROXY_APPCENTER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, APAddr: t2.APAddr, workerManagerList: t2.workerManagerList, response: t2.response, errorCode: t2.ec, success: t2.succ });
            this.send({ type: QC.REQUEST_PROXY_APPCENTER, data: s2 }, true);
          }
          requestProxyWorkerManager(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv({}, n2), {}, { eventType: XC.REQUEST_PROXY_WORKER_MANAGER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i2.startTime, workerManagerAddr: t2.workerManagerAddr, response: t2.response, errorCode: t2.ec, success: t2.succ });
            this.send({ type: QC.REQUEST_PROXY_WORKER_MANAGER, data: s2 }, true);
          }
          setProxyServer(e2) {
            this.proxyServer = e2, e2 ? KC.debug("reportProxyServerurl: ".concat(e2)) : KC.debug("disable reportProxyServerurl: ".concat(e2));
          }
          peerPublishStatus(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv({}, n2), {}, { subscribeElapse: t2.subscribeElapse, peer: t2.peer, peerPublishDuration: Math.max(t2.audioPublishDuration, t2.videoPublishDuration), audiotag: t2.audioPublishDuration > 0 ? 1 : -1, videotag: t2.videoPublishDuration > 0 ? 1 : -1, lts: r2, elapse: r2 - i2.startTime, joinChannelSuccessElapse: r2 - (i2.lastJoinSuccessTime || r2), peerPublishDurationVideo: t2.videoPublishDuration, peerPublishDurationAudio: t2.audioPublishDuration });
            this.send({ type: QC.PEER_PUBLISH_STATUS, data: s2 }, true);
          }
          workerEvent(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = function(e3, t3, i3) {
              const n3 = e3[t3];
              if (!n3 || "string" != typeof n3)
                return [e3];
              e3[t3] = "";
              const r3 = LT(JSON.stringify(e3));
              let s3 = 0;
              const o2 = [];
              let a2 = 0;
              for (let c2 = 0; c2 < n3.length; c2++)
                a2 += n3.charCodeAt(c2) <= 127 ? 1 : 3, a2 <= i3 - r3 || (o2[o2.length] = vT(vT({}, e3), {}, { [t3]: n3.substring(s3, c2) }), s3 = c2, a2 = n3.charCodeAt(c2) <= 127 ? 1 : 3);
              return s3 !== n3.length - 1 && (o2[o2.length] = vT(vT({}, e3), {}, { [t3]: n3.substring(s3) })), o2;
            }(tv(tv(tv({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, productType: "WebRTC" }), "payload", 1300);
            s2.forEach((e3) => this.send({ type: QC.WORKER_EVENT, data: e3 }, true));
          }
          apworkerEvent(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv(tv({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
            this.send({ type: QC.AP_WORKER_EVENT, data: s2 }, true);
          }
          joinWebProxyAP(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv(tv({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2, extend: t2.extend || void 0 });
            this.send({ type: QC.JOIN_WEB_PROXY_AP, data: s2 }, true);
          }
          WebSocketQuit(e2, t2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2)
              return;
            const n2 = i2.info, r2 = Date.now(), s2 = tv(tv(tv({}, n2), t2), {}, { elapse: r2 - i2.startTime, lts: r2 });
            this.send({ type: QC.WEBSOCKET_QUIT, data: s2 }, true);
          }
          async sendCustomReportMessage(e2, t2) {
            if (this.customReportCount += t2.length, this.customReportCount > kC("CUSTOM_REPORT_LIMIT"))
              throw new Vg(xg.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
            this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
              this.customReportCount = 0;
            }, 5e3));
            const i2 = Date.now(), n2 = t2.map((t3) => ({ type: QC.USER_ANALYTICS, data: tv(tv({ sid: e2 }, t3), {}, { lts: i2 }) }));
            try {
              kC("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(n2) : await this.postDataToStatsCollector(n2);
            } catch (e3) {
              throw KC.error("send custom report message failed", e3.toString()), new Vg(xg.CUSTOM_REPORT_SEND_FAILED, e3.message);
            }
          }
          sendApiInvoke(e2) {
            const t2 = kC("NOT_REPORT_EVENT");
            if (e2.tag && Pr(t2) && Pr(t2).call(t2, e2.tag))
              return false;
            if (null === e2.sid)
              return this.apiInvokeUploadPendingItems.push(e2), false;
            const i2 = this.baseInfoMap.get(e2.sid);
            if (!i2)
              return this.apiInvokeUploadPendingItems.push(e2), false;
            const { cname: n2, uid: r2, cid: s2 } = i2.info;
            let o2;
            if (e2.lts = e2.lts || Date.now(), e2.error)
              if (e2.error instanceof Vg) {
                const { code: t3, message: i3 } = e2.error;
                o2 = t3 || (i3 || e2.error.toString());
              } else
                o2 = e2.error.toString();
            const a2 = { invokeId: e2.invokeId, sid: e2.sid, cname: n2, cid: s2, uid: r2, lts: e2.lts, success: e2.success, elapse: e2.lts - i2.startTime, execElapse: e2.lts - e2.apiInvokeTime, apiName: e2.name, options: e2.options ? JSON.stringify(e2.options) : void 0, execStates: e2.states ? JSON.stringify(e2.states) : void 0, execResult: e2.result ? JSON.stringify(e2.result) : void 0, errorCode: e2.error ? o2 : void 0, errorMsg: e2.error ? JSON.stringify(e2.error) : void 0 };
            return this.send({ type: QC.API_INVOKE, data: a2 }, false), true;
          }
          appendSessionId() {
            iv.__CLIENT_LIST__.forEach((e2) => {
              if (e2._sessionId) {
                const t2 = this.apiInvokeUploadPendingItems.length;
                for (let i2 = 0; i2 < t2; i2++) {
                  const t3 = this.apiInvokeUploadPendingItems.shift();
                  t3 && (t3.sid = e2._sessionId, this.sendApiInvoke(Object.assign({}, t3)));
                }
              }
            });
          }
          send(e2, t2) {
            if (t2)
              return this.keyEventUploadPendingItems.push(e2), void this.sendItems(this.keyEventUploadPendingItems, true);
            this.normalEventUploadPendingItems.push(e2), this.normalEventUploadPendingItems.length > kC("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
          }
          doSend() {
            this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
          }
          sendItems(e2, t2) {
            const i2 = [], n2 = [];
            for (; e2.length; ) {
              const t3 = e2.shift();
              i2.length < 20 ? i2.push(t3) : n2.push(t3);
            }
            e2.push(...n2);
            for (const e3 of [...i2]) {
              var r2;
              if (-1 !== this.ltsList.indexOf(e3.data.lts))
                e3.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e3.data.lts);
              else
                this.ltsList.push(e3.data.lts), Zu(r2 = this.ltsList).call(r2, (e4, t3) => e4 - t3);
            }
            t2 || (this.lastSendNormalEventTime = Date.now());
            return kC("ENABLE_EVENT_REPORT") ? (i2.length && (kC("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i2) : this.postDataToStatsCollector(i2)).catch(((e3) => (i3) => {
              kC("EVENT_REPORT_RETRY") && (t2 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e3) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e3), this.normalEventUploadPendingItems.length > kC("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - kC("NORMAL_EVENT_QUEUE_CAPACITY")), KC.warning("report: drop normal events"))));
            })(i2)), e2) : e2;
          }
          async postDataToStatsCollector2(e2) {
            RT.networkState === hT.OFFLINE && await tg.race([RT.onlineWaiter, UT(2 * JT.maxRetryTimeout)]);
            const t2 = (e3) => {
              let t3 = new Uint8Array();
              return e3.forEach((e4) => {
                const i3 = Zg(JSON.stringify(e4.data)), n3 = new ArrayBuffer(5), r2 = ((e5) => {
                  let t4 = 0;
                  return Object.entries(QC).forEach((i4) => {
                    let [n4, r3] = i4;
                    r3 === e5.type && (t4 = EventNameToID[n4]);
                  }), t4;
                })(e4), s2 = new DataView(n3);
                s2.setUint16(0, i3.byteLength, true), s2.setUint8(2, 255 & r2), s2.setUint8(3, r2 >>> 8 & 255), s2.setUint8(4, r2 >>> 16 & 255), t3 = $g(t3, new Uint8Array(n3)), t3 = $g(t3, i3);
              }), t3;
            }, i2 = "event";
            let n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(kC("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i2) : "https://".concat(kC("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i2);
            for (let r2 = 0; r2 < 2; r2 += 1) {
              1 === r2 && (n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(kC("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i2) : "https://".concat(kC("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i2));
              try {
                await RC(n2, { timeout: 1e4, data: t2(e2), headers: tv(tv({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
              } catch (e3) {
                if (1 === r2)
                  throw e3;
                continue;
              }
              return;
            }
          }
          async postDataToStatsCollector(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            const i2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e2.map((e3) => JSON.stringify(e3)), vid: ((e3) => {
              const t3 = e3 && e3.data.sid && this.baseInfoMap.get(e3.data.sid);
              return t3 && t3.info.vid && +t3.info.vid || 0;
            })(e2[0]) };
            RT.networkState === hT.OFFLINE && await tg.race([RT.onlineWaiter, UT(2 * JT.maxRetryTimeout)]);
            const n2 = t2 ? "/events/proto-raws" : "/events/messages";
            let r2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(kC("EVENT_REPORT_DOMAIN"), "&p=").concat(kC("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(kC("EVENT_REPORT_DOMAIN"), ":").concat(kC("STATS_COLLECTOR_PORT")).concat(n2));
            for (let e3 = 0; e3 < 2; e3 += 1) {
              1 === e3 && (r2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(kC("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(kC("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(kC("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(kC("STATS_COLLECTOR_PORT")).concat(n2)));
              try {
                t2 ? await CC(r2, { timeout: 1e4, data: i2 }) : await RC(r2, { timeout: 1e4, data: i2 });
              } catch (t3) {
                if (1 === e3)
                  throw t3;
                continue;
              }
              return;
            }
          }
          createBaseInfo(e2, t2) {
            const i2 = Object.assign({}, zC);
            return i2.sid = e2, this.baseInfoMap.set(e2, { info: i2, startTime: t2 }), i2;
          }
          reportResourceTiming(e2, t2) {
            const i2 = performance.getEntriesByName(e2), n2 = i2[i2.length - 1];
            n2 && this.reportApiInvoke(t2, { name: "Client.resourceTiming", options: n2, tag: oT.TRACER }).onSuccess();
          }
        }
        function nv() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          return function(t2, i2, n2) {
            const r2 = n2.value;
            if ("function" == typeof r2) {
              const s2 = e2.className || t2.__className__ || ("AgoraRTCClient" === t2.constructor.name ? "Client" : t2.constructor.name);
              n2.value = function() {
                for (var t3 = arguments.length, n3 = new Array(t3), o2 = 0; o2 < t3; o2++)
                  n3[o2] = arguments[o2];
                let a2 = n3;
                if (e2.argsMap)
                  try {
                    a2 = e2.argsMap(this, ...n3);
                  } catch (e3) {
                    KC.warning(e3), a2 = [];
                  }
                try {
                  JSON.stringify(a2);
                } catch (e3) {
                  KC.warning("arguments for method ".concat(s2, ".").concat(String(i2), " not serializable for apiInvoke.")), a2 = [];
                }
                const c2 = (e2.report || rv).reportApiInvoke(this._sessionId || null, { name: "".concat(s2, ".").concat(String(i2)), options: a2, tag: oT.TRACER, reportResult: e2.reportResult }, e2.throttleTime);
                try {
                  const t4 = r2.apply(this, n3);
                  return t4 instanceof tg ? t4.then((t5) => (c2.onSuccess(e2.reportResult && t5), t5)).catch((e3) => {
                    throw c2.onError(e3), e3;
                  }) : (c2.onSuccess(e2.reportResult && t4), t4);
                } catch (e3) {
                  throw c2.onError(e3), e3;
                }
              };
            }
            return n2;
          };
        }
        nu(iv, "__CLIENT_LIST__", []);
        const rv = new iv();
        VC.on("REPORT_LOG_UPLOAD", (e2) => {
          e2.networkState = RT.networkState, rv.reportApiInvoke(null, { name: "logUploadError", options: e2, tag: oT.TRACER });
        });
        const sv = ["CHINA", "GLOBAL"], ov = function() {
          const e2 = "us".concat("erna", "me"), t2 = "pa".concat("sswo", "rd"), i2 = ["t", "s", "t"];
          i2.splice(1, 0, "e");
          const n2 = i2.join(""), r2 = [];
          for (let e3 = 0; e3 < 6; e3++)
            r2.push("1");
          const s2 = r2.join(""), o2 = {};
          return o2[e2] = n2, o2[t2] = s2, Object.assign(o2, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
        }();
        window.DEFAULT_TURN_CONFIG = ov, NC || (PC.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], PC.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], PC.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], PC.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], PC.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], PC.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], PC.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", PC.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", PC.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", PC.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", PC.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
        const av = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], cv = [];
        function dv(e2, t2) {
          return !!t2 && cv.some((i2) => i2.uid === e2 && i2.channelName === t2);
        }
        iv.__CLIENT_LIST__ = cv;
        var lv, hv, uv, pv, _v, Ev, mv, fv, gv, Tv, Sv, Rv, Cv, vv, Iv, yv, Av, bv = er("Array").values, wv = Er, Ov = ni, Nv = Ee, Dv = bv, Pv = Array.prototype, Lv = { DOMTokenList: true, NodeList: true }, kv = J(function(e2) {
          var t2 = e2.values;
          return e2 === Pv || Nv(Pv, e2) && t2 === Pv.values || Ov(Lv, wv(e2)) ? Dv : t2;
        });
        function Mv(e2, t2, i2, n2) {
          var r2, s2 = arguments.length, o2 = s2 < 3 ? t2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(t2, i2) : n2;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
            o2 = Reflect.decorate(e2, t2, i2, n2);
          else
            for (var a2 = e2.length - 1; a2 >= 0; a2--)
              (r2 = e2[a2]) && (o2 = (s2 < 3 ? r2(o2) : s2 > 3 ? r2(t2, i2, o2) : r2(t2, i2)) || o2);
          return s2 > 3 && o2 && Object.defineProperty(t2, i2, o2), o2;
        }
        function Uv(e2, t2) {
          if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
            return Reflect.metadata(e2, t2);
        }
        !function(e2) {
          e2.L1T1 = "L1T1", e2.L1T2 = "L1T2", e2.L1T3 = "L1T3", e2.L2T1_KEY = "L2T1_KEY", e2.L2T2_KEY = "L2T2_KEY", e2.L2T3_KEY = "L2T3_KEY", e2.L3T1_KEY = "L3T1_KEY", e2.L3T2_KEY = "L3T2_KEY", e2.L3T3_KEY = "L3T3_KEY";
        }(lv || (lv = {})), function(e2) {
          e2.CERTIFICATE = "certificate", e2.CODEC = "codec", e2.CANDIDATE_PAIR = "candidate-pair", e2.LOCAL_CANDIDATE = "local-candidate", e2.REMOTE_CANDIDATE = "remote-candidate", e2.INBOUND = "inbound-rtp", e2.TRACK = "track", e2.OUTBOUND = "outbound-rtp", e2.PC = "peer-connection", e2.REMOTE_INBOUND = "remote-inbound-rtp", e2.REMOTE_OUTBOUND = "remote-outbound-rtp", e2.TRANSPORT = "transport", e2.CSRC = "csrc", e2.DATA_CHANNEL = "data-channel", e2.STREAM = "stream", e2.SENDER = "sender", e2.RECEIVER = "receiver";
        }(hv || (hv = {})), function(e2) {
          e2[e2.ACCESS_POINT = 101] = "ACCESS_POINT", e2[e2.UNILBS = 201] = "UNILBS", e2[e2.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR";
        }(uv || (uv = {})), function(e2) {
          e2[e2.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e2[e2.IIIEGAL_UID = 2] = "IIIEGAL_UID", e2[e2.INTERNAL_ERROR = 3] = "INTERNAL_ERROR";
        }(pv || (pv = {})), function(e2) {
          e2[e2.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e2[e2.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e2[e2.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e2[e2.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e2[e2.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e2[e2.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e2[e2.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e2[e2.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e2[e2.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e2[e2.USER_OVERLOAD = 16] = "USER_OVERLOAD", e2[e2.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e2[e2.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND";
        }(_v || (_v = {})), function(e2) {
          e2[e2.NO_FLAG_SET = 100] = "NO_FLAG_SET", e2[e2.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e2[e2.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e2[e2.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e2[e2.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e2[e2.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e2[e2.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e2[e2.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e2[e2.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e2[e2.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e2[e2.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e2[e2.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e2[e2.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e2[e2.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e2[e2.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e2[e2.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e2[e2.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV";
        }(Ev || (Ev = {})), function(e2) {
          e2[e2.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e2[e2.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e2[e2.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e2[e2.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e2[e2.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e2[e2.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e2[e2.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e2[e2.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e2[e2.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e2[e2.K_UID_BANNED = 14] = "K_UID_BANNED", e2[e2.K_IP_BANNED = 15] = "K_IP_BANNED", e2[e2.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e2[e2.K_AUTO_REBALANCE = 28] = "K_AUTO_REBALANCE", e2[e2.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e2[e2.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e2[e2.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e2[e2.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e2[e2.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e2[e2.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e2[e2.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e2[e2.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e2[e2.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e2[e2.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e2[e2.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e2[e2.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e2[e2.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e2[e2.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e2[e2.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e2[e2.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e2[e2.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e2[e2.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e2[e2.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e2[e2.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e2[e2.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e2[e2.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e2[e2.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e2[e2.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e2[e2.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e2[e2.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e2[e2.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e2[e2.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e2[e2.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e2[e2.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e2[e2.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e2[e2.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e2[e2.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e2[e2.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e2[e2.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e2[e2.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e2[e2.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e2[e2.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e2[e2.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e2[e2.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e2[e2.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e2[e2.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e2[e2.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e2[e2.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e2[e2.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e2[e2.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e2[e2.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e2[e2.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e2[e2.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e2[e2.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e2[e2.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY";
        }(mv || (mv = {})), function(e2) {
          e2.CONNECTING = "connecting", e2.CONNECTED = "connected", e2.RECONNECTING = "reconnecting", e2.CLOSED = "closed";
        }(fv || (fv = {})), function(e2) {
          e2.WS_CONNECTED = "ws_connected", e2.WS_RECONNECTING = "ws_reconnecting", e2.WS_CLOSED = "ws_closed", e2.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e2.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e2.ON_BINARY_DATA = "on_binary_data", e2.REQUEST_RECOVER = "request_recover", e2.REQUEST_JOIN_INFO = "request_join_info", e2.REQUEST_REJOIN_INFO = "req_rejoin_info", e2.IS_P2P_DISCONNECTED = "is_p2p_dis", e2.DISCONNECT_P2P = "dis_p2p", e2.ABORT_P2P_EXECUTION = "abort_p2p_execution", e2.NEED_RENEW_SESSION = "need-sid", e2.REPORT_JOIN_GATEWAY = "report_join_gateway", e2.REQUEST_TIMEOUT = "request_timeout", e2.REQUEST_SUCCESS = "request_success", e2.JOIN_RESPONSE = "join_response", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_CONNECTING = "datachannel_connecting", e2.DATACHANNEL_FAILBACK = "datachannel_failback", e2.P2P_START = "p2p_start", e2.P2P_CONNECTION = "p2p_connection", e2.P2P_REMOTE_CANDIDATE_UPDATE = "p2p_remote_candidate_update", e2.P2P_SUBSCRIBE = "p2p_subscribe", e2.P2P_UNSUBSCRIBE = "p2p_unsubscribe", e2.P2P_EXCHANGE_SDP = "p2p_exchange_sdp", e2.P2P_ON_ADD_VIDEO_STREAM = "p2p_on_add_video_stream", e2.P2P_ON_ADD_AUDIO_STREAM = "p2p_on_add_audio_stream";
        }(gv || (gv = {})), function(e2) {
          e2.PING = "ping", e2.PING_BACK = "ping_back", e2.JOIN = "join_v3", e2.REJOIN = "rejoin_v3", e2.LEAVE = "leave", e2.SET_CLIENT_ROLE = "set_client_role", e2.PUBLISH = "publish", e2.PUBLISH_DATASTREAM = "publish_datastream", e2.UNPUBLISH = "unpublish", e2.UNPUBLISH_DATASTREAM = "unpublish_datastream", e2.SUBSCRIBE = "subscribe", e2.SUBSCRIBE_DATASTREAM = "subscribe_datastream", e2.SUBSCRIBE_STREAMS = "subscribe_streams", e2.UNSUBSCRIBE = "unsubscribe", e2.UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream", e2.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e2.SUBSCRIBE_CHANGE = "subscribe_change", e2.TRAFFIC_STATS = "traffic_stats", e2.RENEW_TOKEN = "renew_token", e2.SWITCH_VIDEO_STREAM = "switch_video_stream", e2.DEFAULT_VIDEO_STREAM = "default_video_stream", e2.SET_FALLBACK_OPTION = "set_fallback_option", e2.GATEWAY_INFO = "gateway_info", e2.CONTROL = "control", e2.SEND_METADATA = "send_metadata", e2.DATA_STREAM = "data_stream", e2.PICK_SVC_LAYER = "pick_svc_layer", e2.RESTART_ICE = "restart_ice", e2.CONNECT_PC = "connect_pc", e2.SET_VIDEO_PROFILE = "set_video_profile", e2.SET_PARAMETER = "set_parameter", e2.SET_RTM2_FLAG = "set_rtm2_flag";
        }(Tv || (Tv = {})), function(e2) {
          e2.PUBLISH_STATS = "publish_stats", e2.PUBLISH_RELATED_STATS = "publish_related_stats", e2.SUBSCRIBE_STATS = "subscribe_stats", e2.SUBSCRIBE_RELATED_STATS = "subscribe_related_stats", e2.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e2.DENOISER_STATS = "denoiser_stats", e2.TRANSPORT_STATS = "transport_stats", e2.EXTENSION_USAGE_STATS = "extension_usage_stats";
        }(Sv || (Sv = {})), function(e2) {
          e2.ON_USER_ONLINE = "on_user_online", e2.ON_USER_OFFLINE = "on_user_offline", e2.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e2.ON_PUBLISH_STREAM = "on_publish_stream", e2.ON_UPLINK_STATS = "on_uplink_stats", e2.ON_P2P_LOST = "on_p2p_lost", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e2.ON_USER_BANNED = "on_user_banned", e2.ON_USER_LICENSE_BANNED = "on_user_license_banned", e2.ON_NOTIFICATION = "on_notification", e2.ON_CRYPT_ERROR = "on_crypt_error", e2.MUTE_AUDIO = "mute_audio", e2.MUTE_VIDEO = "mute_video", e2.UNMUTE_AUDIO = "unmute_audio", e2.UNMUTE_VIDEO = "unmute_video", e2.ON_P2P_OK = "on_p2p_ok", e2.RECEIVE_METADATA = "receive_metadata", e2.ON_DATA_STREAM = "on_data_stream", e2.ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change", e2.ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update", e2.ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info", e2.ENABLE_LOCAL_VIDEO = "enable_local_video", e2.DISABLE_LOCAL_VIDEO = "disable_local_video", e2.ENABLE_LOCAL_AUDIO = "enable_local_audio", e2.DISABLE_LOCAL_AUDIO = "disable_local_audio", e2.ON_PUBLISHED_USER_LIST = "on_published_user_list";
        }(Rv || (Rv = {})), function(e2) {
          e2.CONNECTION_STATE_CHANGE = "CONNECTION_STATE_CHANGE", e2.NEED_ANSWER = "NEED_ANSWER", e2.NEED_RENEGOTIATE = "NEED_RENEGOTIATE", e2.P2P_LOST = "P2P_LOST", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NEED_UNPUB = "NEED_UNPUB", e2.NEED_UNSUB = "NEED_UNSUB", e2.NEED_UPLOAD = "NEED_UPLOAD", e2.NEED_CONTROL = "NEED_CONTROL", e2.START_RECONNECT = "START_RECONNECT", e2.END_RECONNECT = "END_RECONNECT", e2.NEED_SIGNAL_RTT = "NEED_SIGNAL_RTT";
        }(Cv || (Cv = {})), function(e2) {
          e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY";
        }(vv || (vv = {})), function(e2) {
          e2.CONNECTED = "websocket:connected", e2.RECONNECTING = "websocket:reconnecting", e2.WILL_RECONNECT = "websocket:will_reconnect", e2.CLOSED = "websocket:closed", e2.FAILED = "websocket:failed", e2.ON_MESSAGE = "websocket:on_message", e2.REQUEST_NEW_URLS = "websocket:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire";
        }(Iv || (Iv = {}));
        class xv extends Vg {
          constructor(e2) {
            super(e2, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", arguments.length > 2 ? arguments[2] : void 0), nu(this, "name", "AgoraRTCException");
          }
          print() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
            return super.print(e2, KC);
          }
          throw() {
            super.throw(KC);
          }
        }
        function Vv(e2) {
          if ("string" != typeof e2 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e2))
            throw KC.error("Invalid Channel Name ".concat(e2)), new xv(xg.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
        }
        function Fv(e2) {
          if (!(t2 = e2, "number" == typeof t2 && Math.floor(t2) === t2 && 0 <= t2 && t2 <= 4294967295 || Yg(e2, 1, 255)))
            throw new xv(xg.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
          var t2;
          "string" == typeof e2 && KC.warn("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
        }
        !function(e2) {
          e2.TRANSCODE = "mix_streaming", e2.RAW = "raw_streaming", e2.INJECT = "inject_streaming";
        }(yv || (yv = {})), function(e2) {
          e2[e2.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e2[e2.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e2[e2.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e2[e2.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e2[e2.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e2[e2.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e2[e2.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN";
        }(Av || (Av = {}));
        const Bv = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, jv = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
        function Gv(e2, t2) {
          Wg(e2.url, "".concat(t2, ".url"), 1, 1e3, false), Kg(e2.x) || jg(e2.x, "".concat(t2, ".x"), 0, 1e4), Kg(e2.y) || jg(e2.y, "".concat(t2, ".y"), 0, 1e4), Kg(e2.width) || jg(e2.width, "".concat(t2, ".width"), 0, 1e4), Kg(e2.height) || jg(e2.height, "".concat(t2, ".height"), 0, 1e4), Kg(e2.zOrder) || jg(e2.zOrder, "".concat(t2, ".zOrder"), 0, 255), Kg(e2.alpha) || jg(e2.alpha, "".concat(t2, ".alpha"), 0, 1, false);
        }
        const Wv = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" }, Hv = { audioBitrate: 48, audioChannels: 2, audioVolume: 100, audioSampleRate: 48e3, height: 0, width: 0, videoBitrate: 400, videoFramerate: 15, videoGop: 30 };
        var Kv, Yv, qv, Jv, zv, Xv, Qv, Zv, $v, eI, tI, iI, nI, rI;
        function sI(e2) {
          if (!e2.channelName)
            throw new xv(xg.INVALID_PARAMS, "invalid channelName in info");
          if ("number" != typeof e2.uid)
            throw new xv(xg.INVALID_PARAMS, "invalid uid in info, uid must be a number");
          return e2.token && Wg(e2.token, "info.token", 1, 2047), Fv(e2.uid), Vv(e2.channelName), true;
        }
        !function(e2) {
          e2.WARNING = "@live_uap-warning", e2.ERROR = "@line_uap-error", e2.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e2.INJECT_STREAM_STATUS = "@live_uap-inject-status", e2.WORKER_STATUS = "@live_uap-worker-status", e2.REQUEST_NEW_ADDRESS = "@live_uap-request-address";
        }(Kv || (Kv = {})), function(e2) {
          e2.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager";
        }(Yv || (Yv = {})), function(e2) {
          e2[e2.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e2[e2.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e2[e2.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e2[e2.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e2[e2.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e2[e2.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e2[e2.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e2[e2.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e2[e2.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e2[e2.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e2[e2.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e2[e2.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e2[e2.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e2[e2.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e2[e2.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN";
        }(qv || (qv = {})), function(e2) {
          e2.CONNECT_FAILED = "connect failed", e2.CONNECT_TIMEOUT = "connect timeout", e2.WS_DISCONNECTED = "websocket disconnected", e2.REQUEST_TIMEOUT = "request timeout", e2.REQUEST_FAILED = "request failed", e2.WAIT_STATUS_TIMEOUT = "wait status timeout", e2.WAIT_STATUS_ERROR = "wait status error", e2.BAD_STATE = "bad state", e2.WS_ABORT = "ws abort", e2.AP_REQUEST_TIMEOUT = "AP request timeout", e2.AP_JSON_PARSE_ERROR = "AP json parse error", e2.AP_REQUEST_ERROR = "AP request error", e2.AP_REQUEST_ABORT = "AP request abort";
        }(Jv || (Jv = {})), function(e2) {
          e2[e2.SetSdkProfile = 0] = "SetSdkProfile", e2[e2.SetSourceChannel = 1] = "SetSourceChannel", e2[e2.SetSourceUserId = 2] = "SetSourceUserId", e2[e2.SetDestChannel = 3] = "SetDestChannel", e2[e2.StartPacketTransfer = 4] = "StartPacketTransfer", e2[e2.StopPacketTransfer = 5] = "StopPacketTransfer", e2[e2.UpdateDestChannel = 6] = "UpdateDestChannel", e2[e2.Reconnect = 7] = "Reconnect", e2[e2.SetVideoProfile = 8] = "SetVideoProfile";
        }(zv || (zv = {})), function(e2) {
          e2.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e2.NETWORK_CONNECTED = "NETWORK_CONNECTED", e2.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e2.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e2.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e2.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e2.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e2.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e2.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e2.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE";
        }(Xv || (Xv = {})), function(e2) {
          e2.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e2.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e2.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e2.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE";
        }(Qv || (Qv = {})), function(e2) {
          e2.RELAY_OK = "RELAY_OK", e2.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e2.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e2.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED";
        }(Zv || (Zv = {})), function(e2) {
          e2.High = "high", e2.Low = "low", e2.Audio = "audio", e2.Screen = "screen", e2.ScreenLow = "screen_low";
        }($v || ($v = {})), function(e2) {
          e2.DISCONNECT = "disconnect", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGE = "stream-type-change", e2.IS_P2P_DISCONNECTED = "is-p2p-dis", e2.DISCONNECT_P2P = "dis-p2p", e2.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e2.NEED_RENEW_SESSION = "need-sid", e2.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e2.JOIN_RESPONSE = "join-response", e2.REQUEST_DC_CONNECTION_PARAMS = "request-dc-connection-params", e2.RESET_CONNECTION_EVENTS = "reset-connection-events", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_FAILBACK = "datachannel_failback", e2.RESET_SIGNAL = "reset-signal";
        }(eI || (eI = {})), function(e2) {
          e2.P2P_DISCONNECTED = "P2P_DISCONNECTED", e2.A_ROUND_WS_FAILED = "A_ROUND_WS_FAILED", e2.TIMEOUT = "TIMEOUT", e2.UNKNOWN_REASON = "UNKNOWN_REASON";
        }(tI || (tI = {})), function(e2) {
          e2[e2.Nothing = 0] = "Nothing", e2[e2.Audio = 1] = "Audio", e2[e2.LwoVideo = 2] = "LwoVideo", e2[e2.Video = 4] = "Video", e2[e2.Data = 8] = "Data", e2[e2.DataStream0 = 256] = "DataStream0", e2[e2.DataStream1 = 512] = "DataStream1", e2[e2.DataStream2 = 1024] = "DataStream2", e2[e2.DataStream3 = 2048] = "DataStream3", e2[e2.DataStream4 = 4096] = "DataStream4", e2[e2.DataStream5 = 8192] = "DataStream5", e2[e2.DataStream6 = 16384] = "DataStream6", e2[e2.DataStream7 = 32768] = "DataStream7";
        }(iI || (iI = {})), function(e2) {
          e2[e2.websocket = 0] = "websocket", e2[e2.datachannel = 1] = "datachannel";
        }(nI || (nI = {})), function(e2) {
          e2.CHINA = "CHINA", e2.ASIA = "ASIA", e2.NORTH_AMERICA = "NORTH_AMERICA", e2.EUROPE = "EUROPE", e2.JAPAN = "JAPAN", e2.INDIA = "INDIA", e2.KOREA = "KOREA", e2.HKMC = "HKMC", e2.US = "US", e2.OCEANIA = "OCEANIA", e2.SOUTH_AMERICA = "SOUTH_AMERICA", e2.AFRICA = "AFRICA", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "EXTENSIONS";
        }(rI || (rI = {}));
        const oI = [rI.AFRICA, rI.ASIA, rI.CHINA, rI.EUROPE, rI.GLOBAL, rI.INDIA, rI.JAPAN, rI.NORTH_AMERICA, rI.OCEANIA, rI.OVERSEA, rI.SOUTH_AMERICA];
        var aI;
        !function(e2) {
          e2.CHINA = "CN", e2.ASIA = "AS", e2.NORTH_AMERICA = "NA", e2.EUROPE = "EU", e2.JAPAN = "JP", e2.INDIA = "IN", e2.KOREA = "KR", e2.HKMC = "HK", e2.US = "US", e2.OCEANIA = "OC", e2.SOUTH_AMERICA = "SA", e2.AFRICA = "AF", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "GLOBAL";
        }(aI || (aI = {}));
        const cI = { CHINA: {}, ASIA: { CODE: aI.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: aI.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: aI.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: aI.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "	uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: aI.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: aI.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: aI.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: aI.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: aI.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: aI.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: aI.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: aI.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: aI.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
        var dI, lI, hI, uI, pI, _I, EI, mI, fI, gI, TI, SI, RI, CI, vI, II, yI, AI, bI, wI, OI, NI;
        NC && (cI.CHINA = { CODE: aI.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }), function(e2) {
          e2.UPDATE_BITRATE_LIMIT = "update_bitrate_limit";
        }(dI || (dI = {}));
        class DI extends iT {
          constructor(e2, t2) {
            super(), nu(this, "onICEConnectionStateChange", void 0), nu(this, "onConnectionStateChange", void 0), nu(this, "onDTLSTransportStateChange", void 0), nu(this, "onDTLSTransportError", void 0), nu(this, "onICETransportStateChange", void 0), nu(this, "onFirstAudioReceived", void 0), nu(this, "onFirstVideoReceived", void 0), nu(this, "onFirstAudioDecoded", void 0), nu(this, "onFirstVideoDecoded", void 0), nu(this, "onFirstVideoDecodedTimeout", void 0), nu(this, "onSelectedLocalCandidateChanged", void 0), nu(this, "onSelectedRemoteCandidateChanged", void 0);
          }
        }
        class PI extends DI {
          constructor(e2, t2) {
            super(e2, t2);
          }
        }
        !function(e2) {
          e2.SEND = "sendonly", e2.RECV = "recvonly", e2.SENDRECV = "sendrecv", e2.INACTIVE = "inactive";
        }(lI || (lI = {})), function(e2) {
          e2.VIDEO = "video", e2.AUDIO = "audio";
        }(hI || (hI = {})), function(e2) {
          e2[e2.UDP = 0] = "UDP", e2[e2.TCP = 1] = "TCP", e2[e2.RELAY = 2] = "RELAY";
        }(uI || (uI = {})), function(e2) {
          e2[e2.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e2[e2.TCP_RESTART = 1] = "TCP_RESTART", e2[e2.RELAY_RESTART = 2] = "RELAY_RESTART", e2[e2.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e2[e2.OLD_RESTART = 11] = "OLD_RESTART", e2[e2.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED";
        }(pI || (pI = {})), function(e2) {
          e2.LocalVideoTrack = "videoTrack", e2.LocalAudioTrack = "audioTrack", e2.LocalVideoLowTrack = "videoLowTrack";
        }(_I || (_I = {})), function(e2) {
          e2.New = "new", e2.Connected = "connected", e2.Reconnecting = "reconnecting", e2.Disconnected = "disconnected";
        }(EI || (EI = {})), function(e2) {
          e2.StateChange = "stateChange", e2.IceConnectionStateChange = "iceConnectionStateChange", e2.RequestMuteLocal = "requestMuteLocal", e2.RequestUnmuteLocal = "requestUnmuteLocal", e2.RequestRePublish = "requestRePublish", e2.RequestRePublishDataChannel = "requestRePublishDataChannel", e2.RequestReSubscribe = "requestReSubscribe", e2.RequestUploadStats = "requestUploadStats", e2.MediaReconnectStart = "MediaReconnectStart", e2.MediaReconnectEnd = "MediaReconnectEnd", e2.NeedSignalRTT = "NeedSignalRTT", e2.RequestRestartICE = "RequestRestartIce", e2.PeerConnectionStateChange = "PeerConnectionStateChange", e2.RequestReconnect = "RequestReconnect", e2.RequestReconnectPC = "RequestReconnectPC", e2.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e2.P2PLost = "P2PLost", e2.UpdateVideoEncoder = "UpdateVideoEncoder", e2.ConnectionTypeChange = "ConnectionTypeChange", e2.RequestLowStreamParameter = "RequestLowStreamParameter", e2.QueryClientConnectionState = "QueryClientConnectionState", e2.LocalCandidate = "LocalCandidate", e2.RequestP2PMuteLocal = "requestP2PMuteLocal", e2.RequestP2PPublish = "RequestP2PPublish", e2.RequestP2PUnPublish = "RequestP2PUnPublish", e2.RequestP2PUnmuteRemote = "RequestP2PUnmuteRemote", e2.RequestP2PMuteRemote = "RequestP2PMuteRemote", e2.RequestP2PRestartICE = "RequestP2PRestartICE";
        }(mI || (mI = {})), function(e2) {
          e2.MUTE_LOCAL_VIDEO = "mute_local_video", e2.MUTE_LOCAL_AUDIO = "mute_local_audio", e2.UNMUTE_LOCAL_VIDEO = "unmute_local_video", e2.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", e2.MUTE_REMOTE_VIDEO = "mute_remote_video", e2.MUTE_REMOTE_AUDIO = "mute_remote_audio", e2.UNMUTE_REMOTE_VIDEO = "unmute_remote_video", e2.UNMUTE_REMOTE_AUDIO = "unmute_remote_audio";
        }(fI || (fI = {})), function(e2) {
          e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED";
        }(gI || (gI = {})), function(e2) {
          e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED";
        }(TI || (TI = {})), function(e2) {
          e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
        }(SI || (SI = {})), function(e2) {
          e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
        }(RI || (RI = {})), function(e2) {
          e2.CONNECTED = "transmitter:connected", e2.RECONNECTING = "transmitter:reconnecting", e2.WILL_RECONNECT = "transmitter:will_reconnect", e2.CLOSED = "transmitter:closed", e2.FAILED = "transmitter:failed", e2.ON_MESSAGE = "transmitter:on_message", e2.REQUEST_NEW_URLS = "transmitter:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e2.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e2.FAILBACK = "transmitter:failback";
        }(CI || (CI = {})), function(e2) {
          e2.CAMERA_CHANGED = "camera-changed", e2.MICROPHONE_CHANGED = "microphone-changed", e2.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e2.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e2.AUTOPLAY_FAILED = "autoplay-failed", e2.SECURITY_POLICY_VIOLATION = "security-policy-violation";
        }(vI || (vI = {})), function(e2) {
          e2[e2.APP_TYPE_INVALID_VALUE = -1] = "APP_TYPE_INVALID_VALUE", e2[e2.APP_TYPE_NATIVE = 0] = "APP_TYPE_NATIVE", e2[e2.APP_TYPE_NATIVE_COCOS = 1] = "APP_TYPE_NATIVE_COCOS", e2[e2.APP_TYPE_NATIVE_UNITY = 2] = "APP_TYPE_NATIVE_UNITY", e2[e2.APP_TYPE_NATIVE_ELECTRON = 3] = "APP_TYPE_NATIVE_ELECTRON", e2[e2.APP_TYPE_NATIVE_FLUTTER = 4] = "APP_TYPE_NATIVE_FLUTTER", e2[e2.APP_TYPE_NATIVE_UNREAL = 5] = "APP_TYPE_NATIVE_UNREAL", e2[e2.APP_TYPE_NATIVE_XAMARIN = 6] = "APP_TYPE_NATIVE_XAMARIN", e2[e2.APP_TYPE_NATIVE_API_CLOUD = 7] = "APP_TYPE_NATIVE_API_CLOUD", e2[e2.APP_TYPE_NATIVE_REACT_NATIVE = 8] = "APP_TYPE_NATIVE_REACT_NATIVE", e2[e2.APP_TYPE_NATIVE_PYTHON = 9] = "APP_TYPE_NATIVE_PYTHON", e2[e2.APP_TYPE_NATIVE_COCOS_CREATOR = 10] = "APP_TYPE_NATIVE_COCOS_CREATOR", e2[e2.APP_TYPE_NATIVE_RUST = 11] = "APP_TYPE_NATIVE_RUST", e2[e2.APP_TYPE_NATIVE_C_SHARP = 12] = "APP_TYPE_NATIVE_C_SHARP", e2[e2.APP_TYPE_NATIVE_CEF = 13] = "APP_TYPE_NATIVE_CEF", e2[e2.APP_TYPE_NATIVE_UNI_APP = 14] = "APP_TYPE_NATIVE_UNI_APP", e2[e2.APP_TYPE_WEBRTC = 1e3] = "APP_TYPE_WEBRTC", e2[e2.APP_TYPE_WEBRTC_REACT = 1001] = "APP_TYPE_WEBRTC_REACT", e2[e2.APP_TYPE_WEBRTC_VUE = 1002] = "APP_TYPE_WEBRTC_VUE", e2[e2.APP_TYPE_WEBRTC_ANGULAR = 1003] = "APP_TYPE_WEBRTC_ANGULAR";
        }(II || (II = {})), function(e2) {
          e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED";
        }(yI || (yI = {})), function(e2) {
          e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
        }(AI || (AI = {})), function(e2) {
          e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED";
        }(bI || (bI = {})), function(e2) {
          e2.CALL = "call", e2.CANDIDATE = "candidate", e2.PUBLISH = "publish", e2.UNPUBLISH = "unpublish", e2.SUBSCRIBE = "subscribe", e2.UNSUBSCRIBE = "unsubscribe", e2.CONTROL = "control", e2.RESTART_ICE = "restart_ice", e2.ACK = "ack", e2.JOIN = "join", e2.EXCHANGE_SDP = "exchange_sdp", e2.DO_SUBSCRIBE = "do_subscribe", e2.DO_UNSUBSCRIBE = "do_unsubscribe";
        }(wI || (wI = {})), function(e2) {
          e2.MUTE_LOCAL_AUDIO = "mute_local_audio", e2.MUTE_LOCAL_VIDEO = "mute_local_video", e2.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", e2.UNMUTE_LOCAL_VIDEO = "unmute_local_video";
        }(OI || (OI = {})), function(e2) {
          e2[e2.SUCCESS = 1] = "SUCCESS", e2[e2.FAILED = 0] = "FAILED";
        }(NI || (NI = {}));
        const LI = { [uv.ACCESS_POINT]: { [Ev.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [Ev.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [Ev.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [Ev.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [Ev.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [Ev.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_VOICE]: { desc: "no unilbs voice service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [Ev.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [uv.UNILBS]: { [_v.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [_v.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [_v.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [_v.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [_v.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [_v.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [_v.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [_v.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [_v.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [_v.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [_v.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [_v.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [uv.STRING_UID_ALLOCATOR]: { [pv.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [pv.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [pv.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
        function kI(e2) {
          const t2 = LI[Math.floor(e2 / 1e4)];
          if (!t2)
            return { desc: "unkonw error", retry: false };
          const i2 = t2[e2 % 1e4];
          if (!i2) {
            if (Math.floor(e2 / 1e4) === uv.ACCESS_POINT) {
              const t3 = e2 % 1e4;
              if ("1" === t3.toString()[0])
                return { desc: e2.toString(), retry: false };
              if ("2" === t3.toString()[0])
                return { desc: e2.toString(), retry: true };
            }
            return { desc: "unkonw error", retry: false };
          }
          return i2;
        }
        const MI = { [mv.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [mv.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [mv.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [mv.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [mv.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [mv.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [mv.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [mv.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [mv.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [mv.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [mv.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [mv.K_AUTO_REBALANCE]: { desc: "k_AUTO_REBALANCE", action: "recover" }, [mv.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [mv.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [mv.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [mv.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [mv.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [mv.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [mv.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [mv.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [mv.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [mv.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [mv.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [mv.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [mv.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [mv.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [mv.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [mv.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [mv.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [mv.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [mv.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [mv.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [mv.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [mv.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [mv.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [mv.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [mv.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [mv.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [mv.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [mv.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [mv.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [mv.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [mv.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [mv.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [mv.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [mv.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [mv.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [mv.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [mv.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [mv.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [mv.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [mv.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [mv.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [mv.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [mv.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [mv.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [mv.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [mv.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [mv.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [mv.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [mv.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [mv.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [mv.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
        function UI(e2) {
          const t2 = MI[e2];
          return t2 || { desc: "UNKNOW_ERROR_".concat(e2), action: "failed" };
        }
        function xI(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function VI(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? xI(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : xI(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        function FI(e2) {
          return e2.every((e3) => e3.readyState === WebSocket.CLOSED || e3.readyState === WebSocket.CLOSING);
        }
        function BI(e2, t2) {
          if ("string" == typeof e2)
            return e2;
          const { proxy: i2, host: n2, port: r2 } = e2;
          if (t2) {
            const e3 = kC("JOIN_GATEWAY_FALLBACK_PORT") || 443;
            return 443 === e3 ? "wss://".concat(n2, "/ws/?p=").concat(Number(r2) + 150) : "wss://".concat(n2, ":").concat(e3, "/ws/?p=").concat(Number(r2) + 150);
          }
          return i2 ? "wss://".concat(i2, "/ws/?h=").concat(n2, "&p=").concat(r2) : "wss://".concat(n2, ":").concat(r2);
        }
        const jI = /wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/, GI = /wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/, WI = /wss:\/\/(.+):([0-9]+)\/?/, HI = /wss:\/\/(.[^\/]+)\/?/;
        let KI = 0;
        class YI {
          constructor(e2, t2) {
            nu(this, "id", 0), nu(this, "store", void 0), nu(this, "recordIndex", void 0), nu(this, "websockets", []), nu(this, "try443PortDuration", 2e3), nu(this, "forceCloseWSDuration", 5e3), nu(this, "try443PortTimeout", null), nu(this, "forceCloseTimeout", null), nu(this, "isTry443PortFailed", false), nu(this, "isNormalPortFailed", false), nu(this, "useDoubleDomain", false), nu(this, "useProxy", false), nu(this, "startTime", Date.now()), this.id = ++KI, this.try443PortDuration = kC("JOIN_GATEWAY_TRY_443PORT_DURATION") || 2e3, this.forceCloseWSDuration = e2 || 5e3, this.store = t2;
          }
          closeAllWebsockets() {
            this.websockets.forEach((e2) => {
              e2.onopen = null, e2.onclose = null, e2.onmessage = null, e2.close();
            }), this.websockets.length = 0;
          }
          clearTimeout() {
            this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout);
          }
          logger() {
            var e2;
            const t2 = Date.now() - this.startTime;
            for (var i2 = arguments.length, n2 = new Array(i2), r2 = 0; r2 < i2; r2++)
              n2[r2] = arguments[r2];
            KC.debug("[choose-best-ws ".concat(null === (e2 = this.store) || void 0 === e2 ? void 0 : e2.clientId, " ").concat(this.id, "] ").concat(t2, "ms:"), ...n2);
          }
          createWebSocket(e2, t2, i2) {
            this.logger("createWebSocket:", e2, { isTry443Port: t2, hasTimeoutDetection: i2 });
            const n2 = kC("GATEWAY_DOMAINS"), r2 = Date.now(), s2 = [], o2 = n2.find((t3) => {
              var i3;
              return Pr(i3 = e2.host).call(i3, t3);
            });
            o2 || (this.useDoubleDomain = false);
            const a2 = [];
            if (this.useDoubleDomain)
              n2.forEach((i3) => {
                a2.push(BI(VI(VI({}, e2), {}, { host: e2.host.replace(o2, i3) }), t2));
              });
            else {
              const i3 = VI({}, e2);
              if (t2 && o2) {
                const e3 = n2.find((e4) => e4 !== o2);
                e3 && (i3.host = i3.host.replace(o2, e3));
              }
              a2.push(BI(i3, t2));
            }
            try {
              a2.forEach((e3) => {
                const t3 = new WebSocket(e3);
                t3.binaryType = "arraybuffer", s2.push(t3), this.logger("ws is connecting:", t3.url);
              });
            } catch (n3) {
              if (this.logger("ws create failed"), s2.forEach((e3) => e3.close()), s2.length = 0, this.useDoubleDomain)
                return this.useDoubleDomain = false, this.createWebSocket(e2, t2, i2);
              if (!t2 && 443 !== Number(e2.port))
                return this.createWebSocket(e2, true, i2);
              throw new xv(xg.WS_ERR, "init websocket failed! Error: ".concat(n3.toString()));
            }
            const c2 = ng();
            this.store && this.store.recordJoinChannelService({ urls: s2.map((e3) => e3.url), service: "gateway" }, this.recordIndex), s2.forEach((e3) => {
              e3.onopen = () => {
                this.logger("onopen: ws ".concat(e3.url, " open cost ").concat(Date.now() - r2, "ms")), this.websockets.forEach((t3) => {
                  t3 !== e3 && (t3.onopen = null, t3.onclose = null, t3.onmessage = null, t3.close(), this.logger("close backup websocket: ".concat(t3.url)));
                }), this.websockets.length = 0, c2.resolve(e3);
              }, e3.onclose = (i3) => {
                this.logger("onclose: ws ".concat(e3.url, " closed cost ").concat(Date.now() - r2, "ms state: ").concat(e3.readyState)), t2 ? this.isTry443PortFailed = FI(s2) : this.isNormalPortFailed = FI(s2), this.logger("443: ".concat(this.useProxy ? "not try" : this.isTry443PortFailed ? "failed" : "trying", " 47xx: ").concat(this.isNormalPortFailed ? "failed" : "trying")), (t2 && this.isTry443PortFailed || !t2 && (this.isTry443PortFailed || this.useProxy) && this.isNormalPortFailed) && (this.logger("onclose: all websocket is closed, ".concat(i3.reason)), c2.reject({ code: i3.code, reason: tI.A_ROUND_WS_FAILED }));
              }, e3.onmessage = (t3) => this.logger("".concat(e3.url, " onmessage: ").concat(t3.data));
            }), this.websockets.push(...s2);
            return i2 || (() => {
              const i3 = () => {
                this.logger("5s timeout close un-opens, isWebsocket created: ", c2.isResolved), this.websockets.forEach((e3) => e3.readyState !== WebSocket.OPEN && e3.close());
              };
              if (t2 || this.useProxy)
                return this.logger("add 5s timeout at ".concat(t2 ? "try-443" : "proxy", " condition")), this.forceCloseTimeout = window.setTimeout(i3, this.forceCloseWSDuration);
              this.try443PortTimeout = window.setTimeout(() => {
                if (this.logger("2s timeout, isWebsocket created: ", c2.isResolved), c2.isResolved)
                  return i3();
                pg().os === ag.MAC_OS && Rg() && i3(), this.createWebSocket(e2, true, true).then((e3) => c2.resolve(e3)).catch((e3) => {
                  this.isNormalPortFailed && c2.reject(e3), this.logger("try 443 port to create ws failed");
                }), this.forceCloseTimeout = window.setTimeout(i3, this.forceCloseWSDuration);
              }, this.try443PortDuration);
            })(), c2.promise;
          }
          chooseBestWebsocket(e2, t2, i2, n2) {
            return this.useDoubleDomain = !!t2, "string" == typeof e2 && (e2 = function(e3) {
              let t3, i3, n3;
              return [, t3, i3, n3] = e3.match(jI) || [], t3 || ([, i3, n3] = e3.match(GI) || []), i3 && n3 || ([, i3, n3] = e3.match(WI) || []), i3 && n3 || ([, i3] = e3.match(HI) || []), i3 || KC.warning("un-destructible url: ", e3), { proxy: t3, host: i3, port: n3 || "443" };
            }(e2)), this.recordIndex = n2, this.useProxy = !!e2.proxy, i2 && this.useProxy && (KC.warn("cannot use 443 only when use proxy"), i2 = false), this.createWebSocket(e2, !!i2, false).finally(() => this.clearTimeout());
          }
        }
        function qI(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        class JI extends iT {
          get url() {
            return this.websocket && this.websocket.url || null;
          }
          get reconnectMode() {
            return this._reconnectMode;
          }
          set reconnectMode(e2) {
            var t2;
            Pr(t2 = ["tryNext", "recover"]).call(t2, e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
          }
          get state() {
            return this._state;
          }
          set state(e2) {
            e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(Iv.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(Iv.CONNECTED) : "closed" === this._state ? this.emit(Iv.CLOSED) : "failed" === this._state && this.emit(Iv.FAILED));
          }
          resetReconnectCount(e2) {
            KC.debug("websocket reset reconnect count, reason: " + e2), this.reconnectCount = 0;
          }
          constructor(e2, t2) {
            let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], s2 = arguments.length > 5 ? arguments[5] : void 0;
            super(), nu(this, "connectionID", 0), nu(this, "currentURLIndex", 0), nu(this, "urls", []), nu(this, "_reconnectMode", "tryNext"), nu(this, "reconnectReason", void 0), nu(this, "_initMutex", new YT("websocket")), nu(this, "name", void 0), nu(this, "_state", "closed"), nu(this, "reconnectInterrupter", void 0), nu(this, "websocket", void 0), nu(this, "retryConfig", void 0), nu(this, "reconnectCount", 0), nu(this, "forceCloseTimeout", 5e3), nu(this, "onlineReconnectListener", void 0), nu(this, "useCompress", void 0), nu(this, "tryDoubleDomain", false), nu(this, "use443PortOnly", false), nu(this, "wsInflateLength", 0), nu(this, "wsDeflateLength", 0), nu(this, "closeEstablishingWs", () => {
            }), nu(this, "store", void 0), nu(this, "joinGatewayRecordIndex", void 0), this.store = s2, this.name = e2, this.retryConfig = function(e3) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var i3 = null != arguments[t3] ? arguments[t3] : {};
                t3 % 2 ? qI(Object(i3), true).forEach(function(t4) {
                  nu(e3, t4, i3[t4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : qI(Object(i3)).forEach(function(t4) {
                  Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
                });
              }
              return e3;
            }({}, t2), this.useCompress = i2, this.tryDoubleDomain = n2, this.use443PortOnly = r2;
            const { timeout: o2, timeoutFactor: a2 } = t2, c2 = Math.max(300, Math.floor(3 * o2 / 5)), d2 = Math.max(1.2, Math.floor(8 * a2) / 10);
            hT.ONLINE && (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2), RT.on(uT.NETWORK_STATE_CHANGE, (e3, t3) => {
              e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === hT.ONLINE ? (this.retryConfig.timeout = c2, this.retryConfig.timeoutFactor = d2) : (this.retryConfig.timeout = o2, this.retryConfig.timeoutFactor = a2));
            });
          }
          getConnection() {
            return this.websocket || void 0;
          }
          async init(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
            const i2 = await this._initMutex.lock();
            this.forceCloseTimeout = t2, this.urls = e2, this.state = "connecting";
            try {
              const e3 = ng(), t3 = this.urls[this.currentURLIndex];
              this.createWebSocketConnection(t3).then(e3.resolve).catch(e3.reject), this.once(Iv.CLOSED, () => {
                e3.reject(new Vg(xg.WS_DISCONNECT));
              }), this.once(Iv.CONNECTED, e3.resolve), await e3.promise;
            } catch (e3) {
            } finally {
              i2();
            }
          }
          close(e2, t2) {
            if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
              this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
              const e3 = this.websocket;
              t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this.websocket = void 0;
            }
            this.state = e2 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
          }
          reconnect(e2, t2) {
            if (!this.websocket)
              return void KC.warning("[".concat(this.name, "] can not reconnect, no websocket"));
            void 0 !== e2 && (this.reconnectMode = e2), KC.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinGatewayRecordIndex && this.store && this.store.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this.joinGatewayRecordIndex);
            const i2 = this.websocket.onclose;
            this.websocket.onclose = null, this.websocket.close(), i2 && i2.bind(this.websocket)({ code: 9999, reason: t2 });
          }
          sendMessage(e2) {
            let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN)
              throw new Vg(xg.WS_ABORT, "websocket is not ready");
            try {
              t2 || (e2 = JSON.stringify(e2)), this.websocket.send(e2);
            } catch (e3) {
              throw new Vg(xg.WS_ERR, "send websocket message error" + e3.toString());
            }
          }
          setWsInflateData(e2) {
            this.wsDeflateLength = this.wsDeflateLength + e2.originLength, this.wsInflateLength = this.wsInflateLength + e2.compressedLength;
          }
          getWsInflateData() {
            const e2 = this.wsInflateLength, t2 = this.wsDeflateLength;
            return this.clearWsInflateData(), { wsInflateLength: e2, wsDeflateLength: t2 };
          }
          clearWsInflateData() {
            this.wsInflateLength = 0, this.wsDeflateLength = 0;
          }
          async createWebSocketConnection(e2) {
            var t2;
            const i2 = ng();
            this.connectionID += 1, this.joinGatewayRecordIndex = void 0;
            const n2 = (e3) => {
              var t3;
              null === (t3 = this.store) || void 0 === t3 || t3.signalChannelOpen(), KC.debug("[".concat(this.name, "] websocket opened:"), e3), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i2.resolve();
            }, r2 = async (e3) => {
              var t3;
              if (KC.debug("[".concat(this.name, "] websocket close ").concat(null === (t3 = this.websocket) || void 0 === t3 ? void 0 : t3.url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount)
                i2.reject(new Vg(xg.WS_DISCONNECT, "websocket close: ".concat(e3.code))), this.close();
              else {
                "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
                const t4 = TT(this, Iv.WILL_RECONNECT, this.reconnectMode, e3.reason) || this.reconnectMode, n3 = await this.reconnectWithAction(t4);
                if ("closed" === this.state)
                  return void KC.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
                if (!n3)
                  return i2.reject(new Vg(xg.WS_DISCONNECT, "websocket reconnect failed: ".concat(e3.code))), this.close(true);
                i2.resolve();
              }
            }, s2 = (e3) => {
              this.emit(Iv.ON_MESSAGE, e3);
            }, o2 = (e3) => {
              KC.warn("[".concat(this.connectionID, "] ws open error ").concat(e3));
            };
            this.websocket && (this.websocket.onclose = null, this.websocket.close()), kC("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e2 = kC("GATEWAY_WSS_ADDRESS")), KC.debug("[".concat(this.name, "] start connect, url:"), e2);
            const a2 = null === (t2 = this.store) || void 0 === t2 ? void 0 : t2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
            try {
              var c2;
              const t3 = await this.chooseBestWebsocketConnection(e2);
              this.websocket = t3, n2 && n2(this.websocket.url), this.websocket.onclose = r2, this.websocket.onmessage = s2, this.websocket.onerror = o2, null === (c2 = this.store) || void 0 === c2 || c2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this.joinGatewayRecordIndex = a2;
            } catch (e3) {
              const t3 = "closed" === this.state, n3 = e3 instanceof Vg, s3 = n3 && e3.code === xg.WS_ABORT, o3 = n3 && e3.code === xg.WS_ERR, c3 = n3 ? e3.message : e3 && (e3.reason || e3.toString());
              KC.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(c3)), this.store && this.store.recordJoinChannelService({ endTs: Date.now(), status: s3 ? "aborted" : "error", errors: [e3] }, a2), t3 || o3 ? (i2.reject(t3 ? new Vg(xg.WS_DISCONNECT, "websocket is closed: ".concat(c3)) : new Vg(xg.WS_ERR, "init websocket failed: ".concat(c3))), o3 && KC.error("[".concat(this.name, "] init websocket failed: ").concat(c3))) : r2 && r2(e3);
            }
            return i2.promise;
          }
          async reconnectWithAction(e2) {
            let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (this.reconnectCount >= this.retryConfig.maxRetryCount)
              return false;
            if (0 === this.urls.length)
              return false;
            if ("closed" === this.state)
              return false;
            KC.warning("[choose-best-ws] action: =>", e2), this.onlineReconnectListener || RT.isOnline || !RT.onlineWaiter || (this.onlineReconnectListener = RT.onlineWaiter.then(() => {
              this.onlineReconnectListener = void 0;
            }));
            let i2 = true;
            if (this.reconnectInterrupter = () => i2 = false, t2) {
              const t3 = zT(this.reconnectCount, this.retryConfig);
              KC.debug("[".concat(this.name, "] wait ").concat(t3, "ms to reconnect websocket, mode: ").concat(e2)), await tg.race([UT(t3), this.onlineReconnectListener || new tg(() => {
              })]);
            }
            if ("closed" === this._state || !i2)
              return false;
            this.reconnectCount += 1;
            const n2 = async (e3, t3) => {
              this.emit(Iv.RECONNECT_CREATE_CONNECTION, t3), await this.createWebSocketConnection(e3);
            };
            try {
              if ("retry" === e2)
                this.emit(Iv.RECONNECT_WAITTING_FINISH, e2), await n2(this.urls[this.currentURLIndex], e2);
              else if ("tryNext" === e2) {
                if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length)
                  return this.reconnectWithAction("recover", false);
                KC.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), this.emit(Iv.RECONNECT_WAITTING_FINISH, e2), await n2(this.urls[this.currentURLIndex], e2);
              } else
                "recover" === e2 && (KC.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.emit(Iv.RECONNECT_WAITTING_FINISH, e2), this.urls = await fT(this, Iv.REQUEST_NEW_URLS), this.currentURLIndex = 0, await n2(this.urls[this.currentURLIndex], e2));
            } catch (i3) {
              var r2;
              KC.error("[".concat(this.name, "] reconnect failed ").concat(i3 && i3.toString()));
              const n3 = null == i3 || null === (r2 = i3.data) || void 0 === r2 ? void 0 : r2.desc;
              return Array.isArray(n3) && Pr(n3).call(n3, "dynamic key expired") ? (this.emit(Iv.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : this.reconnectWithAction(e2, t2);
            }
            return true;
          }
        }
        class zI extends JI {
          constructor(e2, t2) {
            super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
          }
          async chooseBestWebsocketConnection(e2, t2) {
            const i2 = ng(), n2 = function(e3, t3) {
              return new YI(e3, t3);
            }(this.forceCloseTimeout, this.store);
            this.closeEstablishingWs = () => {
              KC.debug("[choose-best-ws] close establishing websockets"), n2.closeAllWebsockets(), i2.reject(new Vg(xg.WS_ABORT, "choose best websocket aborted"));
            };
            const r2 = kC("GATEWAY_DOMAINS");
            return KC.debug("[choose-best-ws] currentDomain: ", e2, ", domains: ", r2, "total: ".concat(this.urls.length), "current: ".concat(this.currentURLIndex + 1)), n2.chooseBestWebsocket(e2, this.tryDoubleDomain, this.use443PortOnly, t2).then(i2.resolve).catch(i2.reject), i2.promise.finally(() => {
              this.closeEstablishingWs = void 0;
            });
          }
        }
        class XI extends JI {
          constructor(e2, t2) {
            super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
          }
          async chooseBestWebsocketConnection(e2, t2) {
            return new tg((i2, n2) => {
              let r2 = false;
              const s2 = [];
              this.closeEstablishingWs = () => {
                KC.debug("[choose-best-ws] close establishing websockets"), s2.forEach((e3) => {
                  e3.onclose = null, e3.onopen = null, e3.onmessage = null, e3.close();
                }), n2(new Vg(xg.WS_ABORT, "choose best websocket aborted"));
              };
              const o2 = kC("GATEWAY_DOMAINS");
              let a2;
              const c2 = e2.indexOf("?h="), d2 = o2.find((t3) => -1 !== c2 ? Pr(e2).call(e2, t3, c2) : Pr(e2).call(e2, t3));
              KC.debug("[choose-best-ws] currentDomain: ", d2, ", domains: ", o2);
              let l2 = !this.tryDoubleDomain || !d2;
              if (!l2 && d2) {
                var h2;
                const u3 = Date.now();
                try {
                  o2.forEach((t3) => {
                    const i3 = -1 === c2 ? e2.replace(d2, t3) : e2.substr(0, c2) + e2.substr(c2).replace(d2, t3), n3 = new WebSocket(i3);
                    n3.binaryType = "arraybuffer", s2.push(n3), KC.debug("[choose-best-ws] ws is connecting:", n3.url);
                  });
                } catch (e3) {
                  for (KC.debug("[choose-best-ws] ws create failed, fallback to single url"), s2.forEach((e4) => e4.close()); s2.length; )
                    s2.pop();
                  l2 = true;
                }
                null === (h2 = this.store) || void 0 === h2 || h2.recordJoinChannelService({ urls: s2.map((e3) => e3.url), service: "gateway" }, t2), s2.forEach((e3) => {
                  e3.onopen = () => {
                    if (r2)
                      return;
                    const t3 = Date.now() - u3;
                    KC.debug("[choose-best-ws] ws open cost ".concat(t3, "ms")), s2.filter((t4) => t4 !== e3).forEach((e4) => {
                      KC.debug("[choose-best-ws]close backup websocket: ".concat(e4.url)), e4.close();
                    }), r2 = true, i2(e3);
                  }, e3.onclose = (e4) => {
                    if (a2 = e4, r2)
                      return;
                    s2.find((e5) => !(e5.readyState === WebSocket.CLOSED || e5.readyState === WebSocket.CLOSING)) || (KC.debug("[choose-best-ws] all websocket is closed"), r2 = true, n2(a2));
                  }, e3.onmessage = (t3) => {
                    KC.debug("[choose-best-ws]".concat(e3.url, " onmessage: ").concat(t3.data));
                  };
                }), UT(this.forceCloseTimeout).then(() => {
                  s2.forEach((e3) => {
                    e3.readyState !== WebSocket.OPEN && e3.close();
                  });
                });
              }
              if (l2) {
                var u2;
                let r3;
                KC.debug("[choose-best-ws] use single url: ", e2), null === (u2 = this.store) || void 0 === u2 || u2.recordJoinChannelService({ urls: [e2], service: "gateway" }, t2);
                try {
                  r3 = new WebSocket(e2), s2.push(r3), r3.binaryType = "arraybuffer";
                } catch (e3) {
                  const t3 = new Vg(xg.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                  return KC.error("[".concat(this.name, "]").concat(t3)), void n2(t3);
                }
                r3.onopen = () => {
                  i2(r3);
                }, r3.onclose = (e3) => {
                  n2(e3);
                }, r3.onmessage = (e3) => {
                  KC.debug("[choose-best-ws]".concat(r3.url, " onmessage: ").concat(e3.data));
                }, UT(this.forceCloseTimeout).then(() => {
                  r3 && r3.readyState !== WebSocket.OPEN && r3.close();
                });
              }
            }).then((e3) => (this.closeEstablishingWs = void 0, e3)).catch((e3) => {
              throw this.closeEstablishingWs = void 0, e3;
            });
          }
        }
        class QI extends iT {
          get connectionState() {
            return this._connectionState;
          }
          set connectionState(e2) {
            e2 !== this._connectionState && (this._connectionState = e2, e2 === fv.CONNECTED ? this.emit(gv.WS_CONNECTED) : e2 === fv.RECONNECTING ? this.emit(gv.WS_RECONNECTING, this._websocketReconnectReason) : e2 === fv.CLOSED && this.emit(gv.WS_CLOSED, this._disconnectedReason));
          }
          get currentURLIndex() {
            return this.websocket.currentURLIndex;
          }
          get url() {
            return this.websocket && this.websocket.url || null;
          }
          get rtt() {
            return this.rttRolling.mean();
          }
          constructor(e2, t2) {
            super(), nu(this, "_disconnectedReason", void 0), nu(this, "_websocketReconnectReason", void 0), nu(this, "_connectionState", fv.CLOSED), nu(this, "reconnectToken", void 0), nu(this, "websocket", void 0), nu(this, "openConnectionTime", void 0), nu(this, "clientId", void 0), nu(this, "lastMsgTime", Date.now()), nu(this, "uploadCache", []), nu(this, "uploadCacheInterval", void 0), nu(this, "rttRolling", new dS(5)), nu(this, "pingpongTimer", void 0), nu(this, "wsInflateDataTimer", void 0), nu(this, "pingpongTimeoutCount", 0), nu(this, "joinResponse", void 0), nu(this, "multiIpOption", void 0), nu(this, "initError", void 0), nu(this, "spec", void 0), nu(this, "store", void 0), nu(this, "onWebsocketMessage", (e3) => {
              if (e3.data instanceof ArrayBuffer)
                return void this.emit(gv.ON_BINARY_DATA, e3.data);
              const t3 = JSON.parse(e3.data);
              if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
                const e4 = "res-@".concat(t3._id);
                this.emit(e4, t3._result, t3._message);
              } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
                if (this.emit(t3._type, t3._message), t3._type === Rv.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === Rv.ON_USER_BANNED)
                  switch (t3._message.error_code) {
                    case 14:
                      this.close(cT.UID_BANNED);
                      break;
                    case 15:
                      this.close(cT.IP_BANNED);
                      break;
                    case 16:
                      this.close(cT.CHANNEL_BANNED);
                  }
                if (t3._type === Rv.ON_USER_LICENSE_BANNED)
                  switch (t3._message.error_code) {
                    case mv.ERR_LICENSE_MISSING:
                      this.close(cT.LICENSE_MISSING);
                      break;
                    case mv.ERR_LICENSE_EXPIRED:
                      this.close(cT.LICENSE_EXPIRED);
                      break;
                    case mv.ERR_LICENSE_MINUTES_EXCEEDED:
                      this.close(cT.LICENSE_MINUTES_EXCEEDED);
                      break;
                    case mv.ERR_LICENSE_PERIOD_INVALID:
                      this.close(cT.LICENSE_PERIOD_INVALID);
                      break;
                    case mv.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                      this.close(cT.LICENSE_MULTIPLE_SDK_SERVICE);
                      break;
                    case mv.ERR_LICENSE_ILLEGAL:
                      this.close(cT.LICENSE_ILLEGAL);
                      break;
                    default:
                      this.close();
                  }
              }
            }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new zI("gateway-".concat(this.clientId), this.spec.retryConfig, true, kC("JOIN_GATEWAY_USE_DUAL_DOMAIN"), kC("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
              this.connectionState === fv.CONNECTED && this.reconnect("retry", lT.OFFLINE);
            });
          }
          async request(e2, t2, i2, n2) {
            const r2 = xT(6, ""), s2 = { _id: r2, _type: e2, _message: t2 }, o2 = this.websocket.connectionID, a2 = () => new tg((t3, i3) => {
              if (this.connectionState === fv.CONNECTED)
                return t3();
              const n3 = () => {
                this.off(gv.WS_CLOSED, r3), t3();
              }, r3 = () => {
                this.off(gv.WS_CONNECTED, n3), i3(new xv(xg.WS_ABORT));
              };
              this.once(gv.WS_CONNECTED, n3), this.once(gv.WS_CLOSED, r3), e2 !== Tv.PUBLISH && e2 !== Tv.SUBSCRIBE && e2 !== Tv.UNSUBSCRIBE && e2 !== Tv.UNPUBLISH && e2 !== Tv.CONTROL && e2 !== Tv.RESTART_ICE || this.once(gv.DISCONNECT_P2P, () => {
                i3(new xv(xg.DISCONNECT_P2P));
              }), e2 !== Tv.PUBLISH && e2 !== Tv.RESTART_ICE || this.once(gv.ABORT_P2P_EXECUTION, () => {
                i3(new xv(xg.DISCONNECT_P2P));
              });
            });
            if (this.connectionState !== fv.CONNECTING && this.connectionState !== fv.RECONNECTING || e2 === Tv.JOIN || e2 === Tv.REJOIN || await a2(), this.websocket.sendMessage(s2, true), n2)
              return;
            const c2 = new tg((i3, n3) => {
              let s3 = false;
              const a3 = (n4, r3) => {
                s3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(gv.WS_CLOSED, c3), this.off(gv.WS_RECONNECTING, c3), this.emit(gv.REQUEST_SUCCESS, e2, t2);
              };
              this.once("res-@".concat(r2), a3);
              const c3 = () => {
                n3(new xv(xg.WS_ABORT, "type: ".concat(e2))), this.off(gv.WS_CLOSED, c3), this.off(gv.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
              };
              this.once(gv.WS_CLOSED, c3), this.once(gv.WS_RECONNECTING, c3), UT(kC("SIGNAL_REQUEST_TIMEOUT")).then(() => {
                this.websocket.connectionID !== o2 || s3 || (KC.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(gv.REQUEST_TIMEOUT, e2, t2));
              });
            });
            let d2 = null;
            try {
              d2 = await c2;
            } catch (n3) {
              if (this.connectionState === fv.CLOSED || e2 === Tv.LEAVE)
                throw new xv(xg.WS_ABORT);
              return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === Tv.JOIN || e2 === Tv.REJOIN ? null : (await a2(), await this.request(e2, t2));
            }
            if (d2.isSuccess)
              return d2.message;
            const l2 = Number(d2.message.error_code || d2.message.code), h2 = UI(l2), u2 = new xv(xg.UNEXPECTED_RESPONSE, "".concat(h2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message });
            return "success" === h2.action ? d2.message : (KC.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(h2.desc, ", action: ").concat(h2.action)), l2 === mv.ERR_TOO_MANY_BROADCASTERS ? e2 === Tv.JOIN || e2 === Tv.REJOIN ? (this.initError = u2, this.close(), u2.throw()) : u2.throw() : "failed" === h2.action ? u2.throw() : "quit" === h2.action ? (this.initError = u2, this.close(), u2.throw()) : (l2 === mv.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, KC.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", lT.MULTI_IP)) : this.reconnect(h2.action, lT.SERVER_ERROR), e2 === Tv.JOIN || e2 === Tv.REJOIN ? null : await this.request(e2, t2)));
          }
          waitMessage(e2, t2) {
            return new tg((i2) => {
              const n2 = (r2) => {
                (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
              };
              this.on(e2, n2);
            });
          }
          upload(e2, t2) {
            const i2 = { _type: e2, _message: t2 };
            try {
              this.websocket.sendMessage(i2);
            } catch (e3) {
              const t3 = kC("MAX_UPLOAD_CACHE") || 50;
              this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
                if (this.connectionState !== fv.CONNECTED)
                  return;
                const e4 = this.uploadCache.splice(0, 1)[0];
                0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
              }, kC("UPLOAD_CACHE_INTERVAL") || 2e3));
            }
          }
          send(e2, t2) {
            const i2 = { _type: e2, _message: t2 };
            this.websocket.sendMessage(i2);
          }
          init(e2, t2) {
            return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new tg((t3, i2) => {
              this.once(gv.WS_CONNECTED, () => t3(this.joinResponse)), this.once(gv.WS_CLOSED, () => i2(this.initError || new xv(xg.WS_ABORT))), this.connectionState = fv.CONNECTING, this.websocket.init(e2).catch(i2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
                this.handleWsInflateData();
              }, 2e4);
            });
          }
          close(e2) {
            this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || cT.LEAVE, this.connectionState = fv.CLOSED, KC.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e2 === cT.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new zI("gateway-".concat(this.clientId), this.spec.retryConfig, true, kC("JOIN_GATEWAY_USE_DUAL_DOMAIN"), kC("JOIN_GATEWAY_USE_443PORT_ONLY"), this.store), this.handleWebsocketEvents());
          }
          async join() {
            if (!this.joinResponse) {
              this.emit(gv.ABORT_P2P_EXECUTION);
              const e2 = await fT(this, gv.REQUEST_JOIN_INFO), t2 = await this.request(Tv.JOIN, e2);
              if (!t2)
                return this.emit(gv.REPORT_JOIN_GATEWAY, tI.TIMEOUT, this.url || ""), false;
              this.joinResponse = t2, this.emit(gv.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
            }
            return this.connectionState = fv.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
          }
          async rejoin() {
            if (!this.reconnectToken)
              throw new xv(xg.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
            const e2 = ST(this, gv.REQUEST_REJOIN_INFO);
            e2.token = this.reconnectToken;
            const t2 = await this.request(Tv.REJOIN, e2);
            return !!t2 && (this.connectionState = fv.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
              this.emit(Rv.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(Rv.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(Rv.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(Rv.MUTE_AUDIO, { uid: e3.uid }) : this.emit(Rv.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(Rv.MUTE_VIDEO, { uid: e3.uid }) : this.emit(Rv.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(Rv.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(Rv.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(Rv.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(Rv.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(Rv.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
            }), true);
          }
          reconnect(e2, t2) {
            this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
          }
          handleNotification(e2) {
            KC.debug("[".concat(this.clientId, "] receive notification: "), e2);
            const t2 = UI(e2.code);
            if ("success" !== t2.action) {
              if ("failed" !== t2.action)
                return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(cT.UID_BANNED), void this.close()) : void this.reconnect(t2.action, lT.SERVER_ERROR);
              KC.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
            }
          }
          handlePingPong() {
            if (!this.websocket || "connected" !== this.websocket.state)
              return;
            this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
            const e2 = kC("PING_PONG_TIME_OUT"), t2 = Date.now();
            this.pingpongTimeoutCount >= e2 && (KC.warning("[".concat(this.clientId, "] PING-PONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > kC("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", lT.TIMEOUT) : this.request(Tv.PING, void 0, true).then(() => {
              this.pingpongTimeoutCount = 0;
              const e3 = Date.now() - t2;
              this.rttRolling.add(e3), kC("REPORT_STATS") && this.send(Tv.PING_BACK, { pingpongElapse: e3 });
            }).catch((e3) => {
            });
          }
          handleWsInflateData() {
            const { wsInflateLength: e2, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
            0 !== e2 && 0 !== t2 && this.upload(Sv.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
          }
          handleWebsocketEvents() {
            this.websocket.on(Iv.RECONNECT_WAITTING_FINISH, (e2) => {
              this.emit(gv.WS_RECONNECT_WAITTING_FINISH, e2);
            }), this.websocket.on(Iv.RECONNECT_CREATE_CONNECTION, (e2) => {
              this.emit(gv.WS_RECONNECT_CREATE_CONNECTION, e2);
            }), this.websocket.on(Iv.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Iv.CLOSED, () => {
              this.connectionState = fv.CLOSED;
            }), this.websocket.on(Iv.FAILED, () => {
              this._disconnectedReason = cT.NETWORK_ERROR, this.connectionState = fv.CLOSED;
            }), this.websocket.on(Iv.RECONNECTING, (e2) => {
              this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === fv.CONNECTED ? this.connectionState = fv.RECONNECTING : this.connectionState = fv.CONNECTING;
            }), this.websocket.on(Iv.WILL_RECONNECT, (e2, t2, i2) => {
              const n2 = ST(this, gv.IS_P2P_DISCONNECTED), r2 = n2 || "retry" !== e2;
              n2 && "retry" === e2 && (KC.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), e2 = "tryNext", t2 = tI.P2P_DISCONNECTED), r2 && (KC.debug("".concat(this.clientId, " will renewSession, reconnect mode: ").concat(e2)), this.emit(gv.REPORT_JOIN_GATEWAY, t2 || tI.UNKNOWN_REASON, this.url || ""), this.reconnectToken = void 0, this.emit(gv.NEED_RENEW_SESSION), this.emit(gv.DISCONNECT_P2P)), i2(e2);
            }), this.websocket.on(Iv.CONNECTED, () => {
              this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
                KC.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", lT.SERVER_ERROR);
              }) : this.join().catch((e2) => {
                if (this.emit(gv.REPORT_JOIN_GATEWAY, e2.message || e2.code || tI.UNKNOWN_REASON, this.url || ""), e2 instanceof xv && e2.code === xg.UNEXPECTED_RESPONSE && e2.data.code === mv.ERR_NO_AUTHORIZED)
                  return KC.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", lT.SERVER_ERROR);
                KC.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", lT.SERVER_ERROR) : (this.initError = e2, this.close());
              });
            }), this.websocket.on(Iv.REQUEST_NEW_URLS, (e2, t2) => {
              fT(this, gv.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
            }), this.websocket.on(Iv.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
              this.emit(Rv.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
            });
          }
        }
        var ZI = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", $I = et, ey = gr, ty = ZI, iy = _e("".replace), ny = RegExp("^[" + ty + "]+"), ry = RegExp("(^|[^" + ty + "])[" + ty + "]+$"), sy = function(e2) {
          return function(t2) {
            var i2 = ey($I(t2));
            return 1 & e2 && (i2 = iy(i2, ny, "")), 2 & e2 && (i2 = iy(i2, ry, "$1")), i2;
          };
        }, oy = { start: sy(1), end: sy(2), trim: sy(3) }, ay = Jd.PROPER, cy = ce, dy = ZI, ly = oy.trim;
        kn({ target: "String", proto: true, forced: function(e2) {
          return cy(function() {
            return !!dy[e2]() || "\u200B\x85\u180E" !== "\u200B\x85\u180E"[e2]() || ay && dy[e2].name !== e2;
          });
        }("trim") }, { trim: function() {
          return ly(this);
        } });
        var hy, uy, py = er("String").trim, _y = Ee, Ey = py, my = String.prototype, fy = J(function(e2) {
          var t2 = e2.trim;
          return "string" == typeof e2 || e2 === my || _y(my, e2) && t2 === my.trim ? Ey : t2;
        });
        function gy(e2, t2, i2) {
          return { sampleRate: e2, stereo: t2, bitrate: i2 };
        }
        function Ty(e2, t2, i2, n2, r2) {
          return { width: e2, height: t2, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
        }
        function Sy(e2, t2, i2, n2, r2) {
          return { width: { max: e2 }, height: { max: t2 }, frameRate: i2, bitrateMin: n2, bitrateMax: r2 };
        }
        function Ry(e2, t2) {
          return { numSpatialLayers: e2, numTemporalLayers: t2 };
        }
        !function(e2) {
          e2[e2.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e2[e2.CLOUD_PROXY = 18] = "CLOUD_PROXY", e2[e2.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e2[e2.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK";
        }(hy || (hy = {})), function(e2) {
          e2.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e2.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e2.IOS_INTERRUPTION_START = "ios-interruption-start", e2.IOS_INTERRUPTION_END = "ios-interruption-end", e2.STATE_CHANGE = "state-change";
        }(uy || (uy = {}));
        const Cy = { "90p": Ty(160, 90), "90p_1": Ty(160, 90), "120p": Ty(160, 120, 15, 30, 65), "120p_1": Ty(160, 120, 15, 30, 65), "120p_3": Ty(120, 120, 15, 30, 50), "120p_4": Ty(212, 120), "180p": Ty(320, 180, 15, 30, 140), "180p_1": Ty(320, 180, 15, 30, 140), "180p_3": Ty(180, 180, 15, 30, 100), "180p_4": Ty(240, 180, 15, 30, 120), "240p": Ty(320, 240, 15, 40, 200), "240p_1": Ty(320, 240, 15, 40, 200), "240p_3": Ty(240, 240, 15, 40, 140), "240p_4": Ty(424, 240, 15, 40, 220), "360p": Ty(640, 360, 15, 80, 400), "360p_1": Ty(640, 360, 15, 80, 400), "360p_3": Ty(360, 360, 15, 80, 260), "360p_4": Ty(640, 360, 30, 80, 600), "360p_6": Ty(360, 360, 30, 80, 400), "360p_7": Ty(480, 360, 15, 80, 320), "360p_8": Ty(480, 360, 30, 80, 490), "360p_9": Ty(640, 360, 15, 80, 800), "360p_10": Ty(640, 360, 24, 80, 800), "360p_11": Ty(640, 360, 24, 80, 1e3), "480p": Ty(640, 480, 15, 100, 500), "480p_1": Ty(640, 480, 15, 100, 500), "480p_2": Ty(640, 480, 30, 100, 1e3), "480p_3": Ty(480, 480, 15, 100, 400), "480p_4": Ty(640, 480, 30, 100, 750), "480p_6": Ty(480, 480, 30, 100, 600), "480p_8": Ty(848, 480, 15, 100, 610), "480p_9": Ty(848, 480, 30, 100, 930), "480p_10": Ty(640, 480, 10, 100, 400), "720p": Ty(1280, 720, 15, 120, 1130), "720p_auto": Ty(1280, 720, 30, 900, 3e3), "720p_1": Ty(1280, 720, 15, 120, 1130), "720p_2": Ty(1280, 720, 30, 120, 2e3), "720p_3": Ty(1280, 720, 30, 120, 1710), "720p_5": Ty(960, 720, 15, 120, 910), "720p_6": Ty(960, 720, 30, 120, 1380), "1080p": Ty(1920, 1080, 15, 120, 2080), "1080p_1": Ty(1920, 1080, 15, 120, 2080), "1080p_2": Ty(1920, 1080, 30, 120, 3e3), "1080p_3": Ty(1920, 1080, 30, 120, 3150), "1080p_5": Ty(1920, 1080, 60, 120, 4780), "1440p": Ty(2560, 1440, 30, 120, 4850), "1440p_1": Ty(2560, 1440, 30, 120, 4850), "1440p_2": Ty(2560, 1440, 60, 120, 7350), "4k": Ty(3840, 2160, 30, 120, 8910), "4k_1": Ty(3840, 2160, 30, 120, 8910), "4k_3": Ty(3840, 2160, 60, 120, 13500) }, vy = [{ scaleResolutionDownBy: 2, width: 1280, height: 720, frameRate: 30, bitrateMin: 300, bitrateMax: 900 }, { scaleResolutionDownBy: 1.333333, width: 1280, height: 720, frameRate: 30, bitrateMin: 600, bitrateMax: 2e3 }, { scaleResolutionDownBy: 1, width: 1280, height: 720, frameRate: 30, bitrateMin: 900, bitrateMax: 3e3 }], Iy = { "480p": Sy(640, 480, 5), "480p_1": Sy(640, 480, 5), "480p_2": Sy(640, 480, 30), "480p_3": Sy(640, 480, 15), "720p": Sy(1280, 720, 5), "720p_auto": Ty(1280, 720, 30, 900, 3e3), "720p_1": Sy(1280, 720, 5), "720p_2": Sy(1280, 720, 30), "720p_3": Sy(1280, 720, 15), "1080p": Sy(1920, 1080, 5), "1080p_1": Sy(1920, 1080, 5), "1080p_2": Sy(1920, 1080, 30), "1080p_3": Sy(1920, 1080, 15) }, yy = { "1SL1TL": Ry(1, 1), "3SL3TL": Ry(3, 3), "2SL3TL": Ry(2, 3) };
        function Ay(e2) {
          return e2 || (e2 = "480p_1"), "string" == typeof e2 ? Object.assign({}, Cy[e2]) : e2;
        }
        function by(e2) {
          return "string" == typeof e2 ? Object.assign({}, Iy[e2]) : e2;
        }
        function wy(e2) {
          return "string" == typeof e2 ? Object.assign({}, yy[e2]) : e2;
        }
        const Oy = { speech_low_quality: gy(16e3, false), speech_standard: gy(32e3, false, 18), music_standard: gy(48e3, false), standard_stereo: gy(48e3, true, 56), high_quality: gy(48e3, false, 128), high_quality_stereo: gy(48e3, true, 192) };
        function Ny(e2) {
          return "string" == typeof e2 ? Object.assign({}, Oy[e2]) : e2;
        }
        const Dy = [];
        function Py(e2) {
          return Bg(e2, "mediaSource", ["screen", "window", "application"]), true;
        }
        var Ly, ky, My, Uy, xy, Vy, Fy, By, jy, Gy;
        !function(e2) {
          e2.NEED_RENEGOTIATE = "@need_renegotiate", e2.NEED_REPLACE_TRACK = "@need_replace_track", e2.NEED_CLOSE = "@need_close", e2.NEED_ENABLE_TRACK = "@need_enable_track", e2.NEED_DISABLE_TRACK = "@need_disable_track", e2.NEED_SESSION_ID = "@need_sid", e2.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e2.GET_STATS = "@get_stats", e2.GET_RTC_STATS = "@get_rtc_stats", e2.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e2.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e2.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e2.NEED_MUTE_TRACK = "@need_mute_track", e2.NEED_UNMUTE_TRACK = "@need_unmute_track";
        }(Ly || (Ly = {})), function(e2) {
          e2.SCREEN_TRACK = "screen_track", e2.CUSTOM_TRACK = "custome_track", e2.LOW_STREAM = "low_stream";
        }(ky || (ky = {})), function(e2) {
          e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
        }(My || (My = {})), function(e2) {
          e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
        }(Uy || (Uy = {})), function(e2) {
          e2[e2.DISABLE = 0] = "DISABLE", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.AUDIO_ONLY = 2] = "AUDIO_ONLY";
        }(xy || (xy = {})), function(e2) {
          e2.TRANSCEIVER_UPDATED = "transceiver-updated";
        }(Vy || (Vy = {})), function(e2) {
          e2.SOURCE_STATE_CHANGE = "source-state-change", e2.TRACK_ENDED = "track-ended", e2.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.CLOSED = "closed";
        }(Fy || (Fy = {})), function(e2) {
          e2.FIRST_FRAME_DECODED = "first-frame-decoded", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status";
        }(By || (By = {})), function(e2) {
          e2.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e2.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e2.ON_AUDIO_BUFFER = "on_audio_buffer", e2.UPDATE_SOURCE = "update_source";
        }(jy || (jy = {})), function(e2) {
          e2.UPDATE_TRACK_SOURCE = "update-track-source";
        }(Gy || (Gy = {}));
        const Wy = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, currentPacketLossRate: 0 }, Hy = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, Ky = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, Yy = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, qy = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
        var Jy, zy, Xy, Qy, Zy;
        !function(e2) {
          e2.ON_TRACK = "on_track", e2.ON_NODE = "on_node";
        }(Jy || (Jy = {})), function(e2) {
          e2.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e2.REQUEST_CONSTRAINTS = "request_constraints";
        }(zy || (zy = {})), function(e2) {
          e2.IDLE = "IDLE", e2.INITING = "INITING", e2.INITEND = "INITEND";
        }(Xy || (Xy = {})), function(e2) {
          e2.STATE_CHANGE = "state_change", e2.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e2.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e2.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged";
        }(Qy || (Qy = {})), function(e2) {
          e2.NONE = "none", e2.INIT = "init", e2.CANPLAY = "canplay", e2.PLAYING = "playing", e2.PAUSED = "paused", e2.SUSPEND = "suspend", e2.STALLED = "stalled", e2.WAITING = "waiting", e2.ERROR = "error", e2.DESTROYED = "destroyed", e2.ABORT = "abort", e2.ENDED = "ended", e2.EMPTIED = "emptied", e2.LOADEDDATA = "loadeddata";
        }(Zy || (Zy = {}));
        const $y = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
        var eA;
        !function(e2) {
          e2.OPEN = "open", e2.MESSAGE = "message", e2.CLOSE = "close", e2.CLOSING = "closing", e2.ERROR = "error";
        }(eA || (eA = {}));
        class tA extends iT {
          constructor(e2, t2) {
            super(), nu(this, "_ID", void 0), nu(this, "_rtpTransceiver", void 0), nu(this, "_lowRtpTransceiver", void 0), nu(this, "_hints", []), nu(this, "_isClosed", false), nu(this, "_originMediaStreamTrack", void 0), nu(this, "_mediaStreamTrack", void 0), nu(this, "_external", {}), this._ID = t2 || xT(8, "track-"), this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, function(e3) {
              Pr(Dy).call(Dy, e3) || Dy.push(e3);
            }(this);
          }
          toString() {
            return this._ID;
          }
          getTrackId() {
            return this._ID;
          }
          getMediaStreamTrack(e2) {
            if (!e2) {
              const e3 = rv.reportApiInvoke(null, { name: sT.GET_MEDIA_STREAM_TRACK, options: [], tag: oT.TRACER });
              this._mediaStreamTrack && "string" == typeof this._mediaStreamTrack.label ? e3.onSuccess(this._mediaStreamTrack.label) : e3.onSuccess("");
            }
            return this._mediaStreamTrack;
          }
          getRTCRtpTransceiver(e2) {
            return e2 === My.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
          }
          getMediaStreamTrackSettings() {
            return this.getMediaStreamTrack(true).getSettings();
          }
          close() {
            this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function(e2) {
              const t2 = Dy.indexOf(e2);
              -1 !== t2 && Dy.splice(t2, 1);
            }(this), this.emit(Fy.CLOSED);
          }
          _updateRtpTransceiver(e2, t2) {
            if (t2 === My.LOW_STREAM) {
              if (this._lowRtpTransceiver === e2)
                return;
              this._lowRtpTransceiver = e2;
            } else {
              if (this._rtpTransceiver === e2)
                return;
              this._rtpTransceiver = e2;
            }
            this.emit(Vy.TRANSCEIVER_UPDATED, e2, t2);
          }
        }
        class iA extends tA {
          get isExternalTrack() {
            return this._isExternalTrack;
          }
          get muted() {
            return this._muted;
          }
          get enabled() {
            return this._enabled;
          }
          get processorContext() {
            return this._processorContext;
          }
          set processorContext(e2) {
            this._processorContext = e2;
          }
          constructor(e2, t2) {
            super(e2, t2), nu(this, "_enabled", true), nu(this, "_muted", false), nu(this, "_isExternalTrack", false), nu(this, "_isClosed", false), nu(this, "_enabledMutex", void 0), nu(this, "processor", void 0), nu(this, "_handleTrackEnded", () => {
              this.onTrackEnded();
            }), this._enabledMutex = new YT("".concat(this.getTrackId())), e2.addEventListener("ended", this._handleTrackEnded);
          }
          getTrackLabel() {
            var e2, t2;
            return null !== (e2 = null === (t2 = this._originMediaStreamTrack) || void 0 === t2 ? void 0 : t2.label) && void 0 !== e2 ? e2 : "";
          }
          close() {
            this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, KC.debug("[".concat(this.getTrackId(), "] close")), this.emit(Ly.NEED_CLOSE), super.close());
          }
          async _updateOriginMediaStreamTrack(e2, t2) {
            let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            this._isExternalTrack = i2, e2 !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await gT(this, Ly.NEED_REPLACE_TRACK, this), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }));
          }
          _getDefaultPlayerConfig() {
            return {};
          }
          onTrackEnded() {
            KC.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(Fy.TRACK_ENDED);
          }
          stateCheck(e2, t2) {
            if (KC.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e2, ": ").concat(t2, "]")), Fg(t2, e2), this._enabled && this._muted && "enabled" === e2 && false === t2)
              throw new Vg(xg.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print("error", KC);
            if (!this._enabled && !this._muted && "muted" === e2 && true === t2)
              throw new Vg(xg.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print("error", KC);
          }
          getProcessorStats() {
            return this.processorContext.gatherStats();
          }
          getProcessorUsage() {
            return this.processorContext.gatherUsage();
          }
        }
        function nA(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        const rA = window.AudioContext || window.webkitAudioContext;
        let sA = null;
        const oA = new class extends iT {
          constructor() {
            super(...arguments), nu(this, "prevState", void 0), nu(this, "curState", void 0), nu(this, "currentTime", void 0), nu(this, "currentTimeStuckAt", void 0), nu(this, "interruptDetectorTrack", void 0), nu(this, "onLocalAudioTrackMute", () => {
              KC.info("ios15-interruption-start"), this.emit(uy.IOS_15_16_INTERRUPTION_START);
            }), nu(this, "onLocalAudioTrackUnmute", async () => {
              KC.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? KC.info("ios15-interruption-end-canceled") : (sA && await sA.suspend(), this.emit(uy.IOS_15_16_INTERRUPTION_END));
            });
          }
          get duringInterruption() {
            return "running" === this.prevState && "interrupted" === this.curState;
          }
          bindInterruptDetectorTrack(e2) {
            KC.debug("webaudio bindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e2, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
          }
          unbindInterruptDetectorTrack(e2) {
            KC.debug("webaudio unbindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e2 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
          }
        }();
        function aA() {
          if (!rA)
            return void KC.error("your browser is not support web audio");
          KC.info("create audio context");
          const e2 = function(e3) {
            for (var t2 = 1; t2 < arguments.length; t2++) {
              var i2 = null != arguments[t2] ? arguments[t2] : {};
              t2 % 2 ? nA(Object(i2), true).forEach(function(t3) {
                nu(e3, t3, i2[t3]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i2)) : nA(Object(i2)).forEach(function(t3) {
                Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(i2, t3));
              });
            }
            return e3;
          }({}, kC("WEBAUDIO_INIT_OPTIONS"));
          KC.debug("audio context init option:", JSON.stringify(e2)), sA = new rA(e2), oA.curState = sA.state, sA.onstatechange = () => {
            oA.prevState = oA.curState, oA.curState = sA ? sA.state : void 0;
            const { prevState: e3, curState: t2 } = oA, i2 = "running" === t2, n2 = "interrupted" === t2, r2 = "running" === e3, s2 = "suspended" === e3, o2 = "interrupted" === e3, a2 = pg().osVersion;
            (Cg() || Dg()) && r2 && n2 && (KC.info("ios".concat(a2, "-interruption-start")), oA.emit(uy.IOS_INTERRUPTION_START)), (Cg() || Dg()) && (s2 || o2) && i2 && (KC.info("ios".concat(a2, "-interruption-end")), oA.emit(uy.IOS_INTERRUPTION_END)), e3 !== t2 && (KC.debug("AudioContext State Change", "".concat(e3, "=>").concat(t2)), oA.emit(uy.STATE_CHANGE));
          }, setInterval(() => {
            var e3;
            const t2 = null === (e3 = sA) || void 0 === e3 ? void 0 : e3.currentTime;
            if (oA.currentTime !== t2)
              oA.currentTimeStuckAt && (KC.debug("AudioContext current time resume at ".concat(t2)), oA.currentTimeStuckAt = void 0), oA.currentTime = t2;
            else {
              if (t2 !== oA.currentTimeStuckAt) {
                rv.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t2 }, tag: oT.TRACER }).onSuccess(), KC.warning("AudioContext current time stuck at ".concat(t2));
              }
              oA.currentTimeStuckAt = t2;
            }
          }, 5e3), async function(e3) {
            const t2 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
            let i2, n2 = false, r2 = false, s2 = false;
            function o2(t3) {
              "running" === e3.state ? a2(false) : Cg() || Dg() ? "suspended" === e3.state && (a2(true), t3 && e3.resume().then(d2, d2)) : "closed" !== e3.state && (a2(true), t3 && e3.resume().then(d2, d2));
            }
            function a2(e4) {
              if (n2 !== e4) {
                n2 = e4;
                for (let i3 = 0, n3 = t2; i3 < n3.length; i3 += 1) {
                  const t3 = n3[i3];
                  e4 ? window.addEventListener(t3, l2, { capture: true, passive: true }) : window.removeEventListener(t3, l2, { capture: true, passive: true });
                }
              }
            }
            function c2() {
              o2(true);
            }
            function d2() {
              o2(false);
            }
            function l2() {
              o2(true);
            }
            function h2(e4) {
              if (!s2)
                if (i2.paused)
                  if (e4) {
                    let e5;
                    u2(false), s2 = true;
                    try {
                      e5 = i2.play(), e5 ? e5.then(p2, p2) : (i2.addEventListener("playing", p2), i2.addEventListener("abort", p2), i2.addEventListener("error", p2));
                    } catch (e6) {
                      p2();
                    }
                  } else
                    u2(true);
                else
                  u2(false);
            }
            function u2(e4) {
              if (r2 !== e4) {
                r2 = e4;
                for (let i3 = 0, n3 = t2; i3 < n3.length; i3++) {
                  const t3 = n3[i3];
                  e4 ? window.addEventListener(t3, _2, { capture: true, passive: true }) : window.removeEventListener(t3, _2, { capture: true, passive: true });
                }
              }
            }
            function p2() {
              i2.removeEventListener("playing", p2), i2.removeEventListener("abort", p2), i2.removeEventListener("error", p2), s2 = false, h2(false);
            }
            function _2() {
              h2(true);
            }
            if (Cg()) {
              const t3 = e3.createMediaStreamDestination(), n3 = document.createElement("div");
              n3.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i2 = n3.children.item(0), i2.controls = false, i2.disableRemotePlayback = true, i2.preload = "auto", i2.srcObject = t3.stream, h2(true);
            }
            oA.on(uy.STATE_CHANGE, c2), o2(false);
          }(sA);
        }
        function cA() {
          if (!sA) {
            if (aA(), !sA)
              throw new Vg(xg.NOT_SUPPORTED, "can not create audio context");
            return sA;
          }
          return sA;
        }
        function dA() {
          return !!sA;
        }
        function lA(e2) {
          if (function() {
            if (null !== hA)
              return hA;
            const e3 = cA(), t3 = e3.createBufferSource(), i3 = e3.createGain(), n2 = e3.createGain();
            t3.connect(i3), t3.connect(n2), t3.disconnect(i3);
            let r2 = false;
            try {
              t3.disconnect(i3);
            } catch (e4) {
              r2 = true;
            }
            return t3.disconnect(), hA = r2, r2;
          }())
            return;
          const t2 = e2.connect, i2 = e2.disconnect;
          e2.connect = (i3, n2, r2) => {
            var s2;
            return e2._inputNodes || (e2._inputNodes = []), Pr(s2 = e2._inputNodes).call(s2, i3) || (i3 instanceof AudioNode ? (e2._inputNodes.push(i3), t2.call(e2, i3, n2, r2)) : t2.call(e2, i3, n2)), e2;
          }, e2.disconnect = (n2, r2, s2) => {
            i2.call(e2), n2 ? IT(e2._inputNodes, n2) : e2._inputNodes = [];
            for (const i3 of e2._inputNodes)
              t2.call(e2, i3);
          };
        }
        let hA = null;
        function uA(e2, t2) {
          let i2 = false;
          const n2 = 1 / t2;
          if (kC("DISABLE_WEBAUDIO")) {
            const t3 = window.setInterval(() => {
              i2 ? window.clearInterval(t3) : e2(performance.now() / 1e3);
            }, 1e3 * n2);
          } else {
            const t3 = cA();
            let r2 = t3.createGain();
            r2.gain.value = 0, r2.connect(t3.destination);
            const s2 = () => {
              if (i2)
                return void (r2 = null);
              const o2 = t3.createOscillator();
              o2.onended = s2, o2.connect(r2), o2.start(0), o2.stop(t3.currentTime + n2), e2(t3.currentTime);
            };
            s2();
          }
          return () => {
            i2 = true;
          };
        }
        const pA = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false, supportWebRTCInsertableStream: false };
        function _A() {
          return pA;
        }
        class EA {
          constructor() {
            nu(this, "context", void 0), nu(this, "analyserNode", void 0), nu(this, "sourceNode", void 0), this.context = cA(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
          }
          updateSource(e2) {
            if (e2 !== this.sourceNode) {
              if (this.sourceNode)
                try {
                  this.sourceNode.disconnect(this.analyserNode);
                } catch (e3) {
                }
              this.sourceNode = e2, null == e2 || e2.connect(this.analyserNode);
            }
          }
          getVolumeLevel() {
            if (!this.sourceNode)
              return 0;
            if (!this.context || Cg() || Dg() || "running" !== this.context.state && this.context.resume(), !this.analyserNode)
              return 0;
            const e2 = new Float32Array(this.analyserNode.fftSize);
            if (this.analyserNode.getFloatTimeDomainData)
              this.analyserNode.getFloatTimeDomainData(e2);
            else {
              const t3 = new Uint8Array(this.analyserNode.fftSize);
              this.analyserNode.getByteTimeDomainData(t3);
              for (let i2 = 0; i2 < e2.length; ++i2)
                e2[i2] = t3[i2] / 128 - 1;
            }
            const t2 = cS(e2).call(e2, (e3, t3) => e3 + t3 * t3, 0) / e2.length;
            return Math.max(10 * Math.log10(t2) + 100, 0) / 100;
          }
          getAnalyserNode() {
            return this.analyserNode;
          }
          rebuildAnalyser() {
            try {
              var e2, t2;
              null === (e2 = this.sourceNode) || void 0 === e2 || e2.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t2 = this.sourceNode) || void 0 === t2 || t2.connect(this.analyserNode);
            } catch (e3) {
              KC.warning("rebuild analyser node failed.");
            }
          }
          destroy() {
            this.updateSource(void 0);
          }
        }
        class mA extends iT {
          get processSourceNode() {
            return this.sourceNode;
          }
          set processedNode(e2) {
            var t2;
            if (!this.isDestroyed && this._processedNode !== e2) {
              try {
                var i2;
                null === (i2 = this.sourceNode) || void 0 === i2 || i2.disconnect(this.outputNode);
              } catch (e3) {
              }
              null === (t2 = this._processedNode) || void 0 === t2 || t2.disconnect(), this._processedNode = e2, this.connect();
            }
          }
          get processedNode() {
            return this._processedNode;
          }
          constructor() {
            super(), nu(this, "outputNode", void 0), nu(this, "outputTrack", void 0), nu(this, "isPlayed", false), nu(this, "context", void 0), nu(this, "audioBufferNode", void 0), nu(this, "destNode", void 0), nu(this, "audioOutputLevel", 0), nu(this, "volumeLevelAnalyser", void 0), nu(this, "_processedNode", void 0), nu(this, "playNode", void 0), nu(this, "isDestroyed", false), nu(this, "onNoAudioInput", void 0), nu(this, "isNoAudioInput", false), nu(this, "_noAudioInputCount", 0), this.context = cA(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), lA(this.outputNode), this.volumeLevelAnalyser = new EA();
          }
          startGetAudioBuffer(e2) {
            this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e2), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e3) => {
              this.emit(jy.ON_AUDIO_BUFFER, function(e4) {
                for (let t2 = 0; t2 < e4.outputBuffer.numberOfChannels; t2 += 1) {
                  const i2 = e4.outputBuffer.getChannelData(t2);
                  for (let e5 = 0; e5 < i2.length; e5 += 1)
                    i2[e5] = 0;
                }
                return e4.inputBuffer;
              }(e3));
            });
          }
          stopGetAudioBuffer() {
            this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
          }
          createOutputTrack() {
            if (!_A().webAudioMediaStreamDest)
              throw new Vg(xg.NOT_SUPPORTED, "your browser is not support audio processor");
            return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
          }
          play(e2) {
            "running" !== this.context.state && AT(() => {
              oA.emit("autoplay-failed");
            }), this.isPlayed = true, this.playNode = e2 || this.context.destination, this.outputNode.connect(this.playNode);
          }
          stop() {
            if (this.isPlayed)
              try {
                this.outputNode.disconnect(this.playNode);
              } catch (e2) {
              }
            this.isPlayed = false;
          }
          getAccurateVolumeLevel() {
            return this.volumeLevelAnalyser.getVolumeLevel();
          }
          async checkHasAudioInput() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            if (e2 > 5)
              return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
            Cg() || Dg() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
            const t2 = this.volumeLevelAnalyser.getAnalyserNode();
            let i2;
            t2.getFloatTimeDomainData ? (i2 = new Float32Array(t2.fftSize), t2.getFloatTimeDomainData(i2)) : (i2 = new Uint8Array(t2.fftSize), t2.getByteTimeDomainData(i2));
            let n2 = false;
            for (let e3 = 0; e3 < i2.length; e3++)
              0 !== i2[e3] && (n2 = true);
            return n2 ? (this.isNoAudioInput = false, true) : (await UT(200), await this.checkHasAudioInput(e2 ? e2 + 1 : 1) && n2);
          }
          getAudioVolume() {
            return this.outputNode.gain.value;
          }
          setVolume(e2) {
            this.outputNode.gain.setValueAtTime(e2, this.context.currentTime);
          }
          destroy() {
            this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
          }
          disconnect() {
            var e2, t2;
            null === (e2 = this.processedNode) || void 0 === e2 || e2.disconnect(), null === (t2 = this.sourceNode) || void 0 === t2 || t2.disconnect(), this.outputNode && this.outputNode.disconnect();
          }
          connect() {
            var e2;
            this.processedNode ? null === (e2 = this.processedNode) || void 0 === e2 || e2.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode);
            this.volumeLevelAnalyser.updateSource(this.outputNode);
          }
        }
        class fA extends mA {
          get isFreeze() {
            return false;
          }
          constructor(e2, t2, i2) {
            var n2;
            if (super(), nu(this, "sourceNode", void 0), nu(this, "track", void 0), nu(this, "clonedTrack", void 0), nu(this, "audioElement", void 0), nu(this, "isCurrentTrackCloned", false), nu(this, "isRemoteTrack", false), nu(this, "originVolumeLevelAnalyser", void 0), nu(this, "rebuildWebAudio", async () => {
              if (KC.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed)
                return document.body.removeEventListener("click", this.rebuildWebAudio, true), void KC.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
              this.context.resume().then(() => KC.info("resume success")), KC.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
              const e3 = this.track;
              this.track = this.track.clone(), this.isCurrentTrackCloned ? e3.stop() : this.isCurrentTrackCloned = true;
              const t3 = new MediaStream([this.track]);
              this.sourceNode = this.context.createMediaStreamSource(t3), lA(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
              const i3 = this.outputNode.gain.value;
              this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i3, this.context.currentTime), lA(this.outputNode), this.emit(jy.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t3, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
            }), "audio" !== e2.kind)
              throw new Vg(xg.UNEXPECTED_ERROR);
            this.track = e2;
            const r2 = new MediaStream([this.track]);
            if (this.isRemoteTrack = !!t2, this.sourceNode = this.context.createMediaStreamSource(r2), lA(this.sourceNode), i2) {
              const e3 = i2.clone();
              e3.enabled = true, this.clonedTrack = e3, KC.debug("create an unmuted track ".concat(e3.id, " from the original track ").concat(i2.id, " to get the volume"));
              const t3 = this.context.createMediaStreamSource(new MediaStream([e3]));
              lA(t3), this.originVolumeLevelAnalyser = new EA(), this.originVolumeLevelAnalyser.updateSource(t3);
            }
            this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r2;
            const s2 = pg();
            t2 && s2.os === ag.IOS && Number(null === (n2 = s2.osVersion) || void 0 === n2 ? void 0 : n2.split(".")[0]) < 15 && (oA.on(uy.STATE_CHANGE, () => {
              "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
            }), this.checkHasAudioInput().then((e3) => {
              e3 || document.body.addEventListener("click", this.rebuildWebAudio, true);
            }));
          }
          updateTrack(e2) {
            this.sourceNode.disconnect(), this.track = e2, this.isCurrentTrackCloned = false;
            const t2 = new MediaStream([e2]);
            this.sourceNode = this.context.createMediaStreamSource(t2), lA(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(jy.UPDATE_SOURCE), this.audioElement.srcObject = t2;
          }
          destroy() {
            var e2;
            this.audioElement.srcObject = null, this.audioElement.remove(), oA.off("state-change", this.rebuildWebAudio), null === (e2 = this.originVolumeLevelAnalyser) || void 0 === e2 || e2.destroy(), this.clonedTrack = void 0, super.destroy();
          }
          createMediaStreamSourceNode(e2) {
            return this.context.createMediaStreamSource(new MediaStream([e2]));
          }
          updateOriginTrack(e2) {
            const t2 = e2.clone();
            t2.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t2), KC.debug("create an unmuted track ".concat(t2.id, " from the original track ").concat(e2.id, " to get the volume"));
            const i2 = this.context.createMediaStreamSource(new MediaStream([t2]));
            lA(i2), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i2);
          }
          getOriginVolumeLevel() {
            return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
          }
        }
        async function gA(e2, t2, i2) {
          const n2 = (e3, t3) => e3 ? "number" != typeof e3 ? e3.max || e3.exact || e3.ideal || e3.min || t3 : e3 : t3, r2 = { audio: !!i2 && { mandatory: { chromeMediaSource: "desktop" } }, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e2, maxHeight: n2(t2.height, 1080), maxWidth: n2(t2.width, 1920) } } };
          return t2.frameRate && "number" != typeof t2.frameRate ? (r2.video.mandatory.maxFrameRate = t2.frameRate.max, r2.video.mandatory.minFrameRate = t2.frameRate.min) : "number" == typeof t2.frameRate && (r2.video.mandatory.maxFrameRate = t2.frameRate), await navigator.mediaDevices.getUserMedia(r2);
        }
        async function TA(e2, t2) {
          const i2 = await SA(e2.mediaSource), { sourceId: n2, audio: r2 } = await function(e3) {
            let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return new tg((i3, n3) => {
              const r3 = document.createElement("div");
              r3.innerText = "share screen", r3.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
              const s2 = document.createElement("div");
              s2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
              const o2 = document.createElement("div");
              o2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o2.setAttribute("style", "height: 12%;");
              const a2 = document.createElement("div");
              a2.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
              const c2 = document.createElement("div");
              c2.setAttribute("style", "display: flex; justify-content: space-between; padding: 16px 0;");
              const d2 = document.createElement("button");
              d2.innerHTML = "cancel", d2.setAttribute("style", "width: 85px;"), d2.onclick = () => {
                document.body.removeChild(u2);
                const e4 = new Error("NotAllowedError");
                e4.name = "NotAllowedError", n3(e4);
              };
              let l2 = t3;
              const h2 = document.createElement("div");
              if (t3) {
                const e4 = document.createElement("input");
                e4.setAttribute("type", "checkbox");
                const t4 = document.createElement("span");
                e4.setAttribute("style", "margin-right: 6px;"), t4.innerText = "Share audio", e4.checked = l2, e4.onchange = () => {
                  l2 = e4.checked;
                }, h2.appendChild(e4), h2.appendChild(t4);
              }
              c2.appendChild(h2), c2.appendChild(d2), s2.appendChild(o2), s2.appendChild(a2), s2.appendChild(c2);
              const u2 = document.createElement("div");
              u2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), u2.appendChild(r3), u2.appendChild(s2), document.body.appendChild(u2), e3.map((e4) => {
                if (e4.id) {
                  const t4 = document.createElement("div");
                  t4.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                  let n4 = e4.thumbnail;
                  try {
                    const { width: e5 } = n4.getSize();
                    e5 > 1920 && (n4 = n4.resize({ width: 1920 }));
                  } catch (e5) {
                    throw e5 && e5.message.startsWith("Illegal invocation") && console.error("Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"), e5;
                  }
                  t4.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n4.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e4.name.replace(/[\u00A0-\u9999<>\&]/g, function(e5) {
                    return "&#" + e5.charCodeAt(0) + ";";
                  }) + "</span>", t4.onclick = () => {
                    document.body.removeChild(u2), i3({ sourceId: e4.id, audio: l2 });
                  }, a2.appendChild(t4);
                }
              });
            });
          }(i2, t2);
          return await gA(n2, e2, r2);
        }
        async function SA(e2) {
          let t2 = ["window", "screen"];
          "application" !== e2 && "window" !== e2 || (t2 = ["window"]), "screen" === e2 && (t2 = ["screen"]);
          const i2 = rT();
          if (!i2)
            throw console.error("failed to fetch electron, please mount it to window"), new Vg(xg.ELECTRON_IS_NULL);
          let n2 = null;
          try {
            var r2;
            n2 = (null === (r2 = i2.desktopCapturer) || void 0 === r2 ? void 0 : r2.getSources({ types: t2 })) || i2.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t2 });
          } catch (e3) {
            n2 = null;
          }
          n2 && n2.then || (n2 = new tg((e3, n3) => {
            i2.desktopCapturer.getSources({ types: t2 }, (t3, i3) => {
              t3 ? n3(t3) : e3(i3);
            });
          }));
          try {
            return await n2;
          } catch (e3) {
            throw new Vg(xg.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e3.toString());
          }
        }
        function RA(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        const CA = new YT("safari");
        let vA = false, IA = false;
        async function yA(e2, t2) {
          let i2 = 0, n2 = null;
          for (; i2 < 2; )
            try {
              n2 = await AA(e2, t2, i2 > 0);
              break;
            } catch (e3) {
              if (e3 instanceof Vg)
                throw KC.error("[".concat(t2, "] ").concat(e3.toString())), e3;
              const n3 = bA(e3.name || e3.code || e3, e3.message);
              if (n3.code === xg.MEDIA_OPTION_INVALID) {
                KC.debug("[".concat(t2, "] detect media option invalid, retry")), i2 += 1, await UT(500);
                continue;
              }
              throw KC.error("[".concat(t2, "] ").concat(n3.toString())), n3;
            }
          if (!n2)
            throw new Vg(xg.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
          return n2;
        }
        async function AA(e2, t2, i2) {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
            throw new Vg(xg.NOT_SUPPORTED, "can not find getUserMedia");
          i2 && (e2.video && (delete e2.video.width, delete e2.video.height), e2.screen && (delete e2.screen.width, delete e2.screen.height));
          const n2 = _A(), r2 = new MediaStream();
          if (e2.audioSource && r2.addTrack(e2.audioSource), e2.videoSource && r2.addTrack(e2.videoSource), !e2.audio && !e2.video && !e2.screen)
            return KC.debug("Using Video Source/ Audio Source"), r2;
          if (e2.screen)
            if (rT())
              if (e2.screen.sourceId) {
                wA(r2, await gA(e2.screen.sourceId, e2.screen, e2.screenAudio));
              } else {
                wA(r2, await TA(e2.screen, e2.screenAudio));
              }
            else if (Tg() && e2.screen.extensionId && e2.screen.mandatory) {
              if (!n2.getStreamFromExtension)
                throw new Vg(xg.NOT_SUPPORTED, "This browser does not support screen sharing");
              KC.debug("[".concat(t2, '] Screen access on chrome stable, looking for extension"'));
              const i3 = await (o2 = e2.screen.extensionId, a2 = t2, new tg((e3, t3) => {
                try {
                  chrome.runtime.sendMessage(o2, { getStream: true }, (i4) => {
                    if (!i4 || !i4.streamId)
                      return KC.error("[".concat(a2, "] No response from Chrome Plugin. Plugin not installed properly"), i4), void t3(new Vg(xg.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                    e3(i4.streamId);
                  });
                } catch (e4) {
                  KC.error("[".concat(a2, "] AgoraRTC screensharing plugin is not accessible(").concat(o2, ")"), e4.toString()), t3(new Vg(xg.CHROME_PLUGIN_NOT_INSTALL));
                }
              }));
              e2.screen.mandatory.chromeMediaSourceId = i3;
              wA(r2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e2.screen.mandatory } }));
            } else if (n2.getDisplayMedia) {
              var s2;
              e2.screen.mediaSource && Py(e2.screen.mediaSource);
              const i3 = { width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate, displaySurface: null !== (s2 = e2.screen.displaySurface) && void 0 !== s2 ? s2 : "screen" === e2.screen.mediaSource ? "monitor" : e2.screen.mediaSource }, { selfBrowserSurface: n3, surfaceSwitching: o3, systemAudio: a3 } = e2.screen, c3 = { selfBrowserSurface: n3, surfaceSwitching: o3, systemAudio: a3 };
              !n3 && delete c3.selfBrowserSurface, !o3 && delete c3.surfaceSwitching, !a3 && delete c3.systemAudio, KC.debug("[".concat(t2, "] getDisplayMedia:"), JSON.stringify({ video: i3, audio: !!e2.screenAudio, controls: c3 }));
              const d3 = await navigator.mediaDevices.getDisplayMedia(function(e3) {
                for (var t3 = 1; t3 < arguments.length; t3++) {
                  var i4 = null != arguments[t3] ? arguments[t3] : {};
                  t3 % 2 ? RA(Object(i4), true).forEach(function(t4) {
                    nu(e3, t4, i4[t4]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i4)) : RA(Object(i4)).forEach(function(t4) {
                    Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i4, t4));
                  });
                }
                return e3;
              }({ video: i3, audio: !!e2.screenAudio }, c3));
              wA(r2, d3);
            } else {
              if (!Rg())
                throw KC.error("[".concat(t2, "] This browser does not support screenSharing")), new Vg(xg.NOT_SUPPORTED, "This browser does not support screen sharing");
              {
                e2.screen.mediaSource && Py(e2.screen.mediaSource);
                const i3 = { video: { mediaSource: e2.screen.mediaSource, width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate } };
                KC.debug("[".concat(t2, "] getUserMedia: ").concat(JSON.stringify(i3)));
                wA(r2, await navigator.mediaDevices.getUserMedia(i3));
              }
            }
          var o2, a2;
          if (!e2.video && !e2.audio)
            return r2;
          let c2 = { video: e2.video, audio: e2.audio }, d2 = kC("MEDIA_DEVICE_CONSTRAINTS");
          if (d2)
            try {
              "string" == typeof d2 && (d2 = JSON.parse(d2)), c2 = WT(c2, d2);
            } catch (e3) {
            }
          KC.debug("[".concat(t2, "] GetUserMedia"), JSON.stringify(c2)), pg();
          let l2, h2 = null;
          (Sg() || Cg() || mg()) && (h2 = await CA.lock());
          try {
            l2 = await navigator.mediaDevices.getUserMedia(c2);
          } catch (e3) {
            throw h2 && h2(), e3;
          }
          return c2.audio && (vA = true), c2.video && (IA = true), wA(r2, l2), h2 && h2(), r2;
        }
        function bA(e2, t2) {
          switch (e2) {
            case "Starting video failed":
            case "OverconstrainedError":
            case "TrackStartError":
              return new Vg(xg.MEDIA_OPTION_INVALID, "".concat(e2, ": ").concat(t2));
            case "NotFoundError":
            case "DevicesNotFoundError":
              return new Vg(xg.DEVICE_NOT_FOUND, "".concat(e2, ": ").concat(t2));
            case "NotSupportedError":
              return new Vg(xg.NOT_SUPPORTED, "".concat(e2, ": ").concat(t2));
            case "NotReadableError":
              return new Vg(xg.NOT_READABLE, "".concat(e2, ": ").concat(t2));
            case "InvalidStateError":
            case "NotAllowedError":
            case "PERMISSION_DENIED":
            case "PermissionDeniedError":
              return new Vg(xg.PERMISSION_DENIED, "".concat(e2, ": ").concat(t2));
            case "ConstraintNotSatisfiedError":
              return new Vg(xg.CONSTRAINT_NOT_SATISFIED, "".concat(e2, ": ").concat(t2));
            default:
              return KC.error("getUserMedia unexpected error", e2), new Vg(xg.UNEXPECTED_ERROR, "".concat(e2, ": ").concat(t2));
          }
        }
        function wA(e2, t2) {
          const i2 = e2.getVideoTracks()[0], n2 = e2.getAudioTracks()[0], r2 = t2.getVideoTracks()[0], s2 = t2.getAudioTracks()[0];
          s2 && (n2 && e2.removeTrack(n2), e2.addTrack(s2)), r2 && (i2 && e2.removeTrack(i2), e2.addTrack(r2));
        }
        const OA = new class extends iT {
          get state() {
            return this._state;
          }
          set state(e2) {
            e2 !== this._state && (this.emit(Qy.STATE_CHANGE, e2), this._state = e2);
          }
          constructor() {
            super(), nu(this, "_state", Xy.IDLE), nu(this, "isAccessMicrophonePermission", false), nu(this, "isAccessCameraPermission", false), nu(this, "lastAccessMicrophonePermission", false), nu(this, "lastAccessCameraPermission", false), nu(this, "checkdeviceMatched", false), nu(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
              navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
                (kC("ENUMERATE_DEVICES_INTERVAL") || (Mg() || _g() === ag.HARMONY_OS) && kg()) && this.updateDevicesInfo();
              }, kC("ENUMERATE_DEVICES_INTERVAL_TIME"));
            }).catch((e2) => KC.error(e2.toString()));
          }
          async enumerateDevices(e2, t2) {
            let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
              return new Vg(xg.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
            }
            const n2 = await navigator.mediaDevices.enumerateDevices(), r2 = this.checkMediaDeviceInfoIsOk(n2);
            let s2 = !this.isAccessMicrophonePermission && e2, o2 = !this.isAccessCameraPermission && t2;
            r2.audio && (s2 = false), r2.video && (o2 = false);
            let a2 = null, c2 = null, d2 = null;
            if (!i2 && (s2 || o2)) {
              if (CA.isLocked) {
                KC.debug("[device manager] wait GUM lock");
                (await CA.lock())(), KC.debug("[device manager] GUM unlock");
              }
              if (vA && (s2 = false, this.isAccessMicrophonePermission = true), IA && (o2 = false, this.isAccessCameraPermission = true), KC.debug("[device manager] check media device permissions", e2, t2, s2, o2), s2 && o2) {
                try {
                  d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                } catch (e3) {
                  const t3 = bA(e3.name || e3.code || e3, e3.message);
                  if (t3.code === xg.PERMISSION_DENIED)
                    throw t3;
                  KC.warning("getUserMedia failed in getDevices", t3);
                }
                this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
              } else if (s2) {
                try {
                  a2 = await navigator.mediaDevices.getUserMedia({ audio: e2 });
                } catch (e3) {
                  const t3 = bA(e3.name || e3.code || e3, e3.message);
                  if (t3.code === xg.PERMISSION_DENIED)
                    throw t3;
                  KC.warning("getUserMedia failed in getDevices", t3);
                }
                this.isAccessMicrophonePermission = true;
              } else if (o2) {
                try {
                  c2 = await navigator.mediaDevices.getUserMedia({ video: t2 });
                } catch (e3) {
                  const t3 = bA(e3.name || e3.code || e3, e3.message);
                  if (t3.code === xg.PERMISSION_DENIED)
                    throw t3;
                  KC.warning("getUserMedia failed in getDevices", t3);
                }
                this.isAccessCameraPermission = true;
              }
              KC.debug("[device manager] mic permission", e2, "cam permission", t2);
            }
            try {
              const e3 = await navigator.mediaDevices.enumerateDevices();
              return a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null, e3;
            } catch (e3) {
              a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null;
              return new Vg(xg.ENUMERATE_DEVICES_FAILED, e3.toString()).throw();
            }
          }
          async getRecordingDevices() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audioinput" === e3.kind);
          }
          async getCamerasDevices() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return (await this.enumerateDevices(false, true, e2)).filter((e3) => "videoinput" === e3.kind);
          }
          async getSpeakers() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audiooutput" === e3.kind);
          }
          searchDeviceIdByName(e2) {
            let t2 = null;
            return this.deviceInfoMap.forEach((i2) => {
              i2.device.label === e2 && (t2 = i2.device.deviceId);
            }), t2;
          }
          async getDeviceById(e2) {
            const t2 = (await this.enumerateDevices(true, true, true)).find((t3) => t3.deviceId === e2);
            if (!t2)
              throw new Vg(xg.DEVICE_NOT_FOUND, "deviceId: ".concat(e2));
            return t2;
          }
          async init() {
            this.state = Xy.INITING;
            try {
              await this.updateDevicesInfo(), this.state = Xy.INITEND;
            } catch (e2) {
              if (KC.warning("Device Detection functionality cannot start properly.", e2.toString()), this.state = Xy.IDLE, !("boolean" == typeof isSecureContext ? isSecureContext : "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname)) {
                new Vg(xg.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw();
              }
              throw e2;
            }
          }
          async updateDevicesInfo() {
            const e2 = await this.enumerateDevices(true, true, true), t2 = Date.now(), i2 = [];
            if (e2[0] && e2[0].label && false === this.checkdeviceMatched) {
              this.checkdeviceMatched = true;
              const t3 = e2.find((e3) => "audioinput" === e3.kind && "default" === e3.deviceId), i3 = e2.find((e3) => "audiooutput" === e3.kind && "default" === e3.deviceId);
              t3 && i3 ? i3.groupId === t3.groupId ? KC.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is the same group")) : KC.warning("[device-check] default input ".concat(t3.label, " and output ").concat(i3.label, " is not the same group")) : KC.debug("[device-check] default input or output not found");
            }
            const n2 = this.checkMediaDeviceInfoIsOk(e2);
            if (e2.forEach((e3) => {
              if (!e3.deviceId)
                return;
              const n3 = this.deviceInfoMap.get("".concat(e3.kind, "_").concat(e3.deviceId));
              if ("ACTIVE" !== (n3 ? n3.state : "INACTIVE")) {
                const n4 = { initAt: t2, updateAt: t2, device: e3, state: "ACTIVE" };
                this.deviceInfoMap.set("".concat(e3.kind, "_").concat(e3.deviceId), n4), i2.push(n4);
              }
              n3 && (n3.updateAt = t2);
            }), this.deviceInfoMap.forEach((e3, n3) => {
              "ACTIVE" === e3.state && e3.updateAt !== t2 && (e3.state = "INACTIVE", i2.push(e3));
            }), this.state !== Xy.INITEND)
              return n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
            i2.forEach((e3) => {
              switch (e3.device.kind) {
                case "audioinput":
                  this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(Qy.RECORDING_DEVICE_CHANGED, e3);
                  break;
                case "videoinput":
                  this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(Qy.CAMERA_DEVICE_CHANGED, e3);
                  break;
                case "audiooutput":
                  this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(Qy.PLAYOUT_DEVICE_CHANGED, e3);
              }
            }), n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
          }
          checkMediaDeviceInfoIsOk(e2) {
            const t2 = e2.filter((e3) => "audioinput" === e3.kind), i2 = e2.filter((e3) => "videoinput" === e3.kind), n2 = { audio: false, video: false };
            for (const e3 of t2)
              if (e3.label && e3.deviceId) {
                n2.audio = true;
                break;
              }
            for (const e3 of i2)
              if (e3.label && e3.deviceId) {
                n2.video = true;
                break;
              }
            return n2;
          }
        }();
        let NA = false;
        const DA = new class extends iT {
          constructor() {
            super(...arguments), nu(this, "onAutoplayFailed", void 0), nu(this, "onAudioAutoplayFailed", void 0);
          }
        }();
        function PA() {
          if (pg(), !NA) {
            const e2 = (t2) => {
              t2.preventDefault(), NA = false, Ug() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
            };
            NA = true, Ug() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), KC.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), DA.onAutoplayFailed ? DA.onAutoplayFailed() : DA.onAudioAutoplayFailed ? KC.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : KC.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), DA.emit("autoplay-failed");
          }
        }
        function LA(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function kA(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? LA(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : LA(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        function MA(e2, t2, i2, n2) {
          if (!e2)
            return;
          const r2 = rv.getBaseInfoBySessionId(e2);
          if (!r2)
            return;
          const s2 = r2.info, o2 = Date.now(), a2 = kA(kA({}, s2), {}, { vid: void 0 === s2.vid ? 0 : Number(s2.vid), lts: o2, elapse: o2 - r2.startTime, cbRegistered: DA.onAutoplayFailed || DA.onAudioAutoplayFailed ? 1 : -1, errorMsg: i2, mediaType: t2, trackId: n2, extend: void 0 });
          rv.send({ type: QC.AUTOPLAY_FAILED, data: a2 }, true);
        }
        const UA = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"], xA = new class {
          constructor() {
            nu(this, "onAutoplayFailed", void 0), nu(this, "elementMap", /* @__PURE__ */ new Map()), nu(this, "elementStateMap", /* @__PURE__ */ new Map()), nu(this, "elementsNeedToResume", []), nu(this, "sinkIdMap", /* @__PURE__ */ new Map()), nu(this, "autoResumeAfterInterruption", () => {
              Array.from(this.elementMap.entries()).forEach((e2) => {
                let [t2, i2] = e2;
                const n2 = this.elementStateMap.get(t2), r2 = i2.srcObject.getAudioTracks()[0];
                wg() ? r2 && "live" === r2.readyState && "running" === oA.curState && (KC.debug("auto resume after interruption for iOS 15"), i2.pause(), i2.play()) : n2 && "paused" === n2 && r2 && "live" === r2.readyState && "running" === oA.curState && (KC.debug("auto resume after interruption for iOS"), i2.play());
              });
            }), nu(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
              Array.from(this.elementMap.entries()).forEach((e2) => {
                let [t2, i2] = e2;
                const n2 = i2.srcObject.getAudioTracks()[0];
                n2 && "live" === n2.readyState && (KC.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), i2.pause(), i2.play());
              });
            }), this.autoResumeAudioElement(), oA.on(uy.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), oA.on(uy.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), oA.on(uy.STATE_CHANGE, () => {
              Cg() && "suspended" === oA.prevState && "running" === oA.curState && this.autoResumeAfterInterruption();
            });
          }
          async setSinkID(e2, t2) {
            const i2 = this.elementMap.get(e2);
            if (this.sinkIdMap.set(e2, t2), i2)
              try {
                await i2.setSinkId(t2);
              } catch (e3) {
                throw new Vg(xg.PERMISSION_DENIED, "can not set sink id: " + e3.toString());
              }
          }
          play(e2, t2, i2, n2) {
            if (this.elementMap.has(t2))
              return;
            const r2 = document.createElement("audio");
            r2.autoplay = true, r2.srcObject = new MediaStream([e2]), this.bindAudioElementEvents(t2, r2), this.elementMap.set(t2, r2), this.elementStateMap.set(t2, Zy.INIT), this.setVolume(t2, i2);
            const s2 = this.sinkIdMap.get(t2);
            if (s2)
              try {
                r2.setSinkId(s2).catch((e3) => {
                  KC.warning("[".concat(t2, "] set sink id failed"), e3.toString());
                });
              } catch (e3) {
                KC.warning("[".concat(t2, "] set sink id failed"), e3.toString());
              }
            const o2 = r2.play();
            o2 && o2.then && o2.catch((e3) => {
              n2 && MA(n2, "audio", e3.message, t2), KC.warning("audio element play warning", e3.toString()), this.elementMap.has(t2) && "NotAllowedError" === e3.name && (KC.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r2), AT(() => {
                this.onAutoplayFailed && this.onAutoplayFailed(), PA();
              }));
            });
          }
          updateTrack(e2, t2) {
            const i2 = this.elementMap.get(e2);
            i2 && (i2.srcObject = new MediaStream([t2]));
          }
          isPlaying(e2) {
            return this.elementMap.has(e2) && "playing" === this.elementStateMap.get(e2);
          }
          setVolume(e2, t2) {
            const i2 = this.elementMap.get(e2);
            i2 && (t2 = Math.max(0, Math.min(100, t2)), i2.volume = t2 / 100);
          }
          stop(e2) {
            const t2 = this.elementMap.get(e2);
            if (this.sinkIdMap.delete(e2), !t2)
              return;
            const i2 = this.elementsNeedToResume.indexOf(t2);
            this.elementsNeedToResume.splice(i2, 1), t2.srcObject = null, t2.remove(), this.elementMap.delete(e2), this.elementStateMap.delete(e2);
          }
          bindAudioElementEvents(e2, t2) {
            UA.forEach((i2) => {
              t2.addEventListener(i2, (i3) => {
                const n2 = this.elementStateMap.get(e2), r2 = "pause" === i3.type ? "paused" : i3.type;
                if (KC.debug("[".concat(e2, "] audio-element-status change ").concat(n2, " => ").concat(r2)), "error" === i3.type) {
                  const i4 = null == t2 ? void 0 : t2.error;
                  i4 && KC.error("[".concat(e2, "] media error, code: ").concat(i4.code, ", message: ").concat(i4.message));
                }
                this.elementStateMap.set(e2, r2);
              });
            });
          }
          getPlayerState(e2) {
            return this.elementStateMap.get(e2) || "uninit";
          }
          autoResumeAudioElement() {
            const e2 = () => {
              this.elementsNeedToResume.forEach((e3) => {
                e3.play().then((e4) => {
                  KC.debug("Auto resume audio element success");
                }).catch((e4) => {
                  KC.warning("Auto resume audio element failed!", e4);
                });
              }), this.elementsNeedToResume = [];
            };
            new tg((e3) => {
              document.body ? e3() : window.addEventListener("load", () => e3());
            }).then(() => {
              Ug() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true));
            });
          }
        }();
        function VA() {
          return function(e2, t2, i2) {
            const n2 = i2.value;
            return "function" == typeof n2 && (i2.value = function() {
              this._isClosed && new Vg(xg.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning", KC);
              for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
                t3[i3] = arguments[i3];
              const r2 = n2.apply(this, t3);
              return r2 instanceof tg ? new tg((e4, t4) => {
                r2.then(e4).catch(t4);
              }) : r2;
            }), i2;
          };
        }
        function FA(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function BA(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? FA(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : FA(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class jA extends iT {
          constructor(e2) {
            super(), nu(this, "name", "VideoProcessorDestination"), nu(this, "ID", "0"), nu(this, "_source", void 0), nu(this, "videoContext", void 0), nu(this, "inputTrack", void 0), this.videoContext = e2;
          }
          get kind() {
            return "video";
          }
          get enabled() {
            return true;
          }
          pipe() {
            throw new Vg(xg.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
          }
          unpipe() {
            throw new Vg(xg.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
          }
          enable() {
          }
          disable() {
          }
          updateInput(e2) {
            if (e2.context !== this.videoContext)
              throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
            e2.track && e2.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e2.track, this.emit(Jy.ON_TRACK, e2.track));
          }
          reset() {
            this.inputTrack = void 0, this.videoContext.chained = false, this.emit(Jy.ON_TRACK, void 0);
          }
        }
        class GA extends iT {
          set chained(e2) {
            this._chained = e2;
          }
          get chained() {
            return this._chained;
          }
          constructor(e2, t2) {
            super(), nu(this, "constraintsMap", /* @__PURE__ */ new Map()), nu(this, "statsRegistry", []), nu(this, "usageRegistry", []), nu(this, "trackId", void 0), nu(this, "direction", void 0), nu(this, "_chained", false), this.trackId = e2, this.direction = t2;
          }
          async getConstraints() {
            return await fT(this, zy.REQUEST_CONSTRAINTS);
          }
          async requestApplyConstraints(e2, t2) {
            var i2;
            return KC.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), gT(this, zy.REQUEST_UPDATE_CONSTRAINTS, Array.from(kv(i2 = this.constraintsMap).call(i2)));
          }
          async requestRevertConstraints(e2) {
            var t2;
            if (this.constraintsMap.has(e2))
              return KC.info("processor ".concat(e2.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e2), gT(this, zy.REQUEST_UPDATE_CONSTRAINTS, Array.from(kv(t2 = this.constraintsMap).call(t2)));
          }
          registerStats(e2, t2, i2) {
            this.statsRegistry.find((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i2 });
          }
          unregisterStats(e2, t2) {
            const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2);
            -1 !== i2 && this.statsRegistry.splice(i2, 1);
          }
          gatherStats() {
            const e2 = [];
            for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry)
              try {
                const s2 = r2();
                e2.push({ processorID: t2, processorName: i2, type: n2, stats: s2 });
              } catch (e3) {
                KC.error(new Vg(xg.UNEXPECTED_ERROR, e3.message));
              }
            return e2;
          }
          registerUsage(e2, t2) {
            this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
          }
          unregisterUsage(e2) {
            const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
            -1 !== t2 && this.usageRegistry.splice(t2, 1);
          }
          async gatherUsage() {
            const e2 = [];
            if (!this.chained)
              return [];
            for (const { cb: t2 } of this.usageRegistry)
              try {
                let i2 = t2();
                i2 instanceof tg && (i2 = await i2), e2.push(BA(BA({}, i2), {}, { direction: this.direction }));
              } catch (e3) {
                KC.error("gather extension usage error", e3);
              }
            return e2;
          }
          getDirection() {
            return this.direction;
          }
        }
        class WA extends iT {
          constructor(e2) {
            super(), nu(this, "name", "AudioProcessorDestination"), nu(this, "ID", "0"), nu(this, "inputTrack", void 0), nu(this, "inputNode", void 0), nu(this, "audioProcessorContext", void 0), nu(this, "_source", void 0), this.audioProcessorContext = e2;
          }
          get kind() {
            return "audio";
          }
          get enabled() {
            return true;
          }
          pipe() {
            throw new Vg(xg.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
          }
          unpipe() {
            throw new Vg(xg.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
          }
          enable() {
          }
          disable() {
          }
          reset() {
            this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(Jy.ON_TRACK, void 0), this.emit(Jy.ON_NODE, void 0);
          }
          updateInput(e2) {
            if (e2.context !== this.audioProcessorContext)
              throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
            e2.track && this.inputTrack !== e2.track && (this.audioProcessorContext.chained = true, this.inputTrack = e2.track, this.emit(Jy.ON_TRACK, this.inputTrack)), e2.node && this.inputNode !== e2.node && (this.audioProcessorContext.chained = true, this.inputNode = e2.node, this.emit(Jy.ON_NODE, this.inputNode));
          }
        }
        class HA extends iT {
          set chained(e2) {
            this._chained = e2;
          }
          get chained() {
            return this._chained;
          }
          constructor(e2, t2, i2) {
            super(), nu(this, "constraintsMap", /* @__PURE__ */ new Map()), nu(this, "statsRegistry", []), nu(this, "audioContext", void 0), nu(this, "trackId", void 0), nu(this, "direction", void 0), nu(this, "usageRegistry", []), nu(this, "_chained", false), this.audioContext = e2, this.trackId = t2, this.direction = i2;
          }
          async getConstraints() {
            return fT(this, zy.REQUEST_CONSTRAINTS);
          }
          getAudioContext() {
            return this.audioContext;
          }
          async requestApplyConstraints(e2, t2) {
            var i2;
            return KC.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), gT(this, zy.REQUEST_UPDATE_CONSTRAINTS, Array.from(kv(i2 = this.constraintsMap).call(i2)));
          }
          async requestRevertConstraints(e2) {
            var t2;
            if (this.constraintsMap.has(e2))
              return this.constraintsMap.delete(e2), gT(this, zy.REQUEST_UPDATE_CONSTRAINTS, Array.from(kv(t2 = this.constraintsMap).call(t2)));
          }
          registerStats(e2, t2, i2) {
            this.statsRegistry.find((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i2 });
          }
          unregisterStats(e2, t2) {
            const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t2);
            -1 !== i2 && this.statsRegistry.splice(i2, 1);
          }
          gatherStats() {
            const e2 = [];
            for (const { processorID: t2, processorName: i2, type: n2, cb: r2 } of this.statsRegistry)
              try {
                const s2 = r2();
                e2.push({ processorID: t2, processorName: i2, type: n2, stats: s2 });
              } catch (e3) {
                KC.error(new Vg(xg.UNEXPECTED_ERROR, e3.message));
              }
            return e2;
          }
          registerUsage(e2, t2) {
            this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
          }
          unregisterUsage(e2) {
            const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
            -1 !== t2 && this.usageRegistry.splice(t2, 1);
          }
          async gatherUsage() {
            const e2 = [];
            if (!this.chained)
              return [];
            for (const { cb: t2 } of this.usageRegistry)
              try {
                let i2 = t2();
                i2 instanceof tg && (i2 = await i2), e2.push(BA(BA({}, i2), {}, { direction: this.direction }));
              } catch (e3) {
                KC.error("gather extension usage error", e3);
              }
            return e2;
          }
          getDirection() {
            return this.direction;
          }
        }
        class KA extends iT {
          get isPlayed() {
            return true;
          }
          get isFreeze() {
            return false;
          }
          constructor() {
            super(), nu(this, "context", void 0), nu(this, "processSourceNode", void 0), nu(this, "outputTrack", void 0), nu(this, "processedNode", void 0), nu(this, "clonedTrack", void 0), nu(this, "outputNode", void 0), this.outputNode = new YA();
          }
          setVolume() {
          }
          createOutputTrack() {
            throw new Vg(xg.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
          }
          getOriginVolumeLevel() {
            return 0;
          }
          getAccurateVolumeLevel() {
            return 0;
          }
          stopGetAudioBuffer() {
          }
          startGetAudioBuffer() {
          }
          play() {
          }
          stop() {
          }
          destroy() {
          }
          updateTrack() {
          }
          updateOriginTrack() {
          }
          createMediaStreamSourceNode() {
          }
        }
        class YA {
          disconnect() {
          }
          connect() {
          }
        }
        let qA = null;
        class JA {
          constructor() {
            nu(this, "state", "open"), nu(this, "trigger", void 0), nu(this, "tasks", []), KC.debug("[macro-task-queue] is created."), this.trigger = window.setTimeout(() => {
              this.state = "closed", KC.debug("[macro-task-queue] will be closed, all remaining tasks will execute. [".concat(this.tasks.map((e2) => e2.key), "]")), this.trigger = void 0, this.tasks.forEach((e2) => {
                let { func: t2 } = e2;
                return t2();
              }), this.tasks.length = 0, KC.debug("[macro-task-queue] is closed.");
            });
          }
          enqueue(e2, t2) {
            "closed" !== this.state && (this.tasks.push({ key: e2, func: t2 }), KC.debug("[macro-task-queue] is queued, current queue ".concat(this.tasks.length, ". ").concat("string" == typeof e2 ? e2 : "")));
          }
          runTask(e2) {
            if ("closed" === this.state)
              return;
            const t2 = this.tasks.findIndex((t3) => t3.key === e2);
            if (-1 !== t2) {
              const i2 = this.tasks.splice(t2, 1);
              KC.debug("[macro-task-queue] is unqueued, current queue ".concat(this.tasks.length, ". ").concat("string" == typeof e2 ? e2 : "")), i2[0].func();
            }
          }
          release() {
            this.trigger && (this.state = "closed", clearTimeout(this.trigger), this.trigger = void 0, this.tasks.length = 0, KC.debug("[macro-task-queue] is closed."));
          }
        }
        function zA(e2) {
          return function(t2, i2, n2) {
            var r2;
            const s2 = null !== (r2 = n2.value) && void 0 !== r2 ? r2 : n2.get, o2 = function() {
              qA && "open" === qA.state && qA.runTask(e2);
              for (var t3 = arguments.length, i3 = new Array(t3), n3 = 0; n3 < t3; n3++)
                i3[n3] = arguments[n3];
              return null == s2 ? void 0 : s2.apply(this, ...i3);
            };
            return n2.value ? n2.value = o2 : n2.get = o2, n2;
          };
        }
        function XA(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function QA(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? XA(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : XA(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class ZA extends iA {
          get _source() {
            return this._trackSource;
          }
          set _source(e2) {
            this._trackSource = e2;
          }
          get processorContext() {
            return this._processorContext;
          }
          set processorContext(e2) {
            this._processorContext = e2;
          }
          get processorDestination() {
            return this._processorDestination;
          }
          set processorDestination(e2) {
            this._processorDestination = e2;
          }
          get isPlaying() {
            return this._useAudioElement ? xA.isPlaying(this.getTrackId()) : this._source.isPlayed;
          }
          get __className__() {
            return "LocalAudioTrack";
          }
          constructor(e2, t2, i2, n2, r2) {
            super(e2, i2), nu(this, "trackMediaType", "audio"), nu(this, "_encoderConfig", void 0), nu(this, "_trackSource", void 0), nu(this, "_enabled", true), nu(this, "_volume", 100), nu(this, "_useAudioElement", false), nu(this, "_bypassWebAudio", false), nu(this, "processor", void 0), nu(this, "_processorContext", void 0), nu(this, "_processorDestination", void 0), nu(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t2, this._getOriginVolumeLevel = !!n2;
            const s2 = () => {
              this.processorContext = new HA(this._source.context, this.getTrackId(), "local"), this.processorDestination = new WA(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(jy.UPDATE_SOURCE, () => {
                this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
              });
            }, o2 = r2 && Sg() && !dA();
            if (kC("DISABLE_WEBAUDIO") ? (this._source = new KA(), this._useAudioElement = true, this._bypassWebAudio = true) : o2 ? this._source = new KA() : (this._source = new fA(e2, false, this._getOriginVolumeLevel ? e2 : void 0), kC("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = true)), s2(), !kC("DISABLE_WEBAUDIO") && o2) {
              (qA || (qA = new JA()), qA).enqueue("INIT_WEBAUDIO", () => {
                this._source = new fA(e2, false, this._getOriginVolumeLevel ? e2 : void 0), kC("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = true), s2(), this.emit(Gy.UPDATE_TRACK_SOURCE);
              });
            }
          }
          setVolume(e2) {
            jg(e2, "volume", 0, 1e3), this._volume = e2, this._source.setVolume(e2 / 100), this._useAudioElement && xA.setVolume(this.getTrackId(), e2);
            try {
              if (this._bypassWebAudio)
                return void KC.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
              const e3 = this._source.createOutputTrack();
              this._mediaStreamTrack !== e3 && (this._mediaStreamTrack = e3, gT(this, Ly.NEED_REPLACE_TRACK, this).then(() => {
                KC.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
              }).catch((e4) => {
                KC.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e4);
              }));
            } catch (e3) {
            }
          }
          getVolumeLevel() {
            return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
          }
          async setPlaybackDevice(e2) {
            if (!this._useAudioElement)
              throw new Vg(xg.NOT_SUPPORTED, "your browser does not support setting the audio output device");
            await xA.setSinkID(this.getTrackId(), e2);
          }
          async setEnabled(e2, t2, i2) {
            return this._setEnabled(e2, t2, i2);
          }
          async _setEnabled(e2, t2, i2) {
            if (!i2) {
              if (e2 === this._enabled)
                return;
              this.stateCheck("enabled", e2);
            }
            if (KC.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
              this._originMediaStreamTrack.enabled = true;
              try {
                i2 || (this._enabled = true), await gT(this, Ly.NEED_ENABLE_TRACK, this), KC.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e2, " success"));
              } catch (e3) {
                throw i2 || (this._enabled = false), KC.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
              }
            } else {
              this._originMediaStreamTrack.enabled = false, i2 || (this._enabled = false);
              try {
                await gT(this, Ly.NEED_DISABLE_TRACK, this);
              } catch (e3) {
                throw i2 || (this._enabled = true), KC.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
              }
            }
          }
          async setMuted(e2) {
            e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, KC.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await gT(this, Ly.NEED_MUTE_TRACK, this) : await gT(this, Ly.NEED_UNMUTE_TRACK, this));
          }
          getStats() {
            NT(() => {
              KC.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
            }, "localAudioTrackGetStatsWarning");
            const e2 = TT(this, Ly.GET_STATS);
            return e2 || QA({}, Wy);
          }
          setAudioFrameCallback(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
            if (!e2)
              return this._source.removeAllListeners(jy.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
            this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(jy.ON_AUDIO_BUFFER), this._source.on(jy.ON_AUDIO_BUFFER, (t3) => e2(t3));
          }
          play() {
            KC.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (KC.debug("[".concat(this.getTrackId(), "] start audio playback in element")), xA.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
          }
          stop() {
            KC.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? xA.stop(this.getTrackId()) : this._source.stop();
          }
          close() {
            super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe(), this._source.destroy();
          }
          _updatePlayerSource() {
            let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            KC.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && xA.updateTrack(this.getTrackId(), this._mediaStreamTrack);
          }
          async _updateOriginMediaStreamTrack(e2, t2) {
            this._originMediaStreamTrack !== e2 && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this.processor.updateInput({ track: e2, context: this.processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await gT(this, Ly.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e2));
          }
          renewMediaStreamTrack(e2) {
            return tg.resolve(void 0);
          }
          pipe(e2) {
            if (this._bypassWebAudio)
              throw new Vg(xg.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
            if (this.processor === e2)
              return e2;
            if (e2._source)
              throw new Vg(xg.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
            return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
          }
          unpipe() {
            var e2;
            if (!this.processor)
              return;
            const t2 = this.processor;
            null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
          }
          bindProcessorDestinationEvents() {
            this.processorDestination.on(Jy.ON_TRACK, async (e2) => {
              e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2), await gT(this, Ly.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await gT(this, Ly.NEED_REPLACE_TRACK, this));
            }), this.processorDestination.on(Jy.ON_NODE, (e2) => {
              this._source.processedNode = e2;
            });
          }
          unbindProcessorDestinationEvents() {
            this.processorDestination.removeAllListeners(Jy.ON_TRACK), this.processorDestination.removeAllListeners(Jy.ON_NODE);
          }
          unbindProcessorContextEvents() {
            this.processorContext.removeAllListeners(zy.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(zy.REQUEST_CONSTRAINTS);
          }
        }
        Mv([zA("INIT_WEBAUDIO"), Uv("design:type", Object), Uv("design:paramtypes", [Object])], ZA.prototype, "_source", null), Mv([zA("INIT_WEBAUDIO"), Uv("design:type", HA), Uv("design:paramtypes", [HA])], ZA.prototype, "processorContext", null), Mv([zA("INIT_WEBAUDIO"), Uv("design:type", WA), Uv("design:paramtypes", [WA])], ZA.prototype, "processorDestination", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), Uv("design:type", Function), Uv("design:paramtypes", [Number]), Uv("design:returntype", void 0)], ZA.prototype, "setVolume", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], ZA.prototype, "setPlaybackDevice", null), Mv([qT("LocalAudioTrack", "_enabledMutex"), nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean, Object, Boolean]), Uv("design:returntype", tg)], ZA.prototype, "setEnabled", null), Mv([qT("LocalAudioTrack", "_enabledMutex"), nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean]), Uv("design:returntype", tg)], ZA.prototype, "setMuted", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", Object)], ZA.prototype, "getStats", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", [Object, Number]), Uv("design:returntype", void 0)], ZA.prototype, "setAudioFrameCallback", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], ZA.prototype, "play", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], ZA.prototype, "stop", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], ZA.prototype, "close", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", Object)], ZA.prototype, "pipe", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], ZA.prototype, "unpipe", null);
        class $A extends ZA {
          get __className__() {
            return "MicrophoneAudioTrack";
          }
          constructor(e2, t2, i2, n2) {
            super(e2, t2.encoderConfig ? Ny(t2.encoderConfig) : {}, n2, kC("GET_VOLUME_OF_MUTED_AUDIO_TRACK"), true), nu(this, "_config", void 0), nu(this, "_deviceName", "default"), nu(this, "_constraints", void 0), nu(this, "_originalConstraints", void 0), nu(this, "_enabled", true), this._config = t2, this._constraints = i2, this._originalConstraints = i2, this._deviceName = e2.label, "boolean" == typeof t2.bypassWebAudio && (this._bypassWebAudio = t2.bypassWebAudio), (wg() || Og()) && oA.bindInterruptDetectorTrack(this), this.on(Gy.UPDATE_TRACK_SOURCE, () => {
              this.bindProcessorContextEvents();
            }), dA() && this.bindProcessorContextEvents();
          }
          async setDevice(e2) {
            if (KC.info("[".concat(this.getTrackId(), "] start set device to ").concat(e2)), this._enabled)
              try {
                const t2 = await OA.getDeviceById(e2), i2 = {};
                i2.audio = QA({}, this._constraints), i2.audio.deviceId = { exact: e2 }, this._originMediaStreamTrack.stop();
                let n2 = null;
                try {
                  n2 = await yA(i2, this.getTrackId());
                } catch (e3) {
                  throw KC.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await yA({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), e3;
                }
                await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
              } catch (e3) {
                throw KC.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
              }
            else
              try {
                const t2 = await OA.getDeviceById(e2);
                this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
              } catch (e3) {
                throw KC.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
              }
            KC.info("[".concat(this.getTrackId(), "] set device to ").concat(e2, " success"));
          }
          async setEnabled(e2, t2, i2) {
            if (t2)
              return KC.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e2);
            if (!i2) {
              if (e2 === this._enabled)
                return;
              this.stateCheck("enabled", e2);
            }
            if (KC.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), !e2) {
              var n2;
              this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n2 = this._source.clonedTrack) || void 0 === n2 || n2.stop(), i2 || (this._enabled = false);
              try {
                await gT(this, Ly.NEED_DISABLE_TRACK, this);
              } catch (e3) {
                throw KC.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e3.toString()), e3;
              }
              return;
            }
            const r2 = QA({}, this._constraints), s2 = OA.searchDeviceIdByName(this._deviceName);
            s2 && !r2.deviceId && (r2.deviceId = s2);
            try {
              i2 || (this._enabled = true);
              const e3 = await yA({ audio: this._constraints }, this.getTrackId());
              await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], false), await gT(this, Ly.NEED_ENABLE_TRACK, this);
            } catch (e3) {
              throw i2 || (this._enabled = false), KC.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e3.toString()), e3;
            }
            KC.info("[".concat(this.getTrackId(), "] setEnabled success"));
          }
          close() {
            super.close(), (wg() || Og()) && oA.unbindInterruptDetectorTrack(this);
          }
          onTrackEnded() {
            if ((Cg() || Dg()) && this._enabled && !this._isClosed && oA.duringInterruption) {
              const e2 = async () => {
                oA.off(uy.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (KC.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
              };
              oA.on(uy.IOS_INTERRUPTION_END, e2);
            } else
              KC.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(Fy.TRACK_ENDED);
          }
          async renewMediaStreamTrack(e2) {
            const t2 = e2 || this._constraints, i2 = OA.searchDeviceIdByName(this._deviceName);
            if (i2 && !t2.deviceId && (t2.deviceId = i2), this._constraints = t2, this._enabled) {
              this._originMediaStreamTrack.stop();
              const e3 = await yA({ audio: this._constraints }, this.getTrackId());
              await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], true);
            }
          }
          bindProcessorContextEvents() {
            this.processorContext.on(zy.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, i2) => {
              try {
                const i3 = Object.assign({}, this._originalConstraints, ...e2);
                await this.renewMediaStreamTrack(i3), t2();
              } catch (e3) {
                i2(e3);
              }
            }), this.processorContext.on(zy.REQUEST_CONSTRAINTS, async (e2) => {
              e2(this._originMediaStreamTrack.getSettings());
            });
          }
        }
        Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], $A.prototype, "setDevice", null), Mv([qT("MicrophoneAudioTrack", "_enabledMutex"), nv({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2, i2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean, Boolean, Boolean]), Uv("design:returntype", tg)], $A.prototype, "setEnabled", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], $A.prototype, "close", null);
        class eb extends ZA {
          get __className__() {
            return "BufferSourceAudioTrack";
          }
          constructor(e2, t2, i2, n2) {
            super(t2.createOutputTrack(), i2, n2), nu(this, "source", void 0), nu(this, "_bufferSource", void 0), this.source = e2, this._bufferSource = t2, this._bufferSource.on(jy.AUDIO_SOURCE_STATE_CHANGE, (e3) => {
              this.safeEmit(Fy.SOURCE_STATE_CHANGE, e3);
            });
            try {
              this._mediaStreamTrack = this._source.createOutputTrack();
            } catch (e3) {
            }
          }
          get currentState() {
            return this._bufferSource.currentState;
          }
          get duration() {
            return this._bufferSource.duration;
          }
          get playbackSpeed() {
            return this._bufferSource.playbackSpeed;
          }
          getCurrentTime() {
            return this._bufferSource.currentTime;
          }
          startProcessAudioBuffer(e2) {
            e2 && this._bufferSource.updateOptions(e2), this._bufferSource.startProcessAudioBuffer();
          }
          pauseProcessAudioBuffer() {
            this._bufferSource.pauseProcessAudioBuffer();
          }
          seekAudioBuffer(e2) {
            this._bufferSource.seekAudioBuffer(e2);
          }
          resumeProcessAudioBuffer() {
            this._bufferSource.resumeProcessAudioBuffer();
          }
          stopProcessAudioBuffer() {
            this._bufferSource.stopProcessAudioBuffer();
          }
          close() {
            this.source = null, this._bufferSource.destroy(), super.close();
          }
          setAudioBufferPlaybackSpeed(e2) {
            jg(e2, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e2);
          }
        }
        Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2, e2.duration] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", void 0)], eb.prototype, "startProcessAudioBuffer", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], eb.prototype, "pauseProcessAudioBuffer", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Number]), Uv("design:returntype", void 0)], eb.prototype, "seekAudioBuffer", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], eb.prototype, "resumeProcessAudioBuffer", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], eb.prototype, "stopProcessAudioBuffer", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], eb.prototype, "close", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Number]), Uv("design:returntype", void 0)], eb.prototype, "setAudioBufferPlaybackSpeed", null);
        class tb extends ZA {
          get __className__() {
            return "MixingAudioTrack";
          }
          get isActive() {
            for (const e2 of this.trackList)
              if (e2._enabled && !e2._isClosed && !e2.muted)
                return true;
            return false;
          }
          constructor() {
            const e2 = cA().createMediaStreamDestination();
            super(e2.stream.getAudioTracks()[0], void 0, xT(8, "track-mix-")), nu(this, "trackList", void 0), nu(this, "destNode", void 0);
            try {
              this._mediaStreamTrack = this._source.createOutputTrack();
            } catch (e3) {
            }
            this.destNode = e2, this.trackList = [];
          }
          hasAudioTrack(e2) {
            return -1 !== this.trackList.indexOf(e2);
          }
          addAudioTrack(e2) {
            -1 === this.trackList.indexOf(e2) ? (KC.debug("add ".concat(e2.getTrackId(), " to mixing track")), e2._source.outputNode.connect(this.destNode), this.trackList.push(e2), this.updateEncoderConfig()) : KC.debug("track ".concat(e2.getTrackId(), " is already added"));
          }
          removeAudioTrack(e2) {
            if (-1 !== this.trackList.indexOf(e2)) {
              KC.debug("remove ".concat(e2.getTrackId(), " from mixing track"));
              try {
                e2._source.outputNode.disconnect(this.destNode);
              } catch (e3) {
              }
              IT(this.trackList, e2), this.updateEncoderConfig();
            }
          }
          updateEncoderConfig() {
            const e2 = {};
            this.trackList.forEach((t2) => {
              t2._encoderConfig && ((t2._encoderConfig.bitrate || 0) > (e2.bitrate || 0) && (e2.bitrate = t2._encoderConfig.bitrate), (t2._encoderConfig.sampleRate || 0) > (e2.sampleRate || 0) && (e2.sampleRate = t2._encoderConfig.sampleRate), (t2._encoderConfig.sampleSize || 0) > (e2.sampleSize || 0) && (e2.sampleSize = t2._encoderConfig.sampleSize), t2._encoderConfig.stereo && (e2.stereo = true));
            }), this._encoderConfig = e2;
          }
          _updateRtpTransceiver(e2) {
            this._rtpTransceiver !== e2 && (this._rtpTransceiver = e2, this.trackList.forEach((t2) => {
              t2 instanceof tb ? t2.emit(Vy.TRANSCEIVER_UPDATED, e2) : t2._updateRtpTransceiver(e2);
            }));
          }
        }
        function ib(e2) {
          const t2 = {};
          e2.facingMode && (t2.facingMode = e2.facingMode), e2.cameraId && (t2.deviceId = { exact: e2.cameraId });
          const i2 = Ay(e2.encoderConfig);
          return null != i2.width && (t2.width = i2.width), null != i2.height && (t2.height = i2.height), !Lg() && i2.frameRate && (t2.frameRate = i2.frameRate), pg().name === cg.EDGE && "object" == typeof t2.frameRate && (t2.frameRate.max = 60), Rg() && (t2.frameRate = { ideal: 30, max: 30 }), t2;
        }
        function nb(e2) {
          const t2 = {};
          if (Lg() || (void 0 !== e2.AGC && (t2.autoGainControl = e2.AGC), void 0 !== e2.AEC && (t2.echoCancellation = e2.AEC), void 0 !== e2.ANS && (t2.noiseSuppression = e2.ANS, Tg() && e2.ANS && (t2.googHighpassFilter = e2.ANS))), e2.encoderConfig) {
            const i2 = Ny(e2.encoderConfig);
            t2.channelCount = i2.stereo ? 2 : 1, t2.sampleRate = i2.sampleRate, t2.sampleSize = i2.sampleSize;
          }
          return e2.microphoneId && (t2.deviceId = { exact: e2.microphoneId }), Mg() && (t2.sampleRate = void 0), t2;
        }
        class rb extends mA {
          set currentState(e2) {
            e2 !== this._currentState && (this._currentState = e2, this.safeEmit(jy.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
          }
          get currentState() {
            return this._currentState;
          }
          constructor(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            super(), nu(this, "audioBuffer", void 0), nu(this, "sourceNode", void 0), nu(this, "startPlayTime", 0), nu(this, "startPlayOffset", 0), nu(this, "pausePlayTime", 0), nu(this, "options", void 0), nu(this, "currentLoopCount", 0), nu(this, "currentPlaybackSpeed", 100), nu(this, "_currentState", "stopped"), this.audioBuffer = e2, this.options = t2, this.startPlayOffset = this.options.startPlayTime || 0;
          }
          createWebAudioDiagram() {
            return this.context.createGain();
          }
          get duration() {
            return this.audioBuffer ? this.audioBuffer.duration : 0;
          }
          get playbackSpeed() {
            return this.currentPlaybackSpeed;
          }
          get currentTime() {
            return this.audioBuffer ? "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;
          }
          updateOptions(e2) {
            "stopped" === this.currentState ? (this.options = e2, this.startPlayOffset = this.options.startPlayTime || 0) : KC.warning("can not set audio source options");
          }
          startProcessAudioBuffer() {
            this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
          }
          pauseProcessAudioBuffer() {
            this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
          }
          seekAudioBuffer(e2) {
            this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e2, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e2));
          }
          resumeProcessAudioBuffer() {
            "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
          }
          stopProcessAudioBuffer() {
            if (this.sourceNode) {
              this.sourceNode.onended = null;
              try {
                this.sourceNode.stop();
              } catch (e2) {
              }
              this.reset();
            }
          }
          destroy() {
            this.audioBuffer = null, super.destroy();
          }
          setAudioBufferPlaybackSpeed(e2) {
            this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e2 / 100), this.currentPlaybackSpeed = e2;
          }
          startSourceNode() {
            this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
          }
          createSourceNode() {
            const e2 = this.context.createBufferSource();
            return e2.buffer = this.audioBuffer, e2.loop = !!this.options.loop, e2.connect(this.outputNode), e2.playbackRate.value = this.currentPlaybackSpeed / 100, e2;
          }
          handleSourceNodeEnded() {
            if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount)
              return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
            this.reset();
          }
          reset() {
            this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
          }
        }
        const sb = /* @__PURE__ */ new Map();
        async function ob(e2, t2) {
          let i2 = null;
          if ("string" == typeof e2) {
            const t3 = sb.get(e2);
            if (t3)
              return KC.debug("use cached audio resource: ", e2), t3;
            try {
              i2 = (await XT(() => EC.get(e2, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
            } catch (e3) {
              throw new Vg(xg.FETCH_AUDIO_FILE_FAILED, e3.toString());
            }
          } else {
            const t3 = new tg((t4, i3) => {
              const n3 = new FileReader();
              n3.onload = (e3) => {
                e3.target ? t4(e3.target.result) : i3(new Vg(xg.READ_LOCAL_AUDIO_FILE_ERROR));
              }, n3.onerror = () => {
                i3(new Vg(xg.READ_LOCAL_AUDIO_FILE_ERROR));
              }, n3.readAsArrayBuffer(e2);
            });
            i2 = await t3;
          }
          const n2 = await function(e3) {
            const t3 = cA();
            return new tg((i3, n3) => {
              t3.decodeAudioData(e3, (e4) => {
                i3(e4);
              }, (e4) => {
                n3(new Vg(xg.DECODE_AUDIO_FILE_FAILED, e4.toString()));
              });
            });
          }(i2);
          return "string" == typeof e2 && t2 && sb.set(e2, n2), n2;
        }
        const ab = (e2) => {
          const t2 = document.createElement("canvas");
          return t2.width = 2, t2.height = 2, new tg((i2, n2) => {
            t2.toBlob(async (e3) => {
              if (t2.remove(), e3) {
                const n3 = await cb(e3);
                i2({ buffer: n3, width: t2.width, height: t2.height });
              } else
                n2(new Vg(xg.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
            }, e2, 1);
          });
        }, cb = async (e2) => {
          const t2 = await e2.arrayBuffer();
          return new Uint8Array(t2);
        };
        const db = new class extends iT {
          get visibility() {
            return document.visibilityState;
          }
          get lastHiddenTime() {
            return this._lastHiddenTime;
          }
          get lastVisibleTime() {
            return this._lastVisibleTime;
          }
          constructor() {
            super(), nu(this, "_lastHiddenTime", 0), nu(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
              "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), KC.debug("document visibility went ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
            });
          }
        }();
        function lb(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function hb(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? lb(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : lb(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class ub {
          get videoElementStatus() {
            return this._videoElementStatus;
          }
          set videoElementStatus(e2) {
            e2 !== this._videoElementStatus && (KC.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e2)), this._videoElementStatus = e2);
          }
          constructor(e2) {
            nu(this, "trackId", void 0), nu(this, "config", void 0), nu(this, "onFirstVideoFrameDecoded", void 0), nu(this, "freezeTimeCounterList", []), nu(this, "renderFreezeAccTime", 0), nu(this, "isKeepLastFrame", false), nu(this, "timeUpdatedCount", 0), nu(this, "freezeTime", 0), nu(this, "playbackTime", 0), nu(this, "lastTimeUpdatedTime", 0), nu(this, "autoplayFailed", false), nu(this, "videoTrack", void 0), nu(this, "videoElement", void 0), nu(this, "cacheVideoElement", void 0), nu(this, "videoElementCheckInterval", void 0), nu(this, "_videoElementStatus", Zy.NONE), nu(this, "isGettingVideoDimensions", false), nu(this, "startGetVideoDimensions", () => {
              const e3 = () => {
                if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4)
                  return KC.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
                setTimeout(e3, 500);
              };
              !this.isGettingVideoDimensions && e3();
            }), nu(this, "autoResumeAfterInterruption", () => {
              this.videoTrack && "live" === this.videoTrack.readyState && "running" === oA.curState && (KC.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(Eg())), Ng() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
            }), nu(this, "handleVideoEvents", (e3) => {
              switch (e3.type) {
                case "play":
                case "playing":
                  this.startGetVideoDimensions(), this.videoElementStatus = Zy.PLAYING;
                  break;
                case "loadeddata":
                  if (this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
                    try {
                      this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
                    } catch (e4) {
                    }
                    this.cacheVideoElement = void 0;
                  }
                  break;
                case "canplay":
                  this.videoElementStatus = Zy.CANPLAY;
                  break;
                case "stalled":
                  this.videoElementStatus = Zy.STALLED;
                  break;
                case "suspend":
                  this.videoElementStatus = Zy.SUSPEND;
                  break;
                case "pause":
                  this.videoElementStatus = Zy.PAUSED, Cg() || Dg() || Sg() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (KC.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
                  break;
                case "waiting":
                  this.videoElementStatus = Zy.WAITING;
                  break;
                case "abort":
                  this.videoElementStatus = Zy.ABORT;
                  break;
                case "ended":
                  this.videoElementStatus = Zy.ENDED;
                  break;
                case "emptied":
                  this.videoElementStatus = Zy.EMPTIED;
                  break;
                case "error": {
                  this.videoElementStatus = Zy.ERROR;
                  const e4 = this.videoElement.error;
                  e4 && KC.error("[".concat(this.trackId, "] media error, code: ").concat(e4.code, ", message: ").concat(e4.message));
                  break;
                }
                case "timeupdate": {
                  const e4 = performance.now();
                  if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10)
                    return void (this.lastTimeUpdatedTime = e4);
                  const t2 = e4 - this.lastTimeUpdatedTime, i2 = this.lastTimeUpdatedTime;
                  if (this.lastTimeUpdatedTime = e4, db.lastVisibleTime < db.lastHiddenTime || i2 < db.lastHiddenTime || i2 < db.lastVisibleTime)
                    return;
                  for (t2 > kC("VIDEO_FREEZE_DURATION") && (this.freezeTime += t2), this.playbackTime += t2; this.playbackTime >= 6e3; ) {
                    this.playbackTime -= 6e3;
                    const e5 = Math.min(6e3, this.freezeTime);
                    this.freezeTimeCounterList.push(e5), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
                  }
                  break;
                }
              }
            }), nu(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
              this.videoTrack && "live" === this.videoTrack.readyState && (KC.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(Eg())), Ng() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
            }), this.trackId = e2.trackId, this.config = e2, e2.element instanceof HTMLVideoElement ? this.videoElement = e2.element : this.videoElement = document.createElement("video"), oA.on(uy.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), oA.on(uy.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
          }
          getVideoElement() {
            return this.videoElement;
          }
          getContainerElement() {
            var e2;
            return null !== (e2 = this.videoElement.parentElement) && void 0 !== e2 ? e2 : void 0;
          }
          updateConfig(e2) {
            this.config = e2, this.trackId = e2.trackId, e2.element !== this.videoElement && (this.destroy(), this.videoElement = e2.element), this.videoTrack && this.initVideoElement();
          }
          updateVideoTrack(e2) {
            this.videoTrack !== e2 && (this.videoTrack = e2, this.initVideoElement());
          }
          play(e2) {
            const t2 = this.videoElement.play();
            t2 && t2.catch && t2.catch((t3) => {
              e2 && MA(e2, "video", t3.message, this.trackId), "NotAllowedError" === t3.name ? (KC.warning("detected video element autoplay failed", t3), this.autoplayFailed = true, this.handleAutoPlayFailed()) : KC.warning("[".concat(this.trackId, "] play warning: "), t3);
            });
            const i2 = pg();
            if (("Safari" === i2.name && 15 === Number(i2.version) || wg()) && t2 && t2.then) {
              const e3 = () => {
                this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)");
              };
              t2.then(e3).catch(e3);
            }
          }
          getCurrentFrame() {
            const e2 = document.createElement("canvas");
            e2.width = this.videoElement.videoWidth, e2.height = this.videoElement.videoHeight;
            const t2 = e2.getContext("2d");
            if (!t2)
              return KC.error("create canvas context failed!"), new ImageData(2, 2);
            t2.drawImage(this.videoElement, 0, 0, e2.width, e2.height);
            const i2 = t2.getImageData(0, 0, e2.width, e2.height);
            return e2.remove(), i2;
          }
          async getCurrentFrameToUint8Array(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            const i2 = document.createElement("canvas");
            i2.width = this.videoElement.videoWidth, i2.height = this.videoElement.videoHeight;
            const n2 = i2.getContext("2d");
            return n2 ? (n2.drawImage(this.videoElement, 0, 0, i2.width, i2.height), new tg((n3, r2) => {
              i2.toBlob(async (e3) => {
                if (i2.remove(), e3) {
                  const t3 = await cb(e3);
                  n3({ buffer: t3, width: i2.width, height: i2.height });
                } else
                  r2(new Vg(xg.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
              }, e2, t2 < 0 ? 0.1 : t2 > 1 ? 1 : t2);
            })) : await ab(e2);
          }
          destroy() {
            oA.off(uy.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), oA.off(uy.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [];
          }
          initVideoElement() {
            if (this.videoElementStatus = Zy.INIT, !this.videoElementCheckInterval && (pb.forEach((e3) => {
              this.videoElement.addEventListener(e3, this.handleVideoEvents);
            }), this.videoElementCheckInterval = window.setInterval(() => {
              (function(e3) {
                return e3 !== document.body && document.body.contains(e3);
              })(this.videoElement) || (this.videoElementStatus = Zy.DESTROYED);
            }, 1e3), kC("ENABLE_VIDEO_FRAME_CALLBACK"))) {
              var e2, t2;
              let i3;
              const n3 = (e3, t3) => {
                if (this.videoElementStatus === Zy.PLAYING) {
                  if (i3) {
                    const e4 = t3.presentationTime - i3.presentationTime;
                    e4 > kC("VIDEO_FREEZE_DURATION") && db.lastVisibleTime >= db.lastHiddenTime && i3.timestamp > db.lastVisibleTime && i3.timestamp > db.lastHiddenTime && (this.renderFreezeAccTime += e4);
                  }
                  i3 = hb(hb({}, t3), {}, { timestamp: e3 });
                }
                var r2, s2;
                kC("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (r2 = (s2 = this.videoElement).requestVideoFrameCallback) || void 0 === r2 || r2.call(s2, n3));
              };
              null === (e2 = (t2 = this.videoElement).requestVideoFrameCallback) || void 0 === e2 || e2.call(t2, n3);
            }
            this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), Mg() && (this.videoElement.poster = "noposter");
            const i2 = pg();
            if ("Safari" === i2.name && 15 === Number(i2.version) || wg() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream) {
              this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Rg() && this.videoElement.load());
            } else
              this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Rg() && this.videoElement.load();
            const n2 = this.videoElement.play();
            void 0 !== n2 && n2.catch((e3) => {
              KC.debug("[".concat(this.trackId, "] playback interrupted"), e3.toString());
            });
          }
          resetVideoElement() {
            pb.forEach((e2) => {
              this.videoElement && this.videoElement.removeEventListener(e2, this.handleVideoEvents);
            }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = Zy.NONE;
          }
          handleAutoPlayFailed() {
            const e2 = (t2) => {
              t2.preventDefault(), this.videoElement.play().then(() => {
                KC.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
              }).catch((e3) => {
                KC.error(e3);
              }), this.autoplayFailed = false, Ug() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
            };
            Ug() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), PA();
          }
        }
        const pb = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
        class _b extends ub {
          constructor(e2) {
            super(e2), nu(this, "container", void 0), nu(this, "slot", void 0), this.slot = e2.element, this.updateConfig(e2);
          }
          updateConfig(e2) {
            this.config = e2, this.trackId = e2.trackId;
            const t2 = e2.element;
            t2 !== this.slot && (this.destroy(), this.slot = t2), this.createElements();
          }
          updateVideoTrack(e2) {
            this.videoTrack !== e2 && (this.videoTrack = e2, this.createElements());
          }
          play(e2) {
            var t2;
            null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) && super.play(e2);
          }
          getCurrentFrame() {
            var e2;
            return null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
          }
          async getCurrentFrameToUint8Array(e2) {
            var t2;
            let i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            return null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e2, i2) : await ab(e2);
          }
          destroy() {
            if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
              try {
                this.container.remove(), this.slot.removeChild(this.container);
              } catch (e2) {
              }
              this.container = void 0;
            }
          }
          createElements() {
            this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", kC("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container);
          }
          mountedVideoElement() {
            var e2;
            !this.container || null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
          }
          unmountedVideoElement() {
            var e2;
            if (null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement)) {
              super.resetVideoElement();
              try {
                this.container && this.container.removeChild(this.videoElement);
              } catch (e3) {
              }
              this.videoElement = document.createElement("video");
            }
          }
          resetVideoElement() {
            var e2;
            null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
          }
          getContainerElement() {
            return this.container;
          }
        }
        function Eb(e2) {
          return new tg((t2, i2) => {
            let n2 = false;
            const r2 = document.createElement("video");
            r2.setAttribute("autoplay", ""), r2.setAttribute("muted", ""), r2.muted = true, r2.autoplay = true, r2.setAttribute("playsinline", ""), r2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r2);
            const s2 = Cg() ? "canplay" : "playing";
            r2.addEventListener(s2, () => {
              const e3 = r2.videoWidth, i3 = r2.videoHeight;
              !e3 && Rg() || (n2 = true, r2.srcObject = null, r2.remove(), t2([e3, i3]));
            }), r2.srcObject = new MediaStream([e2]), r2.play().catch(FT), setTimeout(() => {
              n2 || (r2.srcObject = null, r2.remove(), t2([r2.videoWidth, r2.videoHeight]));
            }, 4e3);
          });
        }
        const mb = async (e2, t2, i2) => {
          const n2 = function(e3) {
            const t3 = [];
            for (let i3 = 0; i3 < e3.length; i3 += 2)
              t3.push(parseInt(e3.slice(i3, i3 + 2), 16));
            return Uint8Array.from(t3);
          }(function(e3) {
            const t3 = "0123456789abcdef";
            function i3(e4) {
              let i4, n4 = "";
              for (i4 = 0; i4 <= 3; i4++)
                n4 += t3.charAt(e4 >> 8 * i4 + 4 & 15) + t3.charAt(e4 >> 8 * i4 & 15);
              return n4;
            }
            function n3(e4, t4) {
              const i4 = (65535 & e4) + (65535 & t4);
              return (e4 >> 16) + (t4 >> 16) + (i4 >> 16) << 16 | 65535 & i4;
            }
            function r3(e4, t4, i4, r4, s4, o3) {
              return n3(function(e5, t5) {
                return e5 << t5 | e5 >>> 32 - t5;
              }(n3(n3(t4, e4), n3(r4, o3)), s4), i4);
            }
            function s3(e4, t4, i4, n4, s4, o3, a3) {
              return r3(t4 & i4 | ~t4 & n4, e4, t4, s4, o3, a3);
            }
            function o2(e4, t4, i4, n4, s4, o3, a3) {
              return r3(t4 & n4 | i4 & ~n4, e4, t4, s4, o3, a3);
            }
            function a2(e4, t4, i4, n4, s4, o3, a3) {
              return r3(t4 ^ i4 ^ n4, e4, t4, s4, o3, a3);
            }
            function c2(e4, t4, i4, n4, s4, o3, a3) {
              return r3(i4 ^ (t4 | ~n4), e4, t4, s4, o3, a3);
            }
            const d2 = function(e4) {
              let t4;
              const i4 = 1 + (e4.length + 8 >> 6), n4 = new Array(16 * i4);
              for (t4 = 0; t4 < 16 * i4; t4++)
                n4[t4] = 0;
              for (t4 = 0; t4 < e4.length; t4++)
                n4[t4 >> 2] |= e4.charCodeAt(t4) << t4 % 4 * 8;
              return n4[t4 >> 2] |= 128 << t4 % 4 * 8, n4[16 * i4 - 2] = 8 * e4.length, n4;
            }(e3);
            let l2, h2, u2, p2, _2, E2 = 1732584193, m2 = -271733879, f2 = -1732584194, g2 = 271733878;
            for (l2 = 0; l2 < d2.length; l2 += 16)
              h2 = E2, u2 = m2, p2 = f2, _2 = g2, E2 = s3(E2, m2, f2, g2, d2[l2 + 0], 7, -680876936), g2 = s3(g2, E2, m2, f2, d2[l2 + 1], 12, -389564586), f2 = s3(f2, g2, E2, m2, d2[l2 + 2], 17, 606105819), m2 = s3(m2, f2, g2, E2, d2[l2 + 3], 22, -1044525330), E2 = s3(E2, m2, f2, g2, d2[l2 + 4], 7, -176418897), g2 = s3(g2, E2, m2, f2, d2[l2 + 5], 12, 1200080426), f2 = s3(f2, g2, E2, m2, d2[l2 + 6], 17, -1473231341), m2 = s3(m2, f2, g2, E2, d2[l2 + 7], 22, -45705983), E2 = s3(E2, m2, f2, g2, d2[l2 + 8], 7, 1770035416), g2 = s3(g2, E2, m2, f2, d2[l2 + 9], 12, -1958414417), f2 = s3(f2, g2, E2, m2, d2[l2 + 10], 17, -42063), m2 = s3(m2, f2, g2, E2, d2[l2 + 11], 22, -1990404162), E2 = s3(E2, m2, f2, g2, d2[l2 + 12], 7, 1804603682), g2 = s3(g2, E2, m2, f2, d2[l2 + 13], 12, -40341101), f2 = s3(f2, g2, E2, m2, d2[l2 + 14], 17, -1502002290), m2 = s3(m2, f2, g2, E2, d2[l2 + 15], 22, 1236535329), E2 = o2(E2, m2, f2, g2, d2[l2 + 1], 5, -165796510), g2 = o2(g2, E2, m2, f2, d2[l2 + 6], 9, -1069501632), f2 = o2(f2, g2, E2, m2, d2[l2 + 11], 14, 643717713), m2 = o2(m2, f2, g2, E2, d2[l2 + 0], 20, -373897302), E2 = o2(E2, m2, f2, g2, d2[l2 + 5], 5, -701558691), g2 = o2(g2, E2, m2, f2, d2[l2 + 10], 9, 38016083), f2 = o2(f2, g2, E2, m2, d2[l2 + 15], 14, -660478335), m2 = o2(m2, f2, g2, E2, d2[l2 + 4], 20, -405537848), E2 = o2(E2, m2, f2, g2, d2[l2 + 9], 5, 568446438), g2 = o2(g2, E2, m2, f2, d2[l2 + 14], 9, -1019803690), f2 = o2(f2, g2, E2, m2, d2[l2 + 3], 14, -187363961), m2 = o2(m2, f2, g2, E2, d2[l2 + 8], 20, 1163531501), E2 = o2(E2, m2, f2, g2, d2[l2 + 13], 5, -1444681467), g2 = o2(g2, E2, m2, f2, d2[l2 + 2], 9, -51403784), f2 = o2(f2, g2, E2, m2, d2[l2 + 7], 14, 1735328473), m2 = o2(m2, f2, g2, E2, d2[l2 + 12], 20, -1926607734), E2 = a2(E2, m2, f2, g2, d2[l2 + 5], 4, -378558), g2 = a2(g2, E2, m2, f2, d2[l2 + 8], 11, -2022574463), f2 = a2(f2, g2, E2, m2, d2[l2 + 11], 16, 1839030562), m2 = a2(m2, f2, g2, E2, d2[l2 + 14], 23, -35309556), E2 = a2(E2, m2, f2, g2, d2[l2 + 1], 4, -1530992060), g2 = a2(g2, E2, m2, f2, d2[l2 + 4], 11, 1272893353), f2 = a2(f2, g2, E2, m2, d2[l2 + 7], 16, -155497632), m2 = a2(m2, f2, g2, E2, d2[l2 + 10], 23, -1094730640), E2 = a2(E2, m2, f2, g2, d2[l2 + 13], 4, 681279174), g2 = a2(g2, E2, m2, f2, d2[l2 + 0], 11, -358537222), f2 = a2(f2, g2, E2, m2, d2[l2 + 3], 16, -722521979), m2 = a2(m2, f2, g2, E2, d2[l2 + 6], 23, 76029189), E2 = a2(E2, m2, f2, g2, d2[l2 + 9], 4, -640364487), g2 = a2(g2, E2, m2, f2, d2[l2 + 12], 11, -421815835), f2 = a2(f2, g2, E2, m2, d2[l2 + 15], 16, 530742520), m2 = a2(m2, f2, g2, E2, d2[l2 + 2], 23, -995338651), E2 = c2(E2, m2, f2, g2, d2[l2 + 0], 6, -198630844), g2 = c2(g2, E2, m2, f2, d2[l2 + 7], 10, 1126891415), f2 = c2(f2, g2, E2, m2, d2[l2 + 14], 15, -1416354905), m2 = c2(m2, f2, g2, E2, d2[l2 + 5], 21, -57434055), E2 = c2(E2, m2, f2, g2, d2[l2 + 12], 6, 1700485571), g2 = c2(g2, E2, m2, f2, d2[l2 + 3], 10, -1894986606), f2 = c2(f2, g2, E2, m2, d2[l2 + 10], 15, -1051523), m2 = c2(m2, f2, g2, E2, d2[l2 + 1], 21, -2054922799), E2 = c2(E2, m2, f2, g2, d2[l2 + 8], 6, 1873313359), g2 = c2(g2, E2, m2, f2, d2[l2 + 15], 10, -30611744), f2 = c2(f2, g2, E2, m2, d2[l2 + 6], 15, -1560198380), m2 = c2(m2, f2, g2, E2, d2[l2 + 13], 21, 1309151649), E2 = c2(E2, m2, f2, g2, d2[l2 + 4], 6, -145523070), g2 = c2(g2, E2, m2, f2, d2[l2 + 11], 10, -1120210379), f2 = c2(f2, g2, E2, m2, d2[l2 + 2], 15, 718787259), m2 = c2(m2, f2, g2, E2, d2[l2 + 9], 21, -343485551), E2 = n3(E2, h2), m2 = n3(m2, u2), f2 = n3(f2, p2), g2 = n3(g2, _2);
            return i3(E2) + i3(m2) + i3(f2) + i3(g2);
          }("" + t2 + i2)).slice(0, 16), r2 = n2.slice(0, 12), s2 = await window.crypto.subtle.importKey("raw", n2, "AES-GCM", true, ["encrypt"]);
          return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r2 }, s2, e2));
        }, fb = async (e2, t2, i2) => await mb(e2.buffer, t2, i2);
        function gb(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function Tb(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? gb(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : gb(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class Sb extends iA {
          get isPlaying() {
            return !(!this._player || this._player.videoElementStatus !== Zy.PLAYING);
          }
          get processorContext() {
            return this._processorContext;
          }
          set processorContext(e2) {
            this._processorContext = e2;
          }
          get __className__() {
            return "LocalVideoTrack";
          }
          constructor(e2, t2, i2, n2, r2, s2) {
            if (super(e2, r2), nu(this, "trackMediaType", "video"), nu(this, "_player", void 0), nu(this, "isUseScaleResolutionDownBy", false), nu(this, "_videoVisibleTimer", null), nu(this, "_statsTimer", null), nu(this, "_previousVideoVisibleStatus", void 0), nu(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), nu(this, "_encoderConfig", void 0), nu(this, "_scalabilityMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), nu(this, "_optimizationMode", void 0), nu(this, "_videoHeight", void 0), nu(this, "_videoWidth", void 0), nu(this, "_forceBitrateLimit", void 0), nu(this, "_enabled", true), nu(this, "processorDestination", void 0), nu(this, "_processorContext", void 0), Sg()) {
              const { width: t3, height: i3 } = e2.getSettings();
              this._videoWidth = t3, this._videoHeight = i3;
            } else
              this.updateMediaStreamTrackResolution();
            if (this._encoderConfig = t2, this._scalabilityMode = i2, this._optimizationMode = n2, this._hints = s2 || [], -1 === this._hints.indexOf(ky.SCREEN_TRACK))
              this.updateBitrateFromProfile();
            else if (function(e3, t3, i3) {
              const n3 = pg();
              return !(n3.name !== e3 || !n3.osVersion) && (i3 ? Number(n3.version) >= t3 && Number(n3.version) <= i3 : Number(n3.version) === t3);
            }(cg.CHROME, 115) && -1 !== _g().indexOf("Windows")) {
              const t3 = function(e3, t4) {
                if ("VideoFrame" in window && "TransformStream" in window && _A().supportWebRTCInsertableStream) {
                  const i3 = new MediaStreamTrackProcessor(e3), n3 = new MediaStreamTrackGenerator({ kind: "video" });
                  let r3, s3, o2 = Date.now();
                  const a2 = () => {
                    c2 && (clearInterval(c2), c2 = void 0), r3 && (r3.close(), r3 = void 0), e3.stop(), s3 = void 0, n3.removeEventListener("ended", a2);
                  };
                  let c2 = window.setInterval(() => {
                    if (s3 && r3 && Date.now() - o2 > (null != t4 ? t4 : 1e3))
                      try {
                        "live" === n3.readyState ? s3.enqueue(r3.clone()) : a2();
                      } catch (e4) {
                        a2();
                      }
                  }, null != t4 ? t4 : 1e3);
                  const d2 = new TransformStream({ transform: (e4, t5) => {
                    "live" === n3.readyState ? (s3 = t5, o2 = Date.now(), void 0 === r3 ? (r3 = e4, t5.enqueue(e4.clone())) : (t5.enqueue(r3), r3 = e4)) : e4.close();
                  } });
                  return n3.addEventListener("ended", a2), i3.readable.pipeThrough(d2).pipeTo(n3.writable), n3;
                }
              }(e2);
              t3 && (KC.info("local screen video track begin to inject frame"), this._mediaStreamTrack = t3);
            }
            t2 && -1 !== this._hints.indexOf(ky.CUSTOM_TRACK) && this.setEncoderConfiguration(t2), this.processorContext = new GA(this.getTrackId(), "local"), this.processorDestination = new jA(this.processorContext), this.bindProcessorDestinationEvents();
          }
          play(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if ("string" == typeof e2) {
              const t3 = document.getElementById(e2);
              t3 ? e2 = t3 : (KC.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
            }
            KC.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
            const i2 = Tb(Tb(Tb({}, this._getDefaultPlayerConfig()), t2), {}, { trackId: this.getTrackId(), element: e2 });
            this._player ? this._player.updateConfig(i2) : (e2 instanceof HTMLVideoElement ? this._player = new ub(i2) : this._player = new _b(i2), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
              try {
                const e3 = this.getVideoElementVisibleStatus();
                this.safeEmit(Fy.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
              } catch (e3) {
              }
            }, kC("CHECK_VIDEO_VISIBLE_INTERVAL"));
          }
          stop() {
            this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._statsTimer && (this.isUseScaleResolutionDownBy = false, window.clearInterval(this._statsTimer), this._statsTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, KC.debug("[".concat(this.getTrackId(), "] stop video playback")));
          }
          async setEnabled(e2, t2) {
            if (!t2) {
              if (e2 === this._enabled)
                return;
              this.stateCheck("enabled", e2);
            }
            if (KC.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), !e2) {
              this._originMediaStreamTrack.enabled = false;
              try {
                await gT(this, Ly.NEED_DISABLE_TRACK, this);
              } catch (e3) {
                throw KC.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
              }
              return t2 || (this._enabled = false), void KC.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
            }
            this._originMediaStreamTrack.enabled = true;
            try {
              await gT(this, Ly.NEED_ENABLE_TRACK, this);
            } catch (e3) {
              throw KC.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
            }
            KC.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
          }
          async setMuted(e2) {
            e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, KC.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await gT(this, Ly.NEED_MUTE_TRACK, this) : await gT(this, Ly.NEED_UNMUTE_TRACK, this));
          }
          async setEncoderConfiguration(e2, t2) {
            if (!this._enabled)
              throw new Vg(xg.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
            if ("720p_auto" === e2 ? this.startMonitorStats() : this._statsTimer && (window.clearInterval(this._statsTimer), this._statsTimer = null), e2 = Ay(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin), e2.width || e2.height || e2.frameRate) {
              const t3 = ib({ encoderConfig: e2 });
              (Sg() || Cg() || Dg()) && (t3.deviceId = void 0), KC.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e2), JSON.stringify(t3));
              try {
                await this._originMediaStreamTrack.applyConstraints(t3), this.updateMediaStreamTrackResolution();
              } catch (e3) {
                const t4 = new Vg(xg.UNEXPECTED_ERROR, e3.toString());
                throw KC.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), t4;
              }
            }
            this._encoderConfig = e2, -1 === this._hints.indexOf(ky.SCREEN_TRACK) && this.updateBitrateFromProfile();
            try {
              await gT(this, Ly.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e3) {
              return e3.throw(KC);
            }
          }
          getStats() {
            NT(() => {
              KC.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
            }, "localVideoTrackGetStatsWarning");
            const e2 = TT(this, Ly.GET_STATS);
            return e2 || Tb({}, Hy);
          }
          async setBeautyEffect(e2) {
            KC.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
          }
          getCurrentFrameData() {
            return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
          }
          async getCurrentFrameImage(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            return this._player ? this._player.getCurrentFrameToUint8Array(e2, t2) : await ab(e2);
          }
          async setBitrateLimit(e2) {
            if (KC.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e2))), e2) {
              this._forceBitrateLimit = e2, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e2.max_bitrate ? this._encoderConfig.bitrateMax : e2.max_bitrate : this._encoderConfig.bitrateMax = e2.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e2.min_bitrate);
              try {
                await gT(this, Ly.NEED_UPDATE_VIDEO_ENCODER, this);
              } catch (e3) {
                return e3.throw(KC);
              }
            }
          }
          async setOptimizationMode(e2) {
            if ("motion" !== e2 && "detail" !== e2 && "balanced" !== e2)
              return void KC.error(xg.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
            const t2 = this._optimizationMode;
            try {
              this._optimizationMode = e2, await gT(this, Ly.SET_OPTIMIZATION_MODE, this);
            } catch (e3) {
              throw this._optimizationMode = t2, KC.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e3.toString()), e3;
            }
            KC.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e2, ")"));
          }
          setScalabiltyMode(e2) {
            if (1 === e2.numSpatialLayers && 1 !== e2.numTemporalLayers)
              return KC.error(xg.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabilityMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
            this._scalabilityMode = e2, KC.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e2, ")"));
          }
          updateMediaStreamTrackResolution() {
            Eb(this._originMediaStreamTrack).then((e2) => {
              let [t2, i2] = e2;
              this._videoHeight = i2, this._videoWidth = t2;
            }).catch(FT);
          }
          _updatePlayerSource() {
            this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
          }
          _getDefaultPlayerConfig() {
            return { fit: "contain" };
          }
          async setSenderConfiguration(e2) {
            if (!this._enabled)
              throw new Vg(xg.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
            KC.debug("[".concat(this.getTrackId(), "] setSenderConfiguration applyConstraints"), JSON.stringify(e2)), e2 = Ay(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin), this._encoderConfig = e2, -1 === this._hints.indexOf(ky.SCREEN_TRACK) && this.updateBitrateFromProfile();
            try {
              await gT(this, Ly.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e3) {
              return e3.throw(KC);
            }
          }
          updateBitrateFromProfile() {
            if (!this._encoderConfig)
              return;
            const { width: e2, height: t2, frameRate: i2 } = this.getMediaStreamTrackSettings();
            if (!e2 || !t2 || !i2)
              return;
            const [n2, r2] = function(e3, t3, i3, n3) {
              let r3;
              const s2 = 200 * Math.pow(i3 / 15, 0.6) * Math.pow(e3 * t3 / 640 / 360, 0.75), o2 = s2;
              if ("STANDARD_BITRATE" === n3)
                r3 = 4 * s2;
              else {
                if ("COMPATIABLE_BITRATE" !== n3)
                  return;
                r3 = 2 * s2;
              }
              return [Math.floor(r3), Math.floor(o2)];
            }(e2, t2, i2, kC("BITRATE_ADAPTER_TYPE")) || [void 0, void 0];
            this._encoderConfig.bitrateMin || this._encoderConfig.bitrateMax || (this._encoderConfig.bitrateMin = r2, this._encoderConfig.bitrateMax = n2, KC.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e2, ", h: ").concat(t2, ", fps: ").concat(i2, "] => [brMax: ").concat(n2, ", brMin: ").concat(r2, "]")));
          }
          getVideoElementVisibleStatus() {
            try {
              var e2, t2;
              const i2 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: s2 } = n2;
              if (this.isPlaying && r2 instanceof HTMLVideoElement && s2 instanceof HTMLElement) {
                const e3 = Qg.checkOneElementVisible(r2), t3 = Object.assign({}, e3);
                if (t3.visible !== this._previousVideoVisibleStatus) {
                  this._previousVideoVisibleStatus = t3.visible;
                  const e4 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                  t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
                }
                return t3;
              }
              return;
            } catch (e3) {
              throw new Vg(xg.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
            }
          }
          async renewMediaStreamTrack(e2) {
          }
          pipe(e2) {
            if (this.processor === e2)
              return e2;
            if (e2._source)
              throw new Vg(xg.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
            return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
          }
          unpipe() {
            if (!this.processor)
              return;
            const e2 = this.processor;
            this.processor._source = void 0, this.processor = void 0, e2.reset();
          }
          close() {
            super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
          }
          clone(e2) {
            let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this._encoderConfig;
            e2 && (i2 = Tb(Tb({}, i2), Ay(e2))), i2 = wT(i2);
            const n2 = xT(8, "track-video-cloned-"), r2 = new Sb(t2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, i2, wT(this._scalabilityMode), this._optimizationMode, n2, wT(this._hints));
            return e2 && i2 && r2.setEncoderConfiguration(i2), KC.debug("clone video track from ".concat(this.getTrackId(), " to ").concat(n2, ", clone ").concat(t2)), r2;
          }
          async replaceTrack(e2, t2) {
            if (!(e2 instanceof MediaStreamTrack))
              throw new Vg(xg.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
            if ("video" !== e2.kind)
              throw new Vg(xg.INVALID_PARAMS, "track should be a video MediaStreamTrack");
            await this._updateOriginMediaStreamTrack(e2, t2, true), this.updateMediaStreamTrackResolution();
          }
          startMonitorStats() {
            if (!Sg() && !Cg())
              return;
            this._statsTimer && window.clearInterval(this._statsTimer);
            let e2 = 2, t2 = vy[e2];
            let i2 = -1;
            let n2 = Date.now();
            const r2 = (e3) => {
              e3 > 2 || e3 < 0 || (n2 = Date.now(), t2 = vy[e3], this.setSenderConfiguration(t2));
            };
            this.isUseScaleResolutionDownBy = true, this._statsTimer = window.setInterval(() => {
              const s2 = this.getStats(), o2 = TT(this, Ly.GET_RTC_STATS);
              if (s2.sendPackets > 0 && o2) {
                -1 === i2 && (i2 = Date.now());
                const a2 = Date.now();
                if (a2 - i2 < 1e3 || a2 - n2 < kC("PROFILE_SWITCH_INTERVAL"))
                  return;
                const c2 = s2.sendFrameRate, d2 = 0.6 * t2.frameRate, l2 = 0.9 * t2.frameRate;
                "number" == typeof c2 && c2 > 0 && c2 < d2 ? e2 > 0 && (e2--, r2(e2), KC.debug("[".concat(this.getTrackId(), "] step down for fps ").concat(c2, ", switchProfile to ").concat(e2))) : o2.OutgoingAvailableBandwidth < t2.bitrateMin ? e2 > 0 && (e2--, r2(e2), KC.debug("[".concat(this.getTrackId(), "] step down for OutgoingAvailableBandwidth ").concat(o2.OutgoingAvailableBandwidth, ", bitrateMin ").concat(t2.bitrateMin, ", switchProfile to ").concat(e2))) : "number" == typeof c2 && c2 > l2 && e2 < vy.length - 1 && o2.OutgoingAvailableBandwidth > 1.2 * vy[e2 + 1].bitrateMin && (e2++, r2(e2), KC.debug("[".concat(this.getTrackId(), "] step up for fps ").concat(c2, ", OutgoingAvailableBandwidth ").concat(o2.OutgoingAvailableBandwidth, ", switchProfile to ").concat(e2)));
              }
            }, kC("CHECK_LOCAL_STATS_INTERVAL"));
          }
          bindProcessorDestinationEvents() {
            this.processorDestination.on(Jy.ON_TRACK, async (e2) => {
              e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(), await gT(this, Ly.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await gT(this, Ly.NEED_REPLACE_TRACK, this));
            });
          }
          unbindProcessorDestinationEvents() {
            this.processorDestination.removeAllListeners(Jy.ON_TRACK);
          }
          unbindProcessorContextEvents() {
            this.processorContext.removeAllListeners(zy.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(zy.REQUEST_CONSTRAINTS);
          }
        }
        Mv([nv({ argsMap: (e2, t2, i2) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Object, Object]), Uv("design:returntype", void 0)], Sb.prototype, "play", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Sb.prototype, "stop", null), Mv([qT("LocalVideoTrack", "_enabledMutex"), nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean, Boolean]), Uv("design:returntype", tg)], Sb.prototype, "setEnabled", null), Mv([qT("LocalVideoTrack", "_enabledMutex"), nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean]), Uv("design:returntype", tg)], Sb.prototype, "setMuted", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Object, Boolean]), Uv("design:returntype", tg)], Sb.prototype, "setEncoderConfiguration", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", Object)], Sb.prototype, "getStats", null), Mv([nv({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2, i2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean, Object]), Uv("design:returntype", tg)], Sb.prototype, "setBeautyEffect", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", ImageData)], Sb.prototype, "getCurrentFrameData", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", [String, Number]), Uv("design:returntype", tg)], Sb.prototype, "getCurrentFrameImage", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], Sb.prototype, "setBitrateLimit", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], Sb.prototype, "setOptimizationMode", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", void 0)], Sb.prototype, "setScalabiltyMode", null), Mv([VA(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Sb.prototype, "updateMediaStreamTrackResolution", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", Object)], Sb.prototype, "pipe", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Sb.prototype, "unpipe", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Sb.prototype, "close", null), Mv([nv({ argsMap: (e2, t2, i2) => [e2.getTrackId(), t2.label, i2] }), Uv("design:type", Function), Uv("design:paramtypes", [MediaStreamTrack, Boolean]), Uv("design:returntype", tg)], Sb.prototype, "replaceTrack", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Sb.prototype, "startMonitorStats", null);
        class Rb extends Sb {
          get __className__() {
            return "CameraVideoTrack";
          }
          constructor(e2, t2, i2, n2, r2, s2) {
            super(e2, Ay(t2.encoderConfig), n2, r2, s2), nu(this, "_config", void 0), nu(this, "_originalConstraints", void 0), nu(this, "_constraints", void 0), nu(this, "_enabled", true), nu(this, "_deviceName", "default"), nu(this, "tryResumeVideoForIOS15_16WeChat", async () => {
              (wg() || Og()) && !function() {
                const e3 = pg();
                if (e3.os !== ag.IOS || !e3.osVersion)
                  return false;
                const t3 = e3.osVersion.split(".");
                return 15 === Number(t3[0]) && Number(t3[1]) >= 2;
              }() && Pg() && this._enabled && !this._isClosed && (KC.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
            }), this._config = t2, this._originalConstraints = i2, this._constraints = i2, this._deviceName = e2.label, this._encoderConfig = Ay(this._config.encoderConfig), oA.on(uy.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), oA.on(uy.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
          }
          async setDevice(e2) {
            return "string" == typeof e2 ? this._setDeviceById(e2) : e2.deviceId ? this._setDeviceById(e2.deviceId) : e2.facingMode ? this._setDeviceByFacingModel(e2.facingMode) : void 0;
          }
          async _setDeviceById(e2) {
            if (KC.info("[".concat(this.getTrackId(), "] set device to ").concat(e2)), this._enabled)
              try {
                const t2 = await OA.getDeviceById(e2), i2 = {};
                i2.video = Tb({}, this._constraints), i2.video.deviceId = { exact: e2 }, i2.video.facingMode = void 0, this._originMediaStreamTrack.stop();
                let n2 = null;
                try {
                  n2 = await yA(i2, this.getTrackId());
                } catch (e3) {
                  throw KC.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await yA({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), e3;
                }
                await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t2.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
              } catch (e3) {
                throw KC.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
              }
            else
              try {
                const t2 = await OA.getDeviceById(e2);
                this._deviceName = t2.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
              } catch (e3) {
                throw KC.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
              }
            KC.info("[".concat(this.getTrackId(), "] setDevice success"));
          }
          async _setDeviceByFacingModel(e2) {
            KC.info("[".concat(this.getTrackId(), "] set facingMode ").concat(e2));
            const t2 = { video: Tb(Tb({}, this._constraints), {}, { deviceId: void 0, facingMode: { exact: e2 } }) };
            if (this._enabled) {
              this._originMediaStreamTrack.stop();
              let e3 = null;
              try {
                e3 = await yA(t2, this.getTrackId());
              } catch (t3) {
                throw KC.error("[".concat(this.getTrackId(), "] setDeviceByFacingModel failed"), t3.toString()), e3 = await yA({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false), t3;
              }
              await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution();
            }
            this._deviceName = "", this._config.facingMode = e2, this._config.cameraId = void 0, this._constraints = Tb({}, t2.video), KC.info("[".concat(this.getTrackId(), "] setDeviceByFacingModel success"));
          }
          async setEnabled(e2, t2) {
            if (!t2) {
              if (e2 === this._enabled)
                return;
              this.stateCheck("enabled", e2);
            }
            if (KC.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
              try {
                if (this.isExternalTrack)
                  this._originMediaStreamTrack.enabled = true;
                else {
                  const e3 = await yA({ video: this._constraints }, this.getTrackId());
                  await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false);
                }
                await gT(this, Ly.NEED_ENABLE_TRACK, this);
              } catch (e3) {
                throw KC.error("[".concat(this.getTrackId(), "] setEnabled true error"), e3.toString()), e3;
              }
              this.updateMediaStreamTrackResolution(), KC.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
            } else {
              this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t2 || (this._enabled = false);
              try {
                await gT(this, Ly.NEED_DISABLE_TRACK, this);
              } catch (e3) {
                throw KC.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
              }
              KC.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
            }
          }
          async setEncoderConfiguration(e2, t2) {
            if (!this._enabled)
              throw new Vg(xg.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
            "720p_auto" === e2 ? this.startMonitorStats() : this._statsTimer && (window.clearInterval(this._statsTimer), this._statsTimer = null), e2 = Ay(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin);
            const i2 = bT(this._config);
            i2.encoderConfig = e2;
            const n2 = ib(i2);
            (Sg() || Cg() || Dg()) && (n2.deviceId = void 0), KC.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e2), JSON.stringify(n2));
            try {
              await this._originMediaStreamTrack.applyConstraints(n2), this.updateMediaStreamTrackResolution();
            } catch (e3) {
              const t3 = new Vg(xg.UNEXPECTED_ERROR, e3.toString());
              throw KC.error("[".concat(this.getTrackId(), "] applyConstraints error"), t3.toString()), t3;
            }
            this._config = i2, this._constraints = n2, this._originalConstraints = n2, this._encoderConfig = e2, -1 === this._hints.indexOf(ky.SCREEN_TRACK) && this.updateBitrateFromProfile();
            try {
              await gT(this, Ly.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e3) {
              return e3.throw(KC);
            }
          }
          _getDefaultPlayerConfig() {
            return { mirror: true, fit: "cover" };
          }
          onTrackEnded() {
            if ((Cg() || Dg()) && this._enabled && !this._isClosed && oA.duringInterruption) {
              const e2 = async () => {
                oA.off(uy.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (KC.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
              };
              oA.on(uy.IOS_INTERRUPTION_END, e2);
            } else
              KC.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(Fy.TRACK_ENDED);
          }
          async renewMediaStreamTrack(e2) {
            const t2 = e2 || this._constraints, i2 = OA.searchDeviceIdByName(this._deviceName);
            if (i2 && !t2.deviceId && (t2.deviceId = { exact: i2 }), this._enabled) {
              const e3 = await yA({ video: t2 }, this.getTrackId());
              this._constraints = t2, await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
            }
          }
          close() {
            super.close(), oA.off(uy.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), oA.off(uy.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
          }
          clone(e2) {
            let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this._encoderConfig;
            e2 && (i2 = Tb(Tb({}, i2), Ay(e2))), i2 = wT(i2);
            const n2 = xT(8, "track-cam-cloned-"), r2 = new Rb(t2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, wT(Tb(Tb({}, this._config), {}, { encoderConfig: i2 })), wT(this._constraints), wT(this._scalabilityMode), this._optimizationMode, n2);
            return e2 && i2 && r2.setEncoderConfiguration(i2), KC.debug("clone track from ".concat(this.getTrackId(), " to ").concat(n2, ", clone ").concat(t2)), r2;
          }
          bindProcessorContextEvents() {
            this.processorContext.on(zy.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, i2) => {
              try {
                const i3 = Object.assign({}, this._originalConstraints, ...e2);
                await this.renewMediaStreamTrack(i3), t2();
              } catch (e3) {
                i2(e3);
              }
            }), this.processorContext.on(zy.REQUEST_CONSTRAINTS, async (e2) => {
              e2(this._originMediaStreamTrack.getSettings());
            });
          }
        }
        function Cb(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function vb(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? Cb(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Cb(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        function Ib(e2, t2, i2, n2) {
          i2.optimizationMode && (n2 && n2.width && n2.height ? (i2.encoderConfig = vb(vb({}, n2), {}, { bitrateMin: n2.bitrateMin, bitrateMax: n2.bitrateMax }), "motion" !== i2.optimizationMode && "detail" !== i2.optimizationMode || (t2.contentHint = i2.optimizationMode, t2.contentHint === i2.optimizationMode ? KC.debug("[".concat(e2, "] set content hint to"), i2.optimizationMode) : KC.debug("[".concat(e2, "] set content hint failed")))) : KC.warning("[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig")));
        }
        function yb(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function Ab(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? yb(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yb(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], Rb.prototype, "setDevice", null), Mv([qT("CameraVideoTrack", "_enabledMutex"), nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean, Boolean]), Uv("design:returntype", tg)], Rb.prototype, "setEnabled", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), VA(), Uv("design:type", Function), Uv("design:paramtypes", [Object, Boolean]), Uv("design:returntype", tg)], Rb.prototype, "setEncoderConfiguration", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Rb.prototype, "close", null);
        class bb extends tA {
          getUserId() {
            return this._userId;
          }
          constructor(e2, t2, i2, n2) {
            super(e2, "track-".concat(e2.kind, "-").concat(t2, "-").concat(n2.clientId, "_").concat(xT(5, ""))), nu(this, "_userId", void 0), nu(this, "_uintId", void 0), nu(this, "_isDestroyed", false), nu(this, "store", void 0), nu(this, "processor", void 0), this._userId = t2, this._uintId = i2, this.store = n2;
          }
          _updateOriginMediaStreamTrack(e2) {
            this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
          }
          _destroy() {
            this._isDestroyed = true, KC.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
          }
          getProcessorStats() {
            return this.processorContext.gatherStats();
          }
          getProcessorUsage() {
            return this.processorContext.gatherUsage();
          }
        }
        class wb extends bb {
          get isPlaying() {
            return !(!this._player || this._player.videoElementStatus !== Zy.PLAYING);
          }
          get __className__() {
            return "RemoteVideoTrack";
          }
          constructor(e2, t2, i2, n2) {
            super(e2, t2, i2, n2), nu(this, "_videoVisibleTimer", null), nu(this, "_previousVideoVisibleStatus", void 0), nu(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), nu(this, "trackMediaType", "video"), nu(this, "_videoWidth", void 0), nu(this, "_videoHeight", void 0), nu(this, "_player", void 0), nu(this, "processorDestination", void 0), nu(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new GA(this.getTrackId(), "remote"), this.processorDestination = new jA(this.processorContext), this.bindProcessorDestinationEvents();
          }
          getStats() {
            NT(() => {
              KC.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
            }, "remoteVideoTrackGetStatsWarning");
            return TT(this, Ly.GET_STATS) || Ab({}, qy);
          }
          play(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if ("string" == typeof e2) {
              const t3 = document.getElementById(e2);
              t3 ? e2 = t3 : (KC.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
            }
            KC.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
            const i2 = Ab(Ab({ fit: "cover" }, t2), {}, { trackId: this.getTrackId(), element: e2 });
            this._player ? this._player.updateConfig(i2) : (e2 instanceof HTMLVideoElement ? this._player = new ub(i2) : this._player = new _b(i2), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
              this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(By.FIRST_FRAME_DECODED);
            }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
              try {
                const e3 = this.getVideoElementVisibleStatus();
                this.safeEmit(By.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
              } catch (e3) {
              }
            }, kC("CHECK_VIDEO_VISIBLE_INTERVAL"));
          }
          stop() {
            this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, KC.debug("[".concat(this.getTrackId(), "] stop video playback")));
          }
          getCurrentFrameData() {
            return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
          }
          updateMediaStreamTrackResolution() {
            Eb(this._originMediaStreamTrack).then((e2) => {
              let [t2, i2] = e2;
              this._videoHeight = i2, this._videoWidth = t2;
            }).catch(FT);
          }
          _updatePlayerSource() {
            KC.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
          }
          getVideoElementVisibleStatus() {
            try {
              var e2, t2;
              const i2 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: s2 } = n2;
              if (this.isPlaying && r2 instanceof HTMLVideoElement && s2 instanceof HTMLElement) {
                const e3 = Qg.checkOneElementVisible(r2), t3 = Object.assign({}, e3);
                if (t3.visible !== this._previousVideoVisibleStatus) {
                  this._previousVideoVisibleStatus = t3.visible;
                  const e4 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                  t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
                }
                return t3;
              }
              return;
            } catch (e3) {
              throw new Vg(xg.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
            }
          }
          pipe(e2) {
            if (this.processor === e2)
              return e2;
            if (e2._source)
              throw new Vg(xg.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
            return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
          }
          unpipe() {
            if (!this.processor)
              return;
            const e2 = this.processor;
            this.processor._source = void 0, this.processor = void 0, e2.reset();
          }
          bindProcessorDestinationEvents() {
            this.processorDestination.on(Jy.ON_TRACK, async (e2) => {
              e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
            });
          }
          unbindProcessorDestinationEvents() {
            this.processorDestination.removeAllListeners(Jy.ON_TRACK);
          }
          _destroy() {
            super._destroy(), this.unbindProcessorDestinationEvents();
          }
        }
        Mv([nv({ argsMap: (e2, t2, i2) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), Uv("design:type", Function), Uv("design:paramtypes", [Object, Object]), Uv("design:returntype", void 0)], wb.prototype, "play", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], wb.prototype, "stop", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", Object)], wb.prototype, "pipe", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], wb.prototype, "unpipe", null);
        class Ob extends bb {
          get isPlaying() {
            return this._useAudioElement ? xA.isPlaying(this.getTrackId()) : this._source.isPlayed;
          }
          get __className__() {
            return "RemoteAudioTrack";
          }
          constructor(e2, t2, i2, n2) {
            super(e2, t2, i2, n2), nu(this, "trackMediaType", "audio"), nu(this, "_source", void 0), nu(this, "_useAudioElement", true), nu(this, "_volume", 100), nu(this, "processorContext", void 0), nu(this, "processorDestination", void 0), nu(this, "_played", false), nu(this, "_bypassWebAudio", false), kC("DISABLE_WEBAUDIO") ? (this._source = new KA(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new fA(e2, true), kC("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(jy.RECEIVE_TRACK_BUFFER, () => {
              this.safeEmit(By.FIRST_FRAME_DECODED);
            }), this.processorContext = new HA(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new WA(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(jy.UPDATE_SOURCE, () => {
              this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
            });
          }
          setAudioFrameCallback(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
            if (!e2)
              return this._source.removeAllListeners(jy.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
            this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(jy.ON_AUDIO_BUFFER), this._source.on(jy.ON_AUDIO_BUFFER, (t3) => e2(t3));
          }
          setVolume(e2) {
            this._volume = e2, this._useAudioElement ? xA.setVolume(this.getTrackId(), e2) : this._source.setVolume(e2 / 100);
          }
          async setPlaybackDevice(e2) {
            if (!this._useAudioElement)
              throw new Vg(xg.NOT_SUPPORTED, "your browser does not support setting the audio output device");
            await xA.setSinkID(this.getTrackId(), e2);
          }
          getVolumeLevel() {
            return this._source.getAccurateVolumeLevel();
          }
          getStats() {
            NT(() => {
              KC.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
            }, "remoteAudioTrackGetStatsWarning");
            return TT(this, Ly.GET_STATS) || Ab({}, Ky);
          }
          play() {
            KC.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (KC.debug("[".concat(this.getTrackId(), "] use audio element to play")), xA.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();
          }
          stop() {
            KC.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? xA.stop(this.getTrackId()) : this._source.stop();
          }
          _destroy() {
            super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
          }
          _isFreeze() {
            return this._source.isFreeze;
          }
          _updatePlayerSource() {
            let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            KC.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && xA.updateTrack(this.getTrackId(), this._mediaStreamTrack);
          }
          pipe(e2) {
            if (this._bypassWebAudio)
              throw new Vg(xg.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
            if (this.processor === e2)
              return e2;
            if (e2._source)
              throw new Vg(xg.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
            return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
          }
          unpipe() {
            var e2;
            if (this._bypassWebAudio)
              throw new Vg(xg.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
            if (!this.processor)
              return;
            const t2 = this.processor;
            null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
          }
          bindProcessorDestinationEvents() {
            this.processorDestination.on(Jy.ON_TRACK, async (e2) => {
              e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
            }), this.processorDestination.on(Jy.ON_NODE, (e2) => {
              this._source.processedNode = e2;
              const t2 = !e2;
              this._useAudioElement !== t2 && (this._played ? (this.stop(), this._useAudioElement = t2, this.play()) : this._useAudioElement = t2);
            });
          }
          unbindProcessorDestinationEvents() {
            this.processorDestination.removeAllListeners(Jy.ON_TRACK), this.processorDestination.removeAllListeners(Jy.ON_NODE);
          }
        }
        Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), Uv("design:type", Function), Uv("design:paramtypes", [Number]), Uv("design:returntype", void 0)], Ob.prototype, "setVolume", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], Ob.prototype, "setPlaybackDevice", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Ob.prototype, "play", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Ob.prototype, "stop", null), Mv([nv({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", Object)], Ob.prototype, "pipe", null), Mv([nv({ argsMap: (e2) => [e2.getTrackId()] }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], Ob.prototype, "unpipe", null);
        function Nb(e2) {
          let t2 = e2.length;
          for (; --t2 >= 0; )
            e2[t2] = 0;
        }
        const Db = 256, Pb = 286, Lb = 30, kb = 15, Mb = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), Ub = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), xb = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), Vb = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Fb = new Array(576);
        Nb(Fb);
        const Bb = new Array(60);
        Nb(Bb);
        const jb = new Array(512);
        Nb(jb);
        const Gb = new Array(256);
        Nb(Gb);
        const Wb = new Array(29);
        Nb(Wb);
        const Hb = new Array(Lb);
        function Kb(e2, t2, i2, n2, r2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = i2, this.elems = n2, this.max_length = r2, this.has_stree = e2 && e2.length;
        }
        let Yb, qb, Jb;
        function zb(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        Nb(Hb);
        const Xb = (e2) => e2 < 256 ? jb[e2] : jb[256 + (e2 >>> 7)], Qb = (e2, t2) => {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }, Zb = (e2, t2, i2) => {
          e2.bi_valid > 16 - i2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, Qb(e2, e2.bi_buf), e2.bi_buf = t2 >> 16 - e2.bi_valid, e2.bi_valid += i2 - 16) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += i2);
        }, $b = (e2, t2, i2) => {
          Zb(e2, i2[2 * t2], i2[2 * t2 + 1]);
        }, ew = (e2, t2) => {
          let i2 = 0;
          do {
            i2 |= 1 & e2, e2 >>>= 1, i2 <<= 1;
          } while (--t2 > 0);
          return i2 >>> 1;
        }, tw = (e2, t2, i2) => {
          const n2 = new Array(16);
          let r2, s2, o2 = 0;
          for (r2 = 1; r2 <= kb; r2++)
            o2 = o2 + i2[r2 - 1] << 1, n2[r2] = o2;
          for (s2 = 0; s2 <= t2; s2++) {
            let t3 = e2[2 * s2 + 1];
            0 !== t3 && (e2[2 * s2] = ew(n2[t3]++, t3));
          }
        }, iw = (e2) => {
          let t2;
          for (t2 = 0; t2 < Pb; t2++)
            e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < Lb; t2++)
            e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < 19; t2++)
            e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[512] = 1, e2.opt_len = e2.static_len = 0, e2.sym_next = e2.matches = 0;
        }, nw = (e2) => {
          e2.bi_valid > 8 ? Qb(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }, rw = (e2, t2, i2, n2) => {
          const r2 = 2 * t2, s2 = 2 * i2;
          return e2[r2] < e2[s2] || e2[r2] === e2[s2] && n2[t2] <= n2[i2];
        }, sw = (e2, t2, i2) => {
          const n2 = e2.heap[i2];
          let r2 = i2 << 1;
          for (; r2 <= e2.heap_len && (r2 < e2.heap_len && rw(t2, e2.heap[r2 + 1], e2.heap[r2], e2.depth) && r2++, !rw(t2, n2, e2.heap[r2], e2.depth)); )
            e2.heap[i2] = e2.heap[r2], i2 = r2, r2 <<= 1;
          e2.heap[i2] = n2;
        }, ow = (e2, t2, i2) => {
          let n2, r2, s2, o2, a2 = 0;
          if (0 !== e2.sym_next)
            do {
              n2 = 255 & e2.pending_buf[e2.sym_buf + a2++], n2 += (255 & e2.pending_buf[e2.sym_buf + a2++]) << 8, r2 = e2.pending_buf[e2.sym_buf + a2++], 0 === n2 ? $b(e2, r2, t2) : (s2 = Gb[r2], $b(e2, s2 + Db + 1, t2), o2 = Mb[s2], 0 !== o2 && (r2 -= Wb[s2], Zb(e2, r2, o2)), n2--, s2 = Xb(n2), $b(e2, s2, i2), o2 = Ub[s2], 0 !== o2 && (n2 -= Hb[s2], Zb(e2, n2, o2)));
            } while (a2 < e2.sym_next);
          $b(e2, 256, t2);
        }, aw = (e2, t2) => {
          const i2 = t2.dyn_tree, n2 = t2.stat_desc.static_tree, r2 = t2.stat_desc.has_stree, s2 = t2.stat_desc.elems;
          let o2, a2, c2, d2 = -1;
          for (e2.heap_len = 0, e2.heap_max = 573, o2 = 0; o2 < s2; o2++)
            0 !== i2[2 * o2] ? (e2.heap[++e2.heap_len] = d2 = o2, e2.depth[o2] = 0) : i2[2 * o2 + 1] = 0;
          for (; e2.heap_len < 2; )
            c2 = e2.heap[++e2.heap_len] = d2 < 2 ? ++d2 : 0, i2[2 * c2] = 1, e2.depth[c2] = 0, e2.opt_len--, r2 && (e2.static_len -= n2[2 * c2 + 1]);
          for (t2.max_code = d2, o2 = e2.heap_len >> 1; o2 >= 1; o2--)
            sw(e2, i2, o2);
          c2 = s2;
          do {
            o2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], sw(e2, i2, 1), a2 = e2.heap[1], e2.heap[--e2.heap_max] = o2, e2.heap[--e2.heap_max] = a2, i2[2 * c2] = i2[2 * o2] + i2[2 * a2], e2.depth[c2] = (e2.depth[o2] >= e2.depth[a2] ? e2.depth[o2] : e2.depth[a2]) + 1, i2[2 * o2 + 1] = i2[2 * a2 + 1] = c2, e2.heap[1] = c2++, sw(e2, i2, 1);
          } while (e2.heap_len >= 2);
          e2.heap[--e2.heap_max] = e2.heap[1], ((e3, t3) => {
            const i3 = t3.dyn_tree, n3 = t3.max_code, r3 = t3.stat_desc.static_tree, s3 = t3.stat_desc.has_stree, o3 = t3.stat_desc.extra_bits, a3 = t3.stat_desc.extra_base, c3 = t3.stat_desc.max_length;
            let d3, l2, h2, u2, p2, _2, E2 = 0;
            for (u2 = 0; u2 <= kb; u2++)
              e3.bl_count[u2] = 0;
            for (i3[2 * e3.heap[e3.heap_max] + 1] = 0, d3 = e3.heap_max + 1; d3 < 573; d3++)
              l2 = e3.heap[d3], u2 = i3[2 * i3[2 * l2 + 1] + 1] + 1, u2 > c3 && (u2 = c3, E2++), i3[2 * l2 + 1] = u2, l2 > n3 || (e3.bl_count[u2]++, p2 = 0, l2 >= a3 && (p2 = o3[l2 - a3]), _2 = i3[2 * l2], e3.opt_len += _2 * (u2 + p2), s3 && (e3.static_len += _2 * (r3[2 * l2 + 1] + p2)));
            if (0 !== E2) {
              do {
                for (u2 = c3 - 1; 0 === e3.bl_count[u2]; )
                  u2--;
                e3.bl_count[u2]--, e3.bl_count[u2 + 1] += 2, e3.bl_count[c3]--, E2 -= 2;
              } while (E2 > 0);
              for (u2 = c3; 0 !== u2; u2--)
                for (l2 = e3.bl_count[u2]; 0 !== l2; )
                  h2 = e3.heap[--d3], h2 > n3 || (i3[2 * h2 + 1] !== u2 && (e3.opt_len += (u2 - i3[2 * h2 + 1]) * i3[2 * h2], i3[2 * h2 + 1] = u2), l2--);
            }
          })(e2, t2), tw(i2, d2, e2.bl_count);
        }, cw = (e2, t2, i2) => {
          let n2, r2, s2 = -1, o2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
          for (0 === o2 && (c2 = 138, d2 = 3), t2[2 * (i2 + 1) + 1] = 65535, n2 = 0; n2 <= i2; n2++)
            r2 = o2, o2 = t2[2 * (n2 + 1) + 1], ++a2 < c2 && r2 === o2 || (a2 < d2 ? e2.bl_tree[2 * r2] += a2 : 0 !== r2 ? (r2 !== s2 && e2.bl_tree[2 * r2]++, e2.bl_tree[32]++) : a2 <= 10 ? e2.bl_tree[34]++ : e2.bl_tree[36]++, a2 = 0, s2 = r2, 0 === o2 ? (c2 = 138, d2 = 3) : r2 === o2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4));
        }, dw = (e2, t2, i2) => {
          let n2, r2, s2 = -1, o2 = t2[1], a2 = 0, c2 = 7, d2 = 4;
          for (0 === o2 && (c2 = 138, d2 = 3), n2 = 0; n2 <= i2; n2++)
            if (r2 = o2, o2 = t2[2 * (n2 + 1) + 1], !(++a2 < c2 && r2 === o2)) {
              if (a2 < d2)
                do {
                  $b(e2, r2, e2.bl_tree);
                } while (0 != --a2);
              else
                0 !== r2 ? (r2 !== s2 && ($b(e2, r2, e2.bl_tree), a2--), $b(e2, 16, e2.bl_tree), Zb(e2, a2 - 3, 2)) : a2 <= 10 ? ($b(e2, 17, e2.bl_tree), Zb(e2, a2 - 3, 3)) : ($b(e2, 18, e2.bl_tree), Zb(e2, a2 - 11, 7));
              a2 = 0, s2 = r2, 0 === o2 ? (c2 = 138, d2 = 3) : r2 === o2 ? (c2 = 6, d2 = 3) : (c2 = 7, d2 = 4);
            }
        };
        let lw = false;
        const hw = (e2, t2, i2, n2) => {
          Zb(e2, 0 + (n2 ? 1 : 0), 3), nw(e2), Qb(e2, i2), Qb(e2, ~i2), i2 && e2.pending_buf.set(e2.window.subarray(t2, t2 + i2), e2.pending), e2.pending += i2;
        };
        var uw = (e2) => {
          lw || ((() => {
            let e3, t2, i2, n2, r2;
            const s2 = new Array(16);
            for (i2 = 0, n2 = 0; n2 < 28; n2++)
              for (Wb[n2] = i2, e3 = 0; e3 < 1 << Mb[n2]; e3++)
                Gb[i2++] = n2;
            for (Gb[i2 - 1] = n2, r2 = 0, n2 = 0; n2 < 16; n2++)
              for (Hb[n2] = r2, e3 = 0; e3 < 1 << Ub[n2]; e3++)
                jb[r2++] = n2;
            for (r2 >>= 7; n2 < Lb; n2++)
              for (Hb[n2] = r2 << 7, e3 = 0; e3 < 1 << Ub[n2] - 7; e3++)
                jb[256 + r2++] = n2;
            for (t2 = 0; t2 <= kb; t2++)
              s2[t2] = 0;
            for (e3 = 0; e3 <= 143; )
              Fb[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; )
              Fb[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; )
              Fb[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; )
              Fb[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (tw(Fb, 287, s2), e3 = 0; e3 < Lb; e3++)
              Bb[2 * e3 + 1] = 5, Bb[2 * e3] = ew(e3, 5);
            Yb = new Kb(Fb, Mb, 257, Pb, kb), qb = new Kb(Bb, Ub, 0, Lb, kb), Jb = new Kb(new Array(0), xb, 0, 19, 7);
          })(), lw = true), e2.l_desc = new zb(e2.dyn_ltree, Yb), e2.d_desc = new zb(e2.dyn_dtree, qb), e2.bl_desc = new zb(e2.bl_tree, Jb), e2.bi_buf = 0, e2.bi_valid = 0, iw(e2);
        }, pw = (e2, t2, i2, n2) => {
          let r2, s2, o2 = 0;
          e2.level > 0 ? (2 === e2.strm.data_type && (e2.strm.data_type = ((e3) => {
            let t3, i3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, i3 >>>= 1)
              if (1 & i3 && 0 !== e3.dyn_ltree[2 * t3])
                return 0;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
              return 1;
            for (t3 = 32; t3 < Db; t3++)
              if (0 !== e3.dyn_ltree[2 * t3])
                return 1;
            return 0;
          })(e2)), aw(e2, e2.l_desc), aw(e2, e2.d_desc), o2 = ((e3) => {
            let t3;
            for (cw(e3, e3.dyn_ltree, e3.l_desc.max_code), cw(e3, e3.dyn_dtree, e3.d_desc.max_code), aw(e3, e3.bl_desc), t3 = 18; t3 >= 3 && 0 === e3.bl_tree[2 * Vb[t3] + 1]; t3--)
              ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          })(e2), r2 = e2.opt_len + 3 + 7 >>> 3, s2 = e2.static_len + 3 + 7 >>> 3, s2 <= r2 && (r2 = s2)) : r2 = s2 = i2 + 5, i2 + 4 <= r2 && -1 !== t2 ? hw(e2, t2, i2, n2) : 4 === e2.strategy || s2 === r2 ? (Zb(e2, 2 + (n2 ? 1 : 0), 3), ow(e2, Fb, Bb)) : (Zb(e2, 4 + (n2 ? 1 : 0), 3), ((e3, t3, i3, n3) => {
            let r3;
            for (Zb(e3, t3 - 257, 5), Zb(e3, i3 - 1, 5), Zb(e3, n3 - 4, 4), r3 = 0; r3 < n3; r3++)
              Zb(e3, e3.bl_tree[2 * Vb[r3] + 1], 3);
            dw(e3, e3.dyn_ltree, t3 - 1), dw(e3, e3.dyn_dtree, i3 - 1);
          })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, o2 + 1), ow(e2, e2.dyn_ltree, e2.dyn_dtree)), iw(e2), n2 && nw(e2);
        }, _w = (e2, t2, i2) => (e2.pending_buf[e2.sym_buf + e2.sym_next++] = t2, e2.pending_buf[e2.sym_buf + e2.sym_next++] = t2 >> 8, e2.pending_buf[e2.sym_buf + e2.sym_next++] = i2, 0 === t2 ? e2.dyn_ltree[2 * i2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (Gb[i2] + Db + 1)]++, e2.dyn_dtree[2 * Xb(t2)]++), e2.sym_next === e2.sym_end), Ew = { _tr_init: uw, _tr_stored_block: hw, _tr_flush_block: pw, _tr_tally: _w, _tr_align: (e2) => {
          Zb(e2, 2, 3), $b(e2, 256, Fb), ((e3) => {
            16 === e3.bi_valid ? (Qb(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          })(e2);
        } };
        var mw = (e2, t2, i2, n2) => {
          let r2 = 65535 & e2 | 0, s2 = e2 >>> 16 & 65535 | 0, o2 = 0;
          for (; 0 !== i2; ) {
            o2 = i2 > 2e3 ? 2e3 : i2, i2 -= o2;
            do {
              r2 = r2 + t2[n2++] | 0, s2 = s2 + r2 | 0;
            } while (--o2);
            r2 %= 65521, s2 %= 65521;
          }
          return r2 | s2 << 16 | 0;
        };
        const fw = new Uint32Array((() => {
          let e2, t2 = [];
          for (var i2 = 0; i2 < 256; i2++) {
            e2 = i2;
            for (var n2 = 0; n2 < 8; n2++)
              e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[i2] = e2;
          }
          return t2;
        })());
        var gw = (e2, t2, i2, n2) => {
          const r2 = fw, s2 = n2 + i2;
          e2 ^= -1;
          for (let i3 = n2; i3 < s2; i3++)
            e2 = e2 >>> 8 ^ r2[255 & (e2 ^ t2[i3])];
          return -1 ^ e2;
        }, Tw = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, Sw = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
        const { _tr_init: Rw, _tr_stored_block: Cw, _tr_flush_block: vw, _tr_tally: Iw, _tr_align: yw } = Ew, { Z_NO_FLUSH: Aw, Z_PARTIAL_FLUSH: bw, Z_FULL_FLUSH: ww, Z_FINISH: Ow, Z_BLOCK: Nw, Z_OK: Dw, Z_STREAM_END: Pw, Z_STREAM_ERROR: Lw, Z_DATA_ERROR: kw, Z_BUF_ERROR: Mw, Z_DEFAULT_COMPRESSION: Uw, Z_FILTERED: xw, Z_HUFFMAN_ONLY: Vw, Z_RLE: Fw, Z_FIXED: Bw, Z_DEFAULT_STRATEGY: jw, Z_UNKNOWN: Gw, Z_DEFLATED: Ww } = Sw, Hw = 286, Kw = 30, Yw = 19, qw = 2 * Hw + 1, Jw = 15, zw = 258, Xw = 262, Qw = 42, Zw = 113, $w = 666, eO = (e2, t2) => (e2.msg = Tw[t2], t2), tO = (e2) => 2 * e2 - (e2 > 4 ? 9 : 0), iO = (e2) => {
          let t2 = e2.length;
          for (; --t2 >= 0; )
            e2[t2] = 0;
        }, nO = (e2) => {
          let t2, i2, n2, r2 = e2.w_size;
          t2 = e2.hash_size, n2 = t2;
          do {
            i2 = e2.head[--n2], e2.head[n2] = i2 >= r2 ? i2 - r2 : 0;
          } while (--t2);
          t2 = r2, n2 = t2;
          do {
            i2 = e2.prev[--n2], e2.prev[n2] = i2 >= r2 ? i2 - r2 : 0;
          } while (--t2);
        };
        let rO = (e2, t2, i2) => (t2 << e2.hash_shift ^ i2) & e2.hash_mask;
        const sO = (e2) => {
          const t2 = e2.state;
          let i2 = t2.pending;
          i2 > e2.avail_out && (i2 = e2.avail_out), 0 !== i2 && (e2.output.set(t2.pending_buf.subarray(t2.pending_out, t2.pending_out + i2), e2.next_out), e2.next_out += i2, t2.pending_out += i2, e2.total_out += i2, e2.avail_out -= i2, t2.pending -= i2, 0 === t2.pending && (t2.pending_out = 0));
        }, oO = (e2, t2) => {
          vw(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, sO(e2.strm);
        }, aO = (e2, t2) => {
          e2.pending_buf[e2.pending++] = t2;
        }, cO = (e2, t2) => {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }, dO = (e2, t2, i2, n2) => {
          let r2 = e2.avail_in;
          return r2 > n2 && (r2 = n2), 0 === r2 ? 0 : (e2.avail_in -= r2, t2.set(e2.input.subarray(e2.next_in, e2.next_in + r2), i2), 1 === e2.state.wrap ? e2.adler = mw(e2.adler, t2, r2, i2) : 2 === e2.state.wrap && (e2.adler = gw(e2.adler, t2, r2, i2)), e2.next_in += r2, e2.total_in += r2, r2);
        }, lO = (e2, t2) => {
          let i2, n2, r2 = e2.max_chain_length, s2 = e2.strstart, o2 = e2.prev_length, a2 = e2.nice_match;
          const c2 = e2.strstart > e2.w_size - Xw ? e2.strstart - (e2.w_size - Xw) : 0, d2 = e2.window, l2 = e2.w_mask, h2 = e2.prev, u2 = e2.strstart + zw;
          let p2 = d2[s2 + o2 - 1], _2 = d2[s2 + o2];
          e2.prev_length >= e2.good_match && (r2 >>= 2), a2 > e2.lookahead && (a2 = e2.lookahead);
          do {
            if (i2 = t2, d2[i2 + o2] === _2 && d2[i2 + o2 - 1] === p2 && d2[i2] === d2[s2] && d2[++i2] === d2[s2 + 1]) {
              s2 += 2, i2++;
              do {
              } while (d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && d2[++s2] === d2[++i2] && s2 < u2);
              if (n2 = zw - (u2 - s2), s2 = u2 - zw, n2 > o2) {
                if (e2.match_start = t2, o2 = n2, n2 >= a2)
                  break;
                p2 = d2[s2 + o2 - 1], _2 = d2[s2 + o2];
              }
            }
          } while ((t2 = h2[t2 & l2]) > c2 && 0 != --r2);
          return o2 <= e2.lookahead ? o2 : e2.lookahead;
        }, hO = (e2) => {
          const t2 = e2.w_size;
          let i2, n2, r2;
          do {
            if (n2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= t2 + (t2 - Xw) && (e2.window.set(e2.window.subarray(t2, t2 + t2 - n2), 0), e2.match_start -= t2, e2.strstart -= t2, e2.block_start -= t2, e2.insert > e2.strstart && (e2.insert = e2.strstart), nO(e2), n2 += t2), 0 === e2.strm.avail_in)
              break;
            if (i2 = dO(e2.strm, e2.window, e2.strstart + e2.lookahead, n2), e2.lookahead += i2, e2.lookahead + e2.insert >= 3)
              for (r2 = e2.strstart - e2.insert, e2.ins_h = e2.window[r2], e2.ins_h = rO(e2, e2.ins_h, e2.window[r2 + 1]); e2.insert && (e2.ins_h = rO(e2, e2.ins_h, e2.window[r2 + 3 - 1]), e2.prev[r2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = r2, r2++, e2.insert--, !(e2.lookahead + e2.insert < 3)); )
                ;
          } while (e2.lookahead < Xw && 0 !== e2.strm.avail_in);
        }, uO = (e2, t2) => {
          let i2, n2, r2, s2 = e2.pending_buf_size - 5 > e2.w_size ? e2.w_size : e2.pending_buf_size - 5, o2 = 0, a2 = e2.strm.avail_in;
          do {
            if (i2 = 65535, r2 = e2.bi_valid + 42 >> 3, e2.strm.avail_out < r2)
              break;
            if (r2 = e2.strm.avail_out - r2, n2 = e2.strstart - e2.block_start, i2 > n2 + e2.strm.avail_in && (i2 = n2 + e2.strm.avail_in), i2 > r2 && (i2 = r2), i2 < s2 && (0 === i2 && t2 !== Ow || t2 === Aw || i2 !== n2 + e2.strm.avail_in))
              break;
            o2 = t2 === Ow && i2 === n2 + e2.strm.avail_in ? 1 : 0, Cw(e2, 0, 0, o2), e2.pending_buf[e2.pending - 4] = i2, e2.pending_buf[e2.pending - 3] = i2 >> 8, e2.pending_buf[e2.pending - 2] = ~i2, e2.pending_buf[e2.pending - 1] = ~i2 >> 8, sO(e2.strm), n2 && (n2 > i2 && (n2 = i2), e2.strm.output.set(e2.window.subarray(e2.block_start, e2.block_start + n2), e2.strm.next_out), e2.strm.next_out += n2, e2.strm.avail_out -= n2, e2.strm.total_out += n2, e2.block_start += n2, i2 -= n2), i2 && (dO(e2.strm, e2.strm.output, e2.strm.next_out, i2), e2.strm.next_out += i2, e2.strm.avail_out -= i2, e2.strm.total_out += i2);
          } while (0 === o2);
          return a2 -= e2.strm.avail_in, a2 && (a2 >= e2.w_size ? (e2.matches = 2, e2.window.set(e2.strm.input.subarray(e2.strm.next_in - e2.w_size, e2.strm.next_in), 0), e2.strstart = e2.w_size, e2.insert = e2.strstart) : (e2.window_size - e2.strstart <= a2 && (e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, e2.insert > e2.strstart && (e2.insert = e2.strstart)), e2.window.set(e2.strm.input.subarray(e2.strm.next_in - a2, e2.strm.next_in), e2.strstart), e2.strstart += a2, e2.insert += a2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : a2), e2.block_start = e2.strstart), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), o2 ? 4 : t2 !== Aw && t2 !== Ow && 0 === e2.strm.avail_in && e2.strstart === e2.block_start ? 2 : (r2 = e2.window_size - e2.strstart, e2.strm.avail_in > r2 && e2.block_start >= e2.w_size && (e2.block_start -= e2.w_size, e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, r2 += e2.w_size, e2.insert > e2.strstart && (e2.insert = e2.strstart)), r2 > e2.strm.avail_in && (r2 = e2.strm.avail_in), r2 && (dO(e2.strm, e2.window, e2.strstart, r2), e2.strstart += r2, e2.insert += r2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : r2), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), r2 = e2.bi_valid + 42 >> 3, r2 = e2.pending_buf_size - r2 > 65535 ? 65535 : e2.pending_buf_size - r2, s2 = r2 > e2.w_size ? e2.w_size : r2, n2 = e2.strstart - e2.block_start, (n2 >= s2 || (n2 || t2 === Ow) && t2 !== Aw && 0 === e2.strm.avail_in && n2 <= r2) && (i2 = n2 > r2 ? r2 : n2, o2 = t2 === Ow && 0 === e2.strm.avail_in && i2 === n2 ? 1 : 0, Cw(e2, e2.block_start, i2, o2), e2.block_start += i2, sO(e2.strm)), o2 ? 3 : 1);
        }, pO = (e2, t2) => {
          let i2, n2;
          for (; ; ) {
            if (e2.lookahead < Xw) {
              if (hO(e2), e2.lookahead < Xw && t2 === Aw)
                return 1;
              if (0 === e2.lookahead)
                break;
            }
            if (i2 = 0, e2.lookahead >= 3 && (e2.ins_h = rO(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== i2 && e2.strstart - i2 <= e2.w_size - Xw && (e2.match_length = lO(e2, i2)), e2.match_length >= 3)
              if (n2 = Iw(e2, e2.strstart - e2.match_start, e2.match_length - 3), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= 3) {
                e2.match_length--;
                do {
                  e2.strstart++, e2.ins_h = rO(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
                } while (0 != --e2.match_length);
                e2.strstart++;
              } else
                e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = rO(e2, e2.ins_h, e2.window[e2.strstart + 1]);
            else
              n2 = Iw(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (oO(e2, false), 0 === e2.strm.avail_out))
              return 1;
          }
          return e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === Ow ? (oO(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (oO(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
        }, _O = (e2, t2) => {
          let i2, n2, r2;
          for (; ; ) {
            if (e2.lookahead < Xw) {
              if (hO(e2), e2.lookahead < Xw && t2 === Aw)
                return 1;
              if (0 === e2.lookahead)
                break;
            }
            if (i2 = 0, e2.lookahead >= 3 && (e2.ins_h = rO(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = 2, 0 !== i2 && e2.prev_length < e2.max_lazy_match && e2.strstart - i2 <= e2.w_size - Xw && (e2.match_length = lO(e2, i2), e2.match_length <= 5 && (e2.strategy === xw || 3 === e2.match_length && e2.strstart - e2.match_start > 4096) && (e2.match_length = 2)), e2.prev_length >= 3 && e2.match_length <= e2.prev_length) {
              r2 = e2.strstart + e2.lookahead - 3, n2 = Iw(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - 3), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
              do {
                ++e2.strstart <= r2 && (e2.ins_h = rO(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
              } while (0 != --e2.prev_length);
              if (e2.match_available = 0, e2.match_length = 2, e2.strstart++, n2 && (oO(e2, false), 0 === e2.strm.avail_out))
                return 1;
            } else if (e2.match_available) {
              if (n2 = Iw(e2, 0, e2.window[e2.strstart - 1]), n2 && oO(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
                return 1;
            } else
              e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = Iw(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === Ow ? (oO(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (oO(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
        };
        function EO(e2, t2, i2, n2, r2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = i2, this.max_chain = n2, this.func = r2;
        }
        const mO = [new EO(0, 0, 0, 0, uO), new EO(4, 4, 8, 4, pO), new EO(4, 5, 16, 8, pO), new EO(4, 6, 32, 32, pO), new EO(4, 4, 16, 16, _O), new EO(8, 16, 32, 32, _O), new EO(8, 16, 128, 128, _O), new EO(8, 32, 128, 256, _O), new EO(32, 128, 258, 1024, _O), new EO(32, 258, 258, 4096, _O)];
        function fO() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Ww, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * qw), this.dyn_dtree = new Uint16Array(2 * (2 * Kw + 1)), this.bl_tree = new Uint16Array(2 * (2 * Yw + 1)), iO(this.dyn_ltree), iO(this.dyn_dtree), iO(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(Jw + 1), this.heap = new Uint16Array(2 * Hw + 1), iO(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * Hw + 1), iO(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        const gO = (e2) => {
          if (!e2)
            return 1;
          const t2 = e2.state;
          return !t2 || t2.strm !== e2 || t2.status !== Qw && 57 !== t2.status && 69 !== t2.status && 73 !== t2.status && 91 !== t2.status && 103 !== t2.status && t2.status !== Zw && t2.status !== $w ? 1 : 0;
        }, TO = (e2) => {
          if (gO(e2))
            return eO(e2, Lw);
          e2.total_in = e2.total_out = 0, e2.data_type = Gw;
          const t2 = e2.state;
          return t2.pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = 2 === t2.wrap ? 57 : t2.wrap ? Qw : Zw, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = -2, Rw(t2), Dw;
        }, SO = (e2) => {
          const t2 = TO(e2);
          var i2;
          return t2 === Dw && ((i2 = e2.state).window_size = 2 * i2.w_size, iO(i2.head), i2.max_lazy_match = mO[i2.level].max_lazy, i2.good_match = mO[i2.level].good_length, i2.nice_match = mO[i2.level].nice_length, i2.max_chain_length = mO[i2.level].max_chain, i2.strstart = 0, i2.block_start = 0, i2.lookahead = 0, i2.insert = 0, i2.match_length = i2.prev_length = 2, i2.match_available = 0, i2.ins_h = 0), t2;
        }, RO = (e2, t2, i2, n2, r2, s2) => {
          if (!e2)
            return Lw;
          let o2 = 1;
          if (t2 === Uw && (t2 = 6), n2 < 0 ? (o2 = 0, n2 = -n2) : n2 > 15 && (o2 = 2, n2 -= 16), r2 < 1 || r2 > 9 || i2 !== Ww || n2 < 8 || n2 > 15 || t2 < 0 || t2 > 9 || s2 < 0 || s2 > Bw || 8 === n2 && 1 !== o2)
            return eO(e2, Lw);
          8 === n2 && (n2 = 9);
          const a2 = new fO();
          return e2.state = a2, a2.strm = e2, a2.status = Qw, a2.wrap = o2, a2.gzhead = null, a2.w_bits = n2, a2.w_size = 1 << a2.w_bits, a2.w_mask = a2.w_size - 1, a2.hash_bits = r2 + 7, a2.hash_size = 1 << a2.hash_bits, a2.hash_mask = a2.hash_size - 1, a2.hash_shift = ~~((a2.hash_bits + 3 - 1) / 3), a2.window = new Uint8Array(2 * a2.w_size), a2.head = new Uint16Array(a2.hash_size), a2.prev = new Uint16Array(a2.w_size), a2.lit_bufsize = 1 << r2 + 6, a2.pending_buf_size = 4 * a2.lit_bufsize, a2.pending_buf = new Uint8Array(a2.pending_buf_size), a2.sym_buf = a2.lit_bufsize, a2.sym_end = 3 * (a2.lit_bufsize - 1), a2.level = t2, a2.strategy = s2, a2.method = i2, SO(e2);
        };
        var CO = (e2, t2) => {
          if (gO(e2) || t2 > Nw || t2 < 0)
            return e2 ? eO(e2, Lw) : Lw;
          const i2 = e2.state;
          if (!e2.output || 0 !== e2.avail_in && !e2.input || i2.status === $w && t2 !== Ow)
            return eO(e2, 0 === e2.avail_out ? Mw : Lw);
          const n2 = i2.last_flush;
          if (i2.last_flush = t2, 0 !== i2.pending) {
            if (sO(e2), 0 === e2.avail_out)
              return i2.last_flush = -1, Dw;
          } else if (0 === e2.avail_in && tO(t2) <= tO(n2) && t2 !== Ow)
            return eO(e2, Mw);
          if (i2.status === $w && 0 !== e2.avail_in)
            return eO(e2, Mw);
          if (i2.status === Qw && 0 === i2.wrap && (i2.status = Zw), i2.status === Qw) {
            let t3 = Ww + (i2.w_bits - 8 << 4) << 8, n3 = -1;
            if (n3 = i2.strategy >= Vw || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3, t3 |= n3 << 6, 0 !== i2.strstart && (t3 |= 32), t3 += 31 - t3 % 31, cO(i2, t3), 0 !== i2.strstart && (cO(i2, e2.adler >>> 16), cO(i2, 65535 & e2.adler)), e2.adler = 1, i2.status = Zw, sO(e2), 0 !== i2.pending)
              return i2.last_flush = -1, Dw;
          }
          if (57 === i2.status) {
            if (e2.adler = 0, aO(i2, 31), aO(i2, 139), aO(i2, 8), i2.gzhead)
              aO(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), aO(i2, 255 & i2.gzhead.time), aO(i2, i2.gzhead.time >> 8 & 255), aO(i2, i2.gzhead.time >> 16 & 255), aO(i2, i2.gzhead.time >> 24 & 255), aO(i2, 9 === i2.level ? 2 : i2.strategy >= Vw || i2.level < 2 ? 4 : 0), aO(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (aO(i2, 255 & i2.gzhead.extra.length), aO(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (e2.adler = gw(e2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69;
            else if (aO(i2, 0), aO(i2, 0), aO(i2, 0), aO(i2, 0), aO(i2, 0), aO(i2, 9 === i2.level ? 2 : i2.strategy >= Vw || i2.level < 2 ? 4 : 0), aO(i2, 3), i2.status = Zw, sO(e2), 0 !== i2.pending)
              return i2.last_flush = -1, Dw;
          }
          if (69 === i2.status) {
            if (i2.gzhead.extra) {
              let t3 = i2.pending, n3 = (65535 & i2.gzhead.extra.length) - i2.gzindex;
              for (; i2.pending + n3 > i2.pending_buf_size; ) {
                let r3 = i2.pending_buf_size - i2.pending;
                if (i2.pending_buf.set(i2.gzhead.extra.subarray(i2.gzindex, i2.gzindex + r3), i2.pending), i2.pending = i2.pending_buf_size, i2.gzhead.hcrc && i2.pending > t3 && (e2.adler = gw(e2.adler, i2.pending_buf, i2.pending - t3, t3)), i2.gzindex += r3, sO(e2), 0 !== i2.pending)
                  return i2.last_flush = -1, Dw;
                t3 = 0, n3 -= r3;
              }
              let r2 = new Uint8Array(i2.gzhead.extra);
              i2.pending_buf.set(r2.subarray(i2.gzindex, i2.gzindex + n3), i2.pending), i2.pending += n3, i2.gzhead.hcrc && i2.pending > t3 && (e2.adler = gw(e2.adler, i2.pending_buf, i2.pending - t3, t3)), i2.gzindex = 0;
            }
            i2.status = 73;
          }
          if (73 === i2.status) {
            if (i2.gzhead.name) {
              let t3, n3 = i2.pending;
              do {
                if (i2.pending === i2.pending_buf_size) {
                  if (i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = gw(e2.adler, i2.pending_buf, i2.pending - n3, n3)), sO(e2), 0 !== i2.pending)
                    return i2.last_flush = -1, Dw;
                  n3 = 0;
                }
                t3 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, aO(i2, t3);
              } while (0 !== t3);
              i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = gw(e2.adler, i2.pending_buf, i2.pending - n3, n3)), i2.gzindex = 0;
            }
            i2.status = 91;
          }
          if (91 === i2.status) {
            if (i2.gzhead.comment) {
              let t3, n3 = i2.pending;
              do {
                if (i2.pending === i2.pending_buf_size) {
                  if (i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = gw(e2.adler, i2.pending_buf, i2.pending - n3, n3)), sO(e2), 0 !== i2.pending)
                    return i2.last_flush = -1, Dw;
                  n3 = 0;
                }
                t3 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, aO(i2, t3);
              } while (0 !== t3);
              i2.gzhead.hcrc && i2.pending > n3 && (e2.adler = gw(e2.adler, i2.pending_buf, i2.pending - n3, n3));
            }
            i2.status = 103;
          }
          if (103 === i2.status) {
            if (i2.gzhead.hcrc) {
              if (i2.pending + 2 > i2.pending_buf_size && (sO(e2), 0 !== i2.pending))
                return i2.last_flush = -1, Dw;
              aO(i2, 255 & e2.adler), aO(i2, e2.adler >> 8 & 255), e2.adler = 0;
            }
            if (i2.status = Zw, sO(e2), 0 !== i2.pending)
              return i2.last_flush = -1, Dw;
          }
          if (0 !== e2.avail_in || 0 !== i2.lookahead || t2 !== Aw && i2.status !== $w) {
            let n3 = 0 === i2.level ? uO(i2, t2) : i2.strategy === Vw ? ((e3, t3) => {
              let i3;
              for (; ; ) {
                if (0 === e3.lookahead && (hO(e3), 0 === e3.lookahead)) {
                  if (t3 === Aw)
                    return 1;
                  break;
                }
                if (e3.match_length = 0, i3 = Iw(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, i3 && (oO(e3, false), 0 === e3.strm.avail_out))
                  return 1;
              }
              return e3.insert = 0, t3 === Ow ? (oO(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (oO(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
            })(i2, t2) : i2.strategy === Fw ? ((e3, t3) => {
              let i3, n4, r2, s2;
              const o2 = e3.window;
              for (; ; ) {
                if (e3.lookahead <= zw) {
                  if (hO(e3), e3.lookahead <= zw && t3 === Aw)
                    return 1;
                  if (0 === e3.lookahead)
                    break;
                }
                if (e3.match_length = 0, e3.lookahead >= 3 && e3.strstart > 0 && (r2 = e3.strstart - 1, n4 = o2[r2], n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2])) {
                  s2 = e3.strstart + zw;
                  do {
                  } while (n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && n4 === o2[++r2] && r2 < s2);
                  e3.match_length = zw - (s2 - r2), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= 3 ? (i3 = Iw(e3, 1, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (i3 = Iw(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), i3 && (oO(e3, false), 0 === e3.strm.avail_out))
                  return 1;
              }
              return e3.insert = 0, t3 === Ow ? (oO(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (oO(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
            })(i2, t2) : mO[i2.level].func(i2, t2);
            if (3 !== n3 && 4 !== n3 || (i2.status = $w), 1 === n3 || 3 === n3)
              return 0 === e2.avail_out && (i2.last_flush = -1), Dw;
            if (2 === n3 && (t2 === bw ? yw(i2) : t2 !== Nw && (Cw(i2, 0, 0, false), t2 === ww && (iO(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), sO(e2), 0 === e2.avail_out))
              return i2.last_flush = -1, Dw;
          }
          return t2 !== Ow ? Dw : i2.wrap <= 0 ? Pw : (2 === i2.wrap ? (aO(i2, 255 & e2.adler), aO(i2, e2.adler >> 8 & 255), aO(i2, e2.adler >> 16 & 255), aO(i2, e2.adler >> 24 & 255), aO(i2, 255 & e2.total_in), aO(i2, e2.total_in >> 8 & 255), aO(i2, e2.total_in >> 16 & 255), aO(i2, e2.total_in >> 24 & 255)) : (cO(i2, e2.adler >>> 16), cO(i2, 65535 & e2.adler)), sO(e2), i2.wrap > 0 && (i2.wrap = -i2.wrap), 0 !== i2.pending ? Dw : Pw);
        }, vO = (e2, t2) => {
          let i2 = t2.length;
          if (gO(e2))
            return Lw;
          const n2 = e2.state, r2 = n2.wrap;
          if (2 === r2 || 1 === r2 && n2.status !== Qw || n2.lookahead)
            return Lw;
          if (1 === r2 && (e2.adler = mw(e2.adler, t2, i2, 0)), n2.wrap = 0, i2 >= n2.w_size) {
            0 === r2 && (iO(n2.head), n2.strstart = 0, n2.block_start = 0, n2.insert = 0);
            let e3 = new Uint8Array(n2.w_size);
            e3.set(t2.subarray(i2 - n2.w_size, i2), 0), t2 = e3, i2 = n2.w_size;
          }
          const s2 = e2.avail_in, o2 = e2.next_in, a2 = e2.input;
          for (e2.avail_in = i2, e2.next_in = 0, e2.input = t2, hO(n2); n2.lookahead >= 3; ) {
            let e3 = n2.strstart, t3 = n2.lookahead - 2;
            do {
              n2.ins_h = rO(n2, n2.ins_h, n2.window[e3 + 3 - 1]), n2.prev[e3 & n2.w_mask] = n2.head[n2.ins_h], n2.head[n2.ins_h] = e3, e3++;
            } while (--t3);
            n2.strstart = e3, n2.lookahead = 2, hO(n2);
          }
          return n2.strstart += n2.lookahead, n2.block_start = n2.strstart, n2.insert = n2.lookahead, n2.lookahead = 0, n2.match_length = n2.prev_length = 2, n2.match_available = 0, e2.next_in = o2, e2.input = a2, e2.avail_in = s2, n2.wrap = r2, Dw;
        }, IO = { deflateInit: (e2, t2) => RO(e2, t2, Ww, 15, 8, jw), deflateInit2: RO, deflateReset: SO, deflateResetKeep: TO, deflateSetHeader: (e2, t2) => gO(e2) || 2 !== e2.state.wrap ? Lw : (e2.state.gzhead = t2, Dw), deflate: CO, deflateEnd: (e2) => {
          if (gO(e2))
            return Lw;
          const t2 = e2.state.status;
          return e2.state = null, t2 === Zw ? eO(e2, kw) : Dw;
        }, deflateSetDictionary: vO, deflateInfo: "pako deflate (from Nodeca project)" };
        const yO = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
        var AO = { assign: function(e2) {
          const t2 = Array.prototype.slice.call(arguments, 1);
          for (; t2.length; ) {
            const i2 = t2.shift();
            if (i2) {
              if ("object" != typeof i2)
                throw new TypeError(i2 + "must be non-object");
              for (const t3 in i2)
                yO(i2, t3) && (e2[t3] = i2[t3]);
            }
          }
          return e2;
        }, flattenChunks: (e2) => {
          let t2 = 0;
          for (let i3 = 0, n2 = e2.length; i3 < n2; i3++)
            t2 += e2[i3].length;
          const i2 = new Uint8Array(t2);
          for (let t3 = 0, n2 = 0, r2 = e2.length; t3 < r2; t3++) {
            let r3 = e2[t3];
            i2.set(r3, n2), n2 += r3.length;
          }
          return i2;
        } };
        let bO = true;
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          bO = false;
        }
        const wO = new Uint8Array(256);
        for (let e2 = 0; e2 < 256; e2++)
          wO[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
        wO[254] = wO[254] = 1;
        var OO = { string2buf: (e2) => {
          if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
            return new TextEncoder().encode(e2);
          let t2, i2, n2, r2, s2, o2 = e2.length, a2 = 0;
          for (r2 = 0; r2 < o2; r2++)
            i2 = e2.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < o2 && (n2 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), r2++)), a2 += i2 < 128 ? 1 : i2 < 2048 ? 2 : i2 < 65536 ? 3 : 4;
          for (t2 = new Uint8Array(a2), s2 = 0, r2 = 0; s2 < a2; r2++)
            i2 = e2.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < o2 && (n2 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n2) && (i2 = 65536 + (i2 - 55296 << 10) + (n2 - 56320), r2++)), i2 < 128 ? t2[s2++] = i2 : i2 < 2048 ? (t2[s2++] = 192 | i2 >>> 6, t2[s2++] = 128 | 63 & i2) : i2 < 65536 ? (t2[s2++] = 224 | i2 >>> 12, t2[s2++] = 128 | i2 >>> 6 & 63, t2[s2++] = 128 | 63 & i2) : (t2[s2++] = 240 | i2 >>> 18, t2[s2++] = 128 | i2 >>> 12 & 63, t2[s2++] = 128 | i2 >>> 6 & 63, t2[s2++] = 128 | 63 & i2);
          return t2;
        }, buf2string: (e2, t2) => {
          const i2 = t2 || e2.length;
          if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
            return new TextDecoder().decode(e2.subarray(0, t2));
          let n2, r2;
          const s2 = new Array(2 * i2);
          for (r2 = 0, n2 = 0; n2 < i2; ) {
            let t3 = e2[n2++];
            if (t3 < 128) {
              s2[r2++] = t3;
              continue;
            }
            let o2 = wO[t3];
            if (o2 > 4)
              s2[r2++] = 65533, n2 += o2 - 1;
            else {
              for (t3 &= 2 === o2 ? 31 : 3 === o2 ? 15 : 7; o2 > 1 && n2 < i2; )
                t3 = t3 << 6 | 63 & e2[n2++], o2--;
              o2 > 1 ? s2[r2++] = 65533 : t3 < 65536 ? s2[r2++] = t3 : (t3 -= 65536, s2[r2++] = 55296 | t3 >> 10 & 1023, s2[r2++] = 56320 | 1023 & t3);
            }
          }
          return ((e3, t3) => {
            if (t3 < 65534 && e3.subarray && bO)
              return String.fromCharCode.apply(null, e3.length === t3 ? e3 : e3.subarray(0, t3));
            let i3 = "";
            for (let n3 = 0; n3 < t3; n3++)
              i3 += String.fromCharCode(e3[n3]);
            return i3;
          })(s2, r2);
        }, utf8border: (e2, t2) => {
          (t2 = t2 || e2.length) > e2.length && (t2 = e2.length);
          let i2 = t2 - 1;
          for (; i2 >= 0 && 128 == (192 & e2[i2]); )
            i2--;
          return i2 < 0 || 0 === i2 ? t2 : i2 + wO[e2[i2]] > t2 ? i2 : t2;
        } };
        var NO = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
        const DO = Object.prototype.toString, { Z_NO_FLUSH: PO, Z_SYNC_FLUSH: LO, Z_FULL_FLUSH: kO, Z_FINISH: MO, Z_OK: UO, Z_STREAM_END: xO, Z_DEFAULT_COMPRESSION: VO, Z_DEFAULT_STRATEGY: FO, Z_DEFLATED: BO } = Sw;
        function jO(e2) {
          this.options = AO.assign({ level: VO, method: BO, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: FO }, e2 || {});
          let t2 = this.options;
          t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new NO(), this.strm.avail_out = 0;
          let i2 = IO.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (i2 !== UO)
            throw new Error(Tw[i2]);
          if (t2.header && IO.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            let e3;
            if (e3 = "string" == typeof t2.dictionary ? OO.string2buf(t2.dictionary) : "[object ArrayBuffer]" === DO.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, i2 = IO.deflateSetDictionary(this.strm, e3), i2 !== UO)
              throw new Error(Tw[i2]);
            this._dict_set = true;
          }
        }
        function GO(e2, t2) {
          const i2 = new jO(t2);
          if (i2.push(e2, true), i2.err)
            throw i2.msg || Tw[i2.err];
          return i2.result;
        }
        jO.prototype.push = function(e2, t2) {
          const i2 = this.strm, n2 = this.options.chunkSize;
          let r2, s2;
          if (this.ended)
            return false;
          for (s2 = t2 === ~~t2 ? t2 : true === t2 ? MO : PO, "string" == typeof e2 ? i2.input = OO.string2buf(e2) : "[object ArrayBuffer]" === DO.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; )
            if (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), (s2 === LO || s2 === kO) && i2.avail_out <= 6)
              this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
            else {
              if (r2 = IO.deflate(i2, s2), r2 === xO)
                return i2.next_out > 0 && this.onData(i2.output.subarray(0, i2.next_out)), r2 = IO.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === UO;
              if (0 !== i2.avail_out) {
                if (s2 > 0 && i2.next_out > 0)
                  this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
                else if (0 === i2.avail_in)
                  break;
              } else
                this.onData(i2.output);
            }
          return true;
        }, jO.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, jO.prototype.onEnd = function(e2) {
          e2 === UO && (this.result = AO.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        };
        var WO = { Deflate: jO, deflate: GO, deflateRaw: function(e2, t2) {
          return (t2 = t2 || {}).raw = true, GO(e2, t2);
        }, gzip: function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, GO(e2, t2);
        }, constants: Sw };
        const HO = 16209;
        var KO = function(e2, t2) {
          let i2, n2, r2, s2, o2, a2, c2, d2, l2, h2, u2, p2, _2, E2, m2, f2, g2, T2, S2, R2, C2, v2, I2, y2;
          const A2 = e2.state;
          i2 = e2.next_in, I2 = e2.input, n2 = i2 + (e2.avail_in - 5), r2 = e2.next_out, y2 = e2.output, s2 = r2 - (t2 - e2.avail_out), o2 = r2 + (e2.avail_out - 257), a2 = A2.dmax, c2 = A2.wsize, d2 = A2.whave, l2 = A2.wnext, h2 = A2.window, u2 = A2.hold, p2 = A2.bits, _2 = A2.lencode, E2 = A2.distcode, m2 = (1 << A2.lenbits) - 1, f2 = (1 << A2.distbits) - 1;
          e:
            do {
              p2 < 15 && (u2 += I2[i2++] << p2, p2 += 8, u2 += I2[i2++] << p2, p2 += 8), g2 = _2[u2 & m2];
              t:
                for (; ; ) {
                  if (T2 = g2 >>> 24, u2 >>>= T2, p2 -= T2, T2 = g2 >>> 16 & 255, 0 === T2)
                    y2[r2++] = 65535 & g2;
                  else {
                    if (!(16 & T2)) {
                      if (0 == (64 & T2)) {
                        g2 = _2[(65535 & g2) + (u2 & (1 << T2) - 1)];
                        continue t;
                      }
                      if (32 & T2) {
                        A2.mode = 16191;
                        break e;
                      }
                      e2.msg = "invalid literal/length code", A2.mode = HO;
                      break e;
                    }
                    S2 = 65535 & g2, T2 &= 15, T2 && (p2 < T2 && (u2 += I2[i2++] << p2, p2 += 8), S2 += u2 & (1 << T2) - 1, u2 >>>= T2, p2 -= T2), p2 < 15 && (u2 += I2[i2++] << p2, p2 += 8, u2 += I2[i2++] << p2, p2 += 8), g2 = E2[u2 & f2];
                    i:
                      for (; ; ) {
                        if (T2 = g2 >>> 24, u2 >>>= T2, p2 -= T2, T2 = g2 >>> 16 & 255, !(16 & T2)) {
                          if (0 == (64 & T2)) {
                            g2 = E2[(65535 & g2) + (u2 & (1 << T2) - 1)];
                            continue i;
                          }
                          e2.msg = "invalid distance code", A2.mode = HO;
                          break e;
                        }
                        if (R2 = 65535 & g2, T2 &= 15, p2 < T2 && (u2 += I2[i2++] << p2, p2 += 8, p2 < T2 && (u2 += I2[i2++] << p2, p2 += 8)), R2 += u2 & (1 << T2) - 1, R2 > a2) {
                          e2.msg = "invalid distance too far back", A2.mode = HO;
                          break e;
                        }
                        if (u2 >>>= T2, p2 -= T2, T2 = r2 - s2, R2 > T2) {
                          if (T2 = R2 - T2, T2 > d2 && A2.sane) {
                            e2.msg = "invalid distance too far back", A2.mode = HO;
                            break e;
                          }
                          if (C2 = 0, v2 = h2, 0 === l2) {
                            if (C2 += c2 - T2, T2 < S2) {
                              S2 -= T2;
                              do {
                                y2[r2++] = h2[C2++];
                              } while (--T2);
                              C2 = r2 - R2, v2 = y2;
                            }
                          } else if (l2 < T2) {
                            if (C2 += c2 + l2 - T2, T2 -= l2, T2 < S2) {
                              S2 -= T2;
                              do {
                                y2[r2++] = h2[C2++];
                              } while (--T2);
                              if (C2 = 0, l2 < S2) {
                                T2 = l2, S2 -= T2;
                                do {
                                  y2[r2++] = h2[C2++];
                                } while (--T2);
                                C2 = r2 - R2, v2 = y2;
                              }
                            }
                          } else if (C2 += l2 - T2, T2 < S2) {
                            S2 -= T2;
                            do {
                              y2[r2++] = h2[C2++];
                            } while (--T2);
                            C2 = r2 - R2, v2 = y2;
                          }
                          for (; S2 > 2; )
                            y2[r2++] = v2[C2++], y2[r2++] = v2[C2++], y2[r2++] = v2[C2++], S2 -= 3;
                          S2 && (y2[r2++] = v2[C2++], S2 > 1 && (y2[r2++] = v2[C2++]));
                        } else {
                          C2 = r2 - R2;
                          do {
                            y2[r2++] = y2[C2++], y2[r2++] = y2[C2++], y2[r2++] = y2[C2++], S2 -= 3;
                          } while (S2 > 2);
                          S2 && (y2[r2++] = y2[C2++], S2 > 1 && (y2[r2++] = y2[C2++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (i2 < n2 && r2 < o2);
          S2 = p2 >> 3, i2 -= S2, p2 -= S2 << 3, u2 &= (1 << p2) - 1, e2.next_in = i2, e2.next_out = r2, e2.avail_in = i2 < n2 ? n2 - i2 + 5 : 5 - (i2 - n2), e2.avail_out = r2 < o2 ? o2 - r2 + 257 : 257 - (r2 - o2), A2.hold = u2, A2.bits = p2;
        };
        const YO = 15, qO = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), JO = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), zO = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), XO = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
        var QO = (e2, t2, i2, n2, r2, s2, o2, a2) => {
          const c2 = a2.bits;
          let d2, l2, h2, u2, p2, _2, E2 = 0, m2 = 0, f2 = 0, g2 = 0, T2 = 0, S2 = 0, R2 = 0, C2 = 0, v2 = 0, I2 = 0, y2 = null;
          const A2 = new Uint16Array(16), b2 = new Uint16Array(16);
          let w2, O2, N2, D2 = null;
          for (E2 = 0; E2 <= YO; E2++)
            A2[E2] = 0;
          for (m2 = 0; m2 < n2; m2++)
            A2[t2[i2 + m2]]++;
          for (T2 = c2, g2 = YO; g2 >= 1 && 0 === A2[g2]; g2--)
            ;
          if (T2 > g2 && (T2 = g2), 0 === g2)
            return r2[s2++] = 20971520, r2[s2++] = 20971520, a2.bits = 1, 0;
          for (f2 = 1; f2 < g2 && 0 === A2[f2]; f2++)
            ;
          for (T2 < f2 && (T2 = f2), C2 = 1, E2 = 1; E2 <= YO; E2++)
            if (C2 <<= 1, C2 -= A2[E2], C2 < 0)
              return -1;
          if (C2 > 0 && (0 === e2 || 1 !== g2))
            return -1;
          for (b2[1] = 0, E2 = 1; E2 < YO; E2++)
            b2[E2 + 1] = b2[E2] + A2[E2];
          for (m2 = 0; m2 < n2; m2++)
            0 !== t2[i2 + m2] && (o2[b2[t2[i2 + m2]]++] = m2);
          if (0 === e2 ? (y2 = D2 = o2, _2 = 20) : 1 === e2 ? (y2 = qO, D2 = JO, _2 = 257) : (y2 = zO, D2 = XO, _2 = 0), I2 = 0, m2 = 0, E2 = f2, p2 = s2, S2 = T2, R2 = 0, h2 = -1, v2 = 1 << T2, u2 = v2 - 1, 1 === e2 && v2 > 852 || 2 === e2 && v2 > 592)
            return 1;
          for (; ; ) {
            w2 = E2 - R2, o2[m2] + 1 < _2 ? (O2 = 0, N2 = o2[m2]) : o2[m2] >= _2 ? (O2 = D2[o2[m2] - _2], N2 = y2[o2[m2] - _2]) : (O2 = 96, N2 = 0), d2 = 1 << E2 - R2, l2 = 1 << S2, f2 = l2;
            do {
              l2 -= d2, r2[p2 + (I2 >> R2) + l2] = w2 << 24 | O2 << 16 | N2 | 0;
            } while (0 !== l2);
            for (d2 = 1 << E2 - 1; I2 & d2; )
              d2 >>= 1;
            if (0 !== d2 ? (I2 &= d2 - 1, I2 += d2) : I2 = 0, m2++, 0 == --A2[E2]) {
              if (E2 === g2)
                break;
              E2 = t2[i2 + o2[m2]];
            }
            if (E2 > T2 && (I2 & u2) !== h2) {
              for (0 === R2 && (R2 = T2), p2 += f2, S2 = E2 - R2, C2 = 1 << S2; S2 + R2 < g2 && (C2 -= A2[S2 + R2], !(C2 <= 0)); )
                S2++, C2 <<= 1;
              if (v2 += 1 << S2, 1 === e2 && v2 > 852 || 2 === e2 && v2 > 592)
                return 1;
              h2 = I2 & u2, r2[h2] = T2 << 24 | S2 << 16 | p2 - s2 | 0;
            }
          }
          return 0 !== I2 && (r2[p2 + I2] = E2 - R2 << 24 | 64 << 16 | 0), a2.bits = T2, 0;
        };
        const { Z_FINISH: ZO, Z_BLOCK: $O, Z_TREES: eN, Z_OK: tN, Z_STREAM_END: iN, Z_NEED_DICT: nN, Z_STREAM_ERROR: rN, Z_DATA_ERROR: sN, Z_MEM_ERROR: oN, Z_BUF_ERROR: aN, Z_DEFLATED: cN } = Sw, dN = 16180, lN = 16190, hN = 16191, uN = 16192, pN = 16194, _N = 16199, EN = 16200, mN = 16206, fN = 16209, gN = (e2) => (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        function TN() {
          this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        const SN = (e2) => {
          if (!e2)
            return 1;
          const t2 = e2.state;
          return !t2 || t2.strm !== e2 || t2.mode < dN || t2.mode > 16211 ? 1 : 0;
        }, RN = (e2) => {
          if (SN(e2))
            return rN;
          const t2 = e2.state;
          return e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = dN, t2.last = 0, t2.havedict = 0, t2.flags = -1, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new Int32Array(852), t2.distcode = t2.distdyn = new Int32Array(592), t2.sane = 1, t2.back = -1, tN;
        }, CN = (e2) => {
          if (SN(e2))
            return rN;
          const t2 = e2.state;
          return t2.wsize = 0, t2.whave = 0, t2.wnext = 0, RN(e2);
        }, vN = (e2, t2) => {
          let i2;
          if (SN(e2))
            return rN;
          const n2 = e2.state;
          return t2 < 0 ? (i2 = 0, t2 = -t2) : (i2 = 5 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? rN : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = i2, n2.wbits = t2, CN(e2));
        }, IN = (e2, t2) => {
          if (!e2)
            return rN;
          const i2 = new TN();
          e2.state = i2, i2.strm = e2, i2.window = null, i2.mode = dN;
          const n2 = vN(e2, t2);
          return n2 !== tN && (e2.state = null), n2;
        };
        let yN, AN, bN = true;
        const wN = (e2) => {
          if (bN) {
            yN = new Int32Array(512), AN = new Int32Array(32);
            let t2 = 0;
            for (; t2 < 144; )
              e2.lens[t2++] = 8;
            for (; t2 < 256; )
              e2.lens[t2++] = 9;
            for (; t2 < 280; )
              e2.lens[t2++] = 7;
            for (; t2 < 288; )
              e2.lens[t2++] = 8;
            for (QO(1, e2.lens, 0, 288, yN, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
              e2.lens[t2++] = 5;
            QO(2, e2.lens, 0, 32, AN, 0, e2.work, { bits: 5 }), bN = false;
          }
          e2.lencode = yN, e2.lenbits = 9, e2.distcode = AN, e2.distbits = 5;
        }, ON = (e2, t2, i2, n2) => {
          let r2;
          const s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new Uint8Array(s2.wsize)), n2 >= s2.wsize ? (s2.window.set(t2.subarray(i2 - s2.wsize, i2), 0), s2.wnext = 0, s2.whave = s2.wsize) : (r2 = s2.wsize - s2.wnext, r2 > n2 && (r2 = n2), s2.window.set(t2.subarray(i2 - n2, i2 - n2 + r2), s2.wnext), (n2 -= r2) ? (s2.window.set(t2.subarray(i2 - n2, i2), 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += r2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += r2))), 0;
        };
        var NN = (e2, t2) => {
          let i2, n2, r2, s2, o2, a2, c2, d2, l2, h2, u2, p2, _2, E2, m2, f2, g2, T2, S2, R2, C2, v2, I2 = 0;
          const y2 = new Uint8Array(4);
          let A2, b2;
          const w2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
          if (SN(e2) || !e2.output || !e2.input && 0 !== e2.avail_in)
            return rN;
          i2 = e2.state, i2.mode === hN && (i2.mode = uN), o2 = e2.next_out, r2 = e2.output, c2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, a2 = e2.avail_in, d2 = i2.hold, l2 = i2.bits, h2 = a2, u2 = c2, v2 = tN;
          e:
            for (; ; )
              switch (i2.mode) {
                case dN:
                  if (0 === i2.wrap) {
                    i2.mode = uN;
                    break;
                  }
                  for (; l2 < 16; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (2 & i2.wrap && 35615 === d2) {
                    0 === i2.wbits && (i2.wbits = 15), i2.check = 0, y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = gw(i2.check, y2, 2, 0), d2 = 0, l2 = 0, i2.mode = 16181;
                    break;
                  }
                  if (i2.head && (i2.head.done = false), !(1 & i2.wrap) || (((255 & d2) << 8) + (d2 >> 8)) % 31) {
                    e2.msg = "incorrect header check", i2.mode = fN;
                    break;
                  }
                  if ((15 & d2) !== cN) {
                    e2.msg = "unknown compression method", i2.mode = fN;
                    break;
                  }
                  if (d2 >>>= 4, l2 -= 4, C2 = 8 + (15 & d2), 0 === i2.wbits && (i2.wbits = C2), C2 > 15 || C2 > i2.wbits) {
                    e2.msg = "invalid window size", i2.mode = fN;
                    break;
                  }
                  i2.dmax = 1 << i2.wbits, i2.flags = 0, e2.adler = i2.check = 1, i2.mode = 512 & d2 ? 16189 : hN, d2 = 0, l2 = 0;
                  break;
                case 16181:
                  for (; l2 < 16; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (i2.flags = d2, (255 & i2.flags) !== cN) {
                    e2.msg = "unknown compression method", i2.mode = fN;
                    break;
                  }
                  if (57344 & i2.flags) {
                    e2.msg = "unknown header flags set", i2.mode = fN;
                    break;
                  }
                  i2.head && (i2.head.text = d2 >> 8 & 1), 512 & i2.flags && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = gw(i2.check, y2, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16182;
                case 16182:
                  for (; l2 < 32; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  i2.head && (i2.head.time = d2), 512 & i2.flags && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, y2[2] = d2 >>> 16 & 255, y2[3] = d2 >>> 24 & 255, i2.check = gw(i2.check, y2, 4, 0)), d2 = 0, l2 = 0, i2.mode = 16183;
                case 16183:
                  for (; l2 < 16; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  i2.head && (i2.head.xflags = 255 & d2, i2.head.os = d2 >> 8), 512 & i2.flags && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = gw(i2.check, y2, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16184;
                case 16184:
                  if (1024 & i2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    i2.length = d2, i2.head && (i2.head.extra_len = d2), 512 & i2.flags && 4 & i2.wrap && (y2[0] = 255 & d2, y2[1] = d2 >>> 8 & 255, i2.check = gw(i2.check, y2, 2, 0)), d2 = 0, l2 = 0;
                  } else
                    i2.head && (i2.head.extra = null);
                  i2.mode = 16185;
                case 16185:
                  if (1024 & i2.flags && (p2 = i2.length, p2 > a2 && (p2 = a2), p2 && (i2.head && (C2 = i2.head.extra_len - i2.length, i2.head.extra || (i2.head.extra = new Uint8Array(i2.head.extra_len)), i2.head.extra.set(n2.subarray(s2, s2 + p2), C2)), 512 & i2.flags && 4 & i2.wrap && (i2.check = gw(i2.check, n2, p2, s2)), a2 -= p2, s2 += p2, i2.length -= p2), i2.length))
                    break e;
                  i2.length = 0, i2.mode = 16186;
                case 16186:
                  if (2048 & i2.flags) {
                    if (0 === a2)
                      break e;
                    p2 = 0;
                    do {
                      C2 = n2[s2 + p2++], i2.head && C2 && i2.length < 65536 && (i2.head.name += String.fromCharCode(C2));
                    } while (C2 && p2 < a2);
                    if (512 & i2.flags && 4 & i2.wrap && (i2.check = gw(i2.check, n2, p2, s2)), a2 -= p2, s2 += p2, C2)
                      break e;
                  } else
                    i2.head && (i2.head.name = null);
                  i2.length = 0, i2.mode = 16187;
                case 16187:
                  if (4096 & i2.flags) {
                    if (0 === a2)
                      break e;
                    p2 = 0;
                    do {
                      C2 = n2[s2 + p2++], i2.head && C2 && i2.length < 65536 && (i2.head.comment += String.fromCharCode(C2));
                    } while (C2 && p2 < a2);
                    if (512 & i2.flags && 4 & i2.wrap && (i2.check = gw(i2.check, n2, p2, s2)), a2 -= p2, s2 += p2, C2)
                      break e;
                  } else
                    i2.head && (i2.head.comment = null);
                  i2.mode = 16188;
                case 16188:
                  if (512 & i2.flags) {
                    for (; l2 < 16; ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (4 & i2.wrap && d2 !== (65535 & i2.check)) {
                      e2.msg = "header crc mismatch", i2.mode = fN;
                      break;
                    }
                    d2 = 0, l2 = 0;
                  }
                  i2.head && (i2.head.hcrc = i2.flags >> 9 & 1, i2.head.done = true), e2.adler = i2.check = 0, i2.mode = hN;
                  break;
                case 16189:
                  for (; l2 < 32; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  e2.adler = i2.check = gN(d2), d2 = 0, l2 = 0, i2.mode = lN;
                case lN:
                  if (0 === i2.havedict)
                    return e2.next_out = o2, e2.avail_out = c2, e2.next_in = s2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, nN;
                  e2.adler = i2.check = 1, i2.mode = hN;
                case hN:
                  if (t2 === $O || t2 === eN)
                    break e;
                case uN:
                  if (i2.last) {
                    d2 >>>= 7 & l2, l2 -= 7 & l2, i2.mode = mN;
                    break;
                  }
                  for (; l2 < 3; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  switch (i2.last = 1 & d2, d2 >>>= 1, l2 -= 1, 3 & d2) {
                    case 0:
                      i2.mode = 16193;
                      break;
                    case 1:
                      if (wN(i2), i2.mode = _N, t2 === eN) {
                        d2 >>>= 2, l2 -= 2;
                        break e;
                      }
                      break;
                    case 2:
                      i2.mode = 16196;
                      break;
                    case 3:
                      e2.msg = "invalid block type", i2.mode = fN;
                  }
                  d2 >>>= 2, l2 -= 2;
                  break;
                case 16193:
                  for (d2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  if ((65535 & d2) != (d2 >>> 16 ^ 65535)) {
                    e2.msg = "invalid stored block lengths", i2.mode = fN;
                    break;
                  }
                  if (i2.length = 65535 & d2, d2 = 0, l2 = 0, i2.mode = pN, t2 === eN)
                    break e;
                case pN:
                  i2.mode = 16195;
                case 16195:
                  if (p2 = i2.length, p2) {
                    if (p2 > a2 && (p2 = a2), p2 > c2 && (p2 = c2), 0 === p2)
                      break e;
                    r2.set(n2.subarray(s2, s2 + p2), o2), a2 -= p2, s2 += p2, c2 -= p2, o2 += p2, i2.length -= p2;
                    break;
                  }
                  i2.mode = hN;
                  break;
                case 16196:
                  for (; l2 < 14; ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (i2.nlen = 257 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ndist = 1 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ncode = 4 + (15 & d2), d2 >>>= 4, l2 -= 4, i2.nlen > 286 || i2.ndist > 30) {
                    e2.msg = "too many length or distance symbols", i2.mode = fN;
                    break;
                  }
                  i2.have = 0, i2.mode = 16197;
                case 16197:
                  for (; i2.have < i2.ncode; ) {
                    for (; l2 < 3; ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    i2.lens[w2[i2.have++]] = 7 & d2, d2 >>>= 3, l2 -= 3;
                  }
                  for (; i2.have < 19; )
                    i2.lens[w2[i2.have++]] = 0;
                  if (i2.lencode = i2.lendyn, i2.lenbits = 7, A2 = { bits: i2.lenbits }, v2 = QO(0, i2.lens, 0, 19, i2.lencode, 0, i2.work, A2), i2.lenbits = A2.bits, v2) {
                    e2.msg = "invalid code lengths set", i2.mode = fN;
                    break;
                  }
                  i2.have = 0, i2.mode = 16198;
                case 16198:
                  for (; i2.have < i2.nlen + i2.ndist; ) {
                    for (; I2 = i2.lencode[d2 & (1 << i2.lenbits) - 1], m2 = I2 >>> 24, f2 = I2 >>> 16 & 255, g2 = 65535 & I2, !(m2 <= l2); ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (g2 < 16)
                      d2 >>>= m2, l2 -= m2, i2.lens[i2.have++] = g2;
                    else {
                      if (16 === g2) {
                        for (b2 = m2 + 2; l2 < b2; ) {
                          if (0 === a2)
                            break e;
                          a2--, d2 += n2[s2++] << l2, l2 += 8;
                        }
                        if (d2 >>>= m2, l2 -= m2, 0 === i2.have) {
                          e2.msg = "invalid bit length repeat", i2.mode = fN;
                          break;
                        }
                        C2 = i2.lens[i2.have - 1], p2 = 3 + (3 & d2), d2 >>>= 2, l2 -= 2;
                      } else if (17 === g2) {
                        for (b2 = m2 + 3; l2 < b2; ) {
                          if (0 === a2)
                            break e;
                          a2--, d2 += n2[s2++] << l2, l2 += 8;
                        }
                        d2 >>>= m2, l2 -= m2, C2 = 0, p2 = 3 + (7 & d2), d2 >>>= 3, l2 -= 3;
                      } else {
                        for (b2 = m2 + 7; l2 < b2; ) {
                          if (0 === a2)
                            break e;
                          a2--, d2 += n2[s2++] << l2, l2 += 8;
                        }
                        d2 >>>= m2, l2 -= m2, C2 = 0, p2 = 11 + (127 & d2), d2 >>>= 7, l2 -= 7;
                      }
                      if (i2.have + p2 > i2.nlen + i2.ndist) {
                        e2.msg = "invalid bit length repeat", i2.mode = fN;
                        break;
                      }
                      for (; p2--; )
                        i2.lens[i2.have++] = C2;
                    }
                  }
                  if (i2.mode === fN)
                    break;
                  if (0 === i2.lens[256]) {
                    e2.msg = "invalid code -- missing end-of-block", i2.mode = fN;
                    break;
                  }
                  if (i2.lenbits = 9, A2 = { bits: i2.lenbits }, v2 = QO(1, i2.lens, 0, i2.nlen, i2.lencode, 0, i2.work, A2), i2.lenbits = A2.bits, v2) {
                    e2.msg = "invalid literal/lengths set", i2.mode = fN;
                    break;
                  }
                  if (i2.distbits = 6, i2.distcode = i2.distdyn, A2 = { bits: i2.distbits }, v2 = QO(2, i2.lens, i2.nlen, i2.ndist, i2.distcode, 0, i2.work, A2), i2.distbits = A2.bits, v2) {
                    e2.msg = "invalid distances set", i2.mode = fN;
                    break;
                  }
                  if (i2.mode = _N, t2 === eN)
                    break e;
                case _N:
                  i2.mode = EN;
                case EN:
                  if (a2 >= 6 && c2 >= 258) {
                    e2.next_out = o2, e2.avail_out = c2, e2.next_in = s2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, KO(e2, u2), o2 = e2.next_out, r2 = e2.output, c2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, a2 = e2.avail_in, d2 = i2.hold, l2 = i2.bits, i2.mode === hN && (i2.back = -1);
                    break;
                  }
                  for (i2.back = 0; I2 = i2.lencode[d2 & (1 << i2.lenbits) - 1], m2 = I2 >>> 24, f2 = I2 >>> 16 & 255, g2 = 65535 & I2, !(m2 <= l2); ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (f2 && 0 == (240 & f2)) {
                    for (T2 = m2, S2 = f2, R2 = g2; I2 = i2.lencode[R2 + ((d2 & (1 << T2 + S2) - 1) >> T2)], m2 = I2 >>> 24, f2 = I2 >>> 16 & 255, g2 = 65535 & I2, !(T2 + m2 <= l2); ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    d2 >>>= T2, l2 -= T2, i2.back += T2;
                  }
                  if (d2 >>>= m2, l2 -= m2, i2.back += m2, i2.length = g2, 0 === f2) {
                    i2.mode = 16205;
                    break;
                  }
                  if (32 & f2) {
                    i2.back = -1, i2.mode = hN;
                    break;
                  }
                  if (64 & f2) {
                    e2.msg = "invalid literal/length code", i2.mode = fN;
                    break;
                  }
                  i2.extra = 15 & f2, i2.mode = 16201;
                case 16201:
                  if (i2.extra) {
                    for (b2 = i2.extra; l2 < b2; ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    i2.length += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
                  }
                  i2.was = i2.length, i2.mode = 16202;
                case 16202:
                  for (; I2 = i2.distcode[d2 & (1 << i2.distbits) - 1], m2 = I2 >>> 24, f2 = I2 >>> 16 & 255, g2 = 65535 & I2, !(m2 <= l2); ) {
                    if (0 === a2)
                      break e;
                    a2--, d2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (0 == (240 & f2)) {
                    for (T2 = m2, S2 = f2, R2 = g2; I2 = i2.distcode[R2 + ((d2 & (1 << T2 + S2) - 1) >> T2)], m2 = I2 >>> 24, f2 = I2 >>> 16 & 255, g2 = 65535 & I2, !(T2 + m2 <= l2); ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    d2 >>>= T2, l2 -= T2, i2.back += T2;
                  }
                  if (d2 >>>= m2, l2 -= m2, i2.back += m2, 64 & f2) {
                    e2.msg = "invalid distance code", i2.mode = fN;
                    break;
                  }
                  i2.offset = g2, i2.extra = 15 & f2, i2.mode = 16203;
                case 16203:
                  if (i2.extra) {
                    for (b2 = i2.extra; l2 < b2; ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    i2.offset += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
                  }
                  if (i2.offset > i2.dmax) {
                    e2.msg = "invalid distance too far back", i2.mode = fN;
                    break;
                  }
                  i2.mode = 16204;
                case 16204:
                  if (0 === c2)
                    break e;
                  if (p2 = u2 - c2, i2.offset > p2) {
                    if (p2 = i2.offset - p2, p2 > i2.whave && i2.sane) {
                      e2.msg = "invalid distance too far back", i2.mode = fN;
                      break;
                    }
                    p2 > i2.wnext ? (p2 -= i2.wnext, _2 = i2.wsize - p2) : _2 = i2.wnext - p2, p2 > i2.length && (p2 = i2.length), E2 = i2.window;
                  } else
                    E2 = r2, _2 = o2 - i2.offset, p2 = i2.length;
                  p2 > c2 && (p2 = c2), c2 -= p2, i2.length -= p2;
                  do {
                    r2[o2++] = E2[_2++];
                  } while (--p2);
                  0 === i2.length && (i2.mode = EN);
                  break;
                case 16205:
                  if (0 === c2)
                    break e;
                  r2[o2++] = i2.length, c2--, i2.mode = EN;
                  break;
                case mN:
                  if (i2.wrap) {
                    for (; l2 < 32; ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 |= n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 -= c2, e2.total_out += u2, i2.total += u2, 4 & i2.wrap && u2 && (e2.adler = i2.check = i2.flags ? gw(i2.check, r2, u2, o2 - u2) : mw(i2.check, r2, u2, o2 - u2)), u2 = c2, 4 & i2.wrap && (i2.flags ? d2 : gN(d2)) !== i2.check) {
                      e2.msg = "incorrect data check", i2.mode = fN;
                      break;
                    }
                    d2 = 0, l2 = 0;
                  }
                  i2.mode = 16207;
                case 16207:
                  if (i2.wrap && i2.flags) {
                    for (; l2 < 32; ) {
                      if (0 === a2)
                        break e;
                      a2--, d2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (4 & i2.wrap && d2 !== (4294967295 & i2.total)) {
                      e2.msg = "incorrect length check", i2.mode = fN;
                      break;
                    }
                    d2 = 0, l2 = 0;
                  }
                  i2.mode = 16208;
                case 16208:
                  v2 = iN;
                  break e;
                case fN:
                  v2 = sN;
                  break e;
                case 16210:
                  return oN;
                default:
                  return rN;
              }
          return e2.next_out = o2, e2.avail_out = c2, e2.next_in = s2, e2.avail_in = a2, i2.hold = d2, i2.bits = l2, (i2.wsize || u2 !== e2.avail_out && i2.mode < fN && (i2.mode < mN || t2 !== ZO)) && ON(e2, e2.output, e2.next_out, u2 - e2.avail_out), h2 -= e2.avail_in, u2 -= e2.avail_out, e2.total_in += h2, e2.total_out += u2, i2.total += u2, 4 & i2.wrap && u2 && (e2.adler = i2.check = i2.flags ? gw(i2.check, r2, u2, e2.next_out - u2) : mw(i2.check, r2, u2, e2.next_out - u2)), e2.data_type = i2.bits + (i2.last ? 64 : 0) + (i2.mode === hN ? 128 : 0) + (i2.mode === _N || i2.mode === pN ? 256 : 0), (0 === h2 && 0 === u2 || t2 === ZO) && v2 === tN && (v2 = aN), v2;
        }, DN = { inflateReset: CN, inflateReset2: vN, inflateResetKeep: RN, inflateInit: (e2) => IN(e2, 15), inflateInit2: IN, inflate: NN, inflateEnd: (e2) => {
          if (SN(e2))
            return rN;
          let t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, tN;
        }, inflateGetHeader: (e2, t2) => {
          if (SN(e2))
            return rN;
          const i2 = e2.state;
          return 0 == (2 & i2.wrap) ? rN : (i2.head = t2, t2.done = false, tN);
        }, inflateSetDictionary: (e2, t2) => {
          const i2 = t2.length;
          let n2, r2, s2;
          return SN(e2) ? rN : (n2 = e2.state, 0 !== n2.wrap && n2.mode !== lN ? rN : n2.mode === lN && (r2 = 1, r2 = mw(r2, t2, i2, 0), r2 !== n2.check) ? sN : (s2 = ON(e2, t2, i2, i2), s2 ? (n2.mode = 16210, oN) : (n2.havedict = 1, tN)));
        }, inflateInfo: "pako inflate (from Nodeca project)" };
        var PN = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
        const LN = Object.prototype.toString, { Z_NO_FLUSH: kN, Z_FINISH: MN, Z_OK: UN, Z_STREAM_END: xN, Z_NEED_DICT: VN, Z_STREAM_ERROR: FN, Z_DATA_ERROR: BN, Z_MEM_ERROR: jN } = Sw;
        function GN(e2) {
          this.options = AO.assign({ chunkSize: 65536, windowBits: 15, to: "" }, e2 || {});
          const t2 = this.options;
          t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new NO(), this.strm.avail_out = 0;
          let i2 = DN.inflateInit2(this.strm, t2.windowBits);
          if (i2 !== UN)
            throw new Error(Tw[i2]);
          if (this.header = new PN(), DN.inflateGetHeader(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = OO.string2buf(t2.dictionary) : "[object ArrayBuffer]" === LN.call(t2.dictionary) && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (i2 = DN.inflateSetDictionary(this.strm, t2.dictionary), i2 !== UN)))
            throw new Error(Tw[i2]);
        }
        function WN(e2, t2) {
          const i2 = new GN(t2);
          if (i2.push(e2), i2.err)
            throw i2.msg || Tw[i2.err];
          return i2.result;
        }
        GN.prototype.push = function(e2, t2) {
          const i2 = this.strm, n2 = this.options.chunkSize, r2 = this.options.dictionary;
          let s2, o2, a2;
          if (this.ended)
            return false;
          for (o2 = t2 === ~~t2 ? t2 : true === t2 ? MN : kN, "[object ArrayBuffer]" === LN.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) {
            for (0 === i2.avail_out && (i2.output = new Uint8Array(n2), i2.next_out = 0, i2.avail_out = n2), s2 = DN.inflate(i2, o2), s2 === VN && r2 && (s2 = DN.inflateSetDictionary(i2, r2), s2 === UN ? s2 = DN.inflate(i2, o2) : s2 === BN && (s2 = VN)); i2.avail_in > 0 && s2 === xN && i2.state.wrap > 0 && 0 !== e2[i2.next_in]; )
              DN.inflateReset(i2), s2 = DN.inflate(i2, o2);
            switch (s2) {
              case FN:
              case BN:
              case VN:
              case jN:
                return this.onEnd(s2), this.ended = true, false;
            }
            if (a2 = i2.avail_out, i2.next_out && (0 === i2.avail_out || s2 === xN))
              if ("string" === this.options.to) {
                let e3 = OO.utf8border(i2.output, i2.next_out), t3 = i2.next_out - e3, r3 = OO.buf2string(i2.output, e3);
                i2.next_out = t3, i2.avail_out = n2 - t3, t3 && i2.output.set(i2.output.subarray(e3, e3 + t3), 0), this.onData(r3);
              } else
                this.onData(i2.output.length === i2.next_out ? i2.output : i2.output.subarray(0, i2.next_out));
            if (s2 !== UN || 0 !== a2) {
              if (s2 === xN)
                return s2 = DN.inflateEnd(this.strm), this.onEnd(s2), this.ended = true, true;
              if (0 === i2.avail_in)
                break;
            }
          }
          return true;
        }, GN.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, GN.prototype.onEnd = function(e2) {
          e2 === UN && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = AO.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        };
        var HN = { Inflate: GN, inflate: WN, inflateRaw: function(e2, t2) {
          return (t2 = t2 || {}).raw = true, WN(e2, t2);
        }, ungzip: WN, constants: Sw };
        const { Deflate: KN, deflate: YN, deflateRaw: qN, gzip: JN } = WO, { Inflate: zN, inflate: XN, inflateRaw: QN, ungzip: ZN } = HN;
        var $N, eD = YN, tD = XN;
        !function(e2) {
          e2[e2.ONE_BYTE = 0] = "ONE_BYTE", e2[e2.TWO_BYTE = 1] = "TWO_BYTE";
        }($N || ($N = {}));
        class iD {
          constructor() {
            nu(this, "_sequence", 0), nu(this, "_startTime", Date.now()), nu(this, "isUseOneByte", true);
          }
          get startTime() {
            const e2 = Date.now() - this._startTime;
            return e2 < Math.pow(2, 16) ? e2 : (this._startTime += Math.pow(2, 16), this.startTime);
          }
          get sequence() {
            return this._sequence < Math.pow(2, 32) ? this._sequence++ : (this._sequence -= Math.pow(2, 32), this.sequence);
          }
          serialize(e2) {
            const t2 = { commonPacketHeader: { length: 0, reserved: 0, extension: 0, sequence: this.sequence }, commonStreamHeader: this.startTime, extension: void 0, payload: e2 };
            if (e2.byteLength > 128) {
              const i3 = new Uint8Array(4);
              i3.set([1, 0, 0, 0]);
              const n3 = { id: 0, length: 4, data: i3.buffer }, r3 = { profile: this.isUseOneByte ? 0 : 1, length: this.isUseOneByte ? 5 : 6, datas: [n3] };
              t2.commonPacketHeader.extension = 1, t2.extension = r3, t2.payload = this.compress(e2), t2.commonPacketHeader.length = 8 + (t2.extension.length + 2) + t2.payload.byteLength;
            } else
              t2.commonPacketHeader.length = 8 + t2.payload.byteLength;
            const i2 = new ArrayBuffer(t2.commonPacketHeader.length), n2 = new Uint8Array(i2), r2 = new DataView(i2);
            let s2 = 0;
            if (r2.setUint16(s2, t2.commonPacketHeader.extension << 15 | t2.commonPacketHeader.reserved << 14 | t2.commonPacketHeader.length, true), s2 += 2, r2.setUint32(s2, t2.commonPacketHeader.sequence, true), s2 += 4, r2.setUint16(s2, t2.commonStreamHeader, true), s2 += 2, t2.extension) {
              const e3 = this.serializeExtension(t2.extension);
              n2.set(new Uint8Array(e3), s2), s2 += e3.byteLength;
            }
            if (n2.set(new Uint8Array(t2.payload), s2), s2 += t2.payload.byteLength, s2 !== t2.commonPacketHeader.length)
              throw Error("serialize error!");
            return i2;
          }
          deserialize(e2) {
            if (e2.byteLength < 4)
              return new ArrayBuffer(0);
            const t2 = new DataView(e2);
            let i2 = 0;
            const n2 = t2.getUint16(i2, true);
            i2 += 2;
            const r2 = (32768 & n2) >> 15;
            t2.getUint16(i2 + 2, true), t2.getUint16(i2, true);
            let s2, o2;
            if (i2 += 4, t2.getUint16(i2, true), i2 += 2, r2) {
              o2 = this.deserializeExtension(e2.slice(i2)), i2 += 2 + o2.length, s2 = e2.slice(i2);
              let t3 = false;
              if (o2.datas.length > 0) {
                const e3 = o2.datas.find((e4) => 0 === e4.id);
                if (e3) {
                  t3 = 1 == (1 & new DataView(e3.data).getUint32(0, true));
                }
              }
              s2 = t3 ? this.decompress(s2) : s2;
            } else
              s2 = e2.slice(8);
            return s2;
          }
          serializeExtension(e2) {
            const { profile: t2, length: i2, datas: n2 } = e2, r2 = new ArrayBuffer(i2 + 2), s2 = new Uint8Array(r2), o2 = new DataView(r2);
            let a2 = 0;
            if (o2.setUint8(a2++, t2), o2.setUint8(a2++, i2), n2.forEach((e3) => {
              t2 ? (o2.setUint8(a2++, e3.id), o2.setUint8(a2++, e3.length), s2.set(new Uint8Array(e3.data), a2), a2 += e3.data.byteLength) : (o2.setUint8(a2++, e3.id | e3.length << 4), s2.set(new Uint8Array(e3.data), a2), a2 += e3.data.byteLength);
            }), a2 !== i2 + 2)
              throw Error("serialize extension error, is ".concat(a2, "!==").concat(i2 + 2));
            return r2;
          }
          deserializeExtension(e2) {
            const t2 = new DataView(e2);
            let i2 = 0;
            const n2 = t2.getUint8(i2);
            i2++;
            const r2 = t2.getUint8(i2);
            i2++;
            const s2 = n2 === $N.TWO_BYTE, o2 = [], a2 = new DataView(e2, 2);
            let c2 = 0;
            for (; c2 < r2; ) {
              let e3 = 0, t3 = 0, i3 = new ArrayBuffer(0);
              s2 ? (e3 = a2.getUint8(c2), c2++, t3 = a2.getUint8(c2), c2++) : (e3 = 15 & a2.getUint8(c2), t3 = a2.getUint8(c2) >> 4, c2++), t3 > 0 && (i3 = a2.buffer.slice(c2 + 2, c2 + 2 + t3), c2 += i3.byteLength), o2.push({ id: e3, length: t3, data: i3 });
            }
            if (c2 !== r2)
              throw Error("parse error");
            return { profile: n2, length: r2, datas: o2 };
          }
          decompress(e2) {
            return tD(new Uint8Array(e2));
          }
          compress(e2) {
            return eD(new Uint8Array(e2));
          }
        }
        class nD extends iT {
          constructor(e2, t2) {
            super(), nu(this, "_version", 1), nu(this, "_type", 3), nu(this, "_config", void 0), nu(this, "_originDataChannel", void 0), nu(this, "_dataStreamPacketHeader", new ArrayBuffer(4)), nu(this, "_dataStreamPacketHandler", void 0), nu(this, "_datachannelEventMap", /* @__PURE__ */ new Map()), this._config = e2, t2 && (this._originDataChannel = t2, this._bandDataChannelEvents(t2)), this._initPacketHeader(), this._dataStreamPacketHandler = new iD();
          }
          get id() {
            return this._config.id;
          }
          get ordered() {
            return this._config.ordered;
          }
          get maxRetransmits() {
            return kC("DATASTREAM_MAX_RETRANSMITS");
          }
          get metadata() {
            return this._config.metadata;
          }
          get readyState() {
            var e2, t2;
            return null !== (e2 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.readyState) && void 0 !== e2 ? e2 : "connecting";
          }
          get _originDataChannelId() {
            var e2, t2;
            return null !== (e2 = null === (t2 = this._originDataChannel) || void 0 === t2 ? void 0 : t2.id) && void 0 !== e2 ? e2 : null;
          }
          getChannelId() {
            return this.id;
          }
          getConfig() {
            return this._config;
          }
          _close() {
            this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);
          }
          async _waitTillOpen() {
            return new tg((e2, t2) => {
              if (this._originDataChannel) {
                "open" === this._originDataChannel.readyState && e2();
                const i2 = setTimeout(() => {
                  var e3;
                  t2(new Vg(xg.DATACHANNEL_CONNECTION_TIMEOUT, "Cannot create datachannel, id: ".concat(null === (e3 = this._originDataChannel) || void 0 === e3 ? void 0 : e3.id)));
                }, 1e4);
                this._originDataChannel.onopen = () => {
                  clearTimeout(i2), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e2();
                }, this._originDataChannel.onerror = () => {
                  throw clearTimeout(i2), new Vg(xg.DATACHANNEL_CONNECTION_TIMEOUT);
                };
              } else
                t2(new Vg(xg.DATACHANNEL_CONNECTION_TIMEOUT, "cannot find dataChannel"));
            });
          }
          _updateOriginDataChannel(e2) {
            this._originDataChannel = e2, this._bandDataChannelEvents(e2);
          }
          _initPacketHeader() {
            const e2 = new DataView(this._dataStreamPacketHeader);
            e2.setUint16(0, this._version), e2.setUint8(2, this._type), e2.setUint8(3, this._config.id);
          }
          _bandDataChannelEvents(e2) {
            this._unbindDataChannelEvents(e2), [eA.OPEN, eA.CLOSE, eA.ERROR].forEach((t2) => {
              const i2 = () => {
                this.emit(t2);
              };
              this._datachannelEventMap.set(t2, i2), e2.addEventListener(t2, i2);
            });
          }
          _unbindDataChannelEvents(e2) {
            Array.from(this._datachannelEventMap.entries()).forEach((t2) => {
              let [i2, n2] = t2;
              e2.removeEventListener(i2, n2);
            }), this._datachannelEventMap.clear();
          }
        }
        class rD extends nD {
          constructor(e2) {
            super(e2), nu(this, "_messageListener", void 0), this._messageListener = (e3) => {
              if (e3.data.byteLength < this._dataStreamPacketHeader.byteLength)
                throw Error("invalid byteLength: the byte length must exceed " + this._dataStreamPacketHeader.byteLength);
              const t2 = e3.data.slice(0, this._dataStreamPacketHeader.byteLength);
              if (new DataView(t2).getUint8(3) !== this.id)
                return;
              let i2 = e3.data.slice(this._dataStreamPacketHeader.byteLength);
              i2 = this._dataStreamPacketHandler.deserialize(i2), this.emit(eA.MESSAGE, i2);
            };
          }
          _updateOriginDataChannel(e2) {
            super._updateOriginDataChannel(e2), this._bandRemoteDataChannelEvents();
          }
          _close() {
            this._originDataChannel && (this._originDataChannel.removeEventListener("message", this._messageListener), super._close());
          }
          _bandRemoteDataChannelEvents() {
            this._originDataChannel && this._originDataChannel.addEventListener("message", this._messageListener);
          }
        }
        class sD extends nD {
          send(e2) {
            if (this._originDataChannel) {
              let t2 = e2;
              t2 = this._dataStreamPacketHandler.serialize(e2);
              const i2 = new Uint8Array(this._dataStreamPacketHeader.byteLength + t2.byteLength);
              i2.set(new Uint8Array(this._dataStreamPacketHeader), 0), i2.set(new Uint8Array(t2), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i2.buffer);
            }
          }
        }
        class oD extends iT {
          constructor() {
            super(...arguments), nu(this, "resultStorage", /* @__PURE__ */ new Map());
          }
          setLocalAudioStats(e2, t2, i2) {
            this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e2, this.checkAudioInputLevel(i2, t2)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e2, this.checkSendAudioBitrate(i2, t2));
          }
          setLocalVideoStats(e2, t2, i2) {
            this.record("SEND_VIDEO_BITRATE_TOO_LOW", e2, this.checkSendVideoBitrate(i2, t2)), this.record("FRAMERATE_INPUT_TOO_LOW", e2, this.checkFramerateInput(i2, t2)), this.record("FRAMERATE_SENT_TOO_LOW", e2, this.checkFramerateSent(i2));
          }
          setRemoteAudioStats(e2, t2) {
            const i2 = e2.getUserId();
            this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i2, this.checkAudioOutputLevel(t2));
          }
          setRemoteVideoStats(e2, t2) {
            const i2 = e2.getUserId();
            this.record("RECV_VIDEO_DECODE_FAILED", i2, this.checkVideoDecode(t2));
          }
          record(e2, t2, i2) {
            if (kC("STATS_UPDATE_INTERVAL") > 500)
              return;
            this.resultStorage.has(e2) || this.resultStorage.set(e2, { result: [], isPrevNormal: true });
            const n2 = this.resultStorage.get(e2);
            if (n2 && (n2.result.push(i2), n2.result.length >= 5)) {
              var r2;
              const i3 = Pr(r2 = n2.result).call(r2, true);
              n2.isPrevNormal && !i3 && this.emit("exception", aD[e2], e2, t2), !n2.isPrevNormal && i3 && this.emit("exception", aD[e2] + 2e3, e2 + "_RECOVER", t2), n2.isPrevNormal = i3, n2.result = [];
            }
          }
          checkAudioOutputLevel(e2) {
            return !(e2.receiveBitrate > 0 && 0 === e2.receiveLevel);
          }
          checkAudioInputLevel(e2, t2) {
            return t2 instanceof tb && !t2.isActive || (!!t2.muted || 0 !== e2.sendVolumeLevel);
          }
          checkFramerateInput(e2, t2) {
            let i2 = null;
            t2._encoderConfig && t2._encoderConfig.frameRate && (i2 = mD(t2._encoderConfig.frameRate));
            const n2 = e2.captureFrameRate;
            return !i2 || !n2 || !(i2 > 10 && n2 < 5 || i2 < 10 && i2 >= 5 && n2 <= 1);
          }
          checkFramerateSent(e2) {
            return !(e2.captureFrameRate && e2.sendFrameRate && e2.captureFrameRate > 5 && e2.sendFrameRate <= 1);
          }
          checkSendVideoBitrate(e2, t2) {
            return !!t2.muted || 0 !== e2.sendBitrate;
          }
          checkSendAudioBitrate(e2, t2) {
            return t2 instanceof tb && !t2.isActive || (!!t2.muted || 0 !== e2.sendBitrate);
          }
          checkVideoDecode(e2) {
            return 0 === e2.receiveBitrate || 0 !== e2.decodeFrameRate;
          }
        }
        const aD = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
        const cD = new class {
          markSubscribeStart(e2, t2) {
            performance.mark("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
          }
          markPublishStart(e2, t2) {
            performance.mark("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
          }
          measureFromSubscribeStart(e2, t2) {
            const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
            if (i2.length > 0) {
              const e3 = i2[i2.length - 1];
              return Math.round(performance.now() - e3.startTime);
            }
            return 0;
          }
          measureFromPublishStart(e2, t2) {
            const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
            if (i2.length > 0) {
              const e3 = i2[i2.length - 1];
              return Math.round(performance.now() - e3.startTime);
            }
            return 0;
          }
        }();
        function dD(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function lD(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? dD(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : dD(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class hD {
          constructor(e2) {
            nu(this, "store", void 0), nu(this, "onStatsException", void 0), nu(this, "onUploadPublishDuration", void 0), nu(this, "onStatsChanged", void 0), nu(this, "localStats", /* @__PURE__ */ new Map()), nu(this, "remoteStats", /* @__PURE__ */ new Map()), nu(this, "updateStatsInterval", void 0), nu(this, "trafficStats", void 0), nu(this, "trafficStatsPeerList", []), nu(this, "uplinkStats", void 0), nu(this, "exceptionMonitor", void 0), nu(this, "p2pChannel", void 0), nu(this, "scalabilityMode", lv.L1T1), nu(this, "updateStats", () => {
              this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
            }), this.store = e2, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new oD(), this.exceptionMonitor.on("exception", (e3, t2, i2) => {
              this.onStatsException && this.onStatsException(e3, t2, i2);
            });
          }
          reset() {
            this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
          }
          getLocalAudioTrackStats() {
            return this.localStats.get(_I.LocalAudioTrack) || lD({}, Wy);
          }
          getLocalVideoTrackStats() {
            return this.localStats.get(_I.LocalVideoTrack) || lD({}, Hy);
          }
          getRemoteAudioTrackStats(e2) {
            const t2 = (e3, t3) => {
              if (!this.trafficStats)
                return t3;
              const i3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
              return i3 && (t3.publishDuration = i3.B_ppad + (Date.now() - this.trafficStats.timestamp)), t3;
            }, i2 = {};
            if (e2) {
              var n2;
              const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.audioStats;
              r2 && (i2[e2] = t2(e2, r2));
            } else
              Array.from(this.remoteStats.entries()).forEach((e3) => {
                let [n3, { audioStats: r2 }] = e3;
                r2 && (i2[n3] = t2(n3, r2));
              });
            return i2;
          }
          getRemoteNetworkQualityStats(e2) {
            const t2 = {};
            if (e2) {
              var i2;
              const n2 = null === (i2 = this.remoteStats.get(e2)) || void 0 === i2 ? void 0 : i2.networkStats;
              n2 && (t2[e2] = n2);
            } else
              Array.from(this.remoteStats.entries()).forEach((e3) => {
                let [i3, { networkStats: n2 }] = e3;
                n2 && (t2[i3] = n2);
              });
            return t2;
          }
          getRemoteVideoTrackStats(e2) {
            const t2 = (e3, t3) => {
              if (!this.trafficStats)
                return t3;
              const i3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
              return i3 && (t3.publishDuration = i3.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t3;
            }, i2 = {};
            if (e2) {
              var n2;
              const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.videoStats;
              r2 && (i2[e2] = t2(e2, r2));
            } else
              Array.from(this.remoteStats.entries()).forEach((e3) => {
                let [n3, { videoStats: r2 }] = e3;
                r2 && (i2[n3] = t2(n3, r2));
              });
            return i2;
          }
          getRTCStats() {
            let e2 = 0, t2 = 0, i2 = 0, n2 = 0;
            const r2 = this.localStats.get(_I.LocalAudioTrack);
            r2 && (e2 += r2.sendBytes, t2 += r2.sendBitrate);
            const s2 = this.localStats.get(_I.LocalVideoTrack);
            s2 && (e2 += s2.sendBytes, t2 += s2.sendBitrate);
            const o2 = this.localStats.get(_I.LocalVideoLowTrack);
            o2 && (e2 += o2.sendBytes, t2 += o2.sendBitrate), this.remoteStats.forEach((e3) => {
              let { audioStats: t3, videoStats: r3 } = e3;
              t3 && (i2 += t3.receiveBytes, n2 += t3.receiveBitrate), r3 && (i2 += r3.receiveBytes, n2 += r3.receiveBitrate);
            });
            let a2 = 1;
            return this.trafficStats && (a2 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a2, SendBitrate: t2, SendBytes: e2, RecvBytes: i2, RecvBitrate: n2, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
          }
          addLocalStats(e2) {
            this.localStats.set(e2, void 0);
          }
          removeLocalStats(e2) {
            e2 ? this.localStats.delete(e2) : this.localStats.clear();
          }
          addRemoteStats(e2) {
            this.remoteStats.set(e2, {});
          }
          removeRemoteStats(e2) {
            e2 ? this.remoteStats.delete(e2) : this.remoteStats.clear();
          }
          addP2PChannel(e2) {
            this.p2pChannel = e2;
          }
          updateTrafficStats(e2) {
            e2.peer_delay = e2.peer_delay.filter((e3) => void 0 !== e3.B_ppad || void 0 !== e3.B_ppvd);
            e2.peer_delay.filter((e3) => -1 === this.trafficStatsPeerList.indexOf(e3.peer_uid)).forEach((e3) => {
              var t2;
              const i2 = null === (t2 = this.p2pChannel) || void 0 === t2 ? void 0 : t2.getRemoteMedia(e3.peer_uid), n2 = null != i2 && i2.videoSSRC ? cD.measureFromSubscribeStart(this.store.clientId, i2.videoSSRC) : 0, r2 = null != i2 && i2.audioSSRC ? cD.measureFromSubscribeStart(this.store.clientId, i2.audioSSRC) : 0;
              void 0 !== e3.B_ppad && void 0 !== e3.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e3.peer_uid, e3.B_ppad, e3.B_ppvd, n2 > r2 ? n2 : r2), this.trafficStatsPeerList.push(e3.peer_uid));
            }), this.trafficStats = e2;
          }
          updateUplinkStats(e2) {
            this.uplinkStats && this.uplinkStats.B_fir !== e2.B_fir && KC.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e2.B_fir)), this.uplinkStats = e2;
          }
          static isRemoteVideoFreeze(e2, t2, i2) {
            if (!e2)
              return false;
            const n2 = !!i2 && t2.framesDecodeFreezeTime > i2.framesDecodeFreezeTime, r2 = !i2 || t2.framesDecodeCount > i2.framesDecodeCount;
            return n2 || !r2;
          }
          static isRemoteAudioFreeze(e2) {
            return !!e2 && e2._isFreeze();
          }
          isLocalVideoFreeze(e2) {
            return !(!e2.inputFrame || !e2.sentFrame) && (e2.inputFrame.frameRate > 5 && e2.sentFrame.frameRate < 3);
          }
          updateLocalStats(e2) {
            Array.from(this.localStats.entries()).forEach((t2) => {
              let [i2, n2] = t2;
              switch (i2) {
                case _I.LocalVideoTrack:
                case _I.LocalVideoLowTrack: {
                  const t3 = n2, s2 = lD({}, Hy), o2 = e2.getStats(), a2 = e2.getLocalMedia(i2);
                  if (o2) {
                    const i3 = o2.videoSend.find((e3) => e3.ssrc === (null == a2 ? void 0 : a2.ssrcs[0].ssrcId));
                    if (i3) {
                      const n3 = e2.getLocalVideoSize(), r3 = e2.getEncoderConfig(_I.LocalVideoTrack);
                      "H264" !== i3.codec && "H265" !== i3.codec && "VP8" !== i3.codec && "VP9" !== i3.codec && "AV1X" !== i3.codec && "AV1" !== i3.codec || (s2.codecType = i3.codec), s2.sendBytes = i3.bytes, s2.sendBitrate = t3 ? 8 * Math.max(0, s2.sendBytes - t3.sendBytes) : 0, i3.inputFrame ? (s2.captureFrameRate = i3.inputFrame.frameRate, s2.captureResolutionHeight = i3.inputFrame.height, s2.captureResolutionWidth = i3.inputFrame.width) : n3 && (s2.captureResolutionWidth = n3.width, s2.captureResolutionHeight = n3.height), i3.sentFrame ? (s2.sendFrameRate = i3.sentFrame.frameRate, s2.sendResolutionHeight = i3.sentFrame.height, s2.sendResolutionWidth = i3.sentFrame.width) : n3 && (s2.sendResolutionWidth = n3.width, s2.sendResolutionHeight = n3.height), i3.avgEncodeMs && (s2.encodeDelay = i3.avgEncodeMs), r3 && r3.bitrateMax && (s2.targetSendBitrate = 1e3 * r3.bitrateMax), s2.sendPackets = i3.packets, s2.sendPacketsLost = i3.packetsLost, s2.sendJitterMs = i3.jitterMs, s2.sendRttMs = i3.rttMs, s2.totalDuration = t3 ? t3.totalDuration + 1 : 1, s2.totalFreezeTime = t3 ? t3.totalFreezeTime : 0, this.isLocalVideoFreeze(i3) && (s2.totalFreezeTime += 1), i3.scalabilityMode && this.scalabilityMode !== i3.scalabilityMode && (KC.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(i3.scalabilityMode)), this.scalabilityMode = i3.scalabilityMode);
                    }
                    this.trafficStats && (s2.currentPacketLossRate = (this.trafficStats.B_pvlr4 || 0) / 100);
                  }
                  var r2;
                  if (this.localStats.set(i2, s2), (null == t3 ? void 0 : t3.sendResolutionWidth) !== s2.sendResolutionWidth || (null == t3 ? void 0 : t3.sendResolutionHeight) !== s2.sendResolutionHeight)
                    null === (r2 = this.onStatsChanged) || void 0 === r2 || r2.call(this, "resolution", { width: s2.sendResolutionWidth, height: s2.sendResolutionHeight });
                  s2 && a2 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, a2.track, s2);
                  break;
                }
                case _I.LocalAudioTrack: {
                  const t3 = n2, r3 = lD({}, Wy), s2 = e2.getStats(), o2 = e2.getLocalMedia(i2);
                  if (s2) {
                    const i3 = s2.audioSend.find((e3) => e3.ssrc === (null == o2 ? void 0 : o2.ssrcs[0].ssrcId));
                    if (i3) {
                      if ("opus" !== i3.codec && "aac" !== i3.codec && "PCMU" !== i3.codec && "PCMA" !== i3.codec && "G722" !== i3.codec || (r3.codecType = i3.codec), i3.inputLevel)
                        r3.sendVolumeLevel = Math.round(32767 * i3.inputLevel);
                      else {
                        const t4 = e2.getLocalAudioVolume();
                        t4 && (r3.sendVolumeLevel = Math.round(32767 * t4));
                      }
                      r3.sendBytes = i3.bytes, r3.sendPackets = i3.packets, r3.sendPacketsLost = i3.packetsLost, r3.sendJitterMs = i3.jitterMs, r3.sendRttMs = i3.rttMs, r3.sendBitrate = t3 ? 8 * Math.max(0, r3.sendBytes - t3.sendBytes) : 0;
                    }
                  }
                  this.trafficStats && (r3.currentPacketLossRate = (this.trafficStats.B_palr4 || 0) / 100), this.localStats.set(_I.LocalAudioTrack, r3), r3 && o2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, o2.track, r3);
                  break;
                }
              }
            });
          }
          updateRemoteStats(e2) {
            Array.from(this.remoteStats.entries()).forEach((t2) => {
              let [i2, { videoStats: n2, audioStats: r2, videoPcStats: s2 }] = t2;
              const o2 = r2, a2 = n2, c2 = s2, d2 = lD({}, Ky), l2 = lD({}, qy), h2 = lD({}, Yy), { audioTrack: u2, videoTrack: p2, audioSSRC: _2, videoSSRC: E2 } = e2.getRemoteMedia(i2), m2 = e2.getStats(), f2 = null == m2 ? void 0 : m2.audioRecv.find((e3) => e3.ssrc === _2), g2 = null == m2 ? void 0 : m2.videoRecv.find((e3) => e3.ssrc === E2), T2 = this.trafficStats && this.trafficStats.peer_delay.find((e3) => e3.peer_uid === i2);
              if (f2 && ("opus" !== f2.codec && "aac" !== f2.codec && "PCMU" !== f2.codec && "PCMA" !== f2.codec && "G722" !== f2.codec || (d2.codecType = f2.codec), f2.outputLevel ? d2.receiveLevel = Math.round(32767 * f2.outputLevel) : u2 && (d2.receiveLevel = Math.round(32767 * u2.getVolumeLevel())), d2.receiveBytes = f2.bytes, d2.receivePackets = f2.packets, d2.receivePacketsLost = f2.packetsLost, d2.packetLossRate = d2.receivePacketsLost / (d2.receivePackets + d2.receivePacketsLost), d2.receiveBitrate = o2 ? 8 * Math.max(0, d2.receiveBytes - o2.receiveBytes) : 0, d2.totalDuration = o2 ? o2.totalDuration + 1 : 1, d2.totalFreezeTime = o2 ? o2.totalFreezeTime : 0, d2.freezeRate = d2.totalFreezeTime / d2.totalDuration, d2.receiveDelay = f2.jitterBufferMs, d2.totalDuration > 10 && hD.isRemoteAudioFreeze(u2) && (d2.totalFreezeTime += 1)), g2) {
                "H264" !== g2.codec && "H265" !== g2.codec && "VP8" !== g2.codec && "VP9" !== g2.codec && "AV1X" !== g2.codec && "AV1" !== g2.codec || (l2.codecType = g2.codec), l2.receiveBytes = g2.bytes, l2.receiveBitrate = a2 ? 8 * Math.max(0, l2.receiveBytes - a2.receiveBytes) : 0, l2.decodeFrameRate = g2.decodeFrameRate < 0 ? 0 : g2.decodeFrameRate, l2.renderFrameRate = g2.decodeFrameRate < 0 ? 0 : g2.decodeFrameRate, g2.outputFrame && (l2.renderFrameRate = g2.outputFrame.frameRate), g2.receivedFrame ? (l2.receiveFrameRate = g2.receivedFrame.frameRate, l2.receiveResolutionHeight = g2.receivedFrame.height, l2.receiveResolutionWidth = g2.receivedFrame.width) : p2 && (l2.receiveResolutionHeight = p2._videoHeight || 0, l2.receiveResolutionWidth = p2._videoWidth || 0), void 0 !== g2.framesRateFirefox && (l2.receiveFrameRate = Math.round(g2.framesRateFirefox)), l2.receivePackets = g2.packets, l2.receivePacketsLost = g2.packetsLost, l2.packetLossRate = l2.receivePacketsLost / (l2.receivePackets + l2.receivePacketsLost), l2.totalDuration = a2 ? a2.totalDuration + 1 : 1, l2.totalFreezeTime = a2 ? a2.totalFreezeTime : 0, l2.receiveDelay = g2.jitterBufferMs || 0;
                const t3 = !!E2 && e2.getRemoteVideoIsReady(E2);
                p2 && t3 && hD.isRemoteVideoFreeze(p2, g2, c2) && (l2.totalFreezeTime += 1), l2.freezeRate = l2.totalFreezeTime / l2.totalDuration;
              }
              T2 && (d2.end2EndDelay = T2.B_ad, l2.end2EndDelay = T2.B_vd, d2.transportDelay = T2.B_ed, l2.transportDelay = T2.B_ed, d2.currentPacketLossRate = T2.B_ealr4 / 100, l2.currentPacketLossRate = T2.B_evlr4 / 100, h2.uplinkNetworkQuality = T2.B_punq ? T2.B_punq : 0, h2.downlinkNetworkQuality = T2.B_pdnq ? T2.B_pdnq : 0), this.remoteStats.set(i2, { audioStats: d2, videoStats: l2, videoPcStats: g2, networkStats: h2 }), u2 && this.exceptionMonitor.setRemoteAudioStats(u2, d2), p2 && this.exceptionMonitor.setRemoteVideoStats(p2, l2);
            });
          }
        }
        function uD(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function pD(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? uD(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : uD(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        function _D(e2) {
          return e2.match(/^[\.\:\d]+$/) ? "".concat(e2.replace(/[^\d]/g, "-"), ".").concat(kC("TURN_DOMAIN")) : (KC.info("Cannot recognized as IP address ".concat(e2, ". Used As Host instead")), e2);
        }
        function ED(e2, t2) {
          var i2, n2;
          const r2 = kC("GATEWAY_DOMAINS");
          let s2 = r2[1] && -1 !== t2.indexOf(r2[1]) ? 1 : 0;
          e2.addresses = e2.addresses || [];
          const o2 = e2.addresses.map((e3) => e3.domain_prefix ? { address: "".concat(e3.domain_prefix, ".").concat(r2[s2++ % r2.length], ":").concat(e3.port) } : e3.ip.match(/^[\.\:\d]+$/) ? { ip: e3.ip, port: e3.port, address: "".concat(e3.ip.replace(/[^\d]/g, "-"), ".").concat(r2[s2++ % r2.length], ":").concat(e3.port) } : (KC.info("Cannot recognized as IP address ".concat(e3.ip, ". Used As Host instead")), { ip: e3.ip, port: e3.port, address: "".concat(e3.ip, ":").concat(e3.port) }));
          if (null !== (i2 = e2.detail) && void 0 !== i2 && i2[18] && "string" == typeof (null === (n2 = e2.detail) || void 0 === n2 ? void 0 : n2[18])) {
            const t3 = e2.detail[18], i3 = null == t3 ? void 0 : t3.split(";");
            for (let e3 = 0; e3 < i3.length; e3++) {
              var a2;
              const t4 = fy(a2 = i3[e3]).call(a2);
              o2[e3] && t4 && (o2[e3].ip6 = t4);
            }
          }
          return { gatewayAddrs: o2, uid: e2.uid, cid: e2.cid, cert: e2.cert, vid: e2.detail && e2.detail[8], uni_lbs_ip: e2.detail && e2.detail[1], res: e2, csIp: e2.detail && e2.detail[502] };
        }
        function mD(e2) {
          return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
        }
        function fD(e2) {
          const t2 = e2._encoderConfig;
          if (!t2)
            return {};
          const i2 = { resolution: t2.width && t2.height ? "".concat(mD(t2.width), "x").concat(mD(t2.height)) : void 0, maxVideoBW: t2.bitrateMax, minVideoBW: t2.bitrateMin };
          return "number" == typeof t2.frameRate ? (i2.maxFrameRate = t2.frameRate, i2.minFrameRate = t2.frameRate) : t2.frameRate && (i2.maxFrameRate = t2.frameRate.max || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.min, i2.minFrameRate = t2.frameRate.min || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.max), i2;
        }
        function gD(e2) {
          const t2 = { connectionType: 0, googRtt: e2.rtt };
          switch (e2.selectedCandidatePair.localCandidate.candidateType) {
            case "relay": {
              const i2 = e2.selectedCandidatePair.localCandidate.relayProtocol;
              "udp" === i2 && (t2.connectionType = 1), "tcp" === i2 && (t2.connectionType = 3), "tls" === i2 && (t2.connectionType = 4);
              break;
            }
            case "srflx":
              t2.connectionType = 2;
          }
          return t2;
        }
        function TD(e2) {
          return e2 >= 0 && e2 < 0.17 ? 1 : e2 >= 0.17 && e2 < 0.36 ? 2 : e2 >= 0.36 && e2 < 0.59 ? 3 : e2 >= 0.59 && e2 <= 1 ? 4 : e2 > 1 ? 5 : 0;
        }
        function SD(e2, t2) {
          let i2, n2, r2;
          switch (t2) {
            case hy.CHOOSE_SERVER:
              n2 = 4096, r2 = "choose server";
              break;
            case hy.CLOUD_PROXY:
              n2 = 1048576, r2 = "proxy";
              break;
            case hy.CLOUD_PROXY_5:
              n2 = 4194304, r2 = "proxy5";
              break;
            case hy.CLOUD_PROXY_FALLBACK:
              n2 = 4194310, r2 = "proxy fallback";
              break;
            default:
              throw new xv(xg.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e2.detail && e2.detail[502], retry: false });
          }
          if (e2.response_body.forEach((t3) => {
            t3.buffer && t3.buffer.flag === n2 && (i2 = { code: t3.buffer.code, addresses: (t3.buffer.edges_services || []).map((e3) => pD(pD({}, e3), {}, { ticket: t3.buffer.cert })), server_ts: e2.enter_ts, uid: t3.buffer.uid, cid: t3.buffer.cid, cname: t3.buffer.cname, detail: pD(pD({}, t3.buffer.detail), e2.detail), flag: t3.buffer.flag, opid: e2.opid, cert: t3.buffer.cert });
          }), !i2)
            throw new xv(xg.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(r2, " from multi unilbs response"), { csIp: e2.detail && e2.detail[502] });
          return i2;
        }
        async function RD(e2, t2) {
          return await tg.all(e2.addresses.map(async (e3) => ({ address: _D(e3.ip), tcpport: e3.port, udpport: e3.port, username: t2 && kC("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t2.toString() : ov.username, password: t2 && kC("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await tT(t2.toString()) : ov.password })));
        }
        function CD(e2, t2) {
          const i2 = t2._videoHeight || t2.getMediaStreamTrack(true).getSettings().height;
          return i2 ? Math.max(i2 / mD(e2.height), 1) : (KC.warning("can't get ori-track's height, default scale down 4 times for low stream"), 4);
        }
        function vD(e2) {
          let { candidateType: t2, relayProtocol: i2, type: n2, address: r2, port: s2, protocol: o2 } = e2;
          return "local-candidate" === n2 ? { candidateType: t2, relayProtocol: i2, protocol: o2 } : { candidateType: t2, relayProtocol: i2, address: r2, port: s2, protocol: o2 };
        }
        function ID(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        class yD extends iT {
          get url() {
            return this._url ? this._url : null;
          }
          get reconnectMode() {
            return this._reconnectMode;
          }
          set reconnectMode(e2) {
            var t2;
            Pr(t2 = ["tryNext", "recover"]).call(t2, e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
          }
          get state() {
            return this._state;
          }
          set state(e2) {
            e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(CI.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(CI.CONNECTED) : "closed" === this._state ? this.emit(CI.CLOSED) : "failed" === this._state && this.emit(CI.FAILED));
          }
          constructor(e2, t2, i2, n2) {
            super(), nu(this, "connectionID", 0), nu(this, "currentURLIndex", 0), nu(this, "reconnectReason", void 0), nu(this, "_reconnectMode", "tryNext"), nu(this, "_name", void 0), nu(this, "_state", "closed"), nu(this, "_retryConfig", void 0), nu(this, "_reconnectCount", 0), nu(this, "_forceCloseTimeout", 5e3), nu(this, "_onlineReconnectListener", void 0), nu(this, "_closeEstablishingTransmitter", () => {
            }), nu(this, "_store", void 0), nu(this, "_joinChannelServiceRecordIndex", void 0), nu(this, "_useCompress", void 0), nu(this, "_inflateLength", 0), nu(this, "_deflateLength", 0), this._store = n2, this._name = e2, this._retryConfig = function(e3) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var i3 = null != arguments[t3] ? arguments[t3] : {};
                t3 % 2 ? ID(Object(i3), true).forEach(function(t4) {
                  nu(e3, t4, i3[t4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : ID(Object(i3)).forEach(function(t4) {
                  Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i3, t4));
                });
              }
              return e3;
            }({}, t2), this._useCompress = i2;
          }
          resetReconnectCount(e2) {
            KC.debug("".concat(this._name, " reset reconnect count, reason: ").concat(e2)), this._reconnectCount = 0;
          }
          close(e2, t2) {
            if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {
              this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;
              const e3 = this._transmitter;
              t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this._transmitter = void 0;
            }
            this.state = e2 ? "failed" : "closed", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter();
          }
          reconnect(e2, t2) {
            if (!this._transmitter)
              return void KC.warning("[".concat(this._name, "] can not reconnect, no websocket"));
            var i2;
            (void 0 !== e2 && (this.reconnectMode = e2), KC.debug("[".concat(this._name, "] reconnect is triggered initiative")), "number" == typeof this._joinChannelServiceRecordIndex) && (null === (i2 = this._store) || void 0 === i2 || i2.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this._joinChannelServiceRecordIndex));
            const n2 = this._transmitter.onclose;
            this._transmitter.onclose = null, this._transmitter.close(), n2 && n2.bind(this._transmitter)({ code: 9999, reason: t2 });
          }
          getInflateData() {
            const e2 = this._inflateLength, t2 = this._deflateLength;
            return this.clearInflateData(), { inflateLength: e2, deflateLength: t2 };
          }
          setInflateData(e2) {
            this._deflateLength = this._deflateLength + e2.originLength, this._inflateLength = this._inflateLength + e2.compressedLength;
          }
          clearInflateData() {
            this._inflateLength = 0, this._deflateLength = 0;
          }
        }
        var AD;
        !function(e2) {
          e2[e2.Default = 0] = "Default", e2[e2.Ack = 1] = "Ack";
        }(AD || (AD = {}));
        class bD {
          constructor(e2, t2, i2) {
            nu(this, "version", 1), nu(this, "initialRTO", void 0), nu(this, "maxBatchAckCount", void 0), nu(this, "maxRTO", void 0), nu(this, "initialRTT", void 0), nu(this, "ID", void 0), nu(this, "rtt", void 0), nu(this, "packetNumber", 1), nu(this, "rtoRatioMap", /* @__PURE__ */ new Map()), nu(this, "timeoutMap", /* @__PURE__ */ new Map()), nu(this, "unorderedPacketQueue", []), nu(this, "batchAckPacketQueue", []), nu(this, "lastOrderedPacketNumber", 0), nu(this, "batchAckTimer", void 0), nu(this, "sendImpl", void 0), nu(this, "receiveImpl", void 0), this.sendImpl = e2, this.receiveImpl = t2, this.ID = xT(7, "transmitter-"), this.initialRTO = void 0 !== (null == i2 ? void 0 : i2.initialRTO) ? i2.initialRTO : kC("TRANSMITTER_INITIAL_RTO"), this.initialRTT = void 0 !== (null == i2 ? void 0 : i2.initialRTT) ? i2.initialRTT : kC("TRANSMITTER_INITIAL_RTT"), this.rtt = void 0 !== (null == i2 ? void 0 : i2.initialRTT) ? i2.initialRTT : kC("TRANSMITTER_INITIAL_RTT"), this.maxBatchAckCount = void 0 !== (null == i2 ? void 0 : i2.maxBatchAckCount) ? i2.maxBatchAckCount : kC("TRANSMITTER_MAX_BATCH_ACK_COUNT"), this.maxRTO = void 0 !== (null == i2 ? void 0 : i2.maxRTO) ? i2.maxRTO : kC("TRANSMITTER_MAX_RTO");
          }
          packetize(e2, t2) {
            return { type: AD.Default, version: this.version, packetNumber: t2, payload: e2 };
          }
          serialize(e2) {
            switch (e2.type) {
              case AD.Default: {
                let t2;
                if ("string" == typeof e2.payload) {
                  t2 = new TextEncoder().encode(e2.payload);
                } else
                  t2 = e2.payload;
                const i2 = new ArrayBuffer(t2.length + 15), n2 = new DataView(i2);
                n2.setUint16(0, e2.version), n2.setUint8(2, e2.type), n2.setUint32(3, e2.packetNumber), Jg(n2, 7, BigInt(e2.sendTs));
                return new Uint8Array(n2.buffer).set(t2, 15), i2;
              }
              case AD.Ack: {
                const t2 = new ArrayBuffer(16), i2 = new DataView(t2);
                return i2.setUint16(0, e2.version), i2.setUint8(2, e2.type), i2.setUint32(3, e2.maxAckPacketNumber), i2.setUint8(7, e2.shift), Jg(i2, 8, BigInt(e2.ackSendTs)), t2;
              }
            }
          }
          deserialize(e2) {
            const t2 = new DataView(e2), i2 = t2.getUint16(0), n2 = t2.getUint8(2);
            switch (n2) {
              case AD.Default: {
                const r2 = t2.getUint32(3), s2 = qg(t2, 7), o2 = e2.slice(15), a2 = new TextDecoder().decode(o2);
                return { version: i2, type: n2, packetNumber: r2, sendTs: Number(s2), payload: a2 };
              }
              case AD.Ack: {
                const e3 = t2.getUint32(3), r2 = t2.getUint8(7), s2 = qg(t2, 8);
                return { version: i2, type: n2, maxAckPacketNumber: e3, shift: r2, ackSendTs: Number(s2) };
              }
              default:
                throw KC.error("[".concat(this.ID, "] Unrecognized packet type ").concat(n2)), new Error("Unrecognized packet type ".concat(n2));
            }
          }
          sendMessage(e2) {
            const t2 = this.packetize(e2, this.packetNumber);
            this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;
            const i2 = this.calculateRTO(t2), n2 = window.setTimeout(() => {
              this.resendMessage(t2);
            }, i2);
            this.timeoutMap.set(t2.packetNumber, n2), this.sendPacket(t2);
          }
          onData(e2) {
            const t2 = this.deserialize(e2);
            t2.type === AD.Default ? this.ack(t2) : t2.type === AD.Ack && (this.updateRTT(t2, Math.round(performance.now())), this.clearRTO(t2));
          }
          close() {
            this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              window.clearTimeout(i2);
            }), this.timeoutMap = /* @__PURE__ */ new Map(), this.rtoRatioMap = /* @__PURE__ */ new Map(), this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer);
          }
          resendMessage(e2) {
            const t2 = this.calculateRTO(e2), i2 = window.setTimeout(() => {
              this.resendMessage(e2);
            }, t2);
            this.timeoutMap.set(e2.packetNumber, i2), this.sendPacket(e2);
          }
          calculateRTO(e2) {
            const t2 = this.rtoRatioMap.get(e2.packetNumber);
            if (void 0 === t2)
              return this.rtoRatioMap.set(e2.packetNumber, 1), this.initialRTO;
            {
              const i2 = 9 * this.rtt / 8 * t2;
              return this.rtoRatioMap.set(e2.packetNumber, t2 + 1), i2 > this.maxRTO ? this.maxRTO : i2;
            }
          }
          updateRTT(e2, t2) {
            const i2 = e2.ackSendTs;
            this.rtt = this.rtt * (7 / 8) + (t2 - i2 - this.rtt) / 8;
          }
          ack(e2) {
            if (e2.packetNumber === this.lastOrderedPacketNumber + 1)
              for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e2) : (this.batchAckPacketQueue.push(e2), this.batchAckTimer = window.setTimeout(() => {
                this.batchAck();
              }, this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e2.payload); ; ) {
                const e3 = this.unorderedPacketQueue[0];
                if (!e3) {
                  this.unorderedPacketQueue.shift();
                  break;
                }
                this.batchAckTimer && this.batchAck(), this.receiveImpl(e3.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1;
              }
            else if (e2.packetNumber <= this.lastOrderedPacketNumber) {
              const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: AD.Ack, version: this.version };
              this.sendPacket(t2);
            } else if (e2.packetNumber > this.lastOrderedPacketNumber) {
              this.unorderedPacketQueue[e2.packetNumber - this.lastOrderedPacketNumber - 2] = e2;
              const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: AD.Ack, version: this.version };
              this.sendPacket(t2);
            }
          }
          batchAck() {
            window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;
            const e2 = { ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs, maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber, shift: this.batchAckPacketQueue.length - 1, type: AD.Ack, version: this.version };
            this.sendPacket(e2), this.batchAckPacketQueue = [];
          }
          sendPacket(e2) {
            e2.type === AD.Default && (e2.sendTs = Math.round(performance.now()));
            const t2 = this.serialize(e2);
            this.sendImpl(t2);
          }
          clearRTO(e2) {
            for (let t2 = e2.maxAckPacketNumber - e2.shift; t2 <= e2.maxAckPacketNumber; t2++) {
              const e3 = this.timeoutMap.get(t2);
              void 0 !== e3 && window.clearTimeout(e3), this.timeoutMap.delete(t2), this.rtoRatioMap.delete(t2);
            }
          }
        }
        class wD extends yD {
          constructor(e2, t2) {
            super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), nu(this, "_initMutex", void 0), nu(this, "_reconnectInterrupter", void 0), nu(this, "_url", void 0), nu(this, "_transmitter", void 0), nu(this, "_addresses", void 0), nu(this, "_reliableTransmission", void 0), this._initMutex = new YT("datachannel");
            const { timeout: i2, timeoutFactor: n2 } = t2, r2 = Math.max(300, Math.floor(3 * i2 / 5)), s2 = Math.max(1.2, Math.floor(8 * n2) / 10);
            hT.ONLINE && (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = s2), RT.on(uT.NETWORK_STATE_CHANGE, (e3, t3) => {
              e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === hT.ONLINE ? (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = s2) : (this._retryConfig.timeout = i2, this._retryConfig.timeoutFactor = n2));
            });
          }
          getConnection() {
            if (this._reliableTransmission)
              return this._reliableTransmission;
          }
          async init(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
            this._forceCloseTimeout = t2;
            const i2 = (t3, i3) => {
              this._addresses = e2, this.currentURLIndex = this._addresses.findIndex((e3) => e3.fingerprint || kC("FINGERPRINT"));
              const n2 = this._addresses[this.currentURLIndex];
              this.state = "connecting", this.createTransmitterConnection(n2).then(t3).catch(i3), this.once(CI.CLOSED, () => i3(new xv(xg.WS_DISCONNECT))), this.once(CI.CONNECTED, () => t3());
            };
            return this._initMutex.lock().then((e3) => new tg((e4, t3) => {
              i2(e4, t3);
            }).then(() => {
              e3();
            }).catch(() => {
              e3();
            }));
          }
          sendMessage(e2) {
            let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            if (!this._transmitter || !this._reliableTransmission)
              throw new xv(xg.WS_ABORT, "datachannel is not ready");
            try {
              t2 || (e2 = JSON.stringify(e2)), this._reliableTransmission.sendMessage(e2);
            } catch (e3) {
              throw new xv(xg.WS_ERR, "send datachannel signal message error" + e3.toString());
            }
          }
          unbindDcCloseEventListener() {
            this._transmitter && (this._transmitter.onclose = null);
          }
          sendMessageWithJSON(e2) {
            const t2 = JSON.stringify(e2);
            return { compressed: t2, compressedLength: t2.length, origin: e2 };
          }
          sendMessageWithUint8Array(e2) {
            return { compressed: e2, compressedLength: e2.byteLength, origin: e2 };
          }
          createTransmitterConnection(e2) {
            return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = "dc://".concat(e2.ip, ":").concat(e2.port), new tg((t2, i2) => {
              var n2;
              const r2 = () => {
                KC.debug("[".concat(this._name, "] datachannel opened:"), this._url), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), t2();
              }, s2 = async (e3) => {
                var n3;
                if (null === (n3 = this._closeEstablishingTransmitter) || void 0 === n3 || n3.call(this), KC.debug("[".concat(this._name, "] datachannel close ").concat(this._url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) {
                  "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
                  const n4 = TT(this, CI.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r3 = await this.reconnectWithAction(n4);
                  if ("closed" === this.state)
                    return void KC.debug("[".concat(this.connectionID, "] dc is closed, no need to reconnect"));
                  if (!r3)
                    return i2(new xv(xg.WS_DISCONNECT, "datachannel reconnect failed: ".concat(e3.code))), void this.close(true);
                  t2();
                } else
                  i2(new xv(xg.WS_DISCONNECT, "datachannel close: ".concat(e3.code))), this.close();
              }, o2 = (e3) => {
                var t3;
                null === (t3 = this._reliableTransmission) || void 0 === t3 || t3.onData(e3.data);
              };
              this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), KC.debug("[".concat(this._name, "] start connect, address: ").concat(JSON.stringify(e2)));
              const a2 = null === (n2 = this._store) || void 0 === n2 ? void 0 : n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" }), c2 = Date.now();
              fT(this, CI.TO_CONNECT_DATACHANNEL, e2).then((e3) => {
                var t3, i3;
                if (!e3)
                  throw new Error("transmissonInfo not exist yet");
                const { transmitter: n3, close: d2 } = e3;
                this._transmitter = n3, null === (t3 = this._store) || void 0 === t3 || t3.signalChannelOpen();
                const l2 = Date.now() - c2;
                KC.debug("[choose dc] dc open cost ".concat(l2, "ms"));
                this._reliableTransmission = new bD((e4) => {
                  var t4;
                  this._transmitter && "open" === this._transmitter.readyState && (null === (t4 = this._transmitter) || void 0 === t4 || t4.send(e4));
                }, (e4) => {
                  "string" == typeof e4 && this.emit(CI.ON_MESSAGE, e4);
                }), this._closeEstablishingTransmitter = () => {
                  var e4;
                  null === (e4 = this._reliableTransmission) || void 0 === e4 || e4.close(), this._reliableTransmission = void 0, d2();
                }, r2 && r2(), n3.onclose = s2, n3.onmessage = o2, null === (i3 = this._store) || void 0 === i3 || i3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this._joinChannelServiceRecordIndex = a2;
              }).catch((e3) => {
                var t3;
                if (null === (t3 = this._store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: e3 instanceof xv && e3.code === xg.WS_ABORT ? "aborted" : "error", errors: [e3] }, a2), "closed" !== this.state) {
                  if (e3 instanceof xv && e3.code === xg.WS_ERR) {
                    const t4 = new xv(xg.WS_ERR, "init datachannel failed! Error: ".concat(e3.toString()));
                    return KC.error("[".concat(this._name, "]").concat(t4)), void i2(t4);
                  }
                  s2 && s2(e3);
                } else
                  i2(new xv(xg.WS_DISCONNECT, "datachannel is closed: ".concat(e3.toString())));
              });
            });
          }
          async reconnectWithAction(e2) {
            let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (this._reconnectCount >= this._retryConfig.maxRetryCount)
              return false;
            if (!this._addresses)
              return false;
            if ("closed" === this.state)
              return false;
            this._onlineReconnectListener || RT.networkState !== hT.OFFLINE || (this._onlineReconnectListener = RT.onlineWaiter && RT.onlineWaiter.then(() => {
              this._onlineReconnectListener = void 0;
            }));
            let i2 = true;
            if (this._reconnectInterrupter = () => {
              i2 = false;
            }, t2) {
              const t3 = zT(this._reconnectCount, this._retryConfig);
              KC.debug("[".concat(this._name, "] wait ").concat(t3, "ms to reconnect datachannel, mode: ").concat(e2)), await tg.race([UT(t3), this._onlineReconnectListener || new tg(() => {
              })]);
            }
            if ("closed" === this.state || !i2)
              return false;
            this._reconnectCount += 1;
            const n2 = async (e3, t3) => {
              this.emit(CI.RECONNECT_CREATE_CONNECTION, t3), await this.createTransmitterConnection(e3);
            };
            try {
              if ("retry" === e2) {
                const t3 = this._addresses[this.currentURLIndex];
                this.emit(CI.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
              } else if ("tryNext" === e2) {
                this.currentURLIndex += 1;
                for (let e3 = this.currentURLIndex; e3 < this._addresses.length; e3++) {
                  if (this._addresses[e3].fingerprint || kC("FINGERPRINT")) {
                    this.currentURLIndex = e3;
                    break;
                  }
                  this.currentURLIndex += 1;
                }
                if (this.currentURLIndex >= this._addresses.length)
                  return KC.debug("[".concat(this._name, "] the available addresses are exhausted, change to recover")), await this.reconnectWithAction("recover", false);
                KC.debug("[".concat(this._name, "] datachannel url length: ").concat(this._addresses.length, " current index: ").concat(this.currentURLIndex));
                const t3 = this._addresses[this.currentURLIndex];
                this.emit(CI.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
              } else
                "recover" === e2 && (KC.debug("[".concat(this._name, "] start to failback to websocket")), this.resetReconnectCount("recover mode"), this.emit(CI.RECONNECT_WAITTING_FINISH, e2), this.emit(CI.FAILBACK));
              return true;
            } catch (i3) {
              var r2, s2;
              return KC.error("[".concat(this._name, "] reconnect failed"), i3.toString()), null != i3 && null !== (r2 = i3.data) && void 0 !== r2 && r2.desc && Array.isArray(i3.data.desc) && i3.data.desc.length && Pr(s2 = i3.data.desc).call(s2, "dynamic key expired") ? (this.emit(CI.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e2, t2);
            }
          }
        }
        class OD extends iT {
          get connectionState() {
            return this._connectionState;
          }
          set connectionState(e2) {
            e2 !== this._connectionState && (this._connectionState = e2, e2 === fv.CONNECTED ? this.emit(gv.WS_CONNECTED) : e2 === fv.RECONNECTING ? this.emit(gv.WS_RECONNECTING, this._websocketReconnectReason) : e2 === fv.CLOSED && this.emit(gv.WS_CLOSED, this._disconnectedReason));
          }
          get currentURLIndex() {
            return this.websocket.currentURLIndex;
          }
          get url() {
            return this.websocket ? this.websocket.url : null;
          }
          get rtt() {
            return this.rttRolling.mean();
          }
          constructor(e2, t2) {
            super(), nu(this, "_disconnectedReason", void 0), nu(this, "_websocketReconnectReason", void 0), nu(this, "_connectionState", fv.CLOSED), nu(this, "reconnectToken", void 0), nu(this, "websocket", void 0), nu(this, "openConnectionTime", void 0), nu(this, "clientId", void 0), nu(this, "lastMsgTime", Date.now()), nu(this, "uploadCache", []), nu(this, "uploadCacheInterval", void 0), nu(this, "rttRolling", new dS(5)), nu(this, "pingpongTimer", void 0), nu(this, "inflateDataTimer", void 0), nu(this, "pingpongTimeoutCount", 0), nu(this, "joinResponse", void 0), nu(this, "multiIpOption", void 0), nu(this, "initError", void 0), nu(this, "spec", void 0), nu(this, "store", void 0), nu(this, "onWebsocketMessage", (e3) => {
              if (e3 instanceof ArrayBuffer)
                return void this.emit(gv.ON_BINARY_DATA, e3);
              const t3 = JSON.parse(e3);
              if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
                const e4 = "res-@".concat(t3._id);
                this.emit(e4, t3._result, t3._message);
              } else if (Object.prototype.hasOwnProperty.call(t3, "_type") && (this.emit(t3._type, t3._message), t3._type === Rv.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === Rv.ON_USER_BANNED))
                switch (t3._message.error_code) {
                  case 14:
                    this.close(cT.UID_BANNED);
                    break;
                  case 15:
                    this.close(cT.IP_BANNED);
                    break;
                  case 16:
                    this.close(cT.CHANNEL_BANNED);
                }
            }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new wD("gateway-".concat(this.clientId), this.spec.retryConfig, true, t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
              this.connectionState === fv.CONNECTED && this.reconnect("retry", RI.OFFLINE);
            });
          }
          async request(e2, t2, i2, n2) {
            const r2 = xT(6, ""), s2 = { _id: r2, _type: e2, _message: t2 }, o2 = this.websocket.connectionID, a2 = () => new tg((t3, i3) => {
              if (this.connectionState === fv.CONNECTED)
                return t3();
              const n3 = () => {
                this.off(gv.WS_CLOSED, r3), t3();
              }, r3 = () => {
                this.off(gv.WS_CONNECTED, n3), i3(new xv(xg.WS_ABORT));
              };
              this.once(gv.WS_CONNECTED, n3), this.once(gv.WS_CLOSED, r3), e2 !== Tv.PUBLISH && e2 !== Tv.SUBSCRIBE && e2 !== Tv.UNSUBSCRIBE && e2 !== Tv.UNPUBLISH && e2 !== Tv.CONTROL && e2 !== Tv.RESTART_ICE || this.once(gv.DISCONNECT_P2P, () => {
                i3(new xv(xg.DISCONNECT_P2P));
              }), e2 !== Tv.PUBLISH && e2 !== Tv.RESTART_ICE || this.once(gv.ABORT_P2P_EXECUTION, () => {
                i3(new xv(xg.DISCONNECT_P2P));
              });
            });
            if (this.connectionState !== fv.CONNECTING && this.connectionState !== fv.RECONNECTING || e2 === Tv.JOIN || e2 === Tv.REJOIN || await a2(), e2 === Tv.LEAVE && (this.websocket.unbindDcCloseEventListener(), n2 = true), this.websocket.sendMessage(s2, true, false), n2)
              return;
            const c2 = new tg((i3, n3) => {
              let s3 = false;
              const a3 = (n4, r3) => {
                s3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(gv.WS_CLOSED, c3), this.off(gv.WS_RECONNECTING, c3), this.emit(gv.REQUEST_SUCCESS, e2, t2);
              };
              this.once("res-@".concat(r2), a3);
              const c3 = () => {
                n3(new xv(xg.WS_ABORT, "type: ".concat(e2))), this.off(gv.WS_CLOSED, c3), this.off(gv.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
              };
              this.once(gv.WS_CLOSED, c3), this.once(gv.WS_RECONNECTING, c3), UT(kC("SIGNAL_REQUEST_TIMEOUT")).then(() => {
                this.websocket.connectionID !== o2 || s3 || (KC.warning("dc request timeout, type: ".concat(e2)), this.emit(gv.REQUEST_TIMEOUT, e2, t2));
              });
            });
            let d2 = null;
            try {
              d2 = await c2;
            } catch (n3) {
              if (this.connectionState === fv.CLOSED || e2 === Tv.LEAVE)
                throw new xv(xg.WS_ABORT);
              return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === Tv.JOIN || e2 === Tv.REJOIN ? null : (await a2(), await this.request(e2, t2));
            }
            if (d2.isSuccess)
              return d2.message;
            const l2 = Number(d2.message.error_code || d2.message.code), h2 = UI(l2), u2 = new xv(xg.UNEXPECTED_RESPONSE, "".concat(h2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message });
            return "success" === h2.action ? d2.message : (KC.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(h2.desc, ", action: ").concat(h2.action)), l2 === mv.ERR_TOO_MANY_BROADCASTERS ? e2 === Tv.JOIN || e2 === Tv.REJOIN ? (this.initError = u2, this.close(), u2.throw()) : u2.throw() : "failed" === h2.action ? u2.throw() : "quit" === h2.action ? (this.initError = u2, this.close(), u2.throw()) : (l2 === mv.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, KC.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", RI.MULTI_IP)) : this.reconnect(h2.action, RI.SERVER_ERROR), e2 === Tv.JOIN || e2 === Tv.REJOIN ? null : await this.request(e2, t2)));
          }
          waitMessage(e2, t2) {
            return new tg((i2) => {
              const n2 = (r2) => {
                (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
              };
              this.on(e2, n2);
            });
          }
          upload(e2, t2) {
            const i2 = { _type: e2, _message: t2 };
            try {
              this.websocket.sendMessage(i2);
            } catch (e3) {
              const t3 = kC("MAX_UPLOAD_CACHE") || 50;
              this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
                if (this.connectionState !== fv.CONNECTED)
                  return;
                const e4 = this.uploadCache.splice(0, 1)[0];
                0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
              }, kC("UPLOAD_CACHE_INTERVAL") || 2e3));
            }
          }
          send(e2, t2) {
            const i2 = { _type: e2, _message: t2 };
            this.websocket.sendMessage(i2);
          }
          init(e2, t2) {
            return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new tg((i2, n2) => {
              this.once(gv.WS_CONNECTED, () => i2(this.joinResponse)), this.once(gv.WS_CLOSED, () => n2(this.initError || new xv(xg.WS_ABORT))), this.connectionState = fv.CONNECTING, this.websocket.init(e2).catch(n2), this.websocket.once(CI.FAILBACK, () => {
                void 0 === this.openConnectionTime && n2(new xv(xg.INIT_DATACHANNEL_TIMEOUT));
              }), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval(() => {
                this.handleInflateData();
              }, 2e4), setTimeout(() => {
                t2 && void 0 === this.openConnectionTime && (KC.debug("[".concat(this.clientId, "] init datachannel timeout while join with failback to websocket")), n2(new xv(xg.INIT_DATACHANNEL_TIMEOUT)));
              }, kC("DC_JOIN_WITH_FAILBACK"));
            });
          }
          close(e2) {
            this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || cT.LEAVE, this.connectionState = fv.CLOSED, KC.debug("[".concat(this.clientId, "] ") + "will close datachannel in signal"), this.websocket.close(), e2 === cT.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new wD("gateway-".concat(this.clientId), this.spec.retryConfig, true, this.store), this.handleWebsocketEvents());
          }
          async join() {
            if (!this.joinResponse) {
              this.emit(gv.ABORT_P2P_EXECUTION);
              const e2 = await fT(this, gv.DATACHANNEL_CONNECTING), t2 = await this.request(Tv.JOIN, e2);
              if (!t2)
                return this.emit(gv.REPORT_JOIN_GATEWAY, xg.TIMEOUT, this.url || ""), false;
              this.joinResponse = t2, this.emit(gv.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
            }
            return this.connectionState = fv.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
          }
          async rejoin() {
            if (!this.reconnectToken)
              throw new xv(xg.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
            const e2 = ST(this, gv.REQUEST_REJOIN_INFO);
            e2.token = this.reconnectToken;
            const t2 = await this.request(Tv.REJOIN, e2);
            return !!t2 && (this.connectionState = fv.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
              this.emit(Rv.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(Rv.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(Rv.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(Rv.MUTE_AUDIO, { uid: e3.uid }) : this.emit(Rv.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(Rv.MUTE_VIDEO, { uid: e3.uid }) : this.emit(Rv.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(Rv.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(Rv.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(Rv.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(Rv.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(Rv.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
            }), true);
          }
          reconnect(e2, t2) {
            this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
          }
          handleNotification(e2) {
            KC.debug("[".concat(this.clientId, "] receive notification: "), e2);
            const t2 = UI(e2.code);
            if ("success" !== t2.action) {
              if ("failed" !== t2.action)
                return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(cT.UID_BANNED), void this.close()) : void this.reconnect(t2.action, RI.SERVER_ERROR);
              KC.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
            }
          }
          handlePingPong() {
            if (!this.websocket || "connected" !== this.websocket.state)
              return;
            this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
            const e2 = kC("PING_PONG_TIME_OUT"), t2 = Date.now();
            this.pingpongTimeoutCount >= e2 && (KC.warning("PINGPONG Timeout. Last Socket Message: ".concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > kC("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", RI.TIMEOUT) : this.request(Tv.PING, void 0, true).then(() => {
              this.pingpongTimeoutCount = 0;
              const e3 = Date.now() - t2;
              this.rttRolling.add(e3), kC("REPORT_STATS") && this.send(Tv.PING_BACK, { pingpongElapse: e3 });
            }).catch((e3) => {
            });
          }
          handleInflateData() {
            const { inflateLength: e2, deflateLength: t2 } = this.websocket.getInflateData();
            0 !== e2 && 0 !== t2 && this.upload(Sv.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
          }
          handleWebsocketEvents() {
            this.websocket.on(CI.RECONNECT_WAITTING_FINISH, (e2) => {
              this.emit(gv.WS_RECONNECT_WAITTING_FINISH, e2);
            }), this.websocket.on(CI.RECONNECT_CREATE_CONNECTION, (e2) => {
              this.emit(gv.WS_RECONNECT_CREATE_CONNECTION, e2);
            }), this.websocket.on(CI.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(CI.CLOSED, () => {
              this.connectionState = fv.CLOSED;
            }), this.websocket.on(CI.FAILED, () => {
              this._disconnectedReason = cT.NETWORK_ERROR, this.connectionState = fv.CLOSED;
            }), this.websocket.on(CI.RECONNECTING, (e2) => {
              this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === fv.CONNECTED ? this.connectionState = fv.RECONNECTING : this.connectionState = fv.CONNECTING;
            }), this.websocket.on(CI.WILL_RECONNECT, (e2, t2) => {
              if (ST(this, gv.IS_P2P_DISCONNECTED) && "retry" === e2)
                return KC.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(gv.NEED_RENEW_SESSION), this.emit(gv.DISCONNECT_P2P), t2("tryNext");
              "retry" !== e2 && (KC.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(gv.NEED_RENEW_SESSION), this.emit(gv.DISCONNECT_P2P)), t2(e2);
            }), this.websocket.on(CI.CONNECTED, () => {
              this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
                KC.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", RI.SERVER_ERROR);
              }) : this.join().catch((e2) => {
                if (this.emit(gv.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof xv && e2.code === xg.UNEXPECTED_RESPONSE && e2.data.code === mv.ERR_NO_AUTHORIZED)
                  return KC.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", RI.SERVER_ERROR);
                KC.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", RI.SERVER_ERROR) : (this.initError = e2, this.close());
              });
            }), this.websocket.on(CI.REQUEST_NEW_URLS, (e2, t2) => {
              fT(this, gv.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
            }), this.websocket.on(CI.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
              this.emit(Rv.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
            }), this.websocket.on(CI.TO_CONNECT_DATACHANNEL, async (e2, t2, i2) => fT(this, gv.DATACHANNEL_PRECONNECT, e2).then(t2).catch(i2)), this.websocket.on(CI.FAILBACK, () => {
              void 0 !== this.openConnectionTime && this.emit(gv.DATACHANNEL_FAILBACK);
            });
          }
        }
        class ND extends iT {
          constructor(e2) {
            super(), nu(this, "_signal", void 0), nu(this, "_sequence", 0), nu(this, "_userMap", /* @__PURE__ */ new Map()), nu(this, "_encoder", new TextEncoder()), this._signal = e2;
          }
          async send(e2, t2, i2, n2, r2) {
            var s2, o2, a2;
            "string" != typeof t2 && (t2 = JSON.stringify(t2)), n2 = null !== (s2 = n2) && void 0 !== s2 ? s2 : xT(6, ""), r2 = null !== (o2 = r2) && void 0 !== o2 ? o2 : this._sequence++;
            const c2 = { _id: n2, _type: e2, _seq: null !== (a2 = r2) && void 0 !== a2 ? a2 : this._sequence++, _message: t2 };
            if (kC("SHOW_P2P_LOG") && KC.debug("send message", c2), this.sendStreamMessage(JSON.stringify(c2)), i2)
              return;
            const d2 = new tg((t3, i3) => {
              const r3 = window.setTimeout(() => {
                this.off("res-@".concat(n2), s3), KC.warning("[external-signal] request timeout, type: ".concat(e2)), 0 === this._userMap.size ? i3(new Vg(xg.INVALID_REMOTE_USER)) : i3(new Vg(xg.TIMEOUT));
              }, kC("EXTERNAL_SIGNAL_REQUEST_TIMEOUT")), s3 = (e3, n3) => {
                r3 && window.clearTimeout(r3), "success" === e3 ? t3({ isSuccess: true, message: n3 }) : i3(new Vg(xg.UNEXPECTED_ERROR, n3));
              };
              this.once("res-@".concat(n2), s3);
            });
            let l2;
            try {
              l2 = await d2;
            } catch (i3) {
              if (i3.code === xg.TIMEOUT)
                return await this.send(e2, t2, false, n2, r2);
              throw i3;
            }
            return l2.isSuccess ? l2.message : void 0;
          }
          sendStreamMessage(e2) {
            this._splitMessage(e2).forEach((e3) => {
              this._signal.request(Tv.DATA_STREAM, { payload: PT(this._encoder.encode(e3)) });
            });
          }
          onMessage(e2) {
            const { _uid: t2 } = e2;
            let i2;
            const n2 = this._userMap.get(t2);
            if (n2 ? i2 = n2.splitMessageMap : (i2 = /* @__PURE__ */ new Map(), this._userMap.set(t2, { isStart: false, splitMessageMap: i2, nextExpectedSequenceNumber: 0, receivedMessagesMap: /* @__PURE__ */ new Map() })), "id" in e2 && "total" in e2) {
              var r2;
              const { id: n3, total: s2 } = e2, o2 = null !== (r2 = i2.get(n3)) && void 0 !== r2 ? r2 : [];
              if (o2.push(e2), i2.has(n3) || i2.set(n3, o2), o2.length !== s2)
                return;
              {
                const r3 = Zu(o2).call(o2, (e3, t3) => e3.index - t3.index).map((e3) => e3.payload).join("");
                i2.delete(n3), (e2 = JSON.parse(r3))._uid = t2;
              }
            }
            this.handleReceivedMessage(e2);
          }
          setStart(e2) {
            this._userMap.has(e2) ? this._userMap.get(e2).isStart = true : this._userMap.set(e2, { isStart: true, splitMessageMap: /* @__PURE__ */ new Map(), nextExpectedSequenceNumber: 0, receivedMessagesMap: /* @__PURE__ */ new Map() }), this.handleReceivedMessage();
          }
          setEnd(e2) {
            return this._userMap.delete(e2), 0 === this._userMap.size;
          }
          ack(e2, t2, i2) {
            this.send(wI.ACK, JSON.stringify({ success: !i2, message: t2 }), true, e2);
          }
          handleReceivedMessage(e2) {
            const t2 = () => {
              this._userMap.forEach((e3) => {
                const { receivedMessagesMap: t3, nextExpectedSequenceNumber: i3 } = e3;
                for (; t3.has(i3); ) {
                  const n3 = t3.get(i3);
                  t3.delete(i3), this.receiveMessage(n3), e3.nextExpectedSequenceNumber++;
                }
              });
            };
            if (!e2)
              return void t2();
            const { _uid: i2, _seq: n2 } = e2, r2 = this._userMap.get(i2), { receivedMessagesMap: s2, isStart: o2, nextExpectedSequenceNumber: a2 } = r2;
            n2 < a2 ? KC.debug("[external-signal] receive old message, seq: ".concat(n2)) : (s2.set(n2, e2), o2 && n2 === a2 && (this.receiveMessage(e2), s2.delete(a2), r2.nextExpectedSequenceNumber++, t2()));
          }
          receiveMessage(e2) {
            const { _id: t2, _type: i2, _message: n2, _uid: r2 } = e2;
            if (kC("SHOW_P2P_LOG") && KC.debug("\u6536\u5230\u6D88\u606F", e2), t2)
              switch (e2._type) {
                case wI.PUBLISH:
                  const s2 = JSON.parse(n2);
                  this._signal.emit(i2, s2, r2), this.ack(e2._id);
                  break;
                case wI.CONTROL:
                case wI.UNPUBLISH:
                case wI.DO_SUBSCRIBE:
                case wI.DO_UNSUBSCRIBE: {
                  const t3 = JSON.parse(n2);
                  t3.uid = r2, fT(this._signal, i2, t3).then((t4) => {
                    this.ack(e2._id, t4);
                  }).catch((t4) => {
                    this.ack(e2._id, void 0, true);
                  });
                  break;
                }
                case wI.ACK: {
                  const { success: e3, message: i3 } = JSON.parse(n2);
                  this.emit("res-@".concat(t2), e3 ? "success" : "failed", i3);
                  break;
                }
                case wI.CALL:
                  fT(this, i2, n2).then((e3) => {
                    this.ack(t2, e3);
                  });
                  break;
                case wI.RESTART_ICE:
                case wI.EXCHANGE_SDP:
                case wI.SUBSCRIBE:
                case wI.UNSUBSCRIBE:
                  fT(this._signal, i2, n2).then((e3) => {
                    this.ack(t2, e3);
                  }).catch((t3) => {
                    this.ack(e2._id, void 0, true);
                  });
                  break;
                case wI.CANDIDATE:
                  this._signal.emit(i2, n2), this.ack(t2);
                  break;
                case wI.JOIN:
                  this.emit(i2, JSON.parse(n2));
                  break;
                default:
                  this.emit(i2, n2), this.ack(t2);
              }
          }
          _splitMessage(e2) {
            if (e2.length < ND.MAX_MESSAGE_SIZE)
              return [e2];
            const t2 = [], i2 = xT(6, "");
            let n2 = 0;
            const r2 = Math.ceil(e2.length / 800);
            for (; e2.length > 0; ) {
              n2++;
              const s2 = e2.slice(0, 800);
              t2.push({ id: i2, index: n2, total: r2, payload: s2 }), e2 = e2.slice(800);
            }
            return t2.map((e3) => JSON.stringify(e3));
          }
          clear() {
            this._sequence = 0, this._userMap.clear();
          }
        }
        nu(ND, "MAX_MESSAGE_SIZE", 1024);
        class DD extends iT {
          get connectionState() {
            return this._connectionState;
          }
          set connectionState(e2) {
            e2 !== this._connectionState && (this._connectionState = e2, e2 === fv.CONNECTED ? this.emit(gv.WS_CONNECTED) : e2 === fv.RECONNECTING ? this.emit(gv.WS_RECONNECTING, this._websocketReconnectReason) : e2 === fv.CLOSED && this.emit(gv.WS_CLOSED, this._disconnectedReason));
          }
          get currentURLIndex() {
            return this.websocket.currentURLIndex;
          }
          get url() {
            return this.websocket && this.websocket.url || null;
          }
          get rtt() {
            return this.rttRolling.mean();
          }
          constructor(e2, t2) {
            super(), nu(this, "_disconnectedReason", void 0), nu(this, "_websocketReconnectReason", void 0), nu(this, "_connectionState", fv.CLOSED), nu(this, "reconnectToken", void 0), nu(this, "_userInRoom", false), nu(this, "_userOnlineTime", void 0), nu(this, "websocket", void 0), nu(this, "openConnectionTime", void 0), nu(this, "clientId", void 0), nu(this, "lastMsgTime", Date.now()), nu(this, "uploadCache", []), nu(this, "uploadCacheInterval", void 0), nu(this, "rttRolling", new dS(5)), nu(this, "pingpongTimer", void 0), nu(this, "wsInflateDataTimer", void 0), nu(this, "pingpongTimeoutCount", 0), nu(this, "joinResponse", void 0), nu(this, "multiIpOption", void 0), nu(this, "initError", void 0), nu(this, "spec", void 0), nu(this, "store", void 0), nu(this, "_external_signal", void 0), nu(this, "onWebsocketMessage", (e3) => {
              if (e3.data instanceof ArrayBuffer)
                return void this.emit(gv.ON_BINARY_DATA, e3.data);
              const t3 = JSON.parse(e3.data);
              if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
                const e4 = "res-@".concat(t3._id);
                this.emit(e4, t3._result, t3._message);
              } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
                switch (t3._type) {
                  case Rv.ON_DATA_STREAM:
                    return void this.handleDataStream(t3._message);
                  case Rv.MUTE_AUDIO:
                  case Rv.MUTE_VIDEO:
                  case Rv.ON_P2P_LOST:
                    return;
                  case Rv.ON_USER_ONLINE:
                    this.emit(t3._type, t3._message);
                    const { uid: e4 } = t3._message;
                    return this._external_signal.setStart(e4), void this._external_signal.send(wI.JOIN, { onlineTime: this._userOnlineTime }, true);
                }
                if (this.emit(t3._type, t3._message), t3._type === Rv.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === Rv.ON_USER_BANNED)
                  switch (t3._message.error_code) {
                    case 14:
                      this.close(cT.UID_BANNED);
                      break;
                    case 15:
                      this.close(cT.IP_BANNED);
                      break;
                    case 16:
                      this.close(cT.CHANNEL_BANNED);
                  }
                if (t3._type === Rv.ON_USER_LICENSE_BANNED)
                  switch (t3._message.error_code) {
                    case mv.ERR_LICENSE_MISSING:
                      this.close(cT.LICENSE_MISSING);
                      break;
                    case mv.ERR_LICENSE_EXPIRED:
                      this.close(cT.LICENSE_EXPIRED);
                      break;
                    case mv.ERR_LICENSE_MINUTES_EXCEEDED:
                      this.close(cT.LICENSE_MINUTES_EXCEEDED);
                      break;
                    case mv.ERR_LICENSE_PERIOD_INVALID:
                      this.close(cT.LICENSE_PERIOD_INVALID);
                      break;
                    case mv.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                      this.close(cT.LICENSE_MULTIPLE_SDK_SERVICE);
                      break;
                    case mv.ERR_LICENSE_ILLEGAL:
                      this.close(cT.LICENSE_ILLEGAL);
                      break;
                    default:
                      this.close();
                  }
              }
            }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new zI("gateway-".concat(this.clientId), this.spec.retryConfig, true, kC("JOIN_GATEWAY_USE_DUAL_DOMAIN"), kC("JOIN_GATEWAY_USE_443PORT_ONLY"), t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
              this.connectionState === fv.CONNECTED && this.reconnect("retry", lT.OFFLINE);
            }), this._external_signal = new ND(this), this._handleSignalP2PEvents();
          }
          async request(e2, t2, i2, n2) {
            const r2 = xT(6, ""), s2 = { _id: r2, _type: e2, _message: t2 }, o2 = this.websocket.connectionID, a2 = () => new tg((t3, i3) => {
              if (this.connectionState === fv.CONNECTED)
                return t3();
              const n3 = () => {
                this.off(gv.WS_CLOSED, r3), t3();
              }, r3 = () => {
                this.off(gv.WS_CONNECTED, n3), i3(new Vg(xg.WS_ABORT));
              };
              this.once(gv.WS_CONNECTED, n3), this.once(gv.WS_CLOSED, r3), e2 !== Tv.PUBLISH && e2 !== Tv.SUBSCRIBE && e2 !== Tv.UNSUBSCRIBE && e2 !== Tv.UNPUBLISH && e2 !== Tv.CONTROL && e2 !== Tv.RESTART_ICE || this.once(gv.DISCONNECT_P2P, () => {
                i3(new Vg(xg.DISCONNECT_P2P));
              }), e2 !== Tv.PUBLISH && e2 !== Tv.RESTART_ICE || this.once(gv.ABORT_P2P_EXECUTION, () => {
                i3(new Vg(xg.DISCONNECT_P2P));
              });
            });
            if (this.connectionState !== fv.CONNECTING && this.connectionState !== fv.RECONNECTING || e2 === Tv.JOIN || e2 === Tv.REJOIN || await a2(), this.websocket.sendMessage(s2, true), n2)
              return;
            const c2 = new tg((i3, n3) => {
              let s3 = false;
              const a3 = (n4, r3) => {
                s3 = true, i3({ isSuccess: "success" === n4, message: r3 || {} }), this.off(gv.WS_CLOSED, c3), this.off(gv.WS_RECONNECTING, c3), this.emit(gv.REQUEST_SUCCESS, e2, t2);
              };
              this.once("res-@".concat(r2), a3);
              const c3 = () => {
                n3(new Vg(xg.WS_ABORT, "type: ".concat(e2))), this.off(gv.WS_CLOSED, c3), this.off(gv.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
              };
              this.once(gv.WS_CLOSED, c3), this.once(gv.WS_RECONNECTING, c3), UT(kC("SIGNAL_REQUEST_TIMEOUT")).then(() => {
                this.websocket.connectionID !== o2 || s3 || (KC.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(gv.REQUEST_TIMEOUT, e2, t2));
              });
            });
            let d2 = null;
            try {
              d2 = await c2;
            } catch (n3) {
              if (this.connectionState === fv.CLOSED || e2 === Tv.LEAVE)
                throw new Vg(xg.WS_ABORT);
              return !this.spec.forceWaitGatewayResponse || i2 ? n3.throw() : e2 === Tv.JOIN || e2 === Tv.REJOIN ? null : (await a2(), await this.request(e2, t2));
            }
            if (d2.isSuccess)
              return d2.message;
            const l2 = Number(d2.message.error_code || d2.message.code), h2 = UI(l2), u2 = new Vg(xg.UNEXPECTED_RESPONSE, "".concat(h2.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message });
            return "success" === h2.action ? d2.message : (KC.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(h2.desc, ", action: ").concat(h2.action)), l2 === mv.ERR_TOO_MANY_BROADCASTERS ? e2 === Tv.JOIN || e2 === Tv.REJOIN ? (this.initError = u2, this.close(), u2.throw()) : u2.throw() : "failed" === h2.action ? u2.throw() : "quit" === h2.action ? (this.initError = u2, this.close(), u2.throw()) : (l2 === mv.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, KC.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", lT.MULTI_IP)) : this.reconnect(h2.action, lT.SERVER_ERROR), e2 === Tv.JOIN || e2 === Tv.REJOIN ? null : await this.request(e2, t2)));
          }
          waitMessage(e2, t2) {
            return new tg((i2) => {
              const n2 = (r2) => {
                (!t2 || t2(r2)) && (this.off(e2, n2), i2(r2));
              };
              this.on(e2, n2);
            });
          }
          upload(e2, t2) {
            const i2 = { _type: e2, _message: t2 };
            try {
              this.websocket.sendMessage(i2);
            } catch (e3) {
              const t3 = kC("MAX_UPLOAD_CACHE") || 50;
              this.uploadCache.push(i2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
                if (this.connectionState !== fv.CONNECTED)
                  return;
                const e4 = this.uploadCache.splice(0, 1)[0];
                0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
              }, kC("UPLOAD_CACHE_INTERVAL") || 2e3));
            }
          }
          send(e2, t2) {
            const i2 = { _type: e2, _message: t2 };
            this.websocket.sendMessage(i2);
          }
          async sendExtensionMessage(e2, t2, i2) {
            return await this.waitTillUserOnline(), await this._external_signal.send(e2, t2, i2);
          }
          init(e2, t2) {
            return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new tg((t3, i2) => {
              this.once(gv.WS_CONNECTED, () => t3(this.joinResponse)), this.once(gv.WS_CLOSED, () => i2(this.initError || new Vg(xg.WS_ABORT))), this.connectionState = fv.CONNECTING, this.websocket.init(e2).catch(i2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
                this.handleWsInflateData();
              }, 2e4);
            });
          }
          close(e2) {
            this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || cT.LEAVE, this.connectionState = fv.CLOSED, KC.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e2 === cT.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new zI("gateway-".concat(this.clientId), this.spec.retryConfig, true, kC("JOIN_GATEWAY_USE_DUAL_DOMAIN"), kC("JOIN_GATEWAY_USE_443PORT_ONLY"), this.store), this.handleWebsocketEvents());
          }
          async join() {
            if (!this.joinResponse) {
              this.emit(gv.ABORT_P2P_EXECUTION);
              const e2 = await fT(this, gv.REQUEST_JOIN_INFO), t2 = await this.request(Tv.JOIN, e2);
              if (!t2)
                return this.emit(gv.REPORT_JOIN_GATEWAY, xg.TIMEOUT, this.url || ""), false;
              this.joinResponse = t2, this.emit(gv.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
            }
            return this.connectionState = fv.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), this._userOnlineTime = (/* @__PURE__ */ new Date()).getTime(), this._external_signal.clear(), true;
          }
          async rejoin() {
            if (!this.reconnectToken)
              throw new Vg(xg.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
            const e2 = ST(this, gv.REQUEST_REJOIN_INFO);
            e2.token = this.reconnectToken;
            return !!await this.request(Tv.REJOIN, e2) && (this.connectionState = fv.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true);
          }
          reconnect(e2, t2) {
            this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
          }
          handleDataStream(e2) {
            try {
              var t2;
              const i2 = DT(e2.payload), n2 = new TextDecoder().decode(i2), r2 = JSON.parse(n2);
              "total" in r2 && "id" in r2 || Pr(t2 = Object.values(wI)).call(t2, r2._type) ? (e2.seq && delete e2.seq, r2._uid = e2.uid, this._external_signal.onMessage(r2)) : this.emit(Rv.ON_DATA_STREAM, e2);
            } catch (e3) {
            }
          }
          handleNotification(e2) {
            KC.debug("[".concat(this.clientId, "] receive notification: "), e2);
            const t2 = UI(e2.code);
            if ("success" !== t2.action) {
              if ("failed" !== t2.action)
                return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(cT.UID_BANNED), void this.close()) : void this.reconnect(t2.action, lT.SERVER_ERROR);
              KC.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
            }
          }
          handlePingPong() {
            if (!this.websocket || "connected" !== this.websocket.state)
              return;
            this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
            const e2 = kC("PING_PONG_TIME_OUT"), t2 = Date.now();
            this.pingpongTimeoutCount >= e2 && (KC.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > kC("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", lT.TIMEOUT) : this.request(Tv.PING, void 0, true).then(() => {
              this.pingpongTimeoutCount = 0;
              const e3 = Date.now() - t2;
              this.rttRolling.add(e3), kC("REPORT_STATS") && this.send(Tv.PING_BACK, { pingpongElapse: e3 });
            }).catch((e3) => {
            });
          }
          handleWsInflateData() {
            const { wsInflateLength: e2, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
            0 !== e2 && 0 !== t2 && this.upload(Sv.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
          }
          handleWebsocketEvents() {
            this.websocket.on(Iv.RECONNECT_WAITTING_FINISH, (e2) => {
              this.emit(gv.WS_RECONNECT_WAITTING_FINISH, e2);
            }), this.websocket.on(Iv.RECONNECT_CREATE_CONNECTION, (e2) => {
              this.emit(gv.WS_RECONNECT_CREATE_CONNECTION, e2);
            }), this.websocket.on(Iv.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Iv.CLOSED, () => {
              this.connectionState = fv.CLOSED;
            }), this.websocket.on(Iv.FAILED, () => {
              this._disconnectedReason = cT.NETWORK_ERROR, this.connectionState = fv.CLOSED;
            }), this.websocket.on(Iv.RECONNECTING, (e2) => {
              this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === fv.CONNECTED ? this.connectionState = fv.RECONNECTING : this.connectionState = fv.CONNECTING;
            }), this.websocket.on(Iv.WILL_RECONNECT, (e2, t2, i2) => {
              if (ST(this, gv.IS_P2P_DISCONNECTED) && "retry" === e2)
                return KC.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(gv.NEED_RENEW_SESSION), this.emit(gv.DISCONNECT_P2P), i2("tryNext");
              "retry" !== e2 && (KC.debug("".concat(this.clientId, " websocket will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(gv.NEED_RENEW_SESSION), this.emit(gv.DISCONNECT_P2P)), i2(e2);
            }), this.websocket.on(Iv.CONNECTED, () => {
              this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
                KC.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", lT.SERVER_ERROR);
              }) : this.join().catch((e2) => {
                if (this.emit(gv.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof Vg && e2.code === xg.UNEXPECTED_RESPONSE && e2.data.code === mv.ERR_NO_AUTHORIZED)
                  return KC.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", lT.SERVER_ERROR);
                KC.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", lT.SERVER_ERROR) : (this.initError = e2, this.close());
              });
            }), this.websocket.on(Iv.REQUEST_NEW_URLS, (e2, t2) => {
              fT(this, gv.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
            }), this.websocket.on(Iv.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
              this.emit(Rv.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
            });
          }
          _handleSignalP2PEvents() {
            this._external_signal.on(wI.JOIN, async (e2) => {
              if (this._userOnlineTime && this._userOnlineTime < e2.onlineTime) {
                const e3 = await fT(this, gv.P2P_START, void 0), t2 = await this._external_signal.send(wI.CALL, e3);
                this.emit(gv.P2P_CONNECTION, t2, true);
              }
              this._userInRoom = true, this.emit("user-online");
            }), this.on(Rv.ON_USER_OFFLINE, async (e2) => {
              this._external_signal.clear(), this._userInRoom = false;
            }), this._external_signal.on(wI.CALL, async (e2, t2, i2) => {
              this._userInRoom = true, this.emit("user-online");
              try {
                t2(await fT(this, gv.P2P_START, e2));
              } catch (e3) {
                i2(e3);
              }
            });
          }
          async waitTillUserOnline() {
            return new tg((e2) => {
              if (this._userInRoom)
                e2();
              else {
                const t2 = () => {
                  this.off("user-online", t2), e2();
                };
                this.on("user-online", t2);
              }
            });
          }
        }
        function PD(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function LD(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? PD(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : PD(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        const kD = /* @__PURE__ */ new Map();
        class MD extends iT {
          get state() {
            return this._state;
          }
          set state(e2) {
            if (e2 === this._state)
              return;
            const t2 = this._state;
            this._state = e2, "DISCONNECTED" === e2 && this._disconnectedReason ? this.emit(eI.CONNECTION_STATE_CHANGE, e2, t2, this._disconnectedReason) : this.emit(eI.CONNECTION_STATE_CHANGE, e2, t2);
          }
          get joinGatewayStartTime() {
            return this._joinGatewayStartTime;
          }
          set joinGatewayStartTime(e2) {
            KC.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), this._joinGatewayStartTime = e2;
          }
          constructor(e2, t2) {
            super(), nu(this, "store", void 0), nu(this, "joinInfo", void 0), nu(this, "key", void 0), nu(this, "ntpOffset", 0), nu(this, "signal", void 0), nu(this, "role", void 0), nu(this, "inChannelInfo", { joinAt: null, duration: 0 }), nu(this, "spec", void 0), nu(this, "_state", "DISCONNECTED"), nu(this, "_statsCollector", void 0), nu(this, "_disconnectedReason", void 0), nu(this, "isSignalRecover", false), nu(this, "hasChangeBGPAddress", false), nu(this, "trafficStatsInterval", void 0), nu(this, "networkQualityInterval", void 0), nu(this, "_joinGatewayStartTime", 0), nu(this, "_signalTimeout", false), nu(this, "_clientRoleOptions", void 0), nu(this, "_isProactiveJoin", false), this.store = e2, this.spec = t2, this.signal = this.store.useP2P ? new DD(LD(LD({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2) : this.store.useDataChannel ? new OD(LD(LD({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2) : new QI(LD(LD({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2), this._statsCollector = t2.statsCollector, this.role = t2.role || "audience", this._clientRoleOptions = t2.clientRoleOptions, this.handleSignalEvents();
          }
          async join(e2, t2, i2) {
            if (this.signal instanceof OD) {
              let t3 = false;
              "disabled" !== e2.cloudProxyServer ? (KC.debug("[".concat(this.store.clientId, "] Dc is not supported, because cloudProxyServer are not supported (").concat(e2.cloudProxyServer, ")")), t3 = true) : "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length > 255 || "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length < 22 ? (KC.debug("[".concat(this.store.clientId, "] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")), t3 = true) : e2.apResponse.addresses.some((e3) => e3.fingerprint) || kC("FINGERPRINT") || (KC.debug("[".concat(this.store.clientId, "] Dc is not supported, because fingerprint does not exist")), t3 = true), t3 && this.resetSignal();
            }
            this.store.joinGatewayStart(), "disabled" !== e2.cloudProxyServer && (this.hasChangeBGPAddress = true);
            const n2 = Date.now();
            let r2 = kD.get(e2.cname);
            if (r2 || (r2 = /* @__PURE__ */ new Map(), kD.set(e2.cname, r2)), this._isProactiveJoin = true, r2.has(e2.uid)) {
              const t3 = new xv(xg.UID_CONFLICT);
              throw rv.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.message, addr: null, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e2.proxyServer, signalChannel: this.signal instanceof OD ? "1" : "0" }), this._isProactiveJoin = false, t3;
            }
            r2.set(e2.uid, true), this.joinInfo = e2, this.key = t2;
            let s2 = 0;
            this.joinGatewayStartTime = n2;
            const o2 = e2.proxyServer;
            try {
              let t3;
              if (KC.debug("[".concat(this.store.clientId, "] use ").concat(this.signal instanceof OD ? "datachannel" : "websocket", " join uid ").concat(s2)), this.signal instanceof OD)
                t3 = await this.signal.init(e2.apResponse.addresses, i2);
              else {
                const n3 = e2.gatewayAddrs.map((t4) => {
                  let { address: i3 } = t4;
                  const [n4, r3] = i3.split(":"), s3 = { host: n4, port: r3 };
                  return e2.proxyServer && (s3.proxy = e2.proxyServer), s3;
                });
                t3 = await this.signal.init(n3, i2);
              }
              s2 = t3.uid, KC.debug("[".concat(this.store.clientId, "] ").concat(this.signal instanceof OD ? "datachannel" : "websocket", " join uid ").concat(s2, " cost ").concat(Date.now() - this.joinGatewayStartTime));
            } catch (t3) {
              if (t3 && t3.code === xg.INIT_WEBSOCKET_TIMEOUT)
                throw KC.warning("[".concat(this.store.clientId, "] User join failed"), t3.toString()), t3;
              if (t3 && t3.code === xg.INIT_DATACHANNEL_TIMEOUT)
                throw KC.warning("[".concat(this.store.clientId, "] User join datachannel failed"), t3.toString()), this.resetSignal(), t3;
              throw KC.error("[".concat(this.store.clientId, "] User join failed"), t3.toString()), rv.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.message, addr: this.signal.url, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!o2, signalChannel: this.signal instanceof OD ? "1" : "0" }), this._isProactiveJoin = false, r2.delete(e2.uid), this.signal.close(), t3;
            }
            return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), KC.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
              this.updateTrafficStats().catch((e3) => {
                KC.warning("[".concat(this.store.clientId, "] get traffic stats error"), e3.toString());
              });
            }, 3e3), this.networkQualityInterval = window.setInterval(() => {
              navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(eI.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(eI.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(eI.NETWORK_QUALITY, { uplinkNetworkQuality: TD(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: TD(this._statsCollector.trafficStats.B_dnq) }) : this.emit(eI.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
            }, 2e3), this.store.joinGatewayEnd(), s2;
          }
          async leave() {
            let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 ? arguments[1] : void 0;
            if ("DISCONNECTED" !== this.state) {
              t2 !== cT.FALLBACK && (this.state = "DISCONNECTING");
              try {
                e2 || this.signal.connectionState !== fv.CONNECTED || await function(e3, t3) {
                  return t3 === 1 / 0 ? e3 : tg.race([e3, MT(t3)]);
                }(this.signal.request(Tv.LEAVE, void 0, true), 3e3);
              } catch (e3) {
                KC.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e3);
              }
              this.signal.close(t2), t2 !== cT.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
            }
          }
          async publish(e2, t2, i2) {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new xv(xg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            const n2 = { state: "offer", p2p_id: this.store.p2pId, ortc: t2, mode: this.spec.mode, extend: kC("PUB_EXTEND"), twcc: !!kC("PUBLISH_TWCC"), rtx: !!kC("USE_PUB_RTX") };
            try {
              return (await this.signal.request(Tv.PUBLISH, n2, true))._message;
            } catch (n3) {
              if (i2 && n3.data && n3.data.code === mv.ERR_PUBLISH_REQUEST_INVALID)
                return KC.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n3.toString()), await this.tryUnpubBeforeRepub(e2, t2), this.publish(e2, t2, false);
              throw n3;
            }
          }
          async publishDataChannel(e2, t2, i2) {
            var n2;
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new xv(xg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            const r2 = { stream_id: t2.streamId, ordered: t2.ordered ? 1 : 0, max_retrans_times: null !== (n2 = t2.maxRetransmits) && void 0 !== n2 ? n2 : 10, channel_id: t2.channelId, metadata: t2.metadata };
            try {
              await this.signal.request(Tv.PUBLISH_DATASTREAM, r2, true);
            } catch (n3) {
              if (i2 && n3.data && n3.data.code === mv.ERR_PUBLISH_REQUEST_INVALID)
                return KC.warning("[".concat(this.store.clientId, "] receive publish datachannels error code, retry"), n3.toString()), await this.tryUnpubDataChannelBeforeRepub(e2, t2), this.publishDataChannel(e2, t2, false);
              throw n3;
            }
          }
          async unpublish(e2, t2) {
            try {
              if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
                throw new xv(xg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
              await this.signal.request(Tv.UNPUBLISH, { stream_id: t2, ortc: e2 }, true);
            } catch (e3) {
              KC.warning("[".concat(this.store.clientId, "] unpublish warning: "), e3);
            }
          }
          async unpublishDataChannel(e2) {
            try {
              if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
                throw new xv(xg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
              await tg.all(e2.map((e3) => this.signal.request(Tv.UNPUBLISH_DATASTREAM, { channel_id: e3 }, true)));
            } catch (e3) {
              KC.warning("unpublish datachannels warning: ", e3);
            }
          }
          async subscribe(e2, t2, i2) {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new xv(xg.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
            const n2 = { stream_id: e2, stream_type: t2.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!kC("SUBSCRIBE_TWCC"), rtx: !!kC("USE_SUB_RTX"), extend: kC("SUB_EXTEND"), ssrcId: t2.ssrcId, svc: Array.isArray(kC("SVC")) && 0 !== kC("SVC").length ? kC("SVC") : void 0 };
            try {
              return (await this.signal.request(Tv.SUBSCRIBE, n2, true))._message;
            } catch (n3) {
              if (i2 && n3.data && n3.data.code === mv.ERR_SUBSCRIBE_REQUEST_INVALID)
                return KC.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n3.toString()), await this.tryUnsubBeforeResub(e2, t2), await this.subscribe(e2, t2, false);
              throw n3;
            }
          }
          async subscribeDataChannel(e2, t2, i2) {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new xv(xg.INVALID_OPERATION, "can not subscribe datachannel when connection state is ".concat(this.state));
            const n2 = { uid: e2, stream_id: t2.id, channel_id: t2.datachannelId };
            try {
              return void await this.signal.request(Tv.SUBSCRIBE_DATASTREAM, n2, true);
            } catch (n3) {
              if (i2 && n3.data && n3.data.code === mv.ERR_SUBSCRIBE_REQUEST_INVALID)
                return KC.warning("[".concat(this.store.clientId, "] receiver subscribe datachannel error code, retry"), n3.toString()), await this.tryUnsubDataChannelBeforeResub(e2, t2), await this.subscribeDataChannel(e2, t2, false);
              throw n3;
            }
          }
          async subscribeAll(e2, t2) {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
              throw new xv(xg.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
            const i2 = { p2p_id: this.store.p2pId, users: e2, dtx: false, rtx: !!kC("USE_SUB_RTX") };
            try {
              return await this.signal.request(Tv.SUBSCRIBE_STREAMS, i2, true);
            } catch (i3) {
              if (t2 && i3.data && i3.data.code === mv.ERR_SUBSCRIBE_REQUEST_INVALID)
                return KC.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i3.toString()), await this.tryMassUnsubBeforeResub(e2), await this.subscribeAll(e2, false);
              throw i3;
            }
          }
          async setVideoProfile(e2) {
            const t2 = function(e3) {
              if (!(e3.bitrateMax && e3.bitrateMin && e3.frameRate && e3.height && e3.width))
                return;
              let t3 = e3.frameRate, i2 = e3.width, n2 = e3.height, r2 = true;
              return "number" != typeof t3 && (t3 = t3.exact || t3.ideal || t3.max || t3.min || 0, t3 || (r2 = false)), "number" != typeof i2 && (i2 = i2.exact || i2.ideal || i2.max || i2.min || 0, i2 || (r2 = false)), "number" != typeof n2 && (n2 = n2.exact || n2.ideal || n2.max || n2.min || 0, t3 || (r2 = false)), r2 ? { stream_type: 0, width: i2, height: n2, fps: t3, start_bps: 1e3 * e3.bitrateMax, min_bps: 1e3 * e3.bitrateMin, target_bps: 1e3 * e3.bitrateMax } : void 0;
            }(e2);
            if (t2)
              return this.signal.request(Tv.SET_VIDEO_PROFILE, t2);
            KC.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
          }
          async unsubscribe(e2, t2) {
            try {
              await this.signal.request(Tv.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 }, true);
            } catch (e3) {
              KC.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e3);
            }
          }
          async unsubscribeDataChannel(e2, t2) {
            try {
              if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
                throw new xv(xg.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
              await tg.all(e2.map((e3) => this.signal.request(Tv.UNSUBSCRIBE_DATASTREAM, { stream_id: e3, uid: t2 }, true)));
            } catch (e3) {
              KC.warning("unsubscribeDataChannel warning: ", e3);
            }
          }
          async massUnsubscribe(e2) {
            try {
              await this.signal.request(Tv.UNSUBSCRIBE_STREAMS, e2, true);
            } catch (e3) {
              KC.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e3);
            }
          }
          async reconnectPC(e2) {
            const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = e2;
            return { gatewayEstablishParams: await this.signal.request(Tv.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
          }
          getGatewayInfo() {
            return this.signal.request(Tv.GATEWAY_INFO);
          }
          async renewToken(e2) {
            await this.signal.request(Tv.RENEW_TOKEN, e2), this.key = e2.token;
          }
          async setClientRole(e2, t2) {
            if (t2 && (this._clientRoleOptions = Object.assign({}, t2)), "CONNECTED" !== this.state)
              return void (this.role = e2);
            let i2, n2 = 0;
            "audience" === e2 ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i2 = this._clientRoleOptions.delay, n2 = 1) : n2 = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : n2 = 0, await this.signal.request(Tv.SET_CLIENT_ROLE, { role: e2, level: n2, delay: i2, client_ts: Date.now() }), this.role = e2;
          }
          async setRemoteVideoStreamType(e2, t2) {
            await this.signal.request(Tv.SWITCH_VIDEO_STREAM, { stream_id: e2, stream_type: t2 });
          }
          async setDefaultRemoteVideoStreamType(e2) {
            await this.signal.request(Tv.DEFAULT_VIDEO_STREAM, { stream_type: e2 });
          }
          async setStreamFallbackOption(e2, t2) {
            await this.signal.request(Tv.SET_FALLBACK_OPTION, { stream_id: e2, fallback_type: t2 });
          }
          async pickSVCLayer(e2, t2) {
            await this.signal.request(Tv.PICK_SVC_LAYER, { stream_id: e2, spatial_layer: t2.spatialLayer, temporal_layer: t2.temporalLayer });
          }
          async setRTM2Flag(e2) {
            await this.signal.request(Tv.SET_RTM2_FLAG, { rtm2_flag: e2 });
          }
          async sendExtensionMessage(e2, t2, i2) {
            if (this.signal instanceof DD)
              return this.signal.sendExtensionMessage(e2, t2, i2);
          }
          getInChannelInfo() {
            return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), LD({}, this.inChannelInfo);
          }
          async getGatewayVersion() {
            return (await this.signal.request(Tv.GATEWAY_INFO)).version;
          }
          reset() {
            if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
              const e2 = kD.get(this.joinInfo.cname);
              e2 && e2.delete(this.joinInfo.uid);
            }
            this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
          }
          updateTurnConfigFromSignal() {
            if (!this.joinInfo)
              return;
            const e2 = function(e3) {
              let t2;
              return t2 = e3.startsWith("dc") ? e3.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e3.match(/(wss\:\/\/)?([^:]+):(\d+)/), t2 ? { username: ov.username, password: ov.password, turnServerURL: t2[2], tcpport: parseInt(t2[3]) + 30, udpport: parseInt(t2[3]) + 30, forceturn: false } : null;
            }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
            this.joinInfo.turnServer.serversFromGateway = [], e2 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(LD(LD({}, ov), {}, { turnServerURL: e2.turnServerURL, tcpport: e2.tcpport, udpport: e2.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
          }
          async updateTrafficStats() {
            if ("CONNECTED" !== this.state)
              return;
            const e2 = await this.signal.request(Tv.TRAFFIC_STATS, void 0, true);
            e2.timestamp = Date.now(), null != e2.ntp_offset && (this.ntpOffset = e2.ntp_offset), e2.peer_delay.forEach((e3) => {
              const t2 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t3) => t3.peer_uid === e3.peer_uid);
              t2 && t2.B_st !== e3.B_st && AT(() => {
                this.emit(eI.STREAM_TYPE_CHANGE, e3.peer_uid, e3.B_st);
              });
            }), this._statsCollector.updateTrafficStats(e2);
          }
          getJoinMessage(e2) {
            if (!this.joinInfo || !this.key)
              throw new xv(xg.UNEXPECTED_ERROR, "can not generate join message, no join info");
            const t2 = Object.assign({}, this.joinInfo.apResponse);
            let i2 = kC("REPORT_APP_SCENARIO");
            if ("string" != typeof i2)
              try {
                i2 = JSON.stringify(i2);
              } catch (e3) {
                i2 = void 0;
              }
            i2 && i2.length > 128 && (i2 = void 0);
            const n2 = LD({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: OC, browser: navigator.userAgent, process_id: kC("PROCESS_ID"), mode: this.store.useP2P ? "p2p" : this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t2, extend: kC("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: i2, attributes: { userAttributes: { enablePublishedUserList: kC("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: kC("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: "number" == typeof kC("SUBSCRIBE_AUDIO_FILTER_TOPN") ? kC("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: "boolean" == typeof kC("ENABLE_PUBLISH_AUDIO_FILTER") ? kC("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: "boolean" == typeof kC("ENABLE_USER_LICENSE_CHECK") ? kC("ENABLE_USER_LICENSE_CHECK") : void 0, enableRTX: true === kC("USE_PUB_RTX") || true === kC("USE_SUB_RTX") || void 0, disableFEC: kC("DISABLE_FEC"), enableNTPReport: !!kC("ENABLE_NTP_REPORT") || void 0, enableInstantVideo: !!kC("ENABLE_INSTANT_VIDEO") || void 0, enableDataStream2: "boolean" == typeof kC("ENABLE_DATASTREAM_2") ? kC("ENABLE_DATASTREAM_2") : void 0, rtm2Flag: "number" == typeof kC("RTM2_FLAG") ? kC("RTM2_FLAG") : void 0, enableUserAutoRebalanceCheck: !!kC("ENABLE_USER_AUTO_REBALANCE_CHECK"), enableXR: "boolean" == typeof kC("USE_XR") ? kC("USE_XR") : void 0 } }, join_ts: this.joinGatewayStartTime }, e2);
            return this.joinInfo.stringUid && (n2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (n2.aes_mode = this.joinInfo.aesmode, kC("ENCRYPT_AES") ? (n2.aes_secret = this.joinInfo.aespassword, n2.aes_encrypt = true) : n2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (n2.aes_salt = this.joinInfo.aessalt)), t2.addresses[this.signal.websocket.currentURLIndex] && (n2.ap_response.ticket = t2.addresses[this.signal.websocket.currentURLIndex].ticket, delete t2.addresses), void 0 !== this.joinInfo.defaultVideoStream && (n2.default_video_stream = this.joinInfo.defaultVideoStream), n2;
          }
          getRejoinMessage() {
            if (!this.joinInfo)
              throw new xv(xg.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
            return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
          }
          handleSignalEvents() {
            this.signal.on(gv.WS_RECONNECT_WAITTING_FINISH, (e2) => {
              var t2;
              Pr(t2 = ["tryNext", "recover"]).call(t2, e2) && this.joinInfo && rv.adjustSessionStartTime(this.joinInfo.sid);
            }), this.signal.on(gv.WS_RECONNECT_CREATE_CONNECTION, (e2) => {
              this.joinGatewayStartTime = Date.now();
            }), this.signal.on(gv.WS_RECONNECTING, (e2) => {
              this.joinInfo && rv.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e2 || lT.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", rv.sessionInit(this.joinInfo.sid, { lts: (/* @__PURE__ */ new Date()).getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
            }), this.signal.on(gv.WS_CLOSED, (e2) => {
              let t2;
              switch (e2) {
                case cT.LEAVE:
                  t2 = lT.LEAVE;
                  break;
                case cT.UID_BANNED:
                case cT.IP_BANNED:
                case cT.CHANNEL_BANNED:
                case cT.SERVER_ERROR:
                  t2 = lT.SERVER_ERROR;
                  break;
                case cT.FALLBACK:
                  t2 = lT.FALLBACK;
                  break;
                case cT.LICENSE_MISSING:
                case cT.LICENSE_EXPIRED:
                case cT.LICENSE_MINUTES_EXCEEDED:
                case cT.LICENSE_PERIOD_INVALID:
                case cT.LICENSE_MULTIPLE_SDK_SERVICE:
                case cT.LICENSE_ILLEGAL:
                case cT.TOKEN_EXPIRE:
                  t2 = e2;
                  break;
                default:
                  t2 = lT.NETWORK_ERROR;
              }
              KC.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t2 || "undefined -> " + lT.NETWORK_ERROR)), this.joinInfo && rv.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e2 === cT.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t2 }), this._disconnectedReason = e2, e2 !== cT.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
            }), this.signal.on(gv.WS_CONNECTED, () => {
              if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && ("audience" === this.role && this._clientRoleOptions && (this._clientRoleOptions.level || this._clientRoleOptions.delay) && (KC.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions.level, ", delay: ").concat(this._clientRoleOptions.delay)), this.setClientRole(this.role, this._clientRoleOptions)), rv.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof OD ? "1" : "0" }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {
                const e2 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
                if (!e2)
                  return void KC.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e2));
                LC("EVENT_REPORT_DOMAIN", e2[1]), LC("EVENT_REPORT_BACKUP_DOMAIN", e2[1]), LC("LOG_UPLOAD_SERVER", "".concat(e2[1], ":6444"));
              }
            }), this.signal.on(Rv.ON_UPLINK_STATS, (e2) => {
              this._statsCollector.updateUplinkStats(e2);
            }), this.signal.on(gv.REQUEST_RECOVER, (e2, t2, i2) => {
              if (!this.joinInfo)
                return i2(new xv(xg.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
              e2 && (this.joinInfo.multiIP = e2, this.hasChangeBGPAddress = true), this.isSignalRecover = true, fT(this, eI.REQUEST_NEW_GATEWAY_LIST).then(t2).catch(i2);
            }), this.signal.on(gv.REQUEST_JOIN_INFO, async (e2) => {
              var t2;
              if (this.updateTurnConfigFromSignal(), this.store.useP2P)
                return void e2(this.getJoinMessage({ ortc: {} }));
              const { iceParameters: i2, dtlsParameters: n2, rtpCapabilities: r2 } = await fT(this, eI.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: null === (t2 = this.joinInfo) || void 0 === t2 ? void 0 : t2.turnServer });
              e2(this.getJoinMessage({ ortc: { iceParameters: i2, dtlsParameters: n2, rtpCapabilities: r2, version: "2" } }));
            }), this.signal.on(gv.REQUEST_REJOIN_INFO, (e2) => {
              e2(this.getRejoinMessage());
            }), this.signal.on(gv.REPORT_JOIN_GATEWAY, (e2, t2) => {
              this.joinInfo && (rv.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: e2, addr: t2, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof OD ? "1" : "0" }), this._isProactiveJoin = false);
            }), this.signal.on(gv.IS_P2P_DISCONNECTED, (e2) => {
              e2(ST(this, eI.IS_P2P_DISCONNECTED));
            }), this.signal.on(gv.DISCONNECT_P2P, () => {
              this.emit(eI.DISCONNECT_P2P);
            }), this.signal.on(gv.NEED_RENEW_SESSION, () => {
              this.emit(eI.NEED_RENEW_SESSION);
            }), this.signal.on(gv.REQUEST_SUCCESS, () => {
              this._signalTimeout = false;
            }), this.signal.on(gv.REQUEST_TIMEOUT, () => {
              this._signalTimeout = true;
            }), this.signal.on(gv.JOIN_RESPONSE, (e2) => {
              const t2 = this.getCurrentGatewayAddress();
              this.emit(eI.JOIN_RESPONSE, e2, t2);
            }), this.signal.on(gv.DATACHANNEL_PRECONNECT, async (e2, t2, i2) => {
              this.updateTurnConfigFromSignal();
              const n2 = this.getCurrentGatewayAddress();
              return fT(this, eI.DATACHANNEL_PRECONNECT, e2, n2).then(t2).catch(i2);
            }), this.signal.on(gv.DATACHANNEL_CONNECTING, async (e2) => {
              const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = await fT(this, eI.REQUEST_DC_CONNECTION_PARAMS);
              e2(this.getJoinMessage({ ortc: { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2, version: "2" } }));
            }), this.signal.on(gv.DATACHANNEL_FAILBACK, () => {
              KC.warning("[".concat(this.store.clientId, "] User join datachannel failed")), this.reset(), this.resetSignal(), this.emit(eI.DATACHANNEL_FAILBACK);
            });
          }
          async tryUnsubBeforeResub(e2, t2) {
            try {
              await this.signal.request(Tv.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e2, ortc: [t2] }, true);
            } catch (e3) {
              throw KC.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e3), e3;
            }
          }
          async tryUnsubDataChannelBeforeResub(e2, t2) {
            try {
              await this.signal.request(Tv.UNSUBSCRIBE, { stream_id: t2.id }, true);
            } catch (e3) {
              throw KC.warning("unsubscribe datachannel warning", e3), e3;
            }
          }
          async tryUnpubBeforeRepub(e2, t2) {
            try {
              await this.signal.request(Tv.UNPUBLISH, { stream_id: e2, ortc: t2 }, true);
            } catch (e3) {
              throw KC.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e3), e3;
            }
          }
          async tryUnpubDataChannelBeforeRepub(e2, t2) {
            try {
              await this.signal.request(Tv.UNPUBLISH_DATASTREAM, { channnel_id: t2.channelId }, true);
            } catch (e3) {
              throw KC.warning("unpublish datastream warning: ", e3), e3;
            }
          }
          async tryMassUnsubBeforeResub(e2) {
            const t2 = { users: e2.map((e3) => ({ stream_id: e3.stream_id, stream_type: e3.stream_type })) };
            try {
              await this.signal.request(Tv.UNSUBSCRIBE_STREAMS, t2, true);
            } catch (e3) {
              throw KC.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e3), e3;
            }
          }
          async muteLocal(e2, t2) {
            const i2 = { action: e2.find((e3) => e3.stream_type === $v.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
            try {
              await this.signal.request(Tv.CONTROL, i2, true, true);
            } catch (e3) {
              throw KC.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e3), e3;
            }
          }
          async unmuteLocal(e2, t2) {
            const i2 = { action: e2.find((e3) => e3.stream_type === $v.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
            try {
              await this.signal.request(Tv.CONTROL, i2, true, true);
            } catch (e3) {
              throw KC.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e3), e3;
            }
          }
          async muteRemote(e2, t2) {
            const i2 = { action: e2 === hI.AUDIO ? "mute_remote_audio" : "mute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
            try {
              await this.signal.request(Tv.CONTROL, i2, true, true);
            } catch (e3) {
              throw KC.warning("[".concat(this.store.clientId, "] gateway muteRemote warning: "), e3), e3;
            }
          }
          async unmuteRemote(e2, t2) {
            const i2 = { action: e2 === hI.AUDIO ? "unmute_remote_audio" : "unmute_remote_video", p2p_id: this.store.p2pId, stream_id: t2 };
            try {
              await this.signal.request(Tv.CONTROL, i2, true, true);
            } catch (e3) {
              throw KC.warning("[".concat(this.store.clientId, "] gateway unmuteRemote warning: "), e3), e3;
            }
          }
          uploadStats(e2, t2) {
            this.signal.upload(e2, t2);
          }
          getSignalRTT() {
            return this.signal.rtt;
          }
          async restartICE(e2) {
            const t2 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e2 };
            try {
              return await this.signal.request(Tv.RESTART_ICE, t2, true);
            } catch (e3) {
              throw KC.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e3), e3;
            }
          }
          reconnect() {
            "CONNECTED" === this.state && this.signal.reconnect(void 0, lT.P2P_FAILED);
          }
          getCurrentGatewayAddress() {
            var e2;
            if (!kC("GATEWAY_WSS_ADDRESS"))
              return null !== (e2 = this.joinInfo) && void 0 !== e2 && e2.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
          }
          async setPublishAudioFilterEnabled(e2) {
            await this.signal.request(Tv.SET_PARAMETER, { enablePublishAudioFilter: e2 });
          }
          resetSignal() {
            this.signal && (this.signal.removeAllListeners(), this.signal.close(cT.FALLBACK)), this.store.useDataChannel = false, this.signal = new QI(LD(LD({}, this.spec), {}, { retryConfig: this.spec.websocketRetryConfig }), this.store), this.handleSignalEvents(), this.emit(eI.RESET_SIGNAL, nI.websocket);
          }
        }
        let UD = 0, xD = 0;
        function VD(e2, t2, i2, n2) {
          return new tg((r2, s2) => {
            t2.timeout = t2.timeout || kC("HTTP_CONNECT_TIMEOUT"), t2.responseType = t2.responseType || "json", t2.data && !i2 ? (t2.data = JSON.stringify(t2.data), UD += LT(t2.data)) : i2 && (t2.data.size ? UD += t2.data.size : t2.data instanceof FormData ? UD += kT(t2.data) : UD += LT(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, EC.request(t2).then((e3) => {
              "string" == typeof e3.data ? xD += LT(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? xD += e3.data.byteLength : xD += LT(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
            }).catch((e3) => {
              EC.isCancel(e3) ? s2(new xv(xg.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? s2(new xv(xg.NETWORK_TIMEOUT, e3.message)) : e3.response ? s2(new xv(xg.NETWORK_RESPONSE_ERROR, e3.response.status)) : s2(new xv(xg.NETWORK_ERROR, e3.message));
            });
          });
        }
        !function() {
          var e2;
          function t2(e3) {
            var t3 = 0;
            return function() {
              return t3 < e3.length ? { done: false, value: e3[t3++] } : { done: true };
            };
          }
          var i2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e3, t3, i3) {
            return e3 == Array.prototype || e3 == Object.prototype || (e3[t3] = i3.value), e3;
          };
          var n2, r2 = function(e3) {
            e3 = ["object" == typeof globalThis && globalThis, e3, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof q && q];
            for (var t3 = 0; t3 < e3.length; ++t3) {
              var i3 = e3[t3];
              if (i3 && i3.Math == Math)
                return i3;
            }
            throw Error("Cannot find global object");
          }(this);
          function s2(e3, t3) {
            if (t3)
              e: {
                var n3 = r2;
                e3 = e3.split(".");
                for (var s3 = 0; s3 < e3.length - 1; s3++) {
                  var o3 = e3[s3];
                  if (!(o3 in n3))
                    break e;
                  n3 = n3[o3];
                }
                (t3 = t3(s3 = n3[e3 = e3[e3.length - 1]])) != s3 && null != t3 && i2(n3, e3, { configurable: true, writable: true, value: t3 });
              }
          }
          function o2(e3) {
            return (e3 = { next: e3 })[Symbol.iterator] = function() {
              return this;
            }, e3;
          }
          function a2(e3) {
            var i3 = "undefined" != typeof Symbol && Symbol.iterator && e3[Symbol.iterator];
            return i3 ? i3.call(e3) : { next: t2(e3) };
          }
          if (s2("Symbol", function(e3) {
            function t3(e4, t4) {
              this.A = e4, i2(this, "description", { configurable: true, writable: true, value: t4 });
            }
            if (e3)
              return e3;
            t3.prototype.toString = function() {
              return this.A;
            };
            var n3 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", r3 = 0;
            return function e4(i3) {
              if (this instanceof e4)
                throw new TypeError("Symbol is not a constructor");
              return new t3(n3 + (i3 || "") + "_" + r3++, i3);
            };
          }), s2("Symbol.iterator", function(e3) {
            if (e3)
              return e3;
            e3 = Symbol("Symbol.iterator");
            for (var n3 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), s3 = 0; s3 < n3.length; s3++) {
              var a3 = r2[n3[s3]];
              "function" == typeof a3 && "function" != typeof a3.prototype[e3] && i2(a3.prototype, e3, { configurable: true, writable: true, value: function() {
                return o2(t2(this));
              } });
            }
            return e3;
          }), "function" == typeof Object.setPrototypeOf)
            n2 = Object.setPrototypeOf;
          else {
            var c2;
            e: {
              var d2 = {};
              try {
                d2.__proto__ = { a: true }, c2 = d2.a;
                break e;
              } catch (e3) {
              }
              c2 = false;
            }
            n2 = c2 ? function(e3, t3) {
              if (e3.__proto__ = t3, e3.__proto__ !== t3)
                throw new TypeError(e3 + " is not extensible");
              return e3;
            } : null;
          }
          var l2 = n2;
          function h2() {
            this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
          }
          function u2(e3) {
            if (e3.m)
              throw new TypeError("Generator is already running");
            e3.m = true;
          }
          function p2(e3, t3) {
            return e3.h = 3, { value: t3 };
          }
          function _2(e3) {
            this.g = new h2(), this.G = e3;
          }
          function E2(e3, t3, i3, n3) {
            try {
              var r3 = t3.call(e3.g.j, i3);
              if (!(r3 instanceof Object))
                throw new TypeError("Iterator result " + r3 + " is not an object");
              if (!r3.done)
                return e3.g.m = false, r3;
              var s3 = r3.value;
            } catch (t4) {
              return e3.g.j = null, e3.g.s(t4), m2(e3);
            }
            return e3.g.j = null, n3.call(e3.g, s3), m2(e3);
          }
          function m2(e3) {
            for (; e3.g.h; )
              try {
                var t3 = e3.G(e3.g);
                if (t3)
                  return e3.g.m = false, { value: t3.value, done: false };
              } catch (t4) {
                e3.g.v = void 0, e3.g.s(t4);
              }
            if (e3.g.m = false, e3.g.l) {
              if (t3 = e3.g.l, e3.g.l = null, t3.F)
                throw t3.D;
              return { value: t3.return, done: true };
            }
            return { value: void 0, done: true };
          }
          function f2(e3) {
            this.next = function(t3) {
              return e3.o(t3);
            }, this.throw = function(t3) {
              return e3.s(t3);
            }, this.return = function(t3) {
              return function(e4, t4) {
                u2(e4.g);
                var i3 = e4.g.j;
                return i3 ? E2(e4, "return" in i3 ? i3.return : function(e5) {
                  return { value: e5, done: true };
                }, t4, e4.g.return) : (e4.g.return(t4), m2(e4));
              }(e3, t3);
            }, this[Symbol.iterator] = function() {
              return this;
            };
          }
          function g2(e3, t3) {
            return t3 = new f2(new _2(t3)), l2 && e3.prototype && l2(t3, e3.prototype), t3;
          }
          if (h2.prototype.o = function(e3) {
            this.v = e3;
          }, h2.prototype.s = function(e3) {
            this.l = { D: e3, F: true }, this.h = this.C || this.u;
          }, h2.prototype.return = function(e3) {
            this.l = { return: e3 }, this.h = this.u;
          }, _2.prototype.o = function(e3) {
            return u2(this.g), this.g.j ? E2(this, this.g.j.next, e3, this.g.o) : (this.g.o(e3), m2(this));
          }, _2.prototype.s = function(e3) {
            return u2(this.g), this.g.j ? E2(this, this.g.j.throw, e3, this.g.o) : (this.g.s(e3), m2(this));
          }, s2("Array.prototype.entries", function(e3) {
            return e3 || function() {
              return function(e4, t3) {
                e4 instanceof String && (e4 += "");
                var i3 = 0, n3 = false, r3 = { next: function() {
                  if (!n3 && i3 < e4.length) {
                    var r4 = i3++;
                    return { value: t3(r4, e4[r4]), done: false };
                  }
                  return n3 = true, { done: true, value: void 0 };
                } };
                return r3[Symbol.iterator] = function() {
                  return r3;
                }, r3;
              }(this, function(e4, t3) {
                return [e4, t3];
              });
            };
          }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
            var T2 = function(e3, t3) {
              for (var i3 = 0; i3 < e3.length; i3++)
                t3(e3[i3]);
            }, S2 = function(e3) {
              return e3.replace(/\r?\n|\r/g, "\r\n");
            }, R2 = function(e3, t3, i3) {
              return t3 instanceof Blob ? (i3 = void 0 !== i3 ? String(i3 + "") : "string" == typeof t3.name ? t3.name : "blob", t3.name === i3 && "[object Blob]" !== Object.prototype.toString.call(t3) || (t3 = new File([t3], i3)), [String(e3), t3]) : [String(e3), String(t3)];
            }, C2 = function(e3, t3) {
              if (e3.length < t3)
                throw new TypeError(t3 + " argument required, but only " + e3.length + " present.");
            }, v2 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, I2 = v2.FormData, y2 = v2.XMLHttpRequest && v2.XMLHttpRequest.prototype.send, A2 = v2.Request && v2.fetch, b2 = v2.navigator && v2.navigator.sendBeacon, w2 = v2.Element && v2.Element.prototype, O2 = v2.Symbol && Symbol.toStringTag;
            O2 && (Blob.prototype[O2] || (Blob.prototype[O2] = "Blob"), "File" in v2 && !File.prototype[O2] && (File.prototype[O2] = "File"));
            try {
              new File([], "");
            } catch (e3) {
              v2.File = function(e4, t3, i3) {
                return e4 = new Blob(e4, i3 || {}), Object.defineProperties(e4, { name: { value: t3 }, lastModified: { value: +(i3 && void 0 !== i3.lastModified ? new Date(i3.lastModified) : /* @__PURE__ */ new Date()) }, toString: { value: function() {
                  return "[object File]";
                } } }), O2 && Object.defineProperty(e4, O2, { value: "File" }), e4;
              };
            }
            var N2 = function(e3) {
              return e3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
            }, D2 = function(e3) {
              this.i = [];
              var t3 = this;
              e3 && T2(e3.elements, function(e4) {
                if (e4.name && !e4.disabled && "submit" !== e4.type && "button" !== e4.type && !e4.matches("form fieldset[disabled] *"))
                  if ("file" === e4.type) {
                    var i3 = e4.files && e4.files.length ? e4.files : [new File([], "", { type: "application/octet-stream" })];
                    T2(i3, function(i4) {
                      t3.append(e4.name, i4);
                    });
                  } else
                    "select-multiple" === e4.type || "select-one" === e4.type ? T2(e4.options, function(i4) {
                      !i4.disabled && i4.selected && t3.append(e4.name, i4.value);
                    }) : "checkbox" === e4.type || "radio" === e4.type ? e4.checked && t3.append(e4.name, e4.value) : (i3 = "textarea" === e4.type ? S2(e4.value) : e4.value, t3.append(e4.name, i3));
              });
            };
            if ((e2 = D2.prototype).append = function(e3, t3, i3) {
              C2(arguments, 2), this.i.push(R2(e3, t3, i3));
            }, e2.delete = function(e3) {
              C2(arguments, 1);
              var t3 = [];
              e3 = String(e3), T2(this.i, function(i3) {
                i3[0] !== e3 && t3.push(i3);
              }), this.i = t3;
            }, e2.entries = function e3() {
              var t3, i3 = this;
              return g2(e3, function(e4) {
                if (1 == e4.h && (t3 = 0), 3 != e4.h)
                  return t3 < i3.i.length ? e4 = p2(e4, i3.i[t3]) : (e4.h = 0, e4 = void 0), e4;
                t3++, e4.h = 2;
              });
            }, e2.forEach = function(e3, t3) {
              C2(arguments, 1);
              for (var i3 = a2(this), n3 = i3.next(); !n3.done; n3 = i3.next()) {
                var r3 = a2(n3.value);
                n3 = r3.next().value, r3 = r3.next().value, e3.call(t3, r3, n3, this);
              }
            }, e2.get = function(e3) {
              C2(arguments, 1);
              var t3 = this.i;
              e3 = String(e3);
              for (var i3 = 0; i3 < t3.length; i3++)
                if (t3[i3][0] === e3)
                  return t3[i3][1];
              return null;
            }, e2.getAll = function(e3) {
              C2(arguments, 1);
              var t3 = [];
              return e3 = String(e3), T2(this.i, function(i3) {
                i3[0] === e3 && t3.push(i3[1]);
              }), t3;
            }, e2.has = function(e3) {
              C2(arguments, 1), e3 = String(e3);
              for (var t3 = 0; t3 < this.i.length; t3++)
                if (this.i[t3][0] === e3)
                  return true;
              return false;
            }, e2.keys = function e3() {
              var t3, i3, n3, r3, s3 = this;
              return g2(e3, function(e4) {
                if (1 == e4.h && (t3 = a2(s3), i3 = t3.next()), 3 != e4.h)
                  return i3.done ? void (e4.h = 0) : (n3 = i3.value, r3 = a2(n3), p2(e4, r3.next().value));
                i3 = t3.next(), e4.h = 2;
              });
            }, e2.set = function(e3, t3, i3) {
              C2(arguments, 2), e3 = String(e3);
              var n3 = [], r3 = R2(e3, t3, i3), s3 = true;
              T2(this.i, function(t4) {
                t4[0] === e3 ? s3 && (s3 = !n3.push(r3)) : n3.push(t4);
              }), s3 && n3.push(r3), this.i = n3;
            }, e2.values = function e3() {
              var t3, i3, n3, r3, s3 = this;
              return g2(e3, function(e4) {
                if (1 == e4.h && (t3 = a2(s3), i3 = t3.next()), 3 != e4.h)
                  return i3.done ? void (e4.h = 0) : (n3 = i3.value, (r3 = a2(n3)).next(), p2(e4, r3.next().value));
                i3 = t3.next(), e4.h = 2;
              });
            }, D2.prototype._asNative = function() {
              for (var e3 = new I2(), t3 = a2(this), i3 = t3.next(); !i3.done; i3 = t3.next()) {
                var n3 = a2(i3.value);
                i3 = n3.next().value, n3 = n3.next().value, e3.append(i3, n3);
              }
              return e3;
            }, D2.prototype._blob = function() {
              var e3 = "----formdata-polyfill-" + Math.random(), t3 = [], i3 = "--" + e3 + '\r\nContent-Disposition: form-data; name="';
              return this.forEach(function(e4, n3) {
                return "string" == typeof e4 ? t3.push(i3 + N2(S2(n3)) + '"\r\n\r\n' + S2(e4) + "\r\n") : t3.push(i3 + N2(S2(n3)) + '"; filename="' + N2(e4.name) + '"\r\nContent-Type: ' + (e4.type || "application/octet-stream") + "\r\n\r\n", e4, "\r\n");
              }), t3.push("--" + e3 + "--"), new Blob(t3, { type: "multipart/form-data; boundary=" + e3 });
            }, D2.prototype[Symbol.iterator] = function() {
              return this.entries();
            }, D2.prototype.toString = function() {
              return "[object FormData]";
            }, w2 && !w2.matches && (w2.matches = w2.matchesSelector || w2.mozMatchesSelector || w2.msMatchesSelector || w2.oMatchesSelector || w2.webkitMatchesSelector || function(e3) {
              for (var t3 = (e3 = (this.document || this.ownerDocument).querySelectorAll(e3)).length; 0 <= --t3 && e3.item(t3) !== this; )
                ;
              return -1 < t3;
            }), O2 && (D2.prototype[O2] = "FormData"), y2) {
              var P2 = v2.XMLHttpRequest.prototype.setRequestHeader;
              v2.XMLHttpRequest.prototype.setRequestHeader = function(e3, t3) {
                P2.call(this, e3, t3), "content-type" === e3.toLowerCase() && (this.B = true);
              }, v2.XMLHttpRequest.prototype.send = function(e3) {
                e3 instanceof D2 ? (e3 = e3._blob(), this.B || this.setRequestHeader("Content-Type", e3.type), y2.call(this, e3)) : y2.call(this, e3);
              };
            }
            A2 && (v2.fetch = function(e3, t3) {
              return t3 && t3.body && t3.body instanceof D2 && (t3.body = t3.body._blob()), A2.call(this, e3, t3);
            }), b2 && (v2.navigator.sendBeacon = function(e3, t3) {
              return t3 instanceof D2 && (t3 = t3._asNative()), b2.call(this, e3, t3);
            }), v2.FormData = D2;
          }
        }();
        const FD = () => {
          const e2 = kC("AREAS");
          0 === e2.length && e2.push(rI.GLOBAL);
          return cS(e2).call(e2, (e3, t2, i2) => {
            const n2 = BD(t2);
            return n2 ? 0 === i2 ? n2 : "".concat(e3, ",").concat(n2) : e3;
          }, "");
        }, BD = (e2) => e2 === rI.OVERSEA ? "".concat(aI.ASIA, ",").concat(aI.EUROPE, ",").concat(aI.AFRICA, ",").concat(aI.NORTH_AMERICA, ",").concat(aI.SOUTH_AMERICA, ",").concat(aI.OCEANIA) : aI[e2], jD = (e2) => {
          const t2 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
          return e2.map((e3) => {
            const i2 = cI[e3], n2 = Object.keys(i2);
            n2 && n2.map((e4) => {
              "CODE" !== e4 && (t2[e4] = t2[e4].concat(i2[e4]));
            });
          }), t2;
        }, GD = { GLOBAL: { ASIA: [rI.CHINA, rI.JAPAN, rI.INDIA, rI.KOREA, rI.HKMC], EUROPE: [], NORTH_AMERICA: [rI.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, WD = Object.keys(GD[rI.GLOBAL]), HD = [rI.CHINA, rI.NORTH_AMERICA, rI.EUROPE, rI.ASIA, rI.JAPAN, rI.INDIA, rI.OCEANIA, rI.SOUTH_AMERICA, rI.AFRICA, rI.KOREA, rI.HKMC, rI.US], KD = function(e2, t2) {
          let i2 = [];
          if (Pr(e2).call(e2, rI.GLOBAL)) {
            const s2 = [rI.GLOBAL, rI.OVERSEA], o2 = Object.keys(cI);
            if (t2 === rI.GLOBAL)
              throw new xv(xg.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
            if (t2 === rI.CHINA)
              i2 = [rI.OVERSEA];
            else if (r2 = t2, Pr(WD).call(WD, r2)) {
              const e3 = (n2 = t2, GD[rI.GLOBAL][n2] || []), r3 = [...s2, t2, ...e3];
              i2 = o2.filter((e4) => !Pr(r3).call(r3, e4));
            } else if (function(e3) {
              let t3 = false;
              return WD.forEach((i3) => {
                var n3;
                Pr(n3 = GD[rI.GLOBAL][i3]).call(n3, e3) && (t3 = true);
              }), t3;
            }(t2)) {
              const e3 = function(e4) {
                let t3;
                return WD.forEach((i3) => {
                  var n4;
                  Pr(n4 = GD[rI.GLOBAL][i3]).call(n4, e4) && (t3 = i3);
                }), t3;
              }(t2), n3 = [...s2, e3, t2];
              i2 = o2.filter((e4) => !Pr(n3).call(n3, e4));
            } else
              i2 = e2;
            i2 = function(e3) {
              const t3 = [];
              return HD.forEach((i3) => {
                Pr(e3).call(e3, i3) && t3.push(i3);
              }), t3.concat(e3.filter((e4) => !Pr(HD).call(HD, e4)));
            }(i2);
          } else
            i2 = e2;
          var n2, r2;
          return i2;
        };
        function YD(e2) {
          var t2, i2;
          if (!e2 && Pr(t2 = kC("AREAS")).call(t2, rI.EXTENSIONS))
            return KC.debug("update area from ap : reset"), void qD(sv, true);
          if (!Pr(i2 = kC("AREAS")).call(i2, rI.GLOBAL) || !e2)
            return;
          let n2 = cI.EXTENSIONS;
          n2 && (n2 = { CODE: BD(rI.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e2, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e2, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e2, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e2, ".agora.io"), "cds-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e2, ".agora.io"), "sua-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e2, ".agora.io"), "uap-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e2, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e2, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e2, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e2, ".agora.io")] }, KC.debug("update area from ap success: ".concat(e2, ",config is "), n2), LC("AREAS", [rI.EXTENSIONS], true), Object.keys(n2).map((e3) => {
            if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
              LC(e3, n2[e3][0]);
            } else
              LC(e3, n2[e3]);
          }));
        }
        function qD(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const i2 = rv.reportApiInvoke(null, { name: sT.SET_AREA, options: e2, tag: oT.TRACER });
          try {
            let n2 = [];
            if ("string" == typeof e2 && (n2 = [e2]), Array.isArray(e2) && (e2.forEach((e3) => {
              if (!Pr(oI).call(oI, e3))
                throw new xv(xg.INVALID_PARAMS, "invalid area code");
            }), n2 = e2), "[object Object]" === Object.prototype.toString.call(e2)) {
              const { areaCode: t3, excludedArea: i3 } = e2;
              if (!t3)
                throw new xv(xg.INVALID_PARAMS, "area code is needed");
              let r3 = t3;
              "string" == typeof t3 && (r3 = [t3]), n2 = i3 ? KD(r3, i3) : r3;
            }
            if (!t2) {
              if (MC.AREAS) {
                const e3 = new xv(xg.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
                return i2.onError(e3), void KC.warning("setArea is prohibited because of config-distribute");
              }
              if (Pr(n2).call(n2, rI.GLOBAL) && kC("AREAS") === rI.EXTENSIONS) {
                const e3 = new xv(xg.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
                return i2.onError(e3), void KC.warning("setArea is prohibited because of ap extensions");
              }
            }
            LC("AREAS", n2, t2);
            const r2 = jD(n2);
            Object.keys(r2).map((e3) => {
              if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
                LC(e3, r2[e3][0]);
              } else
                LC(e3, r2[e3]);
            }), KC.debug("set area success:", n2.join(","));
          } catch (e3) {
            throw i2.onError(e3), e3;
          }
          i2.onSuccess();
        }
        function JD(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function zD(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? JD(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : JD(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        let XD = 1;
        function QD(e2, t2, i2, n2, r2) {
          XD += 1;
          const s2 = { sid: i2.sid, command: "convergeAllocateEdge", uid: "666", appId: i2.appId, ts: Math.floor(Date.now() / 1e3), seq: XD, requestId: XD, version: OC, cname: i2.cname }, o2 = { service_name: t2, json_body: JSON.stringify(s2) };
          let a2, c2, d2 = e2[0];
          return XT(async () => {
            a2 = Date.now();
            const e3 = await VD(d2, { data: o2, cancelToken: n2, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
            if (c2 = Date.now() - a2, 0 !== e3.code) {
              const t3 = new xv(xg.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e3.code, { retry: true, responseTime: c2 });
              throw KC.error(t3.toString()), t3;
            }
            const i3 = JSON.parse(e3.json_body);
            if (200 !== i3.code) {
              const e4 = new xv(xg.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i3.code, ", reason: ").concat(i3.reason), { code: i3.code, responseTime: c2 });
              throw KC.error(e4.toString()), e4;
            }
            if (!i3.servers || 0 === i3.servers.length) {
              const e4 = new xv(xg.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i3.code, responseTime: c2 });
              throw KC.error(e4.toString()), e4;
            }
            const r3 = function(e4, t3) {
              return { addressList: e4.servers.map((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(kC("WORKER_DOMAIN"), ":").concat(e5.wss, "?serviceName=").concat(encodeURIComponent(t3))), workerToken: e4.workerToken, vid: e4.vid };
            }(i3, t2);
            return kC("LIVE_STREAMING_ADDRESS") && (r3.addressList = kC("LIVE_STREAMING_ADDRESS") instanceof Array ? kC("LIVE_STREAMING_ADDRESS") : [kC("LIVE_STREAMING_ADDRESS")]), zD(zD({}, r3), {}, { responseTime: c2 });
          }, (n3, r3) => (rv.apworkerEvent(i2.sid, { success: true, sc: 200, serviceName: t2, responseDetail: JSON.stringify(n3.addressList), firstSuccess: 0 === r3, responseTime: c2, serverIp: e2[r3 % e2.length] }), false), (n3, r3) => (rv.apworkerEvent(i2.sid, { success: false, sc: n3.data && n3.data.code || 200, serviceName: t2, responseTime: c2, serverIp: e2[r3 % e2.length] }), !!(n3.code !== xg.OPERATION_ABORTED && n3.code !== xg.UNEXPECTED_RESPONSE || n3.data && n3.data.retry) && (d2 = e2[(r3 + 1) % e2.length], true)), r2);
        }
        let ZD = 1;
        function $D(e2, t2, i2, n2) {
          let { url: r2, areaCode: s2 } = e2;
          const o2 = Date.now();
          let a2;
          const [c2, d2] = rP(t2, s2, [hy.CHOOSE_SERVER]);
          let l2 = RT.networkState;
          return XT(async () => {
            l2 && RT.networkState === hT.OFFLINE && RT.onlineWaiter && await tg.race([RT.onlineWaiter, UT(n2 && n2.maxRetryTimeout || JT.maxRetryTimeout)]), l2 = RT.networkState;
            const { data: e3, headers: s3 } = await VD(r2, { data: c2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
            a2 = "1" === s3.http3 ? 1 : -1, rv.reportResourceTiming(r2, t2.sid), tP(e3, r2, t2, o2, [hy.CHOOSE_SERVER], a2);
            const d3 = SD(e3, hy.CHOOSE_SERVER);
            return iP(d3), ED(d3, r2);
          }, (e3) => (e3 && rv.joinChooseServer(t2.sid, { lts: o2, succ: true, csAddr: r2, opid: d2, serverList: e3.gatewayAddrs.map((e4) => e4.address), ec: null, cid: e3.cid.toString(), uid: e3.uid.toString(), csIp: e3.csIp, unilbsServerIds: [hy.CHOOSE_SERVER].toString(), isHttp3: a2 }), false), (e3) => e3.code !== xg.OPERATION_ABORTED && (e3.code === xg.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (rv.joinChooseServer(t2.sid, { lts: o2, succ: false, csAddr: r2, serverList: null, opid: d2, ec: e3.code, csIp: e3.data && e3.data.csIp, unilbsServerIds: [hy.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: l2 }), isHttp3: a2 }), KC.warning("[".concat(t2.clientId, "] Choose server network error, retry"), e3), true)), n2);
        }
        function eP(e2, t2, i2, n2) {
          let r2, { url: s2, areaCode: o2, serviceIds: a2 } = e2;
          const c2 = Date.now(), [d2, l2] = rP(t2, o2, a2);
          let h2;
          return XT(async () => {
            h2 && RT.networkState === hT.OFFLINE && RT.onlineWaiter && await tg.race([RT.onlineWaiter, UT(n2 && n2.maxRetryTimeout || JT.maxRetryTimeout)]), h2 = RT.networkState;
            const { data: e3, headers: o3 } = await VD(s2, { data: d2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
            r2 = "1" === o3.http3 ? 1 : -1, rv.reportResourceTiming(s2, t2.sid), tP(e3, s2, t2, c2, a2, r2);
            const l3 = SD(e3, hy.CHOOSE_SERVER), u2 = SD(e3, "proxy5" === t2.cloudProxyServer ? hy.CLOUD_PROXY_5 : "proxy3" === t2.cloudProxyServer || "proxy4" === t2.cloudProxyServer ? hy.CLOUD_PROXY : hy.CLOUD_PROXY_FALLBACK);
            return iP(l3), { gatewayInfo: ED(l3, s2), proxyInfo: u2, url: s2 };
          }, (e3) => (e3.gatewayInfo && rv.joinChooseServer(t2.sid, { lts: c2, succ: true, csAddr: s2, serverList: e3.gatewayInfo.gatewayAddrs.map((e4) => e4.address), ec: null, opid: l2, cid: e3.gatewayInfo.cid.toString(), uid: e3.gatewayInfo.uid.toString(), csIp: e3.gatewayInfo.csIp, unilbsServerIds: a2.toString(), isHttp3: r2 }), e3.proxyInfo && rv.joinWebProxyAP(t2.sid, { lts: c2, sucess: 1, apServerAddr: s2, turnServerAddrList: e3.proxyInfo.addresses.map((e4) => e4.ip).join(","), errorCode: null, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString() }), false), (e3) => e3.code !== xg.OPERATION_ABORTED && (e3.code === xg.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (rv.joinWebProxyAP(t2.sid, { lts: c2, sucess: 0, apServerAddr: s2, turnServerAddrList: null, errorCode: e3.code, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString(), extend: JSON.stringify({ networkState: h2 }) }), KC.warning("[".concat(t2.clientId, "] multi unilbs network error, retry"), e3), true)), n2);
        }
        const tP = (e2, t2, i2, n2, r2, s2) => {
          const o2 = [], a2 = (o3) => {
            4096 === o3.flag ? rv.joinChooseServer(i2.sid, { lts: n2, succ: false, csAddr: t2, opid: e2.opid, serverList: null, ec: o3.error.message, csIp: o3.error.data && o3.error.data.csIp, unilbsServerIds: r2.toString(), isHttp3: s2 }) : 1048576 !== o3.flag && 4194304 !== o3.flag && 4194310 !== o3.flag || rv.joinWebProxyAP(i2.sid, { lts: n2, sucess: 0, apServerAddr: t2, turnServerAddrList: null, errorCode: o3.error.code, eventType: i2.cloudProxyServer, unilbsServerIds: r2.toString() });
          };
          if (e2.response_body.forEach((t3) => {
            const i3 = t3.buffer.code;
            if (23 === t3.uri && 0 === i3 && !t3.buffer.edges_services)
              if (4194310 === t3.buffer.flag)
                KC.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t3.buffer.edges_services = [];
              else {
                const i4 = { error: new xv(xg.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e2.detail[502] }), flag: t3.buffer.flag };
                o2.push(i4), a2(i4);
              }
            if (0 !== i3) {
              const n3 = kI(i3), r3 = { error: new xv(xg.CAN_NOT_GET_GATEWAY_SERVER, n3.desc, { desc: n3.desc, retry: n3.retry, csIp: e2.detail[502] }), flag: t3.buffer.flag };
              4194310 === t3.buffer.flag ? KC.warning(r3.error.toString()) : o2.push(r3), a2(r3);
            }
          }), o2.length)
            throw KC.warning("[".concat(i2.clientId, "] multi unilbs ").concat(t2, " failed, ").concat(o2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message, ", retry: ").concat(e3.error.data.retry)).join(" | "))), new xv(xg.CAN_NOT_GET_GATEWAY_SERVER, o2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message)).join(" | "), { retry: !!o2.find((e3) => e3.error.data.retry), csIp: e2.detail[502], desc: [...new Set(o2.map((e3) => {
              var t3;
              return null == e3 || null === (t3 = e3.error) || void 0 === t3 || null === (t3 = t3.data) || void 0 === t3 ? void 0 : t3.desc;
            }).filter((e3) => !!e3))] });
        }, iP = (e2) => {
          var t2, i2, n2, r2;
          if (e2.addresses && 0 === e2.addresses.length && 0 === e2.code)
            throw new xv(xg.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e2.detail && e2.detail[502] });
          kC("AP_AREA") && (null !== (n2 = e2.detail) && void 0 !== n2 && n2[23] && "string" == typeof (null === (r2 = e2.detail) || void 0 === r2 ? void 0 : r2[23]) ? YD(e2.detail[23].toLowerCase()) : YD());
          if (null !== (t2 = e2.detail) && void 0 !== t2 && t2[19] && "string" == typeof (null === (i2 = e2.detail) || void 0 === i2 ? void 0 : i2[19])) {
            const t3 = e2.detail[19], i3 = null == t3 ? void 0 : t3.split(";");
            for (let t4 = 0; t4 < i3.length; t4++) {
              var s2;
              const n3 = fy(s2 = i3[t4]).call(s2);
              e2.addresses[t4] && i3 && (e2.addresses[t4].fingerprint = n3);
            }
          }
          if (kC("GATEWAY_ADDRESS") && kC("GATEWAY_ADDRESS").length > 0) {
            KC.debug("assign gateway address to", kC("GATEWAY_ADDRESS"));
            const t3 = kC("GATEWAY_ADDRESS").map((t4) => {
              var i3, n3;
              const r3 = null !== (i3 = null === (n3 = e2.addresses.find((e3) => e3.ip === t4.ip && e3.port === t4.port)) || void 0 === n3 ? void 0 : n3.fingerprint) && void 0 !== i3 ? i3 : "";
              return { ip: t4.ip, port: t4.port, ticket: e2.addresses[0] && e2.addresses[0].ticket, fingerprint: r3 };
            });
            e2.addresses = t3;
          }
        }, nP = (e2, t2) => {
          if (e2.response_body && e2.response_body.length) {
            const t3 = e2.response_body[0];
            if (0 !== t3.buffer.code) {
              const e3 = kI(t3.buffer.code);
              throw new xv(xg.UPDATE_TICKET_FAILED, "[".concat(t3.buffer.code, "]: ").concat(e3.desc), { retry: e3.retry });
            }
            return t3.buffer.ticket;
          }
          throw KC.debug("update ticket request received ap response without response body:", t2), new xv(xg.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
        }, rP = (e2, t2, i2) => {
          const n2 = Math.floor(Math.random() * 10 ** 12), r2 = { appid: e2.appId, client_ts: Date.now(), opid: n2, sid: e2.sid, request_bodies: [{ uri: 22, buffer: { cname: e2.cname, detail: zD({ 6: e2.stringUid, 11: t2, 12: kC("USE_NEW_TOKEN") ? "1" : void 0, 22: t2 }, kC("AP_RTM") ? { 26: "RTM2" } : {}), key: e2.token, service_ids: i2, uid: e2.uid || 0 } }] };
          r2.request_bodies.forEach((t3) => {
            e2.multiIP && e2.multiIP.gateway_ip && (t3.buffer.detail[5] = JSON.stringify({ vocs_ip: [e2.multiIP.uni_lbs_ip], vos_ip: [e2.multiIP.gateway_ip] }));
          });
          const s2 = new FormData();
          return s2.append("request", JSON.stringify(r2)), [s2, n2];
        }, sP = (e2, t2) => {
          const i2 = Math.floor(Math.random() * 10 ** 12), n2 = { appid: e2.appId, client_ts: Date.now(), opid: i2, sid: e2.sid, request_bodies: [{ uri: 28, buffer: { cname: e2.cname, detail: { 1: "", 6: e2.stringUid, 12: "1" }, token: e2.token, service_ids: t2, uid: e2.uid || 0, edges_services: e2.apResponse.addresses.map((e3) => ({ ip: e3.ip, port: e3.port })) } }] }, r2 = new FormData();
          return r2.append("request", JSON.stringify(n2)), [r2, i2];
        };
        let oP = 0;
        function aP(e2) {
          return tg.all(e2.map((e3) => e3.then((e4) => {
            throw e4;
          }, (e4) => e4))).then((e3) => {
            throw e3;
          }, (e3) => e3);
        }
        const cP = async (e2) => {
          let { fragementLength: t2, referenceList: i2, asyncMapHandler: n2, allFailedhandler: r2, promisesCollector: s2 } = e2, o2 = 0;
          const a2 = t2;
          let c2, d2 = 0;
          const l2 = async () => {
            const e3 = (() => {
              const e4 = o2 * a2, t3 = e4 + a2;
              return i2.slice(e4, t3).map(n2);
            })();
            s2 && s2.push(...e3);
            try {
              c2 = await aP(e3);
            } catch (e4) {
              if (d2 += a2, o2++, !(d2 >= i2.length))
                return void await l2();
              r2(e4);
            }
            e3.forEach((e4) => e4.cancel());
          };
          return await l2(), c2;
        };
        async function dP(e2, t2, i2, n2) {
          const r2 = async function(e3, t3, i3, n3) {
            let r3 = null;
            const s2 = [], o2 = async () => {
              const r4 = kC("WEBCS_DOMAIN").slice(0, kC("AJAX_REQUEST_CONCURRENT")).map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: FD() })), o3 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r4.map((e4) => e4.url) }), a3 = await cP({ fragementLength: kC("FRAGEMENT_LENGTH"), referenceList: r4, asyncMapHandler: (n4) => (KC.debug("[".concat(e3.clientId, "] Connect to choose_server:"), n4.url), $D(n4, e3, t3, i3)), allFailedhandler: (e4) => {
                throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, o3), e4[0];
              }, promisesCollector: s2 });
              return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, o3), a3;
            }, a2 = async () => {
              if (await UT(1e3), null !== r3)
                return r3;
              const o3 = kC("WEBCS_DOMAIN_BACKUP_LIST").map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: FD() })), a3 = n3.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: o3.map((e4) => e4.url) }), c2 = await cP({ fragementLength: kC("FRAGEMENT_LENGTH"), referenceList: o3, asyncMapHandler: (n4) => (KC.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), n4.url), $D(n4, e3, t3, i3)), allFailedhandler: (e4) => {
                throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, a3), e4[0];
              }, promisesCollector: s2 });
              return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), c2;
            };
            try {
              return r3 = await aP([o2(), a2()]), s2.length && s2.forEach((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel()), r3;
            } catch (e4) {
              throw e4[0];
            }
          }(e2, t2, i2, n2);
          return { gatewayInfo: await r2 };
        }
        async function lP(e2, t2, i2, n2, r2) {
          const s2 = e2.cloudProxyServer;
          if ("disabled" === s2) {
            if (!n2)
              return;
            if (e2.useLocalAccessPoint)
              return await dP(e2, t2, i2, r2);
            if (kC("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
              const { gatewayInfo: n3, proxyInfo: s3 } = await pP(e2, t2, i2, r2);
              return e2.turnServer && "auto" !== e2.turnServer.mode || (e2.turnServer = { mode: "manual", servers: s3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || ov.tcpport, udpport: e3.udpport || ov.udpport, username: e3.username || ov.username, password: e3.password || ov.password, forceturn: false, security: true })) }), { gatewayInfo: n3 };
            }
            return await dP(e2, t2, i2, r2);
          }
          const { proxyInfo: o2, gatewayInfo: a2 } = await pP(e2, t2, i2, r2), c2 = { gatewayInfo: a2 };
          return e2.turnServer = { mode: "manual", servers: o2.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === s2 ? void 0 : e3.tcpport ? e3.tcpport : ov.tcpport, udpport: "proxy4" === s2 ? void 0 : e3.udpport ? e3.udpport : ov.udpport, username: e3.username || ov.username, password: e3.password || ov.password, forceturn: "proxy4" !== s2, security: "proxy5" === s2 })) }, KC.debug("[".concat(e2.clientId, "] set proxy server: ").concat(e2.proxyServer, ", mode: ").concat(s2)), c2;
        }
        async function hP(e2, t2, i2, n2, r2) {
          const s2 = kC("ACCOUNT_REGISTER").slice(0, kC("AJAX_REQUEST_CONCURRENT"));
          let o2 = [];
          o2 = t2.proxyServer ? s2.map((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : s2.map((e3) => "https://".concat(e3, "/api/v1"));
          const a2 = null == r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: o2 });
          try {
            const s3 = await async function(e3, t3, i3, n3, r3) {
              const s4 = Date.now(), o3 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t3 };
              let a3 = e3[0];
              const c2 = await XT(() => VD(a3 + "".concat(-1 === a3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: o3, cancelToken: n3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (i4, n4) => {
                if (0 === i4.code) {
                  if (i4.uid <= 0 || i4.uid >= Math.pow(2, 32))
                    throw KC.error("Invalid Uint Uid ".concat(t3, " => ").concat(i4.uid), i4), rv.reqUserAccount(o3.sid, { lts: s4, success: false, serverAddr: a3, stringUid: o3.string_uid, uid: i4.uid, errorCode: xg.INVALID_UINT_UID_FROM_STRING_UID, extend: o3 }), new xv(xg.INVALID_UINT_UID_FROM_STRING_UID);
                  return rv.reqUserAccount(o3.sid, { lts: s4, success: true, serverAddr: a3, stringUid: o3.string_uid, uid: i4.uid, errorCode: null, extend: o3 }), false;
                }
                const r4 = kI(i4.code);
                return r4.retry && (a3 = e3[(n4 + 1) % e3.length]), rv.reqUserAccount(o3.sid, { lts: s4, success: false, serverAddr: a3, stringUid: o3.string_uid, uid: i4.uid, errorCode: r4.desc, extend: o3 }), r4.retry;
              }, (t4, i4) => t4.code !== xg.OPERATION_ABORTED && (rv.reqUserAccount(o3.sid, { lts: s4, success: false, serverAddr: a3, stringUid: o3.string_uid, uid: null, errorCode: t4.code, extend: o3 }), a3 = e3[(i4 + 1) % e3.length], true), r3);
              if (0 !== c2.code) {
                const e4 = kI(c2.code);
                throw new xv(xg.UNEXPECTED_RESPONSE, e4.desc);
              }
              return c2;
            }(o2, e2, t2, i2, n2);
            return null == r2 || r2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a2), s3.uid;
          } catch (e3) {
            throw null == r2 || r2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e3] }, a2), e3;
          }
        }
        async function uP(e2, t2, i2) {
          const n2 = kC("CDS_AP").slice(0, kC("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1?action=config")).map((n3) => function(e3, t3, i3, n4) {
            const r3 = pg(), s3 = { flag: 64, cipher_method: 0, features: { device: r3.name, system: r3.os, system_general: navigator.userAgent, vendor: t3.appId, version: OC, cname: t3.cname, sid: t3.sid, session_id: t3.sid, detail: "", proxyServer: t3.proxyServer } };
            return XT(() => VD(e3, { data: s3, timeout: 1e3, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e4) => e4.code !== xg.OPERATION_ABORTED, n4);
          }(n3, e2, t2, i2));
          let r2 = null, s2 = null, o2 = {};
          try {
            r2 = await aP(n2);
          } catch (e3) {
            if (e3.code === xg.OPERATION_ABORTED)
              throw e3;
            s2 = e3;
          }
          n2.forEach((e3) => e3.cancel());
          if (rv.reportApiInvoke(e2.sid, { name: sT.REQUEST_CONFIG_DISTRIBUTE, options: { error: s2, res: r2 } }).onSuccess(), r2 && r2.test_tags)
            try {
              o2 = function(e3) {
                if (!e3.test_tags)
                  return {};
                const t3 = e3.test_tags, i3 = Object.keys(t3), n3 = {};
                return i3.forEach((e4) => {
                  var i4;
                  const r3 = fy(i4 = e4.slice(4)).call(i4), s3 = JSON.parse(t3[e4])[1];
                  n3[r3] = s3;
                }), n3;
              }(r2);
            } catch (e3) {
            }
          return o2;
        }
        async function pP(e2, t2, i2, n2) {
          const r2 = kC("PROXY_SERVER_TYPE3"), s2 = (e3, t3, i3) => {
            let n3 = i3 || r2;
            return Array.isArray(n3) && (n3 = t3 % 2 == 0 ? r2[1] : r2[0]), "https://".concat(n3, "/ap/?url=").concat(e3);
          };
          let o2 = null;
          const a2 = [], c2 = async () => {
            const r3 = kC("WEBCS_DOMAIN").slice(0, kC("AJAX_REQUEST_CONCURRENT")).map((t3, i3) => {
              let n3;
              return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? s2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : s2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: FD(), serviceIds: [hy.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? hy.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? hy.CLOUD_PROXY : hy.CLOUD_PROXY_FALLBACK] };
            }), o3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), c3 = await cP({ fragementLength: kC("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (KC.debug("[".concat(e2.clientId, "] Connect to choose_server:"), n3.url), eP(n3, e2, t2, i2)), allFailedhandler: (e3) => {
              throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, o3), e3[0];
            }, promisesCollector: a2 });
            return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, o3), c3;
          }, d2 = async () => {
            if (await UT(1e3), null !== o2)
              return o2;
            const r3 = kC("WEBCS_DOMAIN_BACKUP_LIST").map((t3, i3) => {
              let n3;
              return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? s2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : s2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i3), { url: n3, areaCode: FD(), serviceIds: [hy.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? hy.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? hy.CLOUD_PROXY : hy.CLOUD_PROXY_FALLBACK] };
            }), c3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), d3 = await cP({ fragementLength: kC("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (KC.debug("[".concat(e2.clientId, "] Connect to backup choose_server:"), n3.url), eP(n3, e2, t2, i2)), allFailedhandler: (e3) => {
              throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, c3), e3[0];
            }, promisesCollector: a2 });
            return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), d3;
          };
          let l2, h2, u2;
          try {
            ({ gatewayInfo: l2, proxyInfo: h2, url: u2 } = await aP([c2(), d2()]));
          } catch (e3) {
            throw e3[0];
          }
          if (a2.length && a2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), !l2 || !h2)
            throw new xv(xg.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
          if (e2.apUrl = u2, "disabled" !== e2.cloudProxyServer && Array.isArray(r2) && u2) {
            const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(u2)[1];
            Pr(r2).call(r2, t3) && (e2.proxyServer = t3, KC.setProxyServer(t3), rv.setProxyServer(t3));
          }
          return o2 = { gatewayInfo: l2, proxyInfo: await RD(h2, l2.uid) }, o2;
        }
        async function _P(e2, t2, i2, n2) {
          const r2 = kC("UAP_AP").slice(0, kC("AJAX_REQUEST_CONCURRENT")).map((e3) => t2.proxyServer ? "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1?action=uap") : "https://".concat(e3, "/api/v1?action=uap"));
          return await QD(r2, e2, t2, i2, n2);
        }
        async function EP(e2, t2, i2) {
          const n2 = kC("UAP_AP").slice(0, kC("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1?action=uap") : "https://".concat(t3, "/api/v1?action=uap")).map((n3) => function(e3, t3, i3, n4) {
            const r2 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, ts: Date.now(), version: OC, cname: t3.cname, uid: t3.uid.toString(), requestId: ZD, seq: ZD };
            ZD += 1;
            const s2 = { service_name: "tele_channel", json_body: JSON.stringify(r2) };
            return XT(async () => {
              const t4 = await VD(e3, { data: s2, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
              if (0 !== t4.code) {
                const e4 = new xv(xg.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t4.code, { retry: true });
                throw KC.error(e4.toString()), e4;
              }
              const n5 = JSON.parse(t4.json_body);
              if (200 !== n5.code) {
                const e4 = new xv(xg.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n5.code, ", reason: ").concat(n5.reason));
                throw KC.error(e4.toString()), e4;
              }
              if (!n5.servers || 0 === n5.servers.length) {
                const e4 = new xv(xg.UNEXPECTED_RESPONSE, "cross channel app center empty server");
                throw KC.error(e4.toString()), e4;
              }
              return { vid: n5.vid, workerToken: n5.workerToken, addressList: (kC("CHANNEL_MEDIA_RELAY_SERVERS") || n5.servers).map((e4) => "wss://".concat(e4.address.replace(/\./g, "-"), ".").concat(kC("WORKER_DOMAIN"), ":").concat(e4.wss)) };
            }, void 0, (e4) => !!(e4.code !== xg.OPERATION_ABORTED && e4.code !== xg.UNEXPECTED_RESPONSE || e4.data && e4.data.retry), n4);
          }(n3, e2, t2, i2));
          try {
            const e3 = await aP(n2);
            return n2.forEach((e4) => e4.cancel()), e3;
          } catch (e3) {
            throw e3[0];
          }
        }
        async function mP(e2, t2, i2) {
          let n2 = null;
          const r2 = [], s2 = async (s3) => {
            const o2 = kC(s3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t3, "/api/v2/transpond/webrtc?v=2"));
            return s3 && (await UT(1e3), null !== n2) ? n2 : await cP({ fragementLength: kC("FRAGEMENT_LENGTH"), referenceList: o2, asyncMapHandler: (n3) => (KC.debug("[".concat(e2.clientId, "] update ticket, Connect to ").concat(s3 ? "backup" : "", " choose_server:"), n3), function(e3, t3, i3, n4) {
              const [r3] = sP(t3, [hy.CHOOSE_SERVER]);
              let s4 = RT.networkState;
              return XT(async () => {
                s4 && RT.networkState === hT.OFFLINE && RT.onlineWaiter && await tg.race([RT.onlineWaiter, UT(n4 && n4.maxRetryTimeout || JT.maxRetryTimeout)]), s4 = RT.networkState;
                const t4 = await VD(e3, { data: r3, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true);
                return nP(t4, e3);
              }, () => false, (e4) => e4.code !== xg.OPERATION_ABORTED && (e4.code === xg.UPDATE_TICKET_FAILED ? e4.data.retry : (KC.warning("[".concat(t3.clientId, "] update ticket network error, retry"), e4), true)), n4);
            }(n3, e2, t2, i2)), allFailedhandler: (e3) => {
              throw e3[0];
            }, promisesCollector: r2 });
          };
          try {
            return n2 = await aP([s2(false), s2(true)]), r2.length && r2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), n2;
          } catch (e3) {
            throw e3[0];
          }
        }
        function fP(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function gP(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? fP(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : fP(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class TP extends iT {
          constructor() {
            super(), nu(this, "configs", void 0), nu(this, "joinInfo", void 0), nu(this, "cancelToken", void 0), nu(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), nu(this, "interval", void 0), nu(this, "mutex", new YT("config-distribute")), nu(this, "mutableParamsRead", false);
          }
          startGetConfigDistribute(e2, t2) {
            this.joinInfo = e2, this.cancelToken = t2, this.interval && this.stopGetConfigDistribute(), kC("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
              this.updateConfigDistribute();
            }, kC("CONFIG_DISTRIBUTE_INTERVAL")));
          }
          stopGetConfigDistribute() {
            this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
          }
          async awaitConfigDistributeComplete() {
            if (!this.mutex.isLocked)
              return;
            (await this.mutex.lock())();
          }
          async updateConfigDistribute() {
            if (!this.mutableParamsRead) {
              this.mutableParamsRead = true;
              rv.reportApiInvoke(null, { options: void 0, name: sT.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: oT.TRACER }).onSuccess(JSON.stringify(MC));
            }
            if (!this.joinInfo || !this.cancelToken || !this.retryConfig)
              return void KC.debug("[config-distribute] get config distribute interrupted have no joininfo");
            let e2;
            const t2 = await this.mutex.lock();
            try {
              e2 = await uP(this.joinInfo, this.cancelToken, this.retryConfig), KC.debug("[config-distribute] get config distribute", JSON.stringify(e2)), e2.limit_bitrate && this.handleBitrateLimit(e2.limit_bitrate), this.cacheGlobalParameterConfig(e2), this.configs = e2;
            } catch (e3) {
              const t3 = new xv(xg.NETWORK_RESPONSE_ERROR, e3);
              KC.warning("[config-distribute] ".concat(t3.toString()));
            } finally {
              t2();
            }
          }
          getBitrateLimit() {
            return this.configs ? this.configs.limit_bitrate : void 0;
          }
          handleBitrateLimit(e2) {
            var t2;
            (t2 = e2) && t2.uplink && t2.id && void 0 !== t2.uplink.max_bitrate && void 0 !== t2.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e2.id && this.emit(dI.UPDATE_BITRATE_LIMIT, e2) : this.emit(dI.UPDATE_BITRATE_LIMIT, e2));
          }
          getLowStreamConfigDistribute() {
            return this.configs && this.configs.limit_bitrate && gP({}, this.configs.limit_bitrate.low_stream_uplink);
          }
          cacheGlobalParameterConfig(e2) {
            var t2;
            const i2 = Zu(t2 = Object.keys(e2).filter((e3) => /^webrtc_ng_global_parameter/.test(e3))).call(t2);
            for (let t3 = 0; t3 < i2.length; t3++)
              for (let n3 = i2.length - 1; n3 > t3; n3--) {
                const t4 = i2[n3];
                if ("number" == typeof e2[t4].__priority) {
                  const r2 = e2[t4].__priority, s2 = i2[n3 - 1];
                  if ("number" == typeof e2[s2].__priority) {
                    if (!(r2 > e2[s2].__priority))
                      continue;
                    {
                      const e3 = t4;
                      i2[n3] = i2[n3 - 1], i2[n3 - 1] = e3;
                    }
                  } else {
                    const e3 = t4;
                    i2[n3] = i2[n3 - 1], i2[n3 - 1] = e3;
                  }
                }
              }
            const n2 = {};
            i2.forEach((t3) => {
              const i3 = e2[t3], r2 = i3.__expires;
              Object.keys(i3).forEach((e3) => {
                "__priority" === e3 || "__expires" === e3 || Object.prototype.hasOwnProperty.call(n2, e3) || (n2[e3] = gP({ value: i3[e3] }, r2 && { expires: r2 }));
              });
            });
            try {
              !function(e4) {
                try {
                  const t4 = Date.now();
                  Object.keys(e4).forEach((i3) => {
                    switch (i3) {
                      case "ENABLE_EVENT_REPORT":
                      case "UPLOAD_LOG":
                        if (Object.prototype.hasOwnProperty.call(PC, i3)) {
                          const { value: n3, expires: r2 } = e4[i3];
                          if (r2 && r2 <= t4)
                            return;
                          MC[i3] = n3, PC[i3] = n3, KC.debug("Update global parameters from config distribute", i3, n3);
                        }
                    }
                  });
                } catch (t4) {
                  KC.error("Error update config immediately: ".concat(e4), t4.message);
                }
              }(n2);
              const e3 = JSON.stringify(n2), t3 = window.btoa(e3);
              window.localStorage.setItem("websdk_ng_global_parameter", t3), KC.debug("Caching global parameters ".concat(e3));
            } catch (e3) {
              KC.error("Error caching global parameters:", e3.message);
            }
          }
        }
        function SP(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function RP(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? SP(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : SP(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class CP extends iT {
          constructor(e2, t2, i2, n2) {
            super(), nu(this, "spec", void 0), nu(this, "token", void 0), nu(this, "websocket", void 0), nu(this, "pingpongTimer", void 0), nu(this, "reconnectMode", "retry"), nu(this, "serviceMode", void 0), nu(this, "reqId", 0), nu(this, "commandReqId", 0), nu(this, "handleWebSocketOpen", () => {
              this.reconnectMode = "retry", this.startPingPong();
            }), nu(this, "handleWebSocketMessage", (e3) => {
              if (!e3.data)
                return;
              const t3 = JSON.parse(e3.data);
              t3.requestId ? this.emit("@".concat(t3.requestId, "-").concat(t3.sid), t3) : this.serviceMode === yv.INJECT ? this.emit(Kv.INJECT_STREAM_STATUS, t3) : (rv.workerEvent(this.spec.sid, { actionType: "status", serverCode: t3.code, workerType: this.serviceMode === yv.TRANSCODE ? 1 : 2 }), this.emit(Kv.PUBLISH_STREAM_STATUS, t3));
            }), this.spec = t2, this.token = e2, this.serviceMode = n2, this.websocket = new XI("live-streaming", i2), this.websocket.on(Iv.CONNECTED, this.handleWebSocketOpen), this.websocket.on(Iv.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(Iv.REQUEST_NEW_URLS, (e3, t3) => {
              fT(this, Kv.REQUEST_NEW_ADDRESS).then(e3).catch(t3);
            }), this.websocket.on(Iv.RECONNECTING, () => {
              this.websocket.reconnectMode = this.reconnectMode;
            });
          }
          init(e2) {
            return this.websocket.init(e2);
          }
          async request(e2, t2, i2, n2) {
            this.reqId += 1, "request" === e2 && (this.commandReqId += 1);
            const r2 = this.commandReqId, s2 = this.reqId;
            if (!s2 || !this.websocket)
              throw new xv(xg.UNEXPECTED_ERROR);
            const o2 = RP({ command: e2, sdkVersion: "4.19.3" === OC ? "0.0.1" : OC, seq: s2, requestId: s2, allocate: i2, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t2);
            if ("closed" === this.websocket.state)
              throw new xv(xg.WS_DISCONNECT);
            const a2 = () => new tg((e3, t3) => {
              this.websocket.once(Iv.CLOSED, () => t3(new xv(xg.WS_ABORT))), this.websocket.once(Iv.CONNECTED, e3);
            });
            "connected" !== this.websocket.state && await a2(), o2.clientRequest && (o2.clientRequest.workerToken = this.token);
            const c2 = new tg((e3, t3) => {
              const i3 = () => {
                t3(new xv(xg.WS_ABORT));
              };
              this.websocket.once(Iv.RECONNECTING, i3), this.websocket.once(Iv.CLOSED, i3), this.once("@".concat(s2, "-").concat(this.spec.sid), (t4) => {
                e3(t4);
              });
            });
            n2 && rv.workerEvent(this.spec.sid, RP(RP({}, n2), {}, { requestId: r2, actionType: "request", payload: JSON.stringify(t2.clientRequest), serverCode: 0, code: 0 }));
            const d2 = Date.now();
            this.websocket.sendMessage(o2);
            let l2 = null;
            try {
              l2 = await c2;
            } catch (n3) {
              if ("closed" === this.websocket.state)
                throw n3;
              return await a2(), await this.request(e2, t2, i2);
            }
            return n2 && rv.workerEvent(this.spec.sid, RP(RP({}, n2), {}, { requestId: r2, actionType: "response", payload: JSON.stringify(l2.serverResponse), serverCode: l2.code, success: 200 === l2.code, responseTime: Date.now() - d2 })), 200 !== l2.code && this.handleResponseError(l2), l2;
          }
          tryNextAddress() {
            this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
          }
          close() {
            const e2 = "4.19.3" === OC ? "0.0.1" : OC;
            this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e2, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
          }
          handleResponseError(e2) {
            switch (e2.code) {
              case qv.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
                return void KC.warning("live stream response already exists stream");
              case qv.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
              case qv.LIVE_STREAM_RESPONSE_BAD_STREAM:
              case qv.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
                return new xv(xg.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e2.code }).throw();
              case qv.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
                if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
                  return;
                throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
              case qv.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
                return new xv(xg.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e2.code }).throw();
              case qv.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
                const t2 = new xv(xg.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
                return this.emit(Kv.WARNING, t2, e2.serverResponse.url);
              }
              case qv.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
                const t2 = new xv(xg.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
                return this.emit(Kv.WARNING, t2, e2.serverResponse.url);
              }
              case qv.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
                throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
              case qv.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
                return new xv(xg.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e2.code }).throw();
              case qv.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
                const t2 = new xv(xg.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
                return this.emit(Kv.WARNING, t2, e2.serverResponse.url);
              }
              case qv.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
                return new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code }).throw();
              case qv.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
                throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
              case qv.LIVE_STREAM_RESPONSE_WORKER_LOST:
              case qv.LIVE_STREAM_RESPONSE_WORKER_QUIT:
                if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
                  return;
                throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
              case qv.ERROR_FAIL_SEND_MESSAGE:
                if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
                  return;
                if ("UpdateTranscoding" === e2.serverResponse.command || "ControlStream" === e2.serverResponse.command)
                  return new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e2.code }).throw();
                throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
              case qv.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
              case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
              case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
              case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
                return new xv(xg.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code }).throw();
            }
          }
          startPingPong() {
            this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
              "connected" === this.websocket.state && this.request("ping", {}).catch(FT);
            }, 6e3);
          }
        }
        function vP(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function IP(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? vP(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : vP(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class yP extends iT {
          constructor(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : JT, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : JT;
            super(), nu(this, "onLiveStreamWarning", void 0), nu(this, "onLiveStreamError", void 0), nu(this, "onInjectStatusChange", void 0), nu(this, "spec", void 0), nu(this, "retryTimeout", 1e4), nu(this, "connection", void 0), nu(this, "httpRetryConfig", void 0), nu(this, "wsRetryConfig", void 0), nu(this, "streamingTasks", /* @__PURE__ */ new Map()), nu(this, "isStartingStreamingTask", false), nu(this, "taskMutex", new YT("live-streaming")), nu(this, "cancelToken", EC.CancelToken.source()), nu(this, "transcodingConfig", void 0), nu(this, "injectConfig", IP({}, Hv)), nu(this, "injectLoopTimes", 0), nu(this, "uapResponse", void 0), nu(this, "lastTaskId", 1), nu(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e2, this.httpRetryConfig = i2, this.wsRetryConfig = t2;
          }
          async setTranscodingConfig(e2) {
            const t2 = IP(IP({}, Wv), e2);
            66 !== t2.videoCodecProfile && 77 !== t2.videoCodecProfile && 100 !== t2.videoCodecProfile && (KC.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t2.videoCodecProfile, " -> 100")), t2.videoCodecProfile = 100), t2.transcodingUsers || (t2.transcodingUsers = t2.userConfigs), t2.transcodingUsers && (t2.transcodingUsers = t2.transcodingUsers.map((e3) => IP(IP(IP({}, Bv), e3), {}, { zOrder: e3.zOrder ? e3.zOrder + 1 : 1 }))), function(e3) {
              Kg(e3.width) || jg(e3.width, "config.width", 0, 1e4), Kg(e3.height) || jg(e3.height, "config.height", 0, 1e4), Kg(e3.videoBitrate) || jg(e3.videoBitrate, "config.videoBitrate", 1, 1e6), Kg(e3.videoFrameRate) || jg(e3.videoFrameRate, "config.videoFrameRate"), Kg(e3.lowLatency) || Fg(e3.lowLatency, "config.lowLatency"), Kg(e3.audioSampleRate) || Bg(e3.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), Kg(e3.audioBitrate) || jg(e3.audioBitrate, "config.audioBitrate", 1, 128), Kg(e3.audioChannels) || Bg(e3.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), Kg(e3.videoGop) || jg(e3.videoGop, "config.videoGop"), Kg(e3.videoCodecProfile) || Bg(e3.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), Kg(e3.userCount) || jg(e3.userCount, "config.userCount", 0, 17), Kg(e3.backgroundColor) || jg(e3.backgroundColor, "config.backgroundColor", 0, 16777215), Kg(e3.userConfigExtraInfo) || Wg(e3.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e3.transcodingUsers && !Kg(e3.transcodingUsers) && (Hg(e3.transcodingUsers, "config.transcodingUsers"), e3.transcodingUsers.forEach((e4, t3) => {
                Fv(e4.uid), Kg(e4.x) || jg(e4.x, "transcodingUser[".concat(t3, "].x"), 0, 1e4), Kg(e4.y) || jg(e4.y, "transcodingUser[".concat(t3, "].y"), 0, 1e4), Kg(e4.width) || jg(e4.width, "transcodingUser[".concat(t3, "].width"), 0, 1e4), Kg(e4.height) || jg(e4.height, "transcodingUser[".concat(t3, "].height"), 0, 1e4), Kg(e4.zOrder) || jg(e4.zOrder - 1, "transcodingUser[".concat(t3, "].zOrder"), 0, 100), Kg(e4.alpha) || jg(e4.alpha, "transcodingUser[".concat(t3, "].alpha"), 0, 1, false);
              })), Kg(e3.watermark) || Gv(e3.watermark, "watermark"), Kg(e3.backgroundImage) || Gv(e3.backgroundImage, "backgroundImage"), e3.images && !Kg(e3.images) && (Hg(e3.images, "config.images"), e3.images.forEach((e4, t3) => {
                Gv(e4, "images[".concat(t3, "]"));
              }));
            }(t2);
            const i2 = [];
            t2.images && i2.push(...t2.images.map((e3) => IP(IP(IP({}, jv), e3), {}, { zOrder: 255 }))), t2.backgroundImage && (i2.push(IP(IP(IP({}, jv), t2.backgroundImage), {}, { zOrder: 0 })), delete t2.backgroundImage), t2.watermark && (i2.push(IP(IP(IP({}, jv), t2.watermark), {}, { zOrder: 255 })), delete t2.watermark), t2.images = i2, t2.transcodingUsers && (t2.userConfigs = t2.transcodingUsers.map((e3) => IP({}, e3)), t2.userCount = t2.transcodingUsers.length, delete t2.transcodingUsers);
            const n2 = (t2.userConfigs || []).map((e3) => "number" == typeof e3.uid ? tg.resolve(e3.uid) : hP(e3.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
            if ((await tg.all(n2)).forEach((e3, i3) => {
              t2.userConfigs && t2.userConfigs[i3] && (t2.userConfigs[i3].uid = e3);
            }), this.transcodingConfig = t2, this.connection)
              try {
                var r2;
                const e3 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(kv(r2 = this.streamingTasks).call(r2)).map((e4) => e4.taskId).join("#") });
                KC.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e3.code, ", config:"), JSON.stringify(this.transcodingConfig));
              } catch (e3) {
                if (!e3.data || !e3.data.retry)
                  throw e3;
                e3.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t3) => {
                  KC.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e3.toString(), "try to republish", t3.url), this.startLiveStreamingTask(t3.url, t3.mode, e3).then(() => {
                    KC.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t3.url, " success"));
                  }).catch((e4) => {
                    KC.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t3.url, e4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3.url, e4);
                  });
                });
              }
          }
          setInjectStreamConfig(e2, t2) {
            this.injectConfig = Object.assign({}, this.injectConfig, e2), this.injectLoopTimes = t2;
          }
          async startLiveStreamingTask(e2, t2, i2) {
            var n2;
            if (Array.from(kv(n2 = this.streamingTasks).call(n2)).find((e3) => e3.mode === yv.INJECT) && t2 === yv.INJECT)
              return new xv(xg.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw();
            if (!this.transcodingConfig && t2 === yv.TRANSCODE)
              throw new xv(xg.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
            let r2 = { command: "PublishStream", ts: Date.now(), url: e2, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
            KC.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e2, ", mode: ").concat(t2));
            const s2 = await this.taskMutex.lock();
            if (!this.connection && i2)
              return void s2();
            if (this.streamingTasks.get(e2) && !i2)
              return s2(), new xv(xg.LIVE_STREAMING_TASK_CONFLICT).throw();
            try {
              this.connection || (this.connection = await this.connect(t2));
            } catch (e3) {
              throw s2(), e3;
            }
            switch (t2) {
              case yv.TRANSCODE:
                r2.transcodingConfig = IP({}, this.transcodingConfig);
                break;
              case yv.RAW:
                break;
              case yv.INJECT:
                r2 = { cname: this.spec.cname, command: "InjectStream", sid: this.spec.sid, transcodingConfig: this.injectConfig, ts: Date.now(), url: e2, loopTimes: this.injectLoopTimes };
            }
            this.uapResponse && this.uapResponse.vid && (r2.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
            const o2 = this.lastTaskId++;
            try {
              const n3 = new tg((t3, n4) => {
                UT(this.retryTimeout).then(() => {
                  if (i2)
                    return n4(i2);
                  const t4 = this.statusError.get(e2);
                  return t4 ? (this.statusError.delete(e2), n4(t4)) : void 0;
                });
              }), a2 = await tg.race([this.connection.request("request", { clientRequest: r2 }, true, { url: e2, command: "PublishStream", workerType: t2 === yv.TRANSCODE ? 1 : 2, requestByUser: !i2, tid: o2.toString() }), n3]);
              this.isStartingStreamingTask = false, KC.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a2.code)), this.streamingTasks.set(e2, { clientRequest: r2, mode: t2, url: e2, taskId: o2 }), s2();
            } catch (n3) {
              if (s2(), this.isStartingStreamingTask = false, !n3.data || !n3.data.retry || i2)
                throw n3;
              return n3.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e2, t2, n3)) : await this.startLiveStreamingTask(e2, t2, n3);
            }
          }
          stopLiveStreamingTask(e2) {
            return new tg((t2, i2) => {
              const n2 = this.streamingTasks.get(e2);
              if (!n2 || !this.connection)
                return new xv(xg.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
              const r2 = n2.mode;
              n2.abortTask = () => {
                KC.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e2), t2();
              }, this.connection.request("request", { clientRequest: { command: r2 === yv.INJECT ? "UninjectStream" : "UnpublishStream", url: n2.url } }, false, { url: e2, command: "UnPublishStream", workerType: r2 === yv.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((i3) => {
                KC.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i3.code)), this.streamingTasks.delete(e2), 0 === this.streamingTasks.size && r2 !== yv.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t2(), r2 === yv.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e2);
              }).catch(i2);
            });
          }
          async controlInjectStream(e2, t2, i2, n2) {
            const r2 = this.streamingTasks.get(e2);
            if (!r2 || !this.connection || r2.mode !== yv.INJECT)
              throw new xv(xg.INVALID_OPERATION, "can not find inject stream task to control");
            return (await this.connection.request("request", { clientRequest: { command: "ControlStream", url: e2, control: t2, audioVolume: i2, position: n2 } })).serverResponse;
          }
          resetAllTask() {
            var e2;
            const t2 = Array.from(kv(e2 = this.streamingTasks).call(e2));
            this.terminate();
            for (const e3 of t2)
              this.startLiveStreamingTask(e3.url, e3.mode).catch((t3) => {
                this.onLiveStreamError && this.onLiveStreamError(e3.url, t3);
              });
          }
          terminate() {
            this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = EC.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
          }
          async connect(e2) {
            if (this.connection)
              throw new xv(xg.UNEXPECTED_ERROR, "live streaming connection has already connected");
            const t2 = await fT(this, Yv.REQUEST_WORKER_MANAGER_LIST, e2);
            return this.uapResponse = t2, this.connection = new CP(t2.workerToken, this.spec, this.wsRetryConfig, e2), this.connection.on(Kv.WARNING, (e3, t3) => this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e3)), this.connection.on(Kv.PUBLISH_STREAM_STATUS, (e3) => this.handlePublishStreamServer(e3)), this.connection.on(Kv.INJECT_STREAM_STATUS, (e3) => this.handleInjectStreamServerStatus(e3)), this.connection.on(Kv.REQUEST_NEW_ADDRESS, (t3, i2) => {
              if (!this.connection)
                return i2(new xv(xg.UNEXPECTED_ERROR, "can not get new live streaming address list"));
              fT(this, Yv.REQUEST_WORKER_MANAGER_LIST, e2).then((e3) => {
                this.uapResponse = e3, t3(e3.addressList);
              }).catch(i2);
            }), await this.connection.init(t2.addressList), this.connection;
          }
          handlePublishStreamServer(e2) {
            const t2 = e2.serverStatus && e2.serverStatus.url || "empty_url", i2 = this.streamingTasks.get(t2), n2 = e2.reason;
            switch (e2.code) {
              case qv.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
              case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
              case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
              case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
                const n3 = new xv(xg.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code });
                if (i2)
                  return KC.error(n3.toString()), this.onLiveStreamError && this.onLiveStreamError(t2, n3);
                if (!this.isStartingStreamingTask)
                  return;
                this.statusError.set(t2, n3);
              }
              case qv.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
                const e3 = new xv(xg.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n2);
                return this.onLiveStreamWarning && this.onLiveStreamWarning(t2, e3);
              }
              case qv.LIVE_STREAM_RESPONSE_WORKER_LOST:
              case qv.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
                var r2;
                if (!this.connection)
                  return;
                this.connection.tryNextAddress();
                const t3 = Array.from(kv(r2 = this.streamingTasks).call(r2));
                for (const i3 of t3)
                  i3.abortTask ? i3.abortTask() : (KC.warning("[".concat(this.spec.clientId, "] publish stream status code"), e2.code, "try to republish", i3.url), this.startLiveStreamingTask(i3.url, i3.mode, new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code })).then(() => {
                    KC.debug("[".concat(this.spec.clientId, "] republish live stream success"), i3.url);
                  }).catch((e3) => {
                    KC.error(e3.toString()), this.onLiveStreamError && this.onLiveStreamError(i3.url, e3);
                  }));
                return;
              }
            }
          }
          handleInjectStreamServerStatus(e2) {
            const t2 = Number(e2.uid), i2 = e2.serverStatus && e2.serverStatus.url;
            switch (e2.code) {
              case 200:
                return void (this.onInjectStatusChange && this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_START_SUCCESS, t2, i2));
              case 451:
                return this.onInjectStatusChange && this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t2, i2), void this.streamingTasks.delete(i2);
              case 453:
                return this.onInjectStatusChange && this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t2, i2), void this.streamingTasks.delete(i2);
              case 470:
                return this.onInjectStatusChange && this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_BROKEN, t2, i2), void this.streamingTasks.delete(i2);
              case 499:
                return this.onInjectStatusChange && this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_START_TIMEOUT, t2, i2), void this.streamingTasks.delete(i2);
              default:
                return void KC.debug("inject stream server status", e2);
            }
          }
          hasUrl(e2) {
            return this.streamingTasks.has(e2);
          }
        }
        class AP {
          constructor() {
            nu(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), nu(this, "srcChannelMediaInfo", void 0);
          }
          setSrcChannelInfo(e2) {
            sI(e2), this.srcChannelMediaInfo = e2;
          }
          addDestChannelInfo(e2) {
            sI(e2), this.destChannelMediaInfos.set(e2.channelName, e2);
          }
          removeDestChannelInfo(e2) {
            Vv(e2), this.destChannelMediaInfos.delete(e2);
          }
          getSrcChannelMediaInfo() {
            return this.srcChannelMediaInfo;
          }
          getDestChannelMediaInfo() {
            return this.destChannelMediaInfos;
          }
        }
        function bP(e2) {
          if (!(e2 instanceof AP)) {
            return new xv(xg.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
          }
          const t2 = e2.getSrcChannelMediaInfo(), i2 = e2.getDestChannelMediaInfo();
          if (!t2) {
            return new xv(xg.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
          }
          if (0 === i2.size) {
            return new xv(xg.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
          }
        }
        class wP extends iT {
          constructor(e2, t2, i2) {
            super(), nu(this, "ws", void 0), nu(this, "requestId", 1), nu(this, "heartBeatTimer", void 0), nu(this, "joinInfo", void 0), nu(this, "clientId", void 0), nu(this, "onOpen", () => {
              this.emit("open"), this.startHeartBeatCheck();
            }), nu(this, "onClose", (e3) => {
              this.emit("close"), this.dispose();
            }), nu(this, "onMessage", (e3) => {
              const t3 = JSON.parse(e3.data);
              if (!t3 || "serverResponse" !== t3.command || !t3.requestId)
                return t3 && "serverStatus" === t3.command && t3.serverStatus && t3.serverStatus.command ? (this.emit("status", t3.serverStatus), void this.emit(t3.serverStatus.command, t3.serverStatus)) : void 0;
              this.emit("req_".concat(t3.requestId), t3);
            }), this.joinInfo = e2, this.clientId = t2, this.ws = new XI("cross-channel-".concat(this.clientId), i2), this.ws.on(Iv.RECONNECTING, () => {
              this.ws.reconnectMode = "retry", this.emit("reconnecting");
            }), this.ws.on(Iv.CONNECTED, this.onOpen), this.ws.on(Iv.ON_MESSAGE, this.onMessage), this.ws.on(Iv.CLOSED, this.onClose);
          }
          isConnect() {
            return "connected" === this.ws.state;
          }
          sendMessage(e2) {
            const t2 = this.requestId++;
            return e2.requestId = t2, e2.seq = t2, this.ws.sendMessage(e2), t2;
          }
          waitStatus(e2) {
            return new tg((t2, i2) => {
              const n2 = window.setTimeout(() => {
                i2(new xv(xg.TIMEOUT, "wait status timeout, status: ".concat(e2)));
              }, 5e3);
              this.once(e2, (r2) => {
                window.clearTimeout(n2), r2.state && 0 !== r2.state ? i2(new xv(xg.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e2))) : t2(void 0);
              }), this.once("dispose", () => {
                window.clearTimeout(n2), i2(new xv(xg.WS_ABORT));
              });
            });
          }
          async request(e2) {
            if ("closed" === this.ws.state)
              throw new xv(xg.WS_DISCONNECT);
            const t2 = () => new tg((e3, t3) => {
              this.ws.once(Iv.CLOSED, () => t3(new xv(xg.WS_ABORT))), this.ws.once(Iv.CONNECTED, e3);
            });
            "connected" !== this.ws.state && await t2();
            const i2 = this.sendMessage(e2), n2 = new tg((e3, t3) => {
              const n3 = () => {
                t3(new xv(xg.WS_ABORT));
              };
              this.ws.once(Iv.RECONNECTING, n3), this.ws.once(Iv.CLOSED, n3), this.once("req_".concat(i2), e3), UT(3e3).then(() => {
                this.removeAllListeners("req_".concat(i2)), this.ws.off(Iv.RECONNECTING, n3), this.ws.off(Iv.CLOSED, n3), t3(new xv(xg.TIMEOUT, "cross channel ws request timeout"));
              });
            }), r2 = await n2;
            if (!r2 || 200 !== r2.code)
              throw new xv(xg.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r2)));
            return r2;
          }
          async connect(e2) {
            this.ws.removeAllListeners(Iv.REQUEST_NEW_URLS), this.ws.on(Iv.REQUEST_NEW_URLS, (t2) => {
              t2(e2);
            }), await this.ws.init(e2);
          }
          dispose() {
            this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
          }
          sendPing(e2) {
            const t2 = this.requestId++;
            return e2.requestId = t2, this.ws.sendMessage(e2), t2;
          }
          startHeartBeatCheck() {
            this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
              this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +/* @__PURE__ */ new Date(), requestId: 0 });
            }, 3e3);
          }
          clearHeartBeatCheck() {
            window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
          }
        }
        class OP extends iT {
          set state(e2) {
            e2 !== this._state && (e2 !== Qv.RELAY_STATE_FAILURE && (this.errorCode = Zv.RELAY_OK), this.emit("state", e2, this.errorCode), this._state = e2);
          }
          get state() {
            return this._state;
          }
          constructor(e2, t2, i2, n2, r2) {
            super(), nu(this, "joinInfo", void 0), nu(this, "sid", void 0), nu(this, "clientId", void 0), nu(this, "cancelToken", EC.CancelToken.source()), nu(this, "workerToken", void 0), nu(this, "requestId", 0), nu(this, "signal", void 0), nu(this, "prevChannelMediaConfig", void 0), nu(this, "httpRetryConfig", void 0), nu(this, "_resolution", void 0), nu(this, "_state", Qv.RELAY_STATE_IDLE), nu(this, "errorCode", Zv.RELAY_OK), nu(this, "onStatus", (e3) => {
              KC.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e3))), e3 && e3.command && ("onAudioPacketReceived" === e3.command && this.emit("event", Xv.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e3.command && this.emit("event", Xv.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e3.command && (this.errorCode = Zv.SRC_TOKEN_EXPIRED, this.state = Qv.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e3.command && (this.errorCode = Zv.DEST_TOKEN_EXPIRED, this.state = Qv.RELAY_STATE_FAILURE));
            }), nu(this, "onReconnect", async () => {
              KC.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", Xv.NETWORK_DISCONNECTED), this.state = Qv.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e3) => {
                this.state !== Qv.RELAY_STATE_IDLE && (KC.error("auto restart channel media relay failed", e3.toString()), this.errorCode = Zv.SERVER_CONNECTION_LOST, this.state = Qv.RELAY_STATE_FAILURE);
              });
            }), this.joinInfo = e2, this.clientId = t2, this.sid = VT(), this.signal = new wP(this.joinInfo, this.clientId, i2), this.httpRetryConfig = n2, this._resolution = r2;
          }
          async startChannelMediaRelay(e2) {
            if (this.state !== Qv.RELAY_STATE_IDLE)
              throw new xv(xg.INVALID_OPERATION);
            this.state = Qv.RELAY_STATE_CONNECTING, await this.connect(), KC.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
            try {
              await this.sendStartRelayMessage(e2);
            } catch (e3) {
              if (e3.data && e3.data.serverResponse && "SetSourceChannel" === e3.data.serverResponse.command)
                throw new xv(xg.CROSS_CHANNEL_FAILED_JOIN_SRC);
              if (e3.data && e3.data.serverResponse && "SetDestChannelStatus" === e3.serverResponse.command)
                throw new xv(xg.CROSS_CHANNEL_FAILED_JOIN_DEST);
              if (e3.data && e3.data.serverResponse && "StartPacketTransfer" === e3.serverResponse.command)
                throw new xv(xg.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
              throw e3;
            }
            this.prevChannelMediaConfig = e2;
          }
          async updateChannelMediaRelay(e2) {
            if (this.state !== Qv.RELAY_STATE_RUNNING)
              throw new xv(xg.INVALID_OPERATION);
            await this.sendUpdateMessage(e2), this.prevChannelMediaConfig = e2;
          }
          async setVideoProfile(e2) {
            if (this._resolution = e2, this.state !== Qv.RELAY_STATE_RUNNING)
              throw new xv(xg.INVALID_OPERATION);
            const t2 = this.genMessage(zv.SetVideoProfile);
            await this.signal.request(t2), KC.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
          }
          async stopChannelMediaRelay() {
            await this.sendStopRelayMessage(), KC.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = Qv.RELAY_STATE_IDLE, this.dispose();
          }
          dispose() {
            KC.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = EC.CancelToken.source(), this.state = Qv.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
          }
          async connect() {
            const e2 = await EP(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
            this.workerToken = e2.workerToken, await this.signal.connect(e2.addressList), this.emit("event", Xv.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
          }
          async sendStartRelayMessage(e2) {
            const t2 = this.genMessage(zv.StopPacketTransfer);
            await this.signal.request(t2), await this.signal.waitStatus("Normal Quit"), KC.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
            const i2 = this.genMessage(zv.SetSdkProfile, e2);
            await this.signal.request(i2), KC.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
            const n2 = this.genMessage(zv.SetSourceChannel, e2);
            await this.signal.request(n2), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", Xv.PACKET_JOINED_SRC_CHANNEL), KC.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
            const r2 = this.genMessage(zv.SetSourceUserId, e2);
            await this.signal.request(r2), KC.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
            const s2 = this.genMessage(zv.SetDestChannel, e2);
            await this.signal.request(s2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", Xv.PACKET_JOINED_DEST_CHANNEL), KC.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
            const o2 = this.genMessage(zv.StartPacketTransfer, e2);
            await this.signal.request(o2), this.emit("event", Xv.PACKET_SENT_TO_DEST_CHANNEL), this.state = Qv.RELAY_STATE_RUNNING, KC.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
          }
          async sendUpdateMessage(e2) {
            const t2 = this.genMessage(zv.UpdateDestChannel, e2);
            await this.signal.request(t2), this.emit("event", Xv.PACKET_UPDATE_DEST_CHANNEL), KC.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
          }
          async sendStopRelayMessage() {
            const e2 = this.genMessage(zv.StopPacketTransfer);
            await this.signal.request(e2), KC.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
          }
          genMessage(e2, t2) {
            const i2 = [], n2 = [], r2 = [];
            this.requestId += 1;
            const s2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: OC, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
            "4.19.3" === s2.sdkVersion && (s2.sdkVersion = "0.0.1");
            let o2 = null, a2 = null;
            switch (e2) {
              case zv.SetSdkProfile:
                return s2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, s2;
              case zv.SetSourceChannel:
                if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
                  throw new xv(xg.UNEXPECTED_ERROR, "can not find source config");
                return s2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a2.channelName, token: a2.token || this.joinInfo.appId }, s2;
              case zv.SetSourceUserId:
                if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
                  throw new xv(xg.UNEXPECTED_ERROR, "can not find source config");
                return s2.clientRequest = { command: "SetSourceUserId", uid: a2.uid + "" }, s2;
              case zv.SetDestChannel:
                if (o2 = t2 && t2.getDestChannelMediaInfo(), !o2)
                  throw new xv(xg.UNEXPECTED_ERROR, "can not find dest config");
                return o2.forEach((e3) => {
                  i2.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
                }), s2.clientRequest = { command: "SetDestChannel", channelName: i2, uid: n2, token: r2 }, s2;
              case zv.StartPacketTransfer:
                return s2.clientRequest = { command: "StartPacketTransfer" }, s2;
              case zv.Reconnect:
                return s2.clientRequest = { command: "Reconnect" }, s2;
              case zv.StopPacketTransfer:
                return s2.clientRequest = { command: "StopPacketTransfer" }, s2;
              case zv.UpdateDestChannel:
                if (o2 = t2 && t2.getDestChannelMediaInfo(), !o2)
                  throw new xv(xg.UNEXPECTED_ERROR, "can not find dest config");
                return o2.forEach((e3) => {
                  i2.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
                }), s2.clientRequest = { command: "UpdateDestChannel", channelName: i2, uid: n2, token: r2 }, s2;
              case zv.SetVideoProfile:
                s2.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
            }
            return s2;
          }
        }
        class NP {
          get hasVideo() {
            return this._video_enabled_ && !this._video_muted_ && this._video_added_;
          }
          get hasAudio() {
            return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
          }
          get audioTrack() {
            if (this.hasAudio)
              return this._audioTrack;
          }
          get videoTrack() {
            if (this.hasVideo)
              return this._videoTrack;
          }
          get dataChannels() {
            return this._dataChannels;
          }
          constructor(e2, t2) {
            nu(this, "uid", void 0), nu(this, "_uintid", void 0), nu(this, "_trust_in_room_", true), nu(this, "_trust_audio_enabled_state_", true), nu(this, "_trust_video_enabled_state_", true), nu(this, "_trust_audio_mute_state_", true), nu(this, "_trust_video_mute_state_", true), nu(this, "_audio_muted_", false), nu(this, "_video_muted_", false), nu(this, "_audio_enabled_", true), nu(this, "_video_enabled_", true), nu(this, "_audio_added_", false), nu(this, "_video_added_", false), nu(this, "_trust_video_stream_added_state_", true), nu(this, "_trust_audio_stream_added_state_", true), nu(this, "_audioTrack", void 0), nu(this, "_videoTrack", void 0), nu(this, "_dataChannels", []), nu(this, "_audioSSRC", void 0), nu(this, "_videoSSRC", void 0), nu(this, "_audioOrtc", void 0), nu(this, "_videoOrtc", void 0), nu(this, "_cname", void 0), nu(this, "_rtxSsrcId", void 0), this.uid = e2, this._uintid = t2;
          }
        }
        var DP = eg, PP = rm;
        kn({ target: "Promise", stat: true, forced: true }, { withResolvers: function() {
          var e2 = PP.f(this);
          return { promise: e2.promise, resolve: e2.resolve, reject: e2.reject };
        } });
        var LP = rm, kP = FE;
        kn({ target: "Promise", stat: true, forced: true }, { try: function(e2) {
          var t2 = LP.f(this), i2 = kP(e2);
          return (i2.error ? t2.reject : t2.resolve)(i2.value), t2.promise;
        } });
        var MP = J(DP), UP = Fo.f("asyncIterator"), xP = J(UP);
        function VP(e2, t2) {
          this.v = e2, this.k = t2;
        }
        function FP(e2) {
          var t2, i2;
          function n2(t3, i3) {
            try {
              var s2 = e2[t3](i3), o2 = s2.value, a2 = o2 instanceof VP;
              MP.resolve(a2 ? o2.v : o2).then(function(i4) {
                if (a2) {
                  var c2 = "return" === t3 ? "return" : "next";
                  if (!o2.k || i4.done)
                    return n2(c2, i4);
                  i4 = e2[c2](i4).value;
                }
                r2(s2.done ? "return" : "normal", i4);
              }, function(e3) {
                n2("throw", e3);
              });
            } catch (e3) {
              r2("throw", e3);
            }
          }
          function r2(e3, r3) {
            switch (e3) {
              case "return":
                t2.resolve({ value: r3, done: true });
                break;
              case "throw":
                t2.reject(r3);
                break;
              default:
                t2.resolve({ value: r3, done: false });
            }
            (t2 = t2.next) ? n2(t2.key, t2.arg) : i2 = null;
          }
          this._invoke = function(e3, r3) {
            return new MP(function(s2, o2) {
              var a2 = { key: e3, arg: r3, resolve: s2, reject: o2, next: null };
              i2 ? i2 = i2.next = a2 : (t2 = i2 = a2, n2(e3, r3));
            });
          }, "function" != typeof e2.return && (this.return = void 0);
        }
        function BP(e2) {
          return function() {
            return new FP(e2.apply(this, arguments));
          };
        }
        function jP(e2) {
          return new VP(e2, 0);
        }
        function GP(e2) {
          var t2 = {}, i2 = false;
          function n2(t3, n3) {
            return i2 = true, { done: false, value: new VP(n3 = new MP(function(i3) {
              i3(e2[t3](n3));
            }), 1) };
          }
          return t2[void 0 !== Uh && $h || "@@iterator"] = function() {
            return this;
          }, t2.next = function(e3) {
            return i2 ? (i2 = false, e3) : n2("next", e3);
          }, "function" == typeof e2.throw && (t2.throw = function(e3) {
            if (i2)
              throw i2 = false, e3;
            return n2("throw", e3);
          }), "function" == typeof e2.return && (t2.return = function(e3) {
            return i2 ? (i2 = false, e3) : n2("return", e3);
          }), t2;
        }
        FP.prototype["function" == typeof Uh && xP || "@@asyncIterator"] = function() {
          return this;
        }, FP.prototype.next = function(e2) {
          return this._invoke("next", e2);
        }, FP.prototype.throw = function(e2) {
          return this._invoke("throw", e2);
        }, FP.prototype.return = function(e2) {
          return this._invoke("return", e2);
        };
        var WP = J(UP), HP = { exports: {} };
        !function(e2, t2) {
          e2.exports = (() => {
            var e3 = { 8: (e4, t4, i3) => {
              i3.r(t4), i3.d(t4, { Parser: () => C2, Printer: () => b2, parse: () => D2, print: () => P2 });
              const n2 = "\n", r2 = "".concat("\r").concat(n2), s2 = " ";
              let o2;
              function a2(e5) {
                return e5 >= "0" && e5 <= "9";
              }
              function c2(e5) {
                return e5 >= "!" && e5 <= "~";
              }
              function d2(e5) {
                return c2(e5) || e5 >= "\x80" && e5 <= "\xFF";
              }
              function l2(e5) {
                return "!" === e5 || e5 >= "#" && e5 <= "'" || e5 >= "*" && e5 <= "+" || e5 >= "-" && e5 <= "." || e5 >= "0" && e5 <= "9" || e5 >= "A" && e5 <= "Z" || e5 >= "^" && e5 <= "~";
              }
              function h2(e5) {
                return e5 >= "1" && e5 <= "9";
              }
              function u2(e5) {
                return e5 >= "A" && e5 <= "Z" || e5 >= "a" && e5 <= "z";
              }
              function p2(e5) {
                return "d" === e5 || "h" === e5 || "m" === e5 || "s" === e5;
              }
              function _2(e5) {
                return e5 > "" && e5 < "	" || e5 > "\v" && e5 < "\f" || e5 > "" && e5 < "\xFF";
              }
              function E2(e5) {
                return u2(e5) || a2(e5) || "+" === e5 || "/" === e5;
              }
              function m2(e5) {
                return a2(e5) || u2(e5) || "+" === e5 || "/" === e5 || "-" === e5 || "_" === e5;
              }
              function f2(e5) {
                return u2(e5) || a2(e5) || "+" === e5 || "/" === e5;
              }
              function g2(e5, t5) {
                var i4 = Object.keys(e5);
                if (Object.getOwnPropertySymbols) {
                  var n3 = Object.getOwnPropertySymbols(e5);
                  t5 && (n3 = n3.filter(function(t6) {
                    return Object.getOwnPropertyDescriptor(e5, t6).enumerable;
                  })), i4.push.apply(i4, n3);
                }
                return i4;
              }
              function T2(e5) {
                for (var t5 = 1; t5 < arguments.length; t5++) {
                  var i4 = null != arguments[t5] ? arguments[t5] : {};
                  t5 % 2 ? g2(Object(i4), true).forEach(function(t6) {
                    S2(e5, t6, i4[t6]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i4)) : g2(Object(i4)).forEach(function(t6) {
                    Object.defineProperty(e5, t6, Object.getOwnPropertyDescriptor(i4, t6));
                  });
                }
                return e5;
              }
              function S2(e5, t5, i4) {
                return t5 in e5 ? Object.defineProperty(e5, t5, { value: i4, enumerable: true, configurable: true, writable: true }) : e5[t5] = i4, e5;
              }
              !function(e5) {
                e5.VERSION = "v", e5.ORIGIN = "o", e5.SESSION_NAME = "s", e5.INFORMATION = "i", e5.URI = "u", e5.EMAIL = "e", e5.PHONE = "p", e5.CONNECTION = "c", e5.BANDWIDTH = "b", e5.TIME = "t", e5.REPEAT = "r", e5.ZONE_ADJUSTMENTS = "z", e5.KEY = "k", e5.ATTRIBUTE = "a", e5.MEDIA = "m";
              }(o2 || (o2 = {}));
              class R2 {
                consumeText(e5, t5) {
                  let i4 = t5;
                  for (; i4 < e5.length; ) {
                    const t6 = e5[i4];
                    if ("\0" === t6 || "\r" === t6 || t6 === n2)
                      break;
                    i4 += 1;
                  }
                  if (i4 - t5 == 0)
                    throw new Error("Invalid text, at ".concat(e5));
                  return i4;
                }
                consumeUnicastAddress(e5, t5, i4) {
                  return this.consumeTill(e5, t5, s2);
                }
                consumeOneOrMore(e5, t5, i4) {
                  let n3 = t5;
                  for (; i4(e5[n3]); )
                    n3++;
                  if (n3 - t5 == 0)
                    throw new Error("Invalid rule at ".concat(t5, "."));
                  return n3;
                }
                consumeSpace(e5, t5) {
                  if (e5[t5] === s2)
                    return t5 + 1;
                  throw new Error("Invalid space at ".concat(t5, "."));
                }
                consumeIP4Address(e5, t5) {
                  let i4 = t5;
                  for (let t6 = 0; t6 < 4; t6++)
                    if (i4 = this.consumeDecimalUChar(e5, i4), 3 !== t6) {
                      if ("." !== e5[i4])
                        throw new Error("Invalid IP4 address.");
                      i4++;
                    }
                  return i4;
                }
                consumeDecimalUChar(e5, t5) {
                  let i4 = t5;
                  for (let t6 = 0; t6 < 3 && a2(e5[i4]); t6++, i4++)
                    ;
                  if (i4 - t5 == 0)
                    throw new Error("Invalid decimal uchar.");
                  const n3 = parseInt(e5.slice(t5, i4));
                  if (n3 >= 0 && n3 <= 255)
                    return i4;
                  throw new Error("Invalid decimal uchar");
                }
                consumeIP6Address(e5, t5) {
                  let i4 = this.consumeHexpart(e5, t5);
                  return ":" === e5[i4] ? (i4 += 1, i4 = this.consumeIP4Address(e5, i4), i4) : i4;
                }
                consumeHexpart(e5, t5) {
                  let i4 = t5;
                  if (":" === e5[i4] && ":" === e5[i4 + 1]) {
                    i4 += 2;
                    try {
                      i4 = this.consumeHexseq(e5, i4);
                    } catch (e6) {
                    }
                    return i4;
                  }
                  if (i4 = this.consumeHexseq(e5, i4), ":" === e5[i4] && ":" === e5[i4 + 1]) {
                    i4 += 2;
                    try {
                      i4 = this.consumeHexseq(e5, i4);
                    } catch (e6) {
                    }
                    return i4;
                  }
                  return i4;
                }
                consumeHexseq(e5, t5) {
                  let i4 = t5;
                  for (; i4 = this.consumeHex4(e5, i4), ":" === e5[i4] && ":" !== e5[i4 + 1]; )
                    i4 += 1;
                  return i4;
                }
                consumeHex4(e5, t5) {
                  let i4 = 0;
                  for (; i4 < 4; i4++)
                    if (!((n3 = e5[t5 + i4]) >= "0" && n3 <= "9" || n3 >= "a" && n3 <= "f" || n3 >= "A" && n3 <= "F")) {
                      if (0 === i4)
                        throw new Error("Invalid hex 4");
                      break;
                    }
                  var n3;
                  return t5 + i4;
                }
                consumeFQDN(e5, t5) {
                  let i4 = t5;
                  for (; a2(e5[i4]) || u2(e5[i4]) || "-" === e5[i4] || "." === e5[i4]; )
                    i4 += 1;
                  if (i4 - t5 < 4)
                    throw new Error("Invalid FQDN");
                  return i4;
                }
                consumeExtnAddr(e5, t5) {
                  return this.consumeOneOrMore(e5, t5, d2);
                }
                consumeMulticastAddress(e5, t5, i4) {
                  switch (i4) {
                    case "IP4":
                    case "ip4":
                      return this.consumeIP4MulticastAddress(e5, t5);
                    case "IP6":
                    case "ip6":
                      return this.consumeIP6MulticastAddress(e5, t5);
                    default:
                      try {
                        return this.consumeFQDN(e5, t5);
                      } catch (i5) {
                        return this.consumeExtnAddr(e5, t5);
                      }
                  }
                }
                consumeIP6MulticastAddress(e5, t5) {
                  const i4 = this.consumeHexpart(e5, t5);
                  return "/" === e5[i4] ? this.consumeInteger(e5, i4 + 1) : i4;
                }
                consumeIP4MulticastAddress(e5, t5) {
                  let i4 = t5 + 3;
                  const n3 = e5.slice(t5, i4), r3 = parseInt(n3);
                  if (r3 < 224 || r3 > 239)
                    throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
                  for (let t6 = 0; t6 < 3; t6++) {
                    if ("." !== e5[i4])
                      throw new Error("Invalid IP4 multicast address.");
                    i4 += 1, i4 = this.consumeDecimalUChar(e5, i4);
                  }
                  return "/" === e5[i4] && (i4 += 1), i4 = this.consumeTTL(e5, i4), "/" === e5[i4] && (i4 = this.consumeInteger(e5, i4)), i4;
                }
                consumeInteger(e5, t5) {
                  if (!h2(e5[t5]))
                    throw new Error("Invalid integer.");
                  for (t5 += 1; a2(e5[t5]); )
                    t5 += 1;
                  return t5;
                }
                consumeTTL(e5, t5) {
                  if ("0" === e5[t5])
                    return t5 + 1;
                  if (!h2(e5[t5]))
                    throw new Error("Invalid TTL.");
                  t5 += 1;
                  for (let i4 = 0; i4 < 2 && a2(e5[t5]); i4++)
                    t5 += 1;
                  return t5;
                }
                consumeToken(e5, t5) {
                  return this.consumeOneOrMore(e5, t5, l2);
                }
                consumeTime(e5, t5) {
                  let i4 = t5;
                  if ("0" === e5[i4])
                    return i4 + 1;
                  for (h2(e5[i4]) && (i4 += 1); a2(e5[i4]); )
                    i4++;
                  if (i4 - t5 < 10)
                    throw new Error("Invalid time");
                  return i4;
                }
                consumeAddress(e5, t5) {
                  return this.consumeTill(e5, t5, s2);
                }
                consumeTypedTime(e5, t5) {
                  let i4 = t5;
                  return i4 = this.consumeOneOrMore(e5, i4, a2), p2(e5[i4]) ? i4 + 1 : i4;
                }
                consumeRepeatInterval(e5, t5) {
                  if (!h2(e5[t5]))
                    throw new Error("Invalid repeat interval");
                  for (t5 += 1; a2(e5[t5]); )
                    t5 += 1;
                  return p2(e5[t5]) && (t5 += 1), t5;
                }
                consumePort(e5, t5) {
                  return this.consumeOneOrMore(e5, t5, a2);
                }
                consume(e5, t5, i4) {
                  for (let n3 = 0; n3 < i4.length; n3++) {
                    if (t5 + n3 >= e5.length)
                      throw new Error("consume exceeding value length");
                    if (e5[t5 + n3] !== i4[n3])
                      throw new Error("consume ".concat(i4, " failed at ").concat(n3));
                  }
                  return t5 + i4.length;
                }
                consumeTill(e5, t5, i4) {
                  let n3 = t5;
                  for (; n3 < e5.length && ("string" != typeof i4 || e5[n3] !== i4) && ("function" != typeof i4 || !i4(e5[n3])); )
                    n3++;
                  return n3;
                }
              }
              class C2 extends R2 {
                constructor() {
                  super(), S2(this, "records", []), S2(this, "currentLine", 0);
                }
                parse(e5) {
                  const t5 = this.probeEOL(e5);
                  this.records = e5.split(t5).filter((e6) => !!e6.trim()).map(this.parseLine), this.currentLine = 0;
                  const i4 = this.parseVersion(), n3 = this.parseOrigin(), r3 = this.parseSessionName(), s3 = this.parseInformation(), o3 = this.parseUri(), a3 = this.parseEmail(), c3 = this.parsePhone(), d3 = this.parseConnection(), l3 = this.parseBandWidth(), h3 = this.parseTimeFields(), u3 = this.parseKey(), p3 = this.parseSessionAttribute(), _3 = this.parseMediaDescription();
                  if (this.currentLine !== this.records.length)
                    throw new Error("parsing failed, non exhaustive sdp lines.");
                  return { version: i4, origin: n3, sessionName: r3, information: s3, uri: o3, emails: a3, phones: c3, connection: d3, bandwidths: l3, timeFields: h3, key: u3, attributes: p3, mediaDescriptions: _3 };
                }
                getCurrentRecord() {
                  const e5 = this.records[this.currentLine];
                  if (!e5)
                    throw new Error("Record doesn't exit.");
                  return e5;
                }
                probeEOL(e5) {
                  for (let t5 = 0; t5 < e5.length; t5++)
                    if (e5[t5] === n2)
                      return "\r" === e5[t5 - 1] ? r2 : n2;
                  throw new Error("Invalid newline character.");
                }
                parseLine(e5, t5) {
                  if (e5.length < 2)
                    throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
                  const i4 = e5[0];
                  if ("=" !== e5[1])
                    throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
                  return { type: i4, value: e5.slice(2), line: t5, cur: 0 };
                }
                parseSessionAttribute() {
                  const e5 = new I2();
                  for (; this.currentLine < this.records.length; ) {
                    const t5 = this.getCurrentRecord();
                    if (t5.type !== o2.ATTRIBUTE)
                      break;
                    const i4 = { attField: this.extractOneOrMore(t5, (e6) => l2(e6) && ":" !== e6), _cur: 0 };
                    ":" === t5.value[t5.cur] && (t5.cur += 1, i4.attValue = this.extractOneOrMore(t5, _2)), e5.parse(i4), this.currentLine++;
                  }
                  return e5.digest();
                }
                parseMediaAttributes(e5) {
                  const t5 = new y2(e5);
                  for (; this.currentLine < this.records.length; ) {
                    const e6 = this.getCurrentRecord();
                    if (e6.type !== o2.ATTRIBUTE)
                      break;
                    const i4 = { attField: this.extractOneOrMore(e6, (e7) => l2(e7) && ":" !== e7), _cur: 0 };
                    ":" === e6.value[e6.cur] && (e6.cur += 1, i4.attValue = this.extractOneOrMore(e6, _2)), t5.parse(i4), this.currentLine++;
                  }
                  return t5.digest();
                }
                parseKey() {
                  const e5 = this.getCurrentRecord();
                  if (e5.type === o2.KEY) {
                    if ("prompt" === e5.value || "clear:" === e5.value || "base64:" === e5.value || "uri:" === e5.value)
                      return e5.value;
                    throw this.currentLine++, new Error("Invalid key.");
                  }
                }
                parseZone() {
                  const e5 = this.getCurrentRecord();
                  if (e5.type === o2.ZONE_ADJUSTMENTS) {
                    const t5 = [];
                    for (; ; )
                      try {
                        const i4 = this.extract(e5, this.consumeTime);
                        this.consumeSpaceForRecord(e5);
                        let n3 = false;
                        "-" === e5.value[e5.cur] && (n3 = true, e5.cur += 1);
                        const r3 = this.extract(e5, this.consumeTypedTime);
                        t5.push({ time: i4, typedTime: r3, back: n3 });
                      } catch (e6) {
                        break;
                      }
                    if (0 === t5.length)
                      throw new Error("Invalid zone adjustments");
                    return this.currentLine++, t5;
                  }
                  return [];
                }
                parseRepeat() {
                  const e5 = [];
                  for (; ; ) {
                    const t5 = this.getCurrentRecord();
                    if (t5.type !== o2.REPEAT)
                      break;
                    {
                      const i4 = this.extract(t5, this.consumeRepeatInterval), n3 = this.parseTypedTime(t5);
                      e5.push({ repeatInterval: i4, typedTimes: n3 }), this.currentLine++;
                    }
                  }
                  return e5;
                }
                parseTypedTime(e5) {
                  const t5 = [];
                  for (; ; )
                    try {
                      this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeTypedTime));
                    } catch (e6) {
                      break;
                    }
                  if (0 === t5.length)
                    throw new Error("Invalid typed time.");
                  return t5;
                }
                parseTime() {
                  const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeTime);
                  this.consumeSpaceForRecord(e5);
                  const i4 = this.extract(e5, this.consumeTime);
                  return this.currentLine++, { startTime: t5, stopTime: i4 };
                }
                parseBandWidth() {
                  const e5 = [];
                  for (; this.currentLine < this.records.length; ) {
                    const t5 = this.getCurrentRecord();
                    if (t5.type !== o2.BANDWIDTH)
                      break;
                    {
                      const i4 = this.extractOneOrMore(t5, l2);
                      if (":" !== t5.value[t5.cur])
                        throw new Error("Invalid bandwidth field.");
                      t5.cur++;
                      const n3 = this.extractOneOrMore(t5, a2);
                      e5.push({ bwtype: i4, bandwidth: n3 }), this.currentLine++;
                    }
                  }
                  return e5;
                }
                parseVersion() {
                  const e5 = this.getCurrentRecord();
                  if (e5.type !== o2.VERSION)
                    throw new Error("first sdp record must be version");
                  const t5 = e5.value.slice(0, this.consumeOneOrMore(e5.value, 0, a2));
                  if (t5.length !== e5.value.length)
                    throw new Error('invalid proto version, "v='.concat(e5.value, '"'));
                  return this.currentLine++, t5;
                }
                parseOrigin() {
                  const e5 = this.getCurrentRecord();
                  if (e5.type !== o2.ORIGIN)
                    throw new Error("second line of sdp must be origin");
                  const t5 = this.extractOneOrMore(e5, d2);
                  this.consumeSpaceForRecord(e5);
                  const i4 = this.extractOneOrMore(e5, a2);
                  this.consumeSpaceForRecord(e5);
                  const n3 = this.extractOneOrMore(e5, a2);
                  this.consumeSpaceForRecord(e5);
                  const r3 = this.extractOneOrMore(e5, l2);
                  this.consumeSpaceForRecord(e5);
                  const s3 = this.extractOneOrMore(e5, l2);
                  this.consumeSpaceForRecord(e5);
                  const c3 = this.extract(e5, this.consumeUnicastAddress);
                  return this.currentLine++, { username: t5, sessId: i4, sessVersion: n3, nettype: r3, addrtype: s3, unicastAddress: c3 };
                }
                parseSessionName() {
                  const e5 = this.getCurrentRecord();
                  if (e5.type === o2.SESSION_NAME) {
                    const t5 = this.extract(e5, this.consumeText);
                    return this.currentLine++, t5;
                  }
                }
                parseInformation() {
                  const e5 = this.getCurrentRecord();
                  if (e5.type !== o2.INFORMATION)
                    return;
                  const t5 = this.extract(e5, this.consumeText);
                  return this.currentLine++, t5;
                }
                parseUri() {
                  const e5 = this.getCurrentRecord();
                  if (e5.type === o2.URI)
                    return this.currentLine++, e5.value;
                }
                parseEmail() {
                  const e5 = [];
                  for (; ; ) {
                    const t5 = this.getCurrentRecord();
                    if (t5.type !== o2.EMAIL)
                      break;
                    e5.push(t5.value), this.currentLine++;
                  }
                  return e5;
                }
                parsePhone() {
                  const e5 = [];
                  for (; ; ) {
                    const t5 = this.getCurrentRecord();
                    if (t5.type !== o2.PHONE)
                      break;
                    e5.push(t5.value), this.currentLine++;
                  }
                  return e5;
                }
                parseConnection() {
                  const e5 = this.getCurrentRecord();
                  if (e5.type === o2.CONNECTION) {
                    const t5 = this.extractOneOrMore(e5, l2);
                    this.consumeSpaceForRecord(e5);
                    const i4 = this.extractOneOrMore(e5, l2);
                    this.consumeSpaceForRecord(e5);
                    const n3 = this.extract(e5, this.consumeAddress);
                    return this.currentLine++, { nettype: t5, addrtype: i4, address: n3 };
                  }
                }
                parseMedia() {
                  const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeToken);
                  this.consumeSpaceForRecord(e5);
                  let i4 = this.extract(e5, this.consumePort);
                  "/" === e5.value[e5.cur] && (e5.cur += 1, i4 += this.extract(e5, this.consumeInteger)), this.consumeSpaceForRecord(e5);
                  const n3 = [];
                  for (n3.push(this.extract(e5, this.consumeToken)); "/" === e5.value[e5.cur]; )
                    e5.cur += 1, n3.push(this.extract(e5, this.consumeToken));
                  if (0 === n3.length)
                    throw new Error("Invalid proto");
                  const r3 = this.parseFmt(e5);
                  return this.currentLine++, { mediaType: t5, port: i4, protos: n3, fmts: r3 };
                }
                parseTimeFields() {
                  const e5 = [];
                  for (; this.getCurrentRecord().type === o2.TIME; ) {
                    const t5 = this.parseTime(), i4 = this.parseRepeat(), n3 = this.parseZone();
                    e5.push({ time: t5, repeats: i4, zones: n3 });
                  }
                  return e5;
                }
                parseMediaDescription() {
                  const e5 = [];
                  for (; this.currentLine < this.records.length && this.getCurrentRecord().type === o2.MEDIA; ) {
                    const t5 = this.parseMedia(), i4 = this.parseInformation(), n3 = this.parseConnections(), r3 = this.parseBandWidth(), s3 = this.parseKey(), o3 = this.parseMediaAttributes(t5);
                    e5.push({ media: t5, information: i4, connections: n3, bandwidths: r3, key: s3, attributes: o3 });
                  }
                  return e5;
                }
                parseConnections() {
                  const e5 = [];
                  for (; this.currentLine < this.records.length && this.getCurrentRecord().type === o2.CONNECTION; )
                    e5.push(this.parseConnection());
                  return e5;
                }
                parseFmt(e5) {
                  const t5 = [];
                  for (; ; )
                    try {
                      this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeToken));
                    } catch (e6) {
                      break;
                    }
                  if (0 === t5.length)
                    throw new Error("Invalid fmts");
                  return t5;
                }
                extract(e5, t5, ...i4) {
                  const n3 = t5.call(this, e5.value, e5.cur, ...i4), r3 = e5.value.slice(e5.cur, n3);
                  return e5.cur = n3, r3;
                }
                extractOneOrMore(e5, t5) {
                  const i4 = this.consumeOneOrMore(e5.value, e5.cur, t5), n3 = e5.value.slice(e5.cur, i4);
                  return e5.cur = i4, n3;
                }
                consumeSpaceForRecord(e5) {
                  if (e5.value[e5.cur] !== s2)
                    throw new Error("Invalid space at ".concat(e5.cur, "."));
                  e5.cur += 1;
                }
              }
              class v2 extends R2 {
                constructor(...e5) {
                  super(...e5), S2(this, "attributes", void 0), S2(this, "digested", false);
                }
                extractOneOrMore(e5, t5, i4) {
                  const n3 = this.consumeOneOrMore(e5.attValue, e5._cur, t5), r3 = e5.attValue.slice(e5._cur, n3), [s3, o3] = i4 || [];
                  if ("number" == typeof s3 && r3.length < s3)
                    throw new Error("error in length, should be more or equal than ".concat(s3, " characters."));
                  if ("number" == typeof o3 && r3.length > o3)
                    throw new Error("error in length, should be less or equal than ".concat(o3, " characters."));
                  return e5._cur = n3, r3;
                }
                consumeAttributeSpace(e5) {
                  if (e5.attValue[e5._cur] !== s2)
                    throw new Error("Invalid space at ".concat(e5._cur, "."));
                  e5._cur += 1;
                }
                extract(e5, t5, ...i4) {
                  if (!e5.attValue)
                    throw new Error("Nothing to extract from attValue.");
                  const n3 = t5.call(this, e5.attValue, e5._cur, ...i4), r3 = e5.attValue.slice(e5._cur, n3);
                  return e5._cur = n3, r3;
                }
                atEnd(e5) {
                  if (!e5.attValue)
                    throw new Error();
                  return e5._cur >= e5.attValue.length;
                }
                peekChar(e5) {
                  if (!e5.attValue)
                    throw new Error();
                  return e5.attValue[e5._cur];
                }
                peek(e5, t5) {
                  if (!e5.attValue)
                    throw new Error();
                  for (let i4 = 0; i4 < t5.length; i4++)
                    if (t5[i4] !== e5.attValue[e5._cur + i4])
                      return false;
                  return true;
                }
                parseIceUfrag(e5) {
                  if (this.attributes.iceUfrag)
                    throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
                  this.attributes.iceUfrag = this.extractOneOrMore(e5, E2, [4, 256]);
                }
                parseIcePwd(e5) {
                  if (this.attributes.icePwd)
                    throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
                  this.attributes.icePwd = this.extractOneOrMore(e5, E2, [22, 256]);
                }
                parseIceOptions(e5) {
                  if (this.attributes.iceOptions)
                    throw new Error("Invalid ice-options, should be only one 'ice-options' line");
                  const t5 = [];
                  for (; !this.atEnd(e5); ) {
                    t5.push(this.extractOneOrMore(e5, E2));
                    try {
                      this.consumeAttributeSpace(e5);
                    } catch (t6) {
                      if (this.atEnd(e5))
                        break;
                      throw t6;
                    }
                  }
                  this.attributes.iceOptions = t5;
                }
                parseFingerprint(e5) {
                  const t5 = this.extract(e5, this.consumeToken);
                  this.consumeAttributeSpace(e5);
                  const i4 = this.extract(e5, this.consumeTill);
                  this.attributes.fingerprints.push({ hashFunction: t5, fingerprint: i4 });
                }
                parseExtmap(e5) {
                  const t5 = this.extractOneOrMore(e5, a2);
                  let i4;
                  "/" === this.peekChar(e5) && (this.extract(e5, this.consume, "/"), i4 = this.extract(e5, this.consumeToken)), this.consumeAttributeSpace(e5);
                  const n3 = this.extract(e5, this.consumeTill, s2), r3 = T2(T2({ entry: parseInt(t5, 10) }, i4 && { direction: i4 }), {}, { extensionName: n3 });
                  this.peekChar(e5) === s2 && (this.consumeAttributeSpace(e5), r3.extensionAttributes = this.extract(e5, this.consumeTill)), this.attributes.extmaps.push(r3);
                }
                parseSetup(e5) {
                  if (this.attributes.setup)
                    throw new Error("must only be one single 'a=setup' line.");
                  const t5 = this.extract(e5, this.consumeTill);
                  if ("active" !== t5 && "passive" !== t5 && "actpass" !== t5 && "holdconn" !== t5)
                    throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
                  this.attributes.setup = t5;
                }
              }
              class I2 extends v2 {
                constructor(...e5) {
                  super(...e5), S2(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
                }
                parse(e5) {
                  if (this.digested)
                    throw new Error("already digested");
                  try {
                    switch (e5.attField) {
                      case "group":
                        this.parseGroup(e5);
                        break;
                      case "ice-lite":
                        this.parseIceLite();
                        break;
                      case "ice-ufrag":
                        this.parseIceUfrag(e5);
                        break;
                      case "ice-pwd":
                        this.parseIcePwd(e5);
                        break;
                      case "ice-options":
                        this.parseIceOptions(e5);
                        break;
                      case "fingerprint":
                        this.parseFingerprint(e5);
                        break;
                      case "setup":
                        this.parseSetup(e5);
                        break;
                      case "tls-id":
                        this.parseTlsId(e5);
                        break;
                      case "identity":
                        this.parseIdentity(e5);
                        break;
                      case "extmap":
                        this.parseExtmap(e5);
                        break;
                      case "msid-semantic":
                        this.parseMsidSemantic(e5);
                        break;
                      default:
                        e5.ignored = true, this.attributes.unrecognized.push(e5);
                    }
                  } catch (t5) {
                    throw console.error("parsing session attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
                  }
                  if (!e5.ignored && e5.attValue && !this.atEnd(e5))
                    throw new Error("attribute parsing error");
                }
                digest() {
                  return this.digested = true, this.attributes;
                }
                parseGroup(e5) {
                  const t5 = this.extract(e5, this.consumeToken), i4 = [];
                  for (; !this.atEnd(e5) && this.peekChar(e5) === s2; )
                    this.consumeAttributeSpace(e5), i4.push(this.extract(e5, this.consumeToken));
                  this.attributes.groups.push({ semantic: t5, identificationTag: i4 });
                }
                parseIceLite() {
                  if (this.attributes.iceLite)
                    throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
                  this.attributes.iceLite = true;
                }
                parseTlsId(e5) {
                  if (this.attributes.tlsId)
                    throw new Error("must be only one tld-id line");
                  this.attributes.tlsId = this.extractOneOrMore(e5, m2);
                }
                parseIdentity(e5) {
                  const t5 = this.extractOneOrMore(e5, f2), i4 = [];
                  for (; !this.atEnd(e5) && this.peekChar(e5) === s2; ) {
                    this.consumeAttributeSpace(e5);
                    const t6 = this.extract(e5, this.consumeToken);
                    this.extract(e5, this.consume, "=");
                    const n3 = this.extractOneOrMore(e5, (e6) => e6 !== s2 && _2(e6));
                    i4.push({ name: t6, value: n3 });
                  }
                  this.attributes.identities.push({ assertionValue: t5, extensions: i4 });
                }
                parseMsidSemantic(e5) {
                  this.peekChar(e5) === s2 && this.consumeAttributeSpace(e5);
                  const t5 = { semantic: this.extract(e5, this.consumeToken), identifierList: [] };
                  for (; ; ) {
                    try {
                      this.consumeAttributeSpace(e5);
                    } catch (e6) {
                      break;
                    }
                    if ("*" === this.peekChar(e5)) {
                      this.extract(e5, this.consume, "*"), t5.applyForAll = true;
                      break;
                    }
                    {
                      const i4 = this.extract(e5, this.consumeTill, s2);
                      t5.identifierList.push(i4);
                    }
                  }
                  this.attributes.msidSemantic = t5;
                }
              }
              class y2 extends v2 {
                constructor(e5) {
                  super(), S2(this, "attributes", void 0), -1 !== e5.protos.indexOf("RTP") || e5.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
                }
                parse(e5) {
                  if (this.digested)
                    throw new Error("already digested");
                  try {
                    switch (e5.attField) {
                      case "extmap":
                        this.parseExtmap(e5);
                        break;
                      case "setup":
                        this.parseSetup(e5);
                        break;
                      case "ice-ufrag":
                        this.parseIceUfrag(e5);
                        break;
                      case "ice-pwd":
                        this.parseIcePwd(e5);
                        break;
                      case "ice-options":
                        this.parseIceOptions(e5);
                        break;
                      case "candidate":
                        this.parseCandidate(e5);
                        break;
                      case "remote-candidate":
                        this.parseRemoteCandidate(e5);
                        break;
                      case "end-of-candidates":
                        this.parseEndOfCandidates();
                        break;
                      case "fingerprint":
                        this.parseFingerprint(e5);
                        break;
                      case "rtpmap":
                        this.parseRtpmap(e5);
                        break;
                      case "ptime":
                        this.parsePtime(e5);
                        break;
                      case "maxptime":
                        this.parseMaxPtime(e5);
                        break;
                      case "sendrecv":
                      case "recvonly":
                      case "sendonly":
                      case "inactive":
                        this.parseDirection(e5);
                        break;
                      case "ssrc":
                        this.parseSSRC(e5);
                        break;
                      case "fmtp":
                        this.parseFmtp(e5);
                        break;
                      case "rtcp-fb":
                        this.parseRtcpFb(e5);
                        break;
                      case "rtcp-mux":
                        this.parseRTCPMux();
                        break;
                      case "rtcp-mux-only":
                        this.parseRTCPMuxOnly();
                        break;
                      case "rtcp-rsize":
                        this.parseRTCPRsize();
                        break;
                      case "rtcp":
                        this.parseRTCP(e5);
                        break;
                      case "mid":
                        this.parseMid(e5);
                        break;
                      case "msid":
                        this.parseMsid(e5);
                        break;
                      case "imageattr":
                        this.parseImageAttr(e5);
                        break;
                      case "rid":
                        this.parseRid(e5);
                        break;
                      case "simulcast":
                        this.parseSimulcast(e5);
                        break;
                      case "sctp-port":
                        this.parseSctpPort(e5);
                        break;
                      case "max-message-size":
                        this.parseMaxMessageSize(e5);
                        break;
                      case "ssrc-group":
                        this.parseSSRCGroup(e5);
                        break;
                      default:
                        e5.ignored = true, this.attributes.unrecognized.push(e5);
                    }
                  } catch (t5) {
                    throw console.error("parsing media attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
                  }
                  if (!e5.ignored && e5.attValue && !this.atEnd(e5))
                    throw new Error("attribute parsing error");
                }
                parseCandidate(e5) {
                  const t5 = this.extractOneOrMore(e5, E2, [1, 32]);
                  this.consumeAttributeSpace(e5);
                  const i4 = this.extractOneOrMore(e5, a2, [1, 5]);
                  this.consumeAttributeSpace(e5);
                  const n3 = this.extract(e5, this.consumeToken);
                  this.consumeAttributeSpace(e5);
                  const r3 = this.extractOneOrMore(e5, a2, [1, 10]);
                  this.consumeAttributeSpace(e5);
                  const o3 = this.extract(e5, this.consumeAddress);
                  this.consumeAttributeSpace(e5);
                  const d3 = this.extract(e5, this.consumePort);
                  this.consumeAttributeSpace(e5), this.extract(e5, this.consume, "typ"), this.consumeAttributeSpace(e5);
                  const l3 = { foundation: t5, componentId: i4, transport: n3, priority: r3, connectionAddress: o3, port: d3, type: this.extract(e5, this.consumeToken), extension: {} };
                  for (this.peek(e5, " raddr") && (this.extract(e5, this.consume, " raddr"), this.consumeAttributeSpace(e5), l3.relAddr = this.extract(e5, this.consumeAddress)), this.peek(e5, " rport") && (this.extract(e5, this.consume, " rport"), this.consumeAttributeSpace(e5), l3.relPort = this.extract(e5, this.consumePort)); this.peekChar(e5) === s2; ) {
                    this.consumeAttributeSpace(e5);
                    const t6 = this.extract(e5, this.consumeToken);
                    this.consumeAttributeSpace(e5), l3.extension[t6] = this.extractOneOrMore(e5, c2);
                  }
                  this.attributes.candidates.push(l3);
                }
                parseRemoteCandidate(e5) {
                  const t5 = [];
                  for (; ; ) {
                    const i4 = this.extractOneOrMore(e5, a2, [1, 5]);
                    this.consumeAttributeSpace(e5);
                    const n3 = this.extract(e5, this.consumeAddress);
                    this.consumeAttributeSpace(e5);
                    const r3 = this.extract(e5, this.consumePort);
                    t5.push({ componentId: i4, connectionAddress: n3, port: r3 });
                    try {
                      this.consumeAttributeSpace(e5);
                    } catch (e6) {
                      break;
                    }
                  }
                  this.attributes.remoteCandidatesList.push(t5);
                }
                parseEndOfCandidates() {
                  if (this.attributes.endOfCandidates)
                    throw new Error("must be only one line of end-of-candidates");
                  this.attributes.endOfCandidates = true;
                }
                parseRtpmap(e5) {
                  const t5 = this.extract(e5, this.consumeToken);
                  this.consumeAttributeSpace(e5);
                  const i4 = this.extract(e5, this.consumeTill, "/");
                  this.extract(e5, this.consume, "/");
                  const n3 = { encodingName: i4, clockRate: this.extractOneOrMore(e5, a2) };
                  this.atEnd(e5) || "/" !== this.peekChar(e5) || (this.extract(e5, this.consume, "/"), n3.encodingParameters = parseInt(this.extract(e5, this.consumeTill), 10));
                  const r3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                  r3 ? r3.rtpMap = n3 : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtpMap: n3, rtcpFeedbacks: [] });
                }
                parsePtime(e5) {
                  if (this.attributes.ptime)
                    throw new Error("must be only one line of ptime");
                  this.attributes.ptime = this.extract(e5, this.consumeTill);
                }
                parseMaxPtime(e5) {
                  if (this.attributes.maxPtime)
                    throw new Error("must be only one line of ptime");
                  this.attributes.maxPtime = this.extract(e5, this.consumeTill);
                }
                parseDirection(e5) {
                  if (this.attributes.direction)
                    throw new Error("must be only one line of direction info");
                  this.attributes.direction = e5.attField;
                }
                parseSSRC(e5) {
                  const t5 = this.extractOneOrMore(e5, a2);
                  this.consumeAttributeSpace(e5);
                  const i4 = this.extract(e5, this.consumeTill, ":");
                  let n3;
                  ":" === this.peekChar(e5) && (this.extract(e5, this.consume, ":"), n3 = this.extract(e5, this.consumeTill));
                  const r3 = this.attributes.ssrcs.find((e6) => e6.ssrcId === parseInt(t5, 10));
                  r3 ? r3.attributes[i4] = n3 : this.attributes.ssrcs.push({ ssrcId: parseInt(t5, 10), attributes: { [i4]: n3 } });
                }
                parseFmtp(e5) {
                  const t5 = this.extract(e5, this.consumeTill, s2);
                  this.consumeAttributeSpace(e5);
                  const i4 = this.extract(e5, this.consumeTill), n3 = {};
                  i4.split(";").forEach((e6) => {
                    let [t6, i5] = e6.split("=");
                    t6 = t6.trim();
                    const r4 = "string" == typeof i5 ? i5.trim() : null;
                    "string" == typeof t6 && t6.length > 0 && (n3[t6] = r4);
                  });
                  const r3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                  r3 ? r3.fmtp = { parameters: n3 } : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [], fmtp: { parameters: n3 } });
                }
                parseFmtParameters(e5) {
                  const t5 = {}, i4 = this.extract(e5, this.consumeTill, "=");
                  e5._cur++;
                  const n3 = this.extract(e5, this.consumeTill, ";");
                  for (t5[i4] = n3; ";" === e5.attValue[e5._cur]; ) {
                    const i5 = this.extract(e5, this.consumeTill, "=");
                    e5._cur++;
                    const n4 = this.extract(e5, this.consumeTill, ";");
                    t5[i5] = n4;
                  }
                  return t5;
                }
                parseRtcpFb(e5) {
                  let t5 = "";
                  t5 = "*" === this.peekChar(e5) ? this.extract(e5, this.consume, "*") : this.extract(e5, this.consumeTill, s2), this.consumeAttributeSpace(e5);
                  const i4 = this.extract(e5, this.consumeTill, s2);
                  let n3;
                  if ("trr-int" === i4)
                    n3 = { type: i4, interval: this.extract(e5, this.consumeTill) };
                  else {
                    const t6 = { type: i4 };
                    this.peekChar(e5) === s2 && (this.consumeAttributeSpace(e5), t6.parameter = this.extract(e5, this.consumeToken), this.peekChar(e5) === s2 && (t6.additional = this.extract(e5, this.consumeTill))), n3 = t6;
                  }
                  if ("*" === t5)
                    this.attributes.rtcpFeedbackWildcards.push(n3);
                  else {
                    const e6 = this.attributes.payloads.find((e7) => e7.payloadType === parseInt(t5, 10));
                    e6 ? e6.rtcpFeedbacks.push(n3) : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [n3] });
                  }
                }
                parseRTCPMux() {
                  if (this.attributes.rtcpMux)
                    throw new Error("must be single line of rtcp-mux");
                  this.attributes.rtcpMux = true;
                }
                parseRTCPMuxOnly() {
                  if (this.attributes.rtcpMuxOnly)
                    throw new Error("must be single line of rtcp-only");
                  this.attributes.rtcpMuxOnly = true;
                }
                parseRTCPRsize() {
                  if (this.attributes.rtcpRsize)
                    throw new Error("must be single line of rtcp-rsize");
                  this.attributes.rtcpRsize = true;
                }
                parseRTCP(e5) {
                  if (this.attributes.rtcp)
                    throw new Error("must be single line of rtcp");
                  const t5 = { port: this.extract(e5, this.consumePort) };
                  this.peekChar(e5) === s2 && (this.consumeAttributeSpace(e5), t5.netType = this.extractOneOrMore(e5, l2), this.consumeAttributeSpace(e5), t5.addressType = this.extractOneOrMore(e5, l2), this.consumeAttributeSpace(e5), t5.address = this.extract(e5, this.consumeAddress)), this.attributes.rtcp = t5;
                }
                parseMsid(e5) {
                  const t5 = { id: this.extractOneOrMore(e5, l2, [1, 64]) };
                  this.peekChar(e5) === s2 && (this.consumeAttributeSpace(e5), t5.appdata = this.extractOneOrMore(e5, l2, [1, 64])), this.attributes.msids.push(t5);
                }
                parseImageAttr(e5) {
                  this.attributes.imageattr.push(e5.attValue);
                }
                parseRid(e5) {
                  const t5 = this.extractOneOrMore(e5, (e6) => u2(e6) || a2(e6) || "_" === e6 || "-" === e6);
                  this.consumeAttributeSpace(e5);
                  const i4 = { id: t5, direction: this.extract(e5, this.consumeToken), params: [] };
                  if (this.peekChar(e5) === s2) {
                    if (this.consumeAttributeSpace(e5), this.peek(e5, "pt=")) {
                      this.extract(e5, this.consume, "pt=");
                      const t6 = [];
                      for (; ; ) {
                        const i5 = this.extract(e5, this.consumeToken);
                        t6.push(i5);
                        try {
                          this.extract(e5, this.consume, ",");
                        } catch (e6) {
                          break;
                        }
                      }
                      i4.payloads = t6, this.peekChar(e5) === s2 && this.extract(e5, this.consume, s2);
                    }
                    for (; ; ) {
                      const t6 = this.extract(e5, this.consumeToken);
                      switch (t6) {
                        case "depend": {
                          const n3 = { type: t6, rids: this.extract(e5, this.consume, "=").split(",") };
                          i4.params.push(n3);
                          break;
                        }
                        default: {
                          const n3 = { type: t6 };
                          "=" === this.peekChar(e5) && (this.extract(e5, this.consume, "="), n3.val = this.extract(e5, this.consumeTill, ";")), i4.params.push(n3);
                        }
                      }
                      try {
                        this.extract(e5, this.consume, ";");
                      } catch (e6) {
                        break;
                      }
                    }
                  }
                  this.attributes.rids.push(i4);
                }
                parseSimulcast(e5) {
                  if (this.attributes.simulcast)
                    throw new Error("must be single line of simulcast");
                  this.attributes.simulcast = e5.attValue, this.extract(e5, this.consumeTill);
                }
                parseSctpPort(e5) {
                  this.attributes.sctpPort = this.extractOneOrMore(e5, a2, [1, 5]);
                }
                parseMaxMessageSize(e5) {
                  this.attributes.maxMessageSize = this.extractOneOrMore(e5, a2, [1, void 0]);
                }
                digest() {
                  return this.digested = true, this.attributes;
                }
                parseMid(e5) {
                  this.attributes.mid = this.extract(e5, this.consumeToken);
                }
                parseSSRCGroup(e5) {
                  const t5 = this.extract(e5, this.consumeToken), i4 = [];
                  for (; ; )
                    try {
                      this.consumeAttributeSpace(e5);
                      const t6 = this.extract(e5, this.consumeInteger);
                      i4.push(parseInt(t6, 10));
                    } catch (e6) {
                      break;
                    }
                  this.attributes.ssrcGroups.push({ semantic: t5, ssrcIds: i4 });
                }
              }
              function A2(e5, t5, i4) {
                return t5 in e5 ? Object.defineProperty(e5, t5, { value: i4, enumerable: true, configurable: true, writable: true }) : e5[t5] = i4, e5;
              }
              class b2 {
                constructor() {
                  A2(this, "eol", r2);
                }
                print(e5, t5) {
                  let i4 = "";
                  return t5 && (this.eol = t5), i4 += this.printVersion(e5.version), i4 += this.printOrigin(e5.origin), i4 += this.printSessionName(e5.sessionName), i4 += this.printInformation(e5.information), i4 += this.printUri(e5.uri), i4 += this.printEmail(e5.emails), i4 += this.printPhone(e5.phones), i4 += this.printConnection(e5.connection), i4 += this.printBandwidth(e5.bandwidths), i4 += this.printTimeFields(e5.timeFields), i4 += this.printKey(e5.key), i4 += this.printSessionAttributes(e5.attributes), i4 += this.printMediaDescription(e5.mediaDescriptions), i4;
                }
                printVersion(e5) {
                  return "v=".concat(e5).concat(this.eol);
                }
                printOrigin(e5) {
                  return "o=".concat(e5.username, " ").concat(e5.sessId, " ").concat(e5.sessVersion, " ").concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.unicastAddress).concat(this.eol);
                }
                printSessionName(e5) {
                  return e5 ? "s=".concat(e5).concat(this.eol) : "";
                }
                printInformation(e5) {
                  return e5 ? "i=".concat(e5).concat(this.eol) : "";
                }
                printUri(e5) {
                  return e5 ? "u=".concat(e5).concat(this.eol) : "";
                }
                printEmail(e5) {
                  let t5 = "";
                  for (const i4 of e5)
                    t5 += "e=".concat(i4).concat(this.eol);
                  return t5;
                }
                printPhone(e5) {
                  let t5 = "";
                  for (const i4 of e5)
                    t5 += "e=".concat(i4).concat(this.eol);
                  return t5;
                }
                printConnection(e5) {
                  return e5 ? "c=".concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.address).concat(this.eol) : "";
                }
                printBandwidth(e5) {
                  let t5 = "";
                  for (const i4 of e5)
                    t5 += "b=".concat(i4.bwtype, ":").concat(i4.bandwidth).concat(this.eol);
                  return t5;
                }
                printTimeFields(e5) {
                  let t5 = "";
                  for (const i4 of e5) {
                    t5 += "t=".concat(i4.time.startTime, " ").concat(i4.time.startTime).concat(this.eol);
                    for (const e6 of i4.repeats)
                      t5 += "r=".concat(e6.repeatInterval, " ").concat(e6.typedTimes.join(" ")).concat(this.eol);
                    i4.zoneAdjustments && (t5 += "z=", t5 += "z=".concat(i4.zoneAdjustments.map((e6) => "".concat(e6.time, " ").concat(e6.back ? "-" : "", " ").concat(e6.typedTime)).join(" ")).concat(this.eol), t5 += this.eol);
                  }
                  return t5;
                }
                printKey(e5) {
                  return e5 ? "k=".concat(e5).concat(this.eol) : "";
                }
                printAttributes(e5) {
                  let t5 = "";
                  for (const i4 of e5)
                    t5 += "a=".concat(i4.attField).concat(i4.attValue ? ":".concat(i4.attValue) : "").concat(this.eol);
                  return t5;
                }
                printMediaDescription(e5) {
                  let t5 = "";
                  for (const i4 of e5)
                    t5 += this.printMedia(i4.media), t5 += this.printInformation(i4.information), t5 += this.printConnections(i4.connections), t5 += this.printBandwidth(i4.bandwidths), t5 += this.printKey(i4.key), t5 += this.printMediaAttributes(i4);
                  return t5;
                }
                printConnections(e5) {
                  let t5 = "";
                  for (const i4 of e5)
                    t5 += this.printConnection(i4);
                  return t5;
                }
                printMedia(e5) {
                  return "m=".concat(e5.mediaType, " ").concat(e5.port, " ").concat(e5.protos.join("/"), " ").concat(e5.fmts.join(" ")).concat(this.eol);
                }
                printSessionAttributes(e5) {
                  return new O2(this.eol).print(e5);
                }
                printMediaAttributes(e5) {
                  return new N2(this.eol).print(e5);
                }
              }
              class w2 {
                constructor(e5) {
                  A2(this, "eol", void 0), this.eol = e5;
                }
                printIceUfrag(e5) {
                  return void 0 === e5 ? "" : "a=ice-ufrag:".concat(e5).concat(this.eol);
                }
                printIcePwd(e5) {
                  return void 0 === e5 ? "" : "a=ice-pwd:".concat(e5).concat(this.eol);
                }
                printIceOptions(e5) {
                  return void 0 === e5 ? "" : "a=ice-options:".concat(e5.join(s2)).concat(this.eol);
                }
                printFingerprints(e5) {
                  return e5.length > 0 ? e5.map((e6) => "a=fingerprint:".concat(e6.hashFunction).concat(s2).concat(e6.fingerprint)).join(this.eol) + this.eol : "";
                }
                printExtmap(e5) {
                  return e5.map((e6) => "a=extmap:".concat(e6.entry).concat(e6.direction ? "/".concat(e6.direction) : "").concat(s2).concat(e6.extensionName).concat(e6.extensionAttributes ? "".concat(s2).concat(e6.extensionAttributes) : "").concat(this.eol)).join("");
                }
                printSetup(e5) {
                  return void 0 === e5 ? "" : "a=setup:".concat(e5).concat(this.eol);
                }
                printUnrecognized(e5) {
                  return e5.map((e6) => "a=".concat(e6.attField).concat(e6.attValue ? ":".concat(e6.attValue) : "").concat(this.eol)).join("");
                }
              }
              class O2 extends w2 {
                print(e5) {
                  let t5 = "";
                  return t5 += this.printGroups(e5.groups), t5 += this.printMsidSemantic(e5.msidSemantic), t5 += this.printIceLite(e5.iceLite), t5 += this.printIceUfrag(e5.iceUfrag), t5 += this.printIcePwd(e5.icePwd), t5 += this.printIceOptions(e5.iceOptions), t5 += this.printFingerprints(e5.fingerprints), t5 += this.printSetup(e5.setup), t5 += this.printTlsId(e5.tlsId), t5 += this.printIdentity(e5.identities), t5 += this.printExtmap(e5.extmaps), t5 += this.printUnrecognized(e5.unrecognized), t5;
                }
                printGroups(e5) {
                  let t5 = "";
                  return e5.length > 0 && (t5 += e5.map((e6) => "a=group:".concat(e6.semantic).concat(e6.identificationTag.map((e7) => "".concat(s2).concat(e7)).join("")).concat(this.eol)).join("")), t5;
                }
                printIceLite(e5) {
                  return void 0 === e5 ? "" : "a=ice-lite" + this.eol;
                }
                printTlsId(e5) {
                  return e5 ? "a=tls-id:".concat(e5).concat(this.eol) : "";
                }
                printIdentity(e5) {
                  return 0 === e5.length ? "" : e5.map((e6) => "a=identity:".concat(e6.assertionValue).concat(e6.extensions.map((e7) => "".concat(s2).concat(e7.name).concat(e7.value ? "=".concat(e7.value) : "")))).join(this.eol) + this.eol;
                }
                printMsidSemantic(e5) {
                  if (!e5)
                    return "";
                  let t5 = "a=msid-semantic:".concat(e5.semantic);
                  return e5.applyForAll ? t5 += "".concat(s2, "*") : e5.identifierList.length > 0 && (t5 += e5.identifierList.map((e6) => "".concat(s2).concat(e6))), t5 + this.eol;
                }
              }
              class N2 extends w2 {
                print(e5) {
                  const t5 = e5.attributes;
                  let i4 = "";
                  return i4 += this.printRTCP(t5.rtcp), i4 += this.printIceUfrag(t5.iceUfrag), i4 += this.printIcePwd(t5.icePwd), i4 += this.printIceOptions(t5.iceOptions), i4 += this.printCandidates(t5.candidates), i4 += this.printRemoteCandidatesList(t5.remoteCandidatesList), i4 += this.printEndOfCandidates(t5.endOfCandidates), i4 += this.printFingerprints(t5.fingerprints), i4 += this.printSetup(t5.setup), i4 += this.printMid(t5.mid), i4 += this.printExtmap(t5.extmaps), i4 += this.printRTPRelated(t5), i4 += this.printPtime(t5.ptime), i4 += this.printMaxPtime(t5.maxPtime), i4 += this.printDirection(t5.direction), i4 += this.printSSRCGroups(t5.ssrcGroups), i4 += this.printSSRC(t5.ssrcs), i4 += this.printRTCPMux(t5.rtcpMux), i4 += this.printRTCPMuxOnly(t5.rtcpMuxOnly), i4 += this.printRTCPRsize(t5.rtcpRsize), i4 += this.printMSId(t5.msids), i4 += this.printImageattr(t5.imageattr), i4 += this.printRid(t5.rids), i4 += this.printSimulcast(t5.simulcast), i4 += this.printSCTPPort(t5.sctpPort), i4 += this.printMaxMessageSize(t5.maxMessageSize), i4 += this.printUnrecognized(t5.unrecognized), i4;
                }
                printCandidates(e5) {
                  return e5.map((e6) => "a=candidate:".concat(e6.foundation).concat(s2).concat(e6.componentId).concat(s2).concat(e6.transport).concat(s2).concat(e6.priority).concat(s2).concat(e6.connectionAddress).concat(s2).concat(e6.port).concat(s2, "typ").concat(s2).concat(e6.type).concat(e6.relAddr ? "".concat(s2, "raddr").concat(s2).concat(e6.relAddr) : "").concat(e6.relPort ? "".concat(s2, "rport").concat(s2).concat(e6.relPort) : "").concat(Object.keys(e6.extension).map((t5) => "".concat(s2).concat(t5).concat(s2).concat(e6.extension[t5])).join("")).concat(this.eol)).join("");
                }
                printRemoteCandidatesList(e5) {
                  return e5.map((e6) => "a=remote-candidates:".concat(e6.join(s2)).concat(this.eol)).join("");
                }
                printEndOfCandidates(e5) {
                  return void 0 === e5 ? "" : "a=end-of-candidates" + this.eol;
                }
                printRTPRelated(e5) {
                  if (!e5.payloads)
                    return "";
                  const t5 = e5.payloads;
                  let i4 = "";
                  i4 += e5.rtcpFeedbackWildcards.map((e6) => this.printRTCPFeedback("*", e6)).join("");
                  for (const e6 of t5)
                    i4 += this.printRtpMap(e6.payloadType, e6.rtpMap), i4 += this.printFmtp(e6.payloadType, e6.fmtp), i4 += e6.rtcpFeedbacks.map((t6) => this.printRTCPFeedback(e6.payloadType, t6)).join("");
                  return i4;
                }
                printFmtp(e5, t5) {
                  if (!t5)
                    return "";
                  const i4 = Object.keys(t5.parameters);
                  return 1 === i4.length && null === t5.parameters[i4[0]] ? "a=fmtp:".concat(e5).concat(s2).concat(i4[0]).concat(this.eol) : "a=fmtp:".concat(e5).concat(s2).concat(Object.keys(t5.parameters).map((e6) => "".concat(e6, "=").concat(t5.parameters[e6])).join(";")).concat(this.eol);
                }
                printRtpMap(e5, t5) {
                  return t5 ? "a=rtpmap:".concat(e5).concat(s2).concat(t5.encodingName, "/").concat(t5.clockRate).concat(t5.encodingParameters ? "/".concat(t5.encodingParameters) : "").concat(this.eol) : "";
                }
                printRTCPFeedback(e5, t5) {
                  let i4 = "a=rtcp-fb:".concat(e5).concat(s2), n3 = t5;
                  return "trr-int" === n3.type ? i4 += "ttr-int".concat(s2).concat(n3.interval) : (i4 += "".concat(n3.type), n3.parameter && (i4 += "".concat(s2).concat(n3.parameter), n3.additional && (i4 += "".concat(s2).concat(n3.additional)))), i4 + this.eol;
                }
                printPtime(e5) {
                  return void 0 === e5 ? "" : "a=ptime:".concat(e5).concat(this.eol);
                }
                printMaxPtime(e5) {
                  return void 0 === e5 ? "" : "a=maxptime:".concat(e5).concat(this.eol);
                }
                printDirection(e5) {
                  return void 0 === e5 ? "" : "a=".concat(e5).concat(this.eol);
                }
                printSSRC(e5) {
                  return e5.map((e6) => Object.keys(e6.attributes).map((t5) => "a=ssrc:".concat(e6.ssrcId.toString(10)).concat(s2).concat(t5).concat(e6.attributes[t5] ? ":".concat(e6.attributes[t5]) : "").concat(this.eol)).join("")).join("");
                }
                printRTCPMux(e5) {
                  return void 0 === e5 ? "" : "a=rtcp-mux".concat(this.eol);
                }
                printRTCPMuxOnly(e5) {
                  return void 0 === e5 ? "" : "a=rtcp-mux-only".concat(this.eol);
                }
                printRTCPRsize(e5) {
                  return void 0 === e5 ? "" : "a=rtcp-rsize".concat(this.eol);
                }
                printRTCP(e5) {
                  if (void 0 === e5)
                    return "";
                  let t5 = "a=rtcp:".concat(e5.port);
                  return e5.netType && (t5 += "".concat(s2).concat(e5.netType)), e5.addressType && (t5 += "".concat(s2).concat(e5.addressType)), e5.address && (t5 += "".concat(s2).concat(e5.address)), t5 + this.eol;
                }
                printMSId(e5) {
                  return e5.map((e6) => "a=msid:".concat(e6.id).concat(e6.appdata ? "".concat(s2).concat(e6.appdata) : "").concat(this.eol)).join("");
                }
                printImageattr(e5) {
                  return e5.map((e6) => "a=imageattr:".concat(e6).concat(this.eol)).join("");
                }
                printRid(e5) {
                  return e5.map((e6) => {
                    let t5 = "a=rid:".concat(e6.id).concat(s2).concat(e6.direction);
                    return e6.payloads && (t5 += "".concat(s2, "pt=").concat(e6.payloads.join(","))), e6.params.length > 0 && (t5 += "".concat(s2).concat(e6.params.map((e7) => "depend" === e7.type ? "depend=".concat(e7.rids.join(",")) : "".concat(e7.type, "=").concat(e7.val)).join(";"))), t5 + this.eol;
                  }).join("");
                }
                printSimulcast(e5) {
                  return void 0 === e5 ? "" : "a=simulcast:".concat(e5).concat(this.eol);
                }
                printSCTPPort(e5) {
                  return void 0 === e5 ? "" : "a=sctp-port:".concat(e5).concat(this.eol);
                }
                printMaxMessageSize(e5) {
                  return void 0 === e5 ? "" : "a=max-message-size:".concat(e5).concat(this.eol);
                }
                printMid(e5) {
                  return void 0 === e5 ? "" : "a=mid:".concat(e5).concat(this.eol);
                }
                printSSRCGroups(e5) {
                  return e5.map((e6) => "a=ssrc-group:".concat(e6.semantic).concat(e6.ssrcIds.map((e7) => "".concat(s2).concat(e7.toString(10))).join("")).concat(this.eol)).join("");
                }
              }
              function D2(e5) {
                return new C2().parse(e5);
              }
              function P2(e5, t5) {
                return new b2().print(e5, t5);
              }
            } }, t3 = {};
            function i2(n2) {
              if (t3[n2])
                return t3[n2].exports;
              var r2 = t3[n2] = { exports: {} };
              return e3[n2](r2, r2.exports, i2), r2.exports;
            }
            return i2.d = (e4, t4) => {
              for (var n2 in t4)
                i2.o(t4, n2) && !i2.o(e4, n2) && Object.defineProperty(e4, n2, { enumerable: true, get: t4[n2] });
            }, i2.o = (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4), i2.r = (e4) => {
              "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
            }, i2(8);
          })();
        }(HP);
        var KP = HP.exports;
        function YP(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function qP(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? YP(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : YP(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        function JP(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n2 = arguments.length > 3 ? arguments[3] : void 0;
          const { filterRTX: r2, filterVideoFec: s2, filterAudioFec: o2, filterAudioCodec: a2, filterVideoCodec: c2 } = t2, { useXR: d2 } = i2;
          let l2 = [], h2 = [], u2 = [], p2 = [], _2 = false, E2 = false;
          if (KP.parse(e2).mediaDescriptions.forEach((e3) => {
            n2 && n2 !== e3.attributes.direction || ("video" !== e3.media.mediaType || _2 || (h2 = e3.attributes.payloads, p2 = e3.attributes.extmaps, _2 = true), "audio" !== e3.media.mediaType || E2 || (l2 = e3.attributes.payloads, u2 = e3.attributes.extmaps, E2 = true));
          }), !p2 || 0 === h2.length)
            throw new Error("Cannot get video capabilities from SDP.");
          if (!u2 || 0 === l2.length)
            throw new Error("Cannot get audio capabilities from SDP.");
          h2.forEach((e3) => {
            var t3;
            null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), d2 && e3.rtcpFeedbacks.push({ type: "rrtr" });
          }), l2.forEach((e3) => {
            var t3;
            null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), d2 && e3.rtcpFeedbacks.push({ type: "rrtr" });
          }), r2 && (l2 = l2.filter((e3) => {
            var t3;
            return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
          }), h2 = h2.filter((e3) => {
            var t3;
            return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
          })), s2 && (h2 = h2.filter((e3) => {
            var t3;
            return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
          })), o2 && (l2 = l2.filter((e3) => {
            var t3;
            return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
          })), a2 && (null == a2 ? void 0 : a2.length) > 0 && (l2 = l2.filter((e3) => {
            var t3;
            return Pr(a2).call(a2, (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
          })), c2 && (null == c2 ? void 0 : c2.length) > 0 && (h2 = h2.filter((e3) => {
            var t3;
            return Pr(c2).call(c2, (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
          }));
          const m2 = kC("UNSUPPORTED_VIDEO_CODEC");
          return m2 && m2.length > 0 && (h2 = h2.filter((e3) => !(e3.rtpMap && Pr(m2).call(m2, e3.rtpMap.encodingName.toLowerCase())))), { audioCodecs: l2, videoCodecs: h2, audioExtensions: u2, videoExtensions: p2 };
        }
        function zP(e2) {
          const t2 = KP.parse(e2);
          let i2, n2;
          for (const e3 of t2.mediaDescriptions) {
            if (!i2) {
              const t3 = e3.attributes.iceUfrag, n3 = e3.attributes.icePwd;
              if (!t3 || !n3)
                throw new Error("Cannot get iceUfrag or icePwd from SDP.");
              i2 = { iceUfrag: t3, icePwd: n3 };
            }
            if (!n2) {
              const t3 = e3.attributes.fingerprints;
              t3.length > 0 && (n2 = { fingerprints: t3 });
            }
          }
          if (!n2 && t2.attributes.fingerprints.length > 0 && (n2 = { fingerprints: t2.attributes.fingerprints }), !n2 || !i2)
            throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
          return { iceParameters: i2, dtlsParameters: n2 };
        }
        function XP(e2, t2) {
          const i2 = [], n2 = e2.attributes.ssrcGroups.filter((e3) => "FID" === e3.semantic), r2 = e2.attributes.ssrcGroups.find((e3) => "SIM" === e3.semantic), s2 = e2.attributes.ssrcs;
          if (r2)
            r2.ssrcIds.forEach((e3) => {
              var r3;
              const s3 = null === (r3 = n2.find((t3) => t3.ssrcIds[0] === e3)) || void 0 === r3 ? void 0 : r3.ssrcIds[1];
              i2.push({ ssrcId: e3, rtx: t2 ? s3 : void 0 });
            });
          else if (n2.length > 0) {
            const e3 = n2[0].ssrcIds[0], r3 = n2[0].ssrcIds[1];
            i2.push({ ssrcId: e3, rtx: t2 ? r3 : void 0 });
          } else {
            if (0 === s2.length)
              throw new Error("No ssrcs found on local media description.");
            i2.push({ ssrcId: s2[0].ssrcId });
          }
          return i2;
        }
        function QP(e2, t2) {
          const { cname: i2 } = e2;
          let n2;
          t2 && t2.ip && "number" == typeof t2.port ? (n2 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2.ip, port: t2.port.toString(), type: "host", extension: {} }], KC.debug("Using remote candidate from AP ".concat(t2.ip, ":").concat(t2.port)), t2.ip6 && (n2.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2.ip6, port: t2.port.toString(), type: "host", extension: {} }), KC.debug("Using IPV6 remote candidate from AP ".concat(t2.ip6, ":").concat(t2.port)))) : n2 = e2.iceParameters.candidates.map((e3) => ({ foundation: e3.foundation, componentId: "1", transport: e3.protocol, priority: e3.priority.toString(), connectionAddress: e3.ip, port: e3.port.toString(), type: e3.type, extension: {} }));
          const r2 = { fingerprints: e2.dtlsParameters.fingerprints.map((e3) => ({ hashFunction: e3.algorithm, fingerprint: e3.fingerprint })) }, s2 = { iceUfrag: e2.iceParameters.iceUfrag, icePwd: e2.iceParameters.icePwd };
          let o2;
          switch (e2.dtlsParameters.role) {
            case "server":
              o2 = "passive";
              break;
            case "client":
              o2 = "active";
              break;
            case "auto":
              o2 = "actpass";
          }
          return { dtlsParameters: r2, iceParameters: s2, candidates: n2, rtpCapabilities: aL(e2.rtpCapabilities), setup: o2, cname: i2 };
        }
        function ZP(e2, t2, i2) {
          const n2 = [], r2 = [];
          return e2.forEach((e3) => {
            let { ssrcId: s2, rtx: o2 } = e3;
            const a2 = xT(8, "track-"), c2 = { ssrcId: s2, attributes: qP({ label: a2, mslabel: i2 = i2 || xT(10, ""), msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
            if (n2.push(c2), void 0 !== o2) {
              const e4 = { ssrcId: o2, attributes: qP({ label: a2, mslabel: i2, msid: "".concat(i2, " ").concat(a2) }, t2 && { cname: t2 }) };
              n2.push(e4), r2.push({ semantic: "FID", ssrcIds: [s2, o2] });
            }
          }), e2.length > 1 && r2.push({ semantic: "SIM", ssrcIds: e2.map((e3) => {
            let { ssrcId: t3 } = e3;
            return t3;
          }) }), { ssrcs: n2, ssrcGroups: r2 };
        }
        function $P(e2, t2) {
          t2 instanceof ZA && e2.attributes.payloads.forEach((e3) => {
            var i2;
            const n2 = null === (i2 = e3.rtpMap) || void 0 === i2 ? void 0 : i2.encodingName.toLowerCase();
            if (!n2 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n2))
              return;
            e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.minptime = "10", e3.fmtp.parameters.useinbandfec = "1";
            const r2 = t2._encoderConfig;
            r2 && "pcmu" !== n2 && "pcma" !== n2 && "g722" !== n2 && (r2.bitrate && !Rg() && (e3.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r2.bitrate))), r2.sampleRate && (e3.fmtp.parameters.maxplaybackrate = "".concat(r2.sampleRate), e3.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r2.sampleRate)), r2.stereo && (e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1"));
          });
        }
        function eL(e2) {
          const t2 = e2.attributes.unrecognized.findIndex((e3) => "x-google-flag" === e3.attField && "conference" === e3.attValue);
          -1 !== t2 && e2.attributes.unrecognized.splice(t2, 1);
        }
        function tL(e2, t2) {
          var i2;
          if (!(t2 instanceof Sb && t2._encoderConfig && -1 === t2._hints.indexOf(ky.SCREEN_TRACK)))
            return;
          const n2 = t2._encoderConfig;
          _A().supportMinBitrate && n2.bitrateMin && e2.attributes.payloads.forEach((e3) => {
            var t3, i3;
            Pr(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-min-bitrate"] = "".concat(n2.bitrateMin));
          }), _A().supportMinBitrate && !Pr(i2 = t2._hints).call(i2, ky.LOW_STREAM) && n2.bitrateMax && e2.attributes.payloads.forEach((e3) => {
            var t3, i3;
            Pr(t3 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t3, (null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-start-bitrate"] = "".concat(kC("X_GOOGLE_START_BITRATE") || Math.floor(n2.bitrateMax)));
          });
        }
        function iL(e2) {
          if ("video" !== e2.media.mediaType)
            return;
          const t2 = pg();
          if (t2.name !== cg.SAFARI && t2.os !== ag.IOS)
            return;
          const i2 = e2.attributes.extmaps.findIndex((e3) => /video-orientation/g.test(e3.extensionName));
          -1 !== i2 && e2.attributes.extmaps.splice(i2, 1);
        }
        function nL(e2, t2, i2) {
          if (!t2)
            return;
          let n2, r2;
          if ("video" === e2.media.mediaType ? (n2 = i2.videoExtensions, r2 = i2.videoCodecs) : (n2 = i2.audioExtensions, r2 = i2.audioCodecs), true === t2.twcc) {
            const t3 = n2.find((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName);
            if (t3) {
              e2.attributes.extmaps.find((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" });
              const i3 = function(e3, t4) {
                return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "transport-cc" === e5.type)));
              }(r2, e2.attributes.payloads);
              i3.forEach((e3) => {
                e3.rtcpFeedbacks.find((e4) => "transport-cc" === e4.type) || e3.rtcpFeedbacks.push({ type: "transport-cc" });
              });
            }
          } else if (false === t2.twcc) {
            const t3 = e2.attributes.extmaps.findIndex((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName);
            -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
              const t4 = e3.rtcpFeedbacks.findIndex((e4) => "transport-cc" === e4.type);
              -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
            });
          }
          if (true === t2.remb) {
            const t3 = n2.find((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName);
            if (t3) {
              e2.attributes.extmaps.find((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" });
              const i3 = function(e3, t4) {
                return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "goog-remb" === e5.type)));
              }(r2, e2.attributes.payloads);
              i3.forEach((e3) => {
                e3.rtcpFeedbacks.find((e4) => "goog-remb" === e4.type) || e3.rtcpFeedbacks.push({ type: "goog-remb" });
              });
            }
          } else if (false === t2.remb) {
            const t3 = e2.attributes.extmaps.findIndex((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName);
            -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
              const t4 = e3.rtcpFeedbacks.findIndex((e4) => "goog-remb" === e4.type);
              -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
            });
          }
        }
        function rL(e2, t2, i2) {
          if (Rg())
            return;
          if ("video" !== e2.media.mediaType)
            return;
          if (!(t2 instanceof Sb))
            return;
          if ("vp9" !== i2 && "vp8" !== i2)
            return;
          if ("vp8" === i2 && !kC("SIMULCAST"))
            return;
          if (void 0 === t2._scalabilityMode || t2._scalabilityMode.numSpatialLayers <= 1)
            return;
          const n2 = "vp8" === i2 ? 2 : t2._scalabilityMode.numSpatialLayers, r2 = e2.attributes.ssrcs[0], s2 = e2.attributes.ssrcGroups.find((e3) => "FID" === e3.semantic && e3.ssrcIds[0] === r2.ssrcId), o2 = { semantic: "SIM", ssrcIds: [r2.ssrcId] };
          for (let t3 = 1; t3 < n2; t3++)
            e2.attributes.ssrcs.push({ ssrcId: r2.ssrcId + t3, attributes: bT(r2.attributes) }), o2.ssrcIds.push(r2.ssrcId + t3), s2 && (e2.attributes.ssrcs.push({ ssrcId: s2.ssrcIds[1] + t3, attributes: bT(r2.attributes) }), e2.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r2.ssrcId + t3, s2.ssrcIds[1] + t3] }));
          e2.attributes.ssrcGroups.unshift(o2);
        }
        async function sL() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          const { filterRTX: i2, filterVideoFec: n2, filterAudioFec: r2, filterAudioCodec: s2, filterVideoCodec: o2 } = e2, { useXR: a2 } = t2, c2 = new RTCPeerConnection();
          c2.addTransceiver("video", { direction: "sendonly" }), c2.addTransceiver("audio", { direction: "sendonly" }), c2.addTransceiver("video", { direction: "recvonly" }), c2.addTransceiver("audio", { direction: "recvonly" });
          const d2 = (await c2.createOffer()).sdp, l2 = JP(d2, { filterRTX: i2, filterVideoFec: n2, filterAudioFec: r2, filterAudioCodec: s2, filterVideoCodec: o2 }, { useXR: a2 }, "sendonly"), h2 = JP(d2, { filterRTX: i2, filterVideoFec: n2, filterAudioFec: r2, filterAudioCodec: s2, filterVideoCodec: o2 }, { useXR: a2 }, "recvonly"), u2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, p2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, _2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
          if (oL(l2, h2, "videoExtensions", u2, p2, _2), oL(l2, h2, "videoCodecs", u2, p2, _2), oL(l2, h2, "audioExtensions", u2, p2, _2), oL(l2, h2, "audioCodecs", u2, p2, _2), kC("RAISE_H264_BASELINE_PRIORITY")) {
            const e3 = _2.videoCodecs.findIndex((e4) => {
              var t3, i3;
              return "h264" === (null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLocaleLowerCase()) && "42001f" === (null === (i3 = e4.fmtp) || void 0 === i3 ? void 0 : i3.parameters["profile-level-id"]);
            });
            if (-1 !== e3) {
              const t3 = _2.videoCodecs.findIndex((e4) => {
                var t4;
                return "h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase());
              });
              if (t3 < e3) {
                KC.debug("raising H264 baseline profile priority");
                const i3 = _2.videoCodecs[e3];
                _2.videoCodecs.splice(e3, 1), _2.videoCodecs.splice(t3, 0, i3);
              }
              -1 !== t3 && (p2.videoCodecs = p2.videoCodecs.filter((e4) => {
                var t4, i3;
                return !("h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i3 = e4.fmtp) || void 0 === i3 ? void 0 : i3.parameters["profile-level-id"]));
              })), -1 !== t3 && kC("FILTER_SEND_H264_BASELINE") && (u2.videoCodecs = u2.videoCodecs.filter((e4) => {
                var t4, i3;
                return !("h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i3 = e4.fmtp) || void 0 === i3 ? void 0 : i3.parameters["profile-level-id"]));
              }));
            }
          }
          try {
            c2.close();
          } catch (e3) {
          }
          return { send: u2, recv: p2, sendrecv: _2 };
        }
        function oL(e2, t2, i2, n2, r2, s2) {
          if ("videoExtensions" === i2 || "audioExtensions" === i2) {
            const o2 = [];
            return e2[i2].forEach((e3) => {
              t2[i2].some((t3, i3) => {
                if (e3.entry === t3.entry && e3.extensionName === t3.extensionName)
                  return o2.push(i3), true;
              }) ? s2[i2].push(e3) : n2[i2].push(e3);
            }), void t2[i2].forEach((e3, t3) => {
              -1 === o2.indexOf(t3) && r2[i2].push(e3);
            });
          }
          if ("videoCodecs" === i2 || "audioCodecs" === i2) {
            const o2 = [];
            return e2[i2].forEach((e3) => {
              t2[i2].some((t3, i3) => {
                if (e3.payloadType === t3.payloadType && JSON.stringify(e3) === JSON.stringify(t3))
                  return o2.push(i3), true;
              }) ? s2[i2].push(e3) : n2[i2].push(e3);
            }), void t2[i2].forEach((e3, t3) => {
              -1 === o2.indexOf(t3) && r2[i2].push(e3);
            });
          }
        }
        function aL(e2) {
          const { send: t2, recv: i2, sendrecv: n2 } = e2;
          if (!n2) {
            if (!t2 || !i2)
              throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
            return { send: t2, recv: i2 };
          }
          let r2, s2;
          return t2 ? (r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2.audioCodecs = [...t2.audioCodecs, ...n2.audioCodecs], r2.videoCodecs = [...t2.videoCodecs, ...n2.videoCodecs], r2.audioExtensions = [...t2.audioExtensions, ...n2.audioExtensions], r2.videoExtensions = [...t2.videoExtensions, ...n2.videoExtensions]) : r2 = n2, i2 ? (s2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, s2.audioCodecs = [...i2.audioCodecs, ...n2.audioCodecs], s2.videoCodecs = [...i2.videoCodecs, ...n2.videoCodecs], s2.audioExtensions = [...i2.audioExtensions, ...n2.audioExtensions], s2.videoExtensions = [...i2.videoExtensions, ...n2.videoExtensions]) : s2 = n2, { send: r2, recv: s2 };
        }
        function cL(e2) {
          if ("audio" !== e2.media.mediaType)
            return;
          e2.attributes.payloads.filter((e3) => {
            var t2;
            return "opus" === (null === (t2 = e3.rtpMap) || void 0 === t2 ? void 0 : t2.encodingName.toLowerCase());
          }).forEach((e3) => {
            e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1";
          });
        }
        function dL(e2) {
          e2.mediaDescriptions.forEach((e3) => {
            "video" !== e3.media.mediaType && "audio" !== e3.media.mediaType || e3.attributes.payloads.forEach((e4) => {
              -1 === e4.rtcpFeedbacks.findIndex((e5) => "rrtr" === e5.type) && e4.rtcpFeedbacks.push({ type: "rrtr" });
            });
          });
        }
        function lL(e2, t2, i2, n2) {
          let r2 = [];
          if (e2 === hI.VIDEO) {
            if (kC("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (r2 = t2.videoCodecs.filter((e3) => {
              var t3;
              return Pr(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, n2) && e3 && e3.fmtp && e3.fmtp.parameters["profile-level-id"] === kC("H264_PROFILE_LEVEL_ID");
            })), !Array.isArray(r2) || 0 === r2.length) {
              const e3 = i2.videoCodecs.filter((e4) => {
                var t3;
                return Pr(t3 = e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").call(t3, n2);
              });
              0 !== e3.length && (r2 = t2.videoCodecs.filter((t3) => e3.some((e4) => e4.payloadType === t3.payloadType)));
            }
            if (kC("USE_PUB_RTX")) {
              const e3 = r2.map((e4) => e4.payloadType.toString()), i3 = t2.videoCodecs.filter((t3) => t3.rtpMap && "rtx" === t3.rtpMap.encodingName && Pr(e3).call(e3, t3.fmtp && t3.fmtp.parameters.apt || ""));
              r2 = [...r2, ...i3];
            }
            0 === r2.length && (KC.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(t2.videoCodecs[0].rtpMap && t2.videoCodecs[0].rtpMap.encodingName)), r2 = t2.videoCodecs);
          } else
            r2 = t2.audioCodecs.filter((e3) => {
              var t3;
              return Pr(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, n2);
            }), 0 === r2.length && (KC.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to opus")), r2 = t2.audioCodecs.filter((e3) => {
              var t3;
              return Pr(t3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t3, "opus");
            }));
          return r2;
        }
        function hL(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function uL(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? hL(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : hL(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        function pL(e2) {
          if (Array.isArray(e2))
            return e2.map((e3) => e3);
          if (!_L(e2))
            return e2;
          const t2 = {};
          for (const i2 in e2) {
            const n2 = e2[i2];
            _L(n2) || Array.isArray(n2) ? t2[i2] = pL(n2) : t2[i2] = n2;
          }
          return t2;
        }
        function _L(e2) {
          return !("object" != typeof e2 || Array.isArray(e2) || !e2);
        }
        class EL {
          constructor(e2) {
            nu(this, "input", []), nu(this, "size", void 0), this.size = e2;
          }
          add(e2) {
            this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
          }
          diffMean() {
            return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
          }
        }
        const mL = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, fL = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: mL, remoteCandidate: mL } }, gL = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0 }, TL = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0, qpSumPerFrame: 0 }, SL = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0 }, RL = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0 };
        function CL(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function vL(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? CL(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : CL(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class IL {
          constructor(e2, t2) {
            nu(this, "onFirstVideoReceived", void 0), nu(this, "onFirstVideoDecoded", void 0), nu(this, "onFirstAudioReceived", void 0), nu(this, "onFirstVideoDecodedTimeout", void 0), nu(this, "onFirstAudioDecoded", void 0), nu(this, "onSelectedLocalCandidateChanged", void 0), nu(this, "onSelectedRemoteCandidateChanged", void 0), nu(this, "videoIsReady", false), nu(this, "videoIsReady2", {}), nu(this, "pc", void 0), nu(this, "options", void 0), nu(this, "intervalTimer", void 0), nu(this, "stats", pL(fL)), nu(this, "isFirstVideoReceived", {}), nu(this, "isFirstVideoDecoded", {}), nu(this, "isFirstAudioReceived", {}), nu(this, "isFirstAudioDecoded", {}), nu(this, "isFirstVideoDecodedTimeout", {}), nu(this, "lossRateWindowStats", []), this.pc = e2, this.options = t2, this.intervalTimer = window.setInterval(async () => {
              this.updateStats();
            }, this.options.updateInterval);
          }
          getStats() {
            return this.stats;
          }
          getSelectedCandidatePair() {
            return new tg((e2) => {
              e2({ local: vL({}, mL), remote: vL({}, mL) });
            });
          }
          setVideoIsReady(e2) {
            this.videoIsReady = e2;
          }
          setVideoIsReady2(e2, t2) {
            this.videoIsReady2[e2] = t2;
          }
          getVideoIsReady(e2) {
            return this.videoIsReady2[e2] || false;
          }
          setIsFirstAudioDecoded(e2) {
          }
          destroy() {
            window.clearInterval(this.intervalTimer), this.pc = void 0;
          }
          calcLossRate(e2) {
            this.lossRateWindowStats.push(e2), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
            const t2 = this.lossRateWindowStats.length, i2 = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
            let n2 = 0, r2 = 0, s2 = 0, o2 = 0;
            for (const a2 of i2)
              e2[a2].forEach((e3, i3) => {
                if (!this.lossRateWindowStats[t2 - 1][a2][i3] || !this.lossRateWindowStats[0][a2][i3])
                  return;
                const c2 = this.lossRateWindowStats[t2 - 1][a2][i3].packets - this.lossRateWindowStats[0][a2][i3].packets, d2 = this.lossRateWindowStats[t2 - 1][a2][i3].packetsLost - this.lossRateWindowStats[0][a2][i3].packetsLost;
                "videoSend" === a2 || "audioSend" === a2 ? (n2 += c2, s2 += d2) : (r2 += c2, o2 += d2), Number.isNaN(c2) || Number.isNaN(c2) ? e3.packetLostRate = 0 : e3.packetLostRate = c2 <= 0 || d2 <= 0 ? 0 : d2 / (c2 + d2);
              });
            e2.sendPacketLossRate = n2 <= 0 || s2 <= 0 ? 0 : s2 / (n2 + s2), e2.recvPacketLossRate = r2 <= 0 || o2 <= 0 ? 0 : o2 / (r2 + o2);
          }
        }
        function yL(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function AL(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? yL(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yL(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class bL extends IL {
          constructor() {
            super(...arguments), nu(this, "_stats", fL), nu(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
          }
          async updateStats() {
            const e2 = await this._getStats(), t2 = this.statsResponsesToObjects(e2);
            this._stats = pL(fL);
            const i2 = t2.filter((e3) => "ssrc" === e3.type);
            this.processSSRCStats(i2);
            const n2 = t2.find((e3) => "VideoBwe" === e3.type);
            n2 && this.processBandwidthStats(n2), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
          }
          processBandwidthStats(e2) {
            this._stats.bitrate = { actualEncoded: Number(e2.googActualEncBitrate), targetEncoded: Number(e2.googTargetEncBitrate), retransmit: Number(e2.googRetransmitBitrate), transmit: Number(e2.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e2.googAvailableSendBandwidth);
          }
          processSSRCStats(e2) {
            e2.forEach((e3) => {
              var t2;
              const i2 = Pr(t2 = e3.id).call(t2, "send");
              switch ("".concat(e3.mediaType, "_").concat(i2 ? "send" : "recv")) {
                case "video_send": {
                  const t3 = pL(TL);
                  t3.codec = e3.googCodecName, t3.adaptionChangeReason = "none", e3.googCpuLimitedResolution && (t3.adaptionChangeReason = "cpu"), e3.googBandwidthLimitedResolution && (t3.adaptionChangeReason = "bandwidth"), t3.avgEncodeMs = Number(e3.googAvgEncodeMs), t3.inputFrame = { width: Number(e3.googFrameWidthInput) || Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightInput) || Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.sentFrame = { width: Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.firsCount = Number(e3.googFirReceived), t3.nacksCount = Number(e3.googNacksReceived), t3.plisCount = Number(e3.googPlisReceived), t3.frameCount = Number(e3.framesEncoded), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.videoSend.push(t3), this._stats.rtt = t3.rttMs;
                  break;
                }
                case "video_recv": {
                  const t3 = pL(gL), i3 = this.lastDecodeVideoReceiverStats.get(Number(e3.ssrc));
                  if (t3.codec = e3.googCodecName, t3.targetDelayMs = Number(e3.googTargetDelayMs), t3.renderDelayMs = Number(e3.googRenderDelayMs), t3.currentDelayMs = Number(e3.googCurrentDelayMs), t3.minPlayoutDelayMs = Number(e3.googMinPlayoutDelayMs), t3.decodeMs = Number(e3.googDecodeMs), t3.maxDecodeMs = Number(e3.googMaxDecodeMs), t3.receivedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateReceived) }, t3.decodedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateDecoded) }, t3.decodeFrameRate = Number(e3.googFrameRateDecoded), t3.outputFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateOutput) }, t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.firsCount = Number(e3.googFirsSent), t3.nacksCount = Number(e3.googNacksSent), t3.plisCount = Number(e3.googPlisSent), t3.framesDecodeCount = Number(e3.framesDecoded), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, t3.decodedFrame.width, t3.decodedFrame.height), this.isFirstVideoDecoded[t3.ssrc] = true), i3) {
                    const n2 = i3.stats, r2 = Date.now() - i3.lts;
                    t3.framesDecodeFreezeTime = n2.framesDecodeFreezeTime, t3.framesDecodeInterval = n2.framesDecodeInterval, t3.framesDecodeCount > n2.framesDecodeCount && this.isFirstVideoDecoded[t3.ssrc] ? (i3.lts = Date.now(), t3.framesDecodeInterval = r2, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e3.ssrc, 10)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e3.ssrc, 10), true))) : t3.framesDecodeCount < i3.stats.framesDecodeCount && (t3.framesDecodeInterval = 0);
                  }
                  this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: AL({}, t3), lts: Date.now() }), this._stats.videoRecv.push(t3);
                  break;
                }
                case "audio_recv": {
                  const t3 = pL(RL);
                  t3.codec = e3.googCodecName, t3.outputLevel = Math.abs(Number(e3.audioOutputLevel)) / 32767, t3.decodingCNG = Number(e3.googDecodingCNG), t3.decodingCTN = Number(e3.googDecodingCTN), t3.decodingCTSG = Number(e3.googDecodingCTSG), t3.decodingNormal = Number(e3.googDecodingNormal), t3.decodingPLC = Number(e3.googDecodingPLC), t3.decodingPLCCNG = Number(e3.googDecodingPLCCNG), t3.expandRate = Number(e3.googExpandRate), t3.accelerateRate = Number(e3.googAccelerateRate), t3.preemptiveExpandRate = Number(e3.googPreemptiveExpandRate), t3.secondaryDecodedRate = Number(e3.googSecondaryDecodedRate), t3.speechExpandRate = Number(e3.googSpeechExpandRate), t3.preferredJitterBufferMs = Number(e3.googPreferredJitterBufferMs), t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.jitterMs = Number(e3.googJitterReceived), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.receivedFrames = Number(e3.googDecodingCTN) || Number(e3.packetsReceived), t3.droppedFrames = Number(e3.googDecodingPLC) + Number(e3.googDecodingPLCCNG) || Number(e3.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.decodingNormal > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true), this._stats.audioRecv.push(t3);
                  break;
                }
                case "audio_send": {
                  const t3 = pL(SL);
                  t3.codec = e3.googCodecName, t3.inputLevel = Math.abs(Number(e3.audioInputLevel)) / 32767, t3.aecReturnLoss = Number(e3.googEchoCancellationReturnLoss || 0), t3.aecReturnLossEnhancement = Number(e3.googEchoCancellationReturnLossEnhancement || 0), t3.residualEchoLikelihood = Number(e3.googResidualEchoLikelihood || 0), t3.residualEchoLikelihoodRecentMax = Number(e3.googResidualEchoLikelihoodRecentMax || 0), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.rtt = t3.rttMs, this._stats.audioSend.push(t3);
                  break;
                }
              }
            });
          }
          _getStats() {
            return new tg((e2, t2) => {
              this.pc.getStats(e2, t2);
            });
          }
          statsResponsesToObjects(e2) {
            const t2 = [];
            return e2.result().forEach((e3) => {
              const i2 = { id: e3.id, timestamp: e3.timestamp.valueOf().toString(), type: e3.type };
              e3.names().forEach((t3) => {
                i2[t3] = e3.stat(t3);
              }), t2.push(i2);
            }), t2;
          }
        }
        function wL(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function OL(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? wL(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : wL(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class NL extends IL {
          constructor() {
            super(...arguments), nu(this, "_stats", fL), nu(this, "report", void 0), nu(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), nu(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), nu(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), nu(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), nu(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), nu(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), nu(this, "mediaBytesSent", /* @__PURE__ */ new Map()), nu(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), nu(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), nu(this, "lastEncoderMs", /* @__PURE__ */ new Map());
          }
          async updateStats() {
            this.report = await this.pc.getStats(), this._stats = pL(fL), this.report.forEach((e2) => {
              switch (e2.type) {
                case hv.OUTBOUND:
                case hv.INBOUND: {
                  const t2 = e2.mediaType || e2.kind, i2 = !t2 && "frameWidth" in e2, n2 = !t2 && !("frameWidth" in e2);
                  e2.type === hv.OUTBOUND ? "audio" === t2 || n2 ? this.processAudioOutboundStats(e2) : ("video" === t2 || i2) && this.processVideoOutboundStats(e2) : e2.type === hv.INBOUND && ("audio" === t2 || n2 ? this.processAudioInboundStats(e2) : ("video" === t2 || i2) && this.processVideoInboundStats(e2));
                  break;
                }
                case hv.TRANSPORT: {
                  const t2 = this.report.get(e2.selectedCandidatePairId);
                  t2 && this.processCandidatePairStats(t2);
                  break;
                }
                case hv.CANDIDATE_PAIR:
                  e2.selected && this.processCandidatePairStats(e2);
              }
            }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
          }
          async getSelectedCandidatePair() {
            const e2 = await this.pc.getStats(), t2 = { local: OL({}, mL), remote: OL({}, mL) };
            return e2.forEach((i2) => {
              let n2;
              if (i2.type === hv.TRANSPORT && (n2 = e2.get(i2.selectedCandidatePairId)), i2.type === hv.CANDIDATE_PAIR && i2.selected && (n2 = i2), n2) {
                const i3 = (e3, t3) => {
                  e3.type = t3.type, e3.id = t3.id, t3.address && (e3.address = t3.address), t3.candidateType && (e3.candidateType = t3.candidateType), t3.port && (e3.port = t3.port), t3.priority && (e3.priority = t3.priority), t3.protocol && (e3.protocol = t3.protocol), t3.relayProtocol && (e3.relayProtocol = t3.relayProtocol);
                };
                if (n2.localCandidateId) {
                  const r2 = e2.get(n2.localCandidateId);
                  r2 && i3(t2.local, r2);
                }
                if (n2.remoteCandidateId) {
                  const r2 = e2.get(n2.remoteCandidateId);
                  r2 && i3(t2.remote, r2);
                }
              }
            }), t2;
          }
          processCandidatePairStats(e2) {
            if (this._stats.sendBandwidth = e2.availableOutgoingBitrate || 0, e2.currentRoundTripTime && (this._stats.rtt = 1e3 * e2.currentRoundTripTime), this._stats.videoSend.forEach((t2) => {
              e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
            }), this._stats.audioSend.forEach((t2) => {
              e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
            }), this._stats.selectedCandidatePair.id = e2.id, e2.localCandidateId) {
              const t2 = this.report.get(e2.localCandidateId);
              t2 && this.processCandidateStats(t2);
            }
            if (e2.remoteCandidateId) {
              const t2 = this.report.get(e2.remoteCandidateId);
              t2 && this.processCandidateStats(t2);
            }
          }
          processCandidateStats(e2) {
            let t2;
            e2.type === hv.LOCAL_CANDIDATE && (t2 = this._stats.selectedCandidatePair.localCandidate), e2.type === hv.REMOTE_CANDIDATE && (t2 = this._stats.selectedCandidatePair.remoteCandidate), t2 && (t2.type = e2.type, t2.id = e2.id, e2.address && (t2.address = e2.address), e2.candidateType && (t2.candidateType = e2.candidateType), e2.port && (t2.port = e2.port), e2.priority && (t2.priority = e2.priority), e2.protocol && (t2.protocol = e2.protocol), e2.relayProtocol && (t2.relayProtocol = e2.relayProtocol), e2.type === hv.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t2.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(OL({}, t2), OL({}, this.stats.selectedCandidatePair.localCandidate)), e2.type === hv.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t2.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(OL({}, t2), OL({}, this.stats.selectedCandidatePair.remoteCandidate)));
          }
          processAudioInboundStats(e2) {
            let t2 = this._stats.audioRecv.find((t3) => t3.ssrc === e2.ssrc);
            t2 || (t2 = pL(RL), this._stats.audioRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.jitterMs = 1e3 * e2.jitter, this.processAudioTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), t2.receivedFrames || (t2.receivedFrames = e2.packetsReceived), t2.droppedFrames || (t2.droppedFrames = e2.packetsLost), t2.receivedFrames > 0 && !this.isFirstAudioReceived[t2.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t2.ssrc), this.isFirstAudioReceived[t2.ssrc] = true), t2.outputLevel && t2.outputLevel > 0 && !this.isFirstAudioDecoded[t2.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t2.ssrc), this.isFirstAudioDecoded[t2.ssrc] = true), "number" == typeof e2.concealedSamples && (t2.concealedSamples = e2.concealedSamples);
          }
          processVideoInboundStats(e2) {
            let t2 = this._stats.videoRecv.find((t3) => t3.ssrc === e2.ssrc);
            t2 || (t2 = pL(gL), this._stats.videoRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.framesDecodeCount = e2.framesDecoded, t2.totalInterFrameDelay = e2.totalInterFrameDelay, t2.totalSquaredInterFrameDelay = e2.totalSquaredInterFrameDelay;
            const i2 = this.lastDecodeVideoReceiverStats.get(t2.ssrc), n2 = this.lastVideoFramesDecode.get(t2.ssrc), r2 = Date.now();
            if (t2.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t2.ssrc]) {
              const e3 = t2.decodedFrame ? t2.decodedFrame.width : 0, i3 = t2.decodedFrame ? t2.decodedFrame.height : 0;
              this.onFirstVideoDecoded && this.onFirstVideoDecoded(t2.ssrc, e3, i3), this.isFirstVideoDecoded[t2.ssrc] = true;
            }
            if (i2) {
              const n3 = i2.stats, s2 = r2 - i2.lts;
              t2.framesDecodeFreezeTime = n3.framesDecodeFreezeTime, t2.framesDecodeInterval = n3.framesDecodeInterval, !this.isFirstVideoDecoded[t2.ssrc] && s2 > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t2.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t2.ssrc), this.isFirstVideoDecodedTimeout[t2.ssrc] = true), t2.framesDecodeCount > n3.framesDecodeCount && this.isFirstVideoDecoded[t2.ssrc] ? (i2.lts = Date.now(), t2.framesDecodeInterval = s2, t2.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e2.ssrc)) ? t2.framesDecodeFreezeTime += t2.framesDecodeInterval : this.setVideoIsReady2(parseInt(e2.ssrc, 10), true))) : t2.framesDecodeCount < n3.framesDecodeCount && (t2.framesDecodeInterval = 0), e2.framesDecoded && e2.qpSum && (i2.stats.framesDecodeCount > e2.framesDecoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesDecoded : t2.qpSumPerFrame = (e2.qpSum - i2.qpSum) / (e2.framesDecoded - i2.stats.framesDecodeCount));
            }
            n2 && r2 - n2.lts >= 800 ? (t2.decodeFrameRate = Math.round((t2.framesDecodeCount - n2.count) / ((r2 - n2.lts) / 1e3)), this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: r2, rate: t2.decodeFrameRate })) : n2 ? t2.decodeFrameRate = n2.rate : this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: r2, rate: 0 }), e2.totalDecodeTime && (t2.decodeMs = 1e3 * e2.totalDecodeTime), this.processVideoTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.framerateMean && (t2.framesRateFirefox = e2.framerateMean), t2.packets > 0 && !this.isFirstVideoReceived[t2.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t2.ssrc), this.isFirstVideoReceived[t2.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t2.ssrc, { stats: OL({}, t2), lts: i2 ? i2.lts : Date.now(), qpSum: e2.qpSum });
          }
          processVideoOutboundStats(e2) {
            let t2 = this._stats.videoSend.find((t3) => t3.ssrc === e2.ssrc);
            t2 || (t2 = pL(TL), this._stats.videoSend.push(t2));
            const i2 = this.mediaBytesSent.get(e2.ssrc);
            if (i2)
              i2.add(e2.bytesSent);
            else {
              const t3 = new EL(10);
              t3.add(e2.bytesSent), this.mediaBytesSent.set(e2.ssrc, t3);
            }
            if (void 0 !== e2.retransmittedBytesSent) {
              const t3 = this.mediaBytesRetransmit.get(e2.ssrc);
              if (t3)
                t3.add(e2.retransmittedBytesSent);
              else {
                const t4 = new EL(10);
                t4.add(e2.retransmittedBytesSent), this.mediaBytesRetransmit.set(e2.ssrc, t4);
              }
            }
            if (e2.totalEncodedBytesTarget) {
              const t3 = this.mediaBytesTargetEncode.get(e2.ssrc);
              if (t3)
                t3.add(e2.totalEncodedBytesTarget);
              else {
                const t4 = new EL(10);
                t4.add(e2.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e2.ssrc, t4);
              }
            }
            if (t2.ssrc = e2.ssrc, t2.bytes = e2.bytesSent, t2.packets = e2.packetsSent, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.frameCount = e2.framesEncoded, t2.adaptionChangeReason = e2.qualityLimitationReason, t2.scalabilityMode = e2.scalabilityMode, e2.totalEncodeTime && e2.framesEncoded) {
              const i3 = this.lastEncoderMs.get(e2.ssrc);
              if (!i3 || i3.lastFrameCount > e2.framesEncoded)
                t2.avgEncodeMs = 1e3 * e2.totalEncodeTime / e2.framesEncoded;
              else {
                const n2 = e2.framesEncoded - i3.lastFrameCount, r2 = e2.totalEncodeTime - i3.lastEncoderTime;
                t2.avgEncodeMs = 1e3 * r2 / n2;
              }
            }
            if (e2.framesEncoded && e2.qpSum) {
              const i3 = this.lastEncoderMs.get(e2.ssrc);
              !i3 || i3.lastFrameCount > e2.framesEncoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesEncoded : t2.qpSumPerFrame = (e2.qpSum - i3.lastQpSum) / (e2.framesEncoded - i3.lastFrameCount);
            }
            if (this.lastEncoderMs.set(e2.ssrc, { lastFrameCount: e2.framesEncoded, lastEncoderTime: e2.totalEncodeTime, lastQpSum: e2.qpSum, lts: Date.now() }), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.mediaSourceId && this.processVideoMediaSource(e2.mediaSourceId, t2), this.processVideoTrackSenderStats(e2, e2.trackId, t2), e2.remoteId)
              this.processRemoteInboundStats(e2.remoteId, t2);
            else {
              const i3 = this.findRemoteStatsId(e2.ssrc, hv.REMOTE_INBOUND);
              i3 && this.processRemoteInboundStats(i3, t2);
            }
          }
          processAudioOutboundStats(e2) {
            let t2 = this._stats.audioSend.find((t3) => t3.ssrc === e2.ssrc);
            if (t2 || (t2 = pL(SL), this._stats.audioSend.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsSent, t2.bytes = e2.bytesSent, e2.mediaSourceId && this.processAudioMediaSource(e2.mediaSourceId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), this.processAudioTrackSenderStats(e2, e2.trackId, t2), e2.remoteId)
              this.processRemoteInboundStats(e2.remoteId, t2);
            else {
              const i2 = this.findRemoteStatsId(e2.ssrc, hv.REMOTE_INBOUND);
              i2 && this.processRemoteInboundStats(i2, t2);
            }
          }
          findRemoteStatsId(e2, t2) {
            var i2;
            const n2 = Array.from(kv(i2 = this.report).call(i2)).find((i3) => i3.type === t2 && i3.ssrc === e2);
            return n2 ? n2.id : null;
          }
          processVideoMediaSource(e2, t2) {
            const i2 = this.report.get(e2);
            i2 && i2.width && i2.height && i2.framesPerSecond && (t2.inputFrame = { width: i2.width, height: i2.height, frameRate: i2.framesPerSecond });
          }
          processAudioMediaSource(e2, t2) {
            const i2 = this.report.get(e2);
            i2 && (t2.inputLevel = i2.audioLevel);
          }
          processVideoTrackSenderStats(e2, t2, i2) {
            var n2, r2, s2, o2;
            const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null == a2 ? void 0 : a2.framesSent) && void 0 !== n2 ? n2 : e2.framesSent;
            if ("number" != typeof c2)
              return;
            let d2 = null !== (r2 = null == a2 ? void 0 : a2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, l2 = null !== (s2 = null == a2 ? void 0 : a2.frameHeight) && void 0 !== s2 ? s2 : e2.frameHeight, h2 = null !== (o2 = null == a2 ? void 0 : a2.framesPerSecond) && void 0 !== o2 ? o2 : e2.framesPerSecond;
            if ("number" == typeof d2 && "number" == typeof l2 || (d2 = 0, l2 = 0), null == h2) {
              const e3 = Date.now(), t3 = this.lastVideoFramesSent.get(i2.ssrc);
              t3 && e3 - t3.lts >= 800 ? (h2 = Math.round((c2 - t3.count) / ((e3 - t3.lts) / 1e3)), this.lastVideoFramesSent.set(i2.ssrc, { count: c2, lts: e3, rate: h2 })) : t3 ? h2 = t3.rate : this.lastVideoFramesSent.set(i2.ssrc, { count: c2, lts: e3, rate: 0 });
            }
            i2.sentFrame = { width: d2, height: l2, frameRate: Math.max(0, h2) };
          }
          processVideoTrackReceiverStats(e2, t2, i2) {
            var n2, r2, s2, o2, a2;
            const c2 = t2 ? this.report.get(t2) : void 0, d2 = null !== (n2 = null == c2 ? void 0 : c2.framesReceived) && void 0 !== n2 ? n2 : e2.framesReceived, l2 = null !== (r2 = null == c2 ? void 0 : c2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, h2 = null !== (s2 = null == c2 ? void 0 : c2.frameHeight) && void 0 !== s2 ? s2 : e2.frameHeight, u2 = null !== (o2 = null == c2 ? void 0 : c2.jitterBufferDelay) && void 0 !== o2 ? o2 : e2.jitterBufferDelay, p2 = null !== (a2 = null == c2 ? void 0 : c2.jitterBufferEmittedCount) && void 0 !== a2 ? a2 : e2.jitterBufferEmittedCount;
            if ("number" == typeof d2) {
              const e3 = this.lastVideoFramesRecv.get(i2.ssrc), t3 = Date.now();
              i2.framesReceivedCount = d2;
              let n3 = 0;
              e3 && t3 - e3.lts >= 800 ? (n3 = Math.round((d2 - e3.count) / ((t3 - e3.lts) / 1e3)), this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: n3 })) : e3 ? n3 = e3.rate : this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t3, rate: 0 }), i2.receivedFrame = { width: l2 || 0, height: h2 || 0, frameRate: n3 || 0 }, i2.decodedFrame = { width: l2 || 0, height: h2 || 0, frameRate: i2.decodeFrameRate || 0 }, i2.outputFrame = { width: l2 || 0, height: h2 || 0, frameRate: i2.decodeFrameRate || 0 };
            }
            if (u2 && p2) {
              const e3 = this.lastVideoJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
              let t3 = e3.jitterBufferMs;
              const n3 = p2 - e3.jitterBufferEmittedCount;
              n3 > 0 && (t3 = 1e3 * (u2 - e3.jitterBufferDelay) / n3), i2.jitterBufferMs = t3, i2.currentDelayMs = Math.round(t3), this.lastVideoJBDelay.set(i2.ssrc, { jitterBufferDelay: u2, jitterBufferEmittedCount: p2, jitterBufferMs: i2.currentDelayMs });
            }
          }
          processAudioTrackSenderStats(e2, t2, i2) {
            var n2, r2, s2, o2;
            const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null !== (r2 = null == a2 ? void 0 : a2.echoReturnLoss) && void 0 !== r2 ? r2 : e2.echoReturnLoss) && void 0 !== n2 ? n2 : 0, d2 = null !== (s2 = null !== (o2 = null == a2 ? void 0 : a2.echoReturnLossEnhancement) && void 0 !== o2 ? o2 : e2.echoReturnLossEnhancement) && void 0 !== s2 ? s2 : 0;
            i2.aecReturnLoss = c2, i2.aecReturnLossEnhancement = d2;
          }
          processAudioTrackReceiverStats(e2, t2, i2) {
            var n2, r2, s2, o2, a2, c2, d2;
            const l2 = t2 ? this.report.get(t2) : void 0, h2 = null !== (n2 = null == l2 ? void 0 : l2.removedSamplesForAcceleration) && void 0 !== n2 ? n2 : e2.removedSamplesForAcceleration, u2 = null !== (r2 = null == l2 ? void 0 : l2.totalSamplesReceived) && void 0 !== r2 ? r2 : e2.totalSamplesReceived, p2 = null !== (s2 = null == l2 ? void 0 : l2.jitterBufferDelay) && void 0 !== s2 ? s2 : e2.jitterBufferDelay, _2 = null !== (o2 = null == l2 ? void 0 : l2.jitterBufferEmittedCount) && void 0 !== o2 ? o2 : e2.jitterBufferEmittedCount, E2 = null !== (a2 = null == l2 ? void 0 : l2.audioLevel) && void 0 !== a2 ? a2 : null == e2 ? void 0 : e2.audioLevel, m2 = null !== (c2 = null == l2 ? void 0 : l2.totalSamplesDuration) && void 0 !== c2 ? c2 : null == e2 ? void 0 : e2.totalSamplesDuration, f2 = null !== (d2 = null == l2 ? void 0 : l2.concealedSamples) && void 0 !== d2 ? d2 : e2.concealedSamples;
            if (h2 && u2 && (i2.accelerateRate = h2 / u2), p2 && _2) {
              const e3 = this.lastAudioJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
              let t3 = e3.jitterBufferMs;
              const n3 = _2 - e3.jitterBufferEmittedCount;
              n3 > 0 && (t3 = 1e3 * (p2 - e3.jitterBufferDelay) / n3), i2.jitterBufferMs = Math.round(t3), this.lastAudioJBDelay.set(i2.ssrc, { jitterBufferDelay: p2, jitterBufferEmittedCount: _2, jitterBufferMs: i2.jitterBufferMs });
            }
            i2.outputLevel = E2;
            let g2 = 1920;
            m2 && u2 && (g2 = u2 / m2 / 50, i2.receivedFrames = Math.round(u2 / g2)), f2 && (i2.droppedFrames = Math.round(f2 / g2));
          }
          processRemoteInboundStats(e2, t2) {
            const i2 = this.report.get(e2);
            i2 && (t2.packetsLost = i2.packetsLost, i2.roundTripTime && (t2.rttMs = 1e3 * i2.roundTripTime), i2.jitter && (t2.jitterMs = 1e3 * i2.jitter), i2.timestamp && (t2.timestamp = i2.timestamp));
          }
          getCodecFromCodecStats(e2) {
            const t2 = this.report.get(e2);
            if (!t2)
              return "";
            const i2 = t2.mimeType.match(/\/(.*)$/);
            return i2 && i2[1] ? i2[1] : "";
          }
          updateSendBitrate() {
            let e2 = 0, t2 = null, i2 = null;
            this.mediaBytesSent.forEach((t3) => {
              e2 += t3.diffMean();
            }), this.mediaBytesRetransmit.forEach((e3) => {
              t2 = null === t2 ? e3.diffMean() : t2 + e3.diffMean();
            }), this.mediaBytesTargetEncode.forEach((e3) => {
              i2 = null === i2 ? e3.diffMean() : i2 + e3.diffMean();
            });
            const n2 = null !== t2 ? e2 - t2 : e2;
            this._stats.bitrate = { actualEncoded: 8 * n2 / (this.options.updateInterval / 1e3), transmit: 8 * e2 / (this.options.updateInterval / 1e3) }, null !== t2 && (this._stats.bitrate.retransmit = 8 * t2 / (this.options.updateInterval / 1e3)), null !== i2 && (this._stats.bitrate.targetEncoded = 8 * i2 / (this.options.updateInterval / 1e3));
          }
        }
        class DL extends IL {
          updateStats() {
            return tg.resolve();
          }
        }
        function PL(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;
          const s2 = function() {
            const e3 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
            return e3 && e3[0] ? Number(e3[0].split("/")[1]) : null;
          }();
          return s2 ? s2 < 76 ? new bL(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new NL(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : function(e3) {
            return !!window.RTCStatsReport && e3.getStats() instanceof tg;
          }(e2) ? new NL(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new DL(e2, { updateInterval: t2, lossRateInterval: i2, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 });
        }
        function LL(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function kL(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? LL(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : LL(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class ML extends PI {
          get peerConnectionState() {
            return this.peerConnection.connectionState;
          }
          get iceConnectionState() {
            return this.peerConnection.iceConnectionState;
          }
          get currentLocalDescription() {
            return this.peerConnection.currentLocalDescription;
          }
          get currentRemoteDescription() {
            return this.peerConnection.currentRemoteDescription;
          }
          constructor(e2, t2) {
            super(e2, t2), nu(this, "store", void 0), nu(this, "peerConnection", void 0), nu(this, "remoteSDP", void 0), nu(this, "initialOffer", void 0), nu(this, "statsFilter", void 0), nu(this, "useRTX", false), nu(this, "localCapabilities", void 0), nu(this, "localCandidateCount", 0), nu(this, "allCandidatesReceived", false), nu(this, "establishPromise", void 0), nu(this, "mutex", new YT("P2PConnection-mutex")), this.store = t2, this.peerConnection = new RTCPeerConnection(ML.resolvePCConfiguration(e2), { optional: [{ googDscp: true }] }), this.statsFilter = PL(this.peerConnection, kC("STATS_UPDATE_INTERVAL"), void 0, Rg() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
          }
          async establish() {
            try {
              const e2 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
              if (!e2.sdp)
                throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
              const t2 = zP(e2.sdp), i2 = JP(e2.sdp, { filterRTX: !this.useRTX, filterVideoFec: kC("FILTER_VIDEO_FEC"), filterAudioFec: kC("FILTER_AUDIO_FEC"), filterAudioCodec: ["opus"] });
              return this.localCapabilities = i2, this.initialOffer = e2, kL(kL({}, t2), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i2 }, offerSDP: e2.sdp });
            } catch (e2) {
              throw new Vg(xg.GET_LOCAL_CONNECTION_PARAMS_FAILED, e2.toString());
            }
          }
          async connect(e2, t2, i2, n2, r2, s2) {
            try {
              if (!this.initialOffer)
                throw new Error("Cannot establish P2PConnection without initial offer.");
              this.remoteSDP = new class {
                constructor(e3) {
                  nu(this, "sessionDesc", void 0), nu(this, "localCapabilities", void 0), nu(this, "rtpCapabilities", void 0), nu(this, "candidates", void 0), nu(this, "iceParameters", void 0), nu(this, "dtlsParameters", void 0), nu(this, "setup", void 0), nu(this, "currentMidIndex", void 0), nu(this, "cname", void 0), e3 = bT(e3);
                  const { remoteIceParameters: t3, remoteDtlsParameters: i3, candidates: n3, remoteRTPCapabilities: r3, remoteSetup: s3, localCapabilities: o3, sdkCodec: a2, cname: c2 } = e3, d2 = KP.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
                  this.rtpCapabilities = r3, this.candidates = n3, this.iceParameters = t3, this.dtlsParameters = i3, this.setup = s3, this.localCapabilities = o3, this.cname = c2;
                  for (let e4 = 0; e4 < d2.mediaDescriptions.length; e4++) {
                    const o4 = d2.mediaDescriptions[e4];
                    if (o4.attributes.iceUfrag = t3.iceUfrag, o4.attributes.icePwd = t3.icePwd, o4.attributes.fingerprints = i3.fingerprints, o4.attributes.candidates = n3, o4.attributes.setup = s3, "video" === o4.media.mediaType) {
                      o4.media.fmts = r3.videoCodecs.map((e6) => e6.payloadType.toString(10));
                      let e5 = r3.videoCodecs.filter((e6) => {
                        var t4, i4;
                        return null === (t4 = e6.rtpMap) || void 0 === t4 ? void 0 : Pr(i4 = t4.encodingName.toLowerCase()).call(i4, a2);
                      });
                      0 === e5.length && (e5 = r3.videoCodecs), o4.attributes.payloads = e5, o4.attributes.extmaps = r3.videoExtensions;
                    }
                    "audio" === o4.media.mediaType && (o4.media.fmts = r3.audioCodecs.map((e5) => e5.payloadType.toString(10)), o4.attributes.payloads = r3.audioCodecs, o4.attributes.extmaps = r3.audioExtensions), d2.mediaDescriptions[e4] = this.mungMediaDesc(o4);
                  }
                  this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
                }
                toString() {
                  return KP.print(this.sessionDesc);
                }
                send(e3, t3, i3) {
                  const { ssrcs: n3, ssrcGroups: r3 } = ZP(t3, this.cname), s3 = this.sessionDesc.mediaDescriptions.find((t4) => e3 === hI.VIDEO ? "video" === t4.media.mediaType : "audio" === t4.media.mediaType), o3 = n3[0].attributes.label, a2 = n3[0].attributes.mslabel;
                  return s3.attributes.ssrcs = s3.attributes.ssrcs.concat(n3), s3.attributes.ssrcGroups = s3.attributes.ssrcGroups.concat(r3), { id: o3, mslabel: a2 };
                }
                batchSend(e3) {
                  return e3.map((e4) => {
                    let { kind: t3, ssrcMsg: i3 } = e4;
                    return this.send(t3, i3, void 0);
                  });
                }
                stopSending(e3) {
                  this.sessionDesc.mediaDescriptions.forEach((t3) => {
                    const i3 = [], n3 = [], r3 = [];
                    t3.attributes.ssrcs.forEach((t4) => {
                      Pr(e3).call(e3, t4.attributes.label || "") ? r3.push(t4) : i3.push(t4);
                    }), t3.attributes.ssrcGroups.forEach((e4) => {
                      var t4;
                      Pr(t4 = r3.map((e5) => e5.ssrcId)).call(t4, e4.ssrcIds[0]) || n3.push(e4);
                    }), t3.attributes.ssrcs = i3, t3.attributes.ssrcGroups = n3;
                  });
                }
                mute(e3) {
                  const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                  if (!t3)
                    throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.mute."));
                  t3.attributes.direction = "inactive";
                }
                unmute(e3) {
                  const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                  if (!t3)
                    throw new Error("mediaDescription not found with ".concat(e3, " in remote SDP when calling RemoteSDP.unmute."));
                  t3.attributes.direction = "sendonly";
                }
                receive(e3, t3, i3) {
                  e3.forEach((e4, t4) => {
                    const i4 = e4._mediaStreamTrack, n3 = this.sessionDesc.mediaDescriptions.findIndex((e5) => e5.attributes.mid === i4.kind), r3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n3], e4);
                    this.sessionDesc.mediaDescriptions[n3] = r3;
                  });
                }
                stopReceiving(e3) {
                }
                updateCandidates(e3) {
                  e3 === uI.TCP ? this.candidates.forEach((e4) => {
                    -1 === this.candidates.findIndex((t3) => "tcp" === t3.transport && t3.connectionAddress === e4.connectionAddress && t3.port === e4.port) && this.candidates.push(uL(uL({}, e4), {}, { foundation: "tcpcandidate", priority: Number(e4.priority) - 1 + "", transport: "tcp", port: Number(e4.port) + 90 + "" }));
                  }) : this.candidates = this.candidates.filter((e4) => "tcp" !== e4.transport);
                  for (const e4 of this.sessionDesc.mediaDescriptions)
                    e4.attributes.candidates = this.candidates;
                }
                restartICE(e3) {
                  e3 = bT(e3), this.iceParameters = e3, this.sessionDesc.mediaDescriptions.forEach((t3) => {
                    t3.attributes.iceUfrag = e3.iceUfrag, t3.attributes.icePwd = e3.icePwd;
                  });
                }
                predictReceivingMids(e3) {
                  const t3 = [];
                  for (let i3 = 0; i3 < e3; i3++)
                    t3.push((this.currentMidIndex + i3 + 1).toString(10));
                  return t3;
                }
                mungRecvMediaDsec(e3, t3) {
                  const i3 = bT(e3);
                  return $P(i3, t3), tL(i3, t3), i3;
                }
                updateRecvMedia(e3, t3) {
                  const i3 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e3);
                  if (-1 !== i3) {
                    const e4 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t3);
                    this.sessionDesc.mediaDescriptions[i3] = e4;
                  }
                }
                bumpMid(e3) {
                  this.currentMidIndex += e3;
                }
                updateTrackLabel(e3, t3, i3) {
                  const n3 = this.sessionDesc.mediaDescriptions.find((t4) => e3 === hI.VIDEO ? "video" === t4.attributes.mid : "audio" === t4.attributes.mid);
                  if (n3) {
                    const e4 = n3.attributes.ssrcs.find((e5) => e5.attributes.label === t3);
                    var r3;
                    e4 && (e4.attributes.label = i3, null === (r3 = e4.attributes.msid) || void 0 === r3 || r3.replace(t3, i3));
                  }
                }
                mungMediaDesc(e3) {
                  const t3 = bT(e3);
                  return eL(t3), function(e4) {
                    const t4 = e4.attributes.extmaps.find((e5) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e5.extensionName);
                    t4 && e4.attributes.extmaps.splice(e4.attributes.extmaps.indexOf(t4), 1), e4.attributes.payloads.forEach((e5) => {
                      const t5 = e5.rtcpFeedbacks.findIndex((e6) => "transport-cc" === e6.type);
                      -1 !== t5 && e5.rtcpFeedbacks.splice(t5, 1);
                    });
                  }(t3), t3;
                }
                getSSRC(e3) {
                  for (const t3 of this.sessionDesc.mediaDescriptions)
                    for (const i3 of t3.attributes.ssrcs)
                      if (i3.attributes.label === e3)
                        return [i3];
                }
              }({ remoteIceParameters: e2, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2.send, remoteSetup: r2, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec, cname: s2 });
              const o2 = this.remoteSDP.toString();
              await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e3.toString()));
            }
          }
          async updateRemoteRTPCapabilities(e2, t2) {
            throw new Vg(xg.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
          }
          send(e2, t2) {
            var i2 = this;
            return BP(function* () {
              const n2 = yield jP(i2.mutex.lock());
              try {
                if (!i2.remoteSDP)
                  throw new Error("Cannot call P2PConnection.send before remote SDP created");
                const r2 = e2.map((e3) => i2.peerConnection.addTrack(e3._mediaStreamTrack)), s2 = yield jP(i2.peerConnection.createOffer()), o2 = KP.parse(s2.sdp), a2 = e2.map((e3) => {
                  const t3 = e3._mediaStreamTrack, n3 = o2.mediaDescriptions.find((e4) => e4.attributes.mid === t3.kind);
                  if (!n3)
                    throw new Error("Cannot extract ssrc from mediaDescription.");
                  return function(e4, t4, i3) {
                    const n4 = e4.attributes.ssrcs.filter((e5) => e5.attributes.label === t4), r3 = e4.attributes.ssrcGroups;
                    if (0 === n4.length)
                      throw new Error("Cannot extract ssrc from plan-b SDP.");
                    if (r3 && n4.length > 1) {
                      const e5 = r3.find((e6) => -1 !== e6.ssrcIds.indexOf(n4[0].ssrcId));
                      return e5 ? [{ ssrcId: e5.ssrcIds[0], rtx: i3 ? e5.ssrcIds[1] : void 0 }] : [{ ssrcId: n4[0].ssrcId }];
                    }
                    return [{ ssrcId: n4[0].ssrcId }];
                  }(n3, t3.id, i2.useRTX);
                });
                let c2;
                try {
                  c2 = yield a2;
                } catch (e3) {
                  throw r2.forEach((e4) => {
                    Sg() && e4.replaceTrack(null), i2.peerConnection.removeTrack(e4);
                  }), e3;
                }
                const d2 = i2.mungSendOfferSDP(s2.sdp, e2);
                i2.remoteSDP.receive(e2, t2, c2);
                const l2 = i2.remoteSDP.toString();
                return yield jP(i2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield jP(i2.applySendEncodings(r2, e2)), yield jP(i2.peerConnection.setRemoteDescription({ type: "answer", sdp: l2 })), e2.map((e3, t3) => {
                  const i3 = e3._mediaStreamTrack.id;
                  return { localSSRC: a2[t3], id: i3 };
                });
              } catch (e3) {
                throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e3.toString()));
              } finally {
                n2();
              }
            })();
          }
          async stopSending(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
              const t2 = this.peerConnection.getSenders().filter((t3) => {
                var i3;
                return -1 !== e2.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
              });
              if (t2.length !== e2.length)
                throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
              t2.map((e3) => {
                Sg() && e3.replaceTrack(null), this.peerConnection.removeTrack(e3);
              });
              const i2 = await this.peerConnection.createOffer();
              await this.peerConnection.setLocalDescription(i2), this.remoteSDP.stopReceiving(e2);
              const n2 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e3.toString()));
            }
          }
          async receive(e2, t2, i2, n2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.receive ".concat(e2, " before remoteSDP created."));
              const { id: i3, mslabel: r2 } = this.remoteSDP.send(e2, t2, n2), s2 = new tg((t3, n3) => {
                const s3 = setTimeout(() => {
                  n3(new Error("Cannot receive track, id: ".concat(i3)));
                }, 1e4), o3 = (n4) => {
                  const a3 = pg();
                  if (("Safari" === a3.name && 11 === Number(a3.version) || Cg()) && n4.track.id !== i3 && n4.streams[0].id === r2) {
                    var c2;
                    const r3 = n4.streams[0].getTracks()[0];
                    return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(e2, i3, n4.track.id), this.peerConnection.removeEventListener("track", o3), clearTimeout(s3), void t3(r3);
                  }
                  if (n4.track.id === i3)
                    return this.peerConnection.removeEventListener("track", o3), clearTimeout(s3), void t3(n4.track);
                };
                this.peerConnection.addEventListener("track", o3);
              }), o2 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: o2 });
              const a2 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(a2);
              return { track: await s2, id: i3 };
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e3.toString()));
            }
          }
          async stopReceiving(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
              this.remoteSDP.stopSending(e2);
              const t2 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const i2 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(i2);
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e3.toString()));
            }
          }
          async muteRemote(e2) {
          }
          async unmuteRemote(e2) {
          }
          async muteLocal(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
              const t2 = this.peerConnection.getSenders().filter((t3) => {
                var i2;
                return -1 !== e2.indexOf((null === (i2 = t3.track) || void 0 === i2 ? void 0 : i2.id) || "");
              });
              if (t2.length !== e2.length)
                throw new Error("sender' length doesn't match mids' length.");
              t2.map((e3) => {
                if (Sg() && e3.track)
                  e3.track.enabled = false;
                else {
                  const t3 = e3.getParameters();
                  t3.encodings.forEach((e4) => e4.active = false), e3.setParameters(t3);
                }
              });
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e3.toString()));
            }
          }
          async unmuteLocal(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
              const t2 = this.peerConnection.getSenders().filter((t3) => {
                var i3;
                return -1 !== e2.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
              });
              if (t2.length !== e2.length)
                throw new Error("Senders' length doesn't match mids' length.");
              t2.map(async (e3) => {
                if (Sg() && e3.track)
                  e3.track.enabled = true;
                else {
                  const t3 = e3.getParameters();
                  t3.encodings.forEach((e4) => e4.active = true), await e3.setParameters(t3);
                }
              });
              const i2 = await this.peerConnection.createOffer();
              await this.peerConnection.setLocalDescription(i2);
              const n2 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e3.toString()));
            }
          }
          restartICE(e2) {
            var t2 = this;
            return BP(function* () {
              const i2 = yield jP(t2.mutex.lock("From P2PConnection.restartICE"));
              try {
                if (!t2.remoteSDP)
                  throw new Error("Cannot restartICE before remoteSDP created.");
                if (_A().supportPCSetConfiguration) {
                  const i3 = t2.peerConnection.getConfiguration(), n3 = e2 === uI.RELAY ? "relay" : "all";
                  i3.iceTransportPolicy !== n3 && (KC.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
                } else if (e2 === uI.RELAY)
                  return;
                e2 !== uI.RELAY && t2.remoteSDP.updateCandidates(e2);
                const n2 = yield jP(t2.peerConnection.createOffer({ iceRestart: true }));
                if (!n2.sdp)
                  throw new Error("Cannot restartICE because restart offer SDP does not exist.");
                const r2 = zP(n2.sdp), { remoteIceParameters: s2 } = yield r2.iceParameters;
                t2.remoteSDP.restartICE(s2);
                const o2 = t2.remoteSDP.toString();
                yield jP(t2.peerConnection.setLocalDescription(n2)), yield jP(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 }));
              } catch (e3) {
                KC.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e3);
              } finally {
                i2();
              }
            })();
          }
          close() {
            var e2;
            this.peerConnection.close(), null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
          }
          getStats() {
            return this.statsFilter.getStats();
          }
          getRemoteVideoIsReady(e2) {
            return this.statsFilter.getVideoIsReady(e2);
          }
          async updateEncoderConfig(e2, t2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
              const e3 = await this.peerConnection.createOffer(), i2 = this.mungSendOfferSDP(e3.sdp, [t2]);
              this.remoteSDP.updateRecvMedia(t2._mediaStreamTrack.kind, t2);
              const n2 = this.remoteSDP.toString();
              await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, e3.toString());
            }
          }
          async updateSendParameters(e2, t2) {
            const i2 = this.peerConnection.getSenders().filter((t3) => {
              var i3;
              return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e2;
            });
            1 === i2.length && await this.applySendEncodings(i2, [t2]);
          }
          setStatsRemoteVideoIsReady(e2, t2) {
            this.statsFilter.setVideoIsReady2(e2, t2);
          }
          async replaceTrack(e2, t2) {
            const i2 = this.peerConnection.getSenders().find((e3) => {
              var i3;
              return (null === (i3 = e3.track) || void 0 === i3 ? void 0 : i3.id) === t2;
            });
            i2 && await i2.replaceTrack(e2._mediaStreamTrack);
          }
          createDataChannels(e2, t2) {
            throw new Vg(xg.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
          }
          stopDataChannels(e2) {
            throw new Vg(xg.NOT_SUPPORTED, "Planb mode does not support stopDataChannels.");
          }
          bindPCEvents() {
            this.peerConnection.oniceconnectionstatechange = () => {
              var e2;
              null === (e2 = this.onICEConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.iceConnectionState);
            }, this.peerConnection.onconnectionstatechange = () => {
              var e2;
              null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.connectionState);
            }, this.peerConnection.onicecandidate = (e2) => {
              e2.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, KC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
            }, setTimeout(() => {
              this.allCandidatesReceived || (this.allCandidatesReceived = true, KC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
            }, kC("CANDIDATE_TIMEOUT"));
          }
          unbindPCEvents() {
            this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
          }
          static resolvePCConfiguration(e2) {
            const t2 = { iceServers: [], sdpSemantics: "plan-b" };
            return e2.iceServers ? t2.iceServers = e2.iceServers : e2.turnServer && "off" !== e2.turnServer.mode && (_T(e2.turnServer.servers) ? t2.iceServers = e2.turnServer.servers : (t2.iceServers && t2.iceServers.push(...ML.turnServerConfigToIceServers(e2.turnServer.servers)), kC("USE_TURN_SERVER_OF_GATEWAY") && t2.iceServers && e2.turnServer.serversFromGateway && t2.iceServers.push(...ML.turnServerConfigToIceServers(e2.turnServer.serversFromGateway)), e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).forEach((e3) => {
              e3.forceturn && (t2.iceTransportPolicy = "relay");
            }))), t2;
          }
          static turnServerConfigToIceServers(e2) {
            const t2 = [];
            return e2.forEach((e3) => {
              e3.security ? e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turns:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }) : (e3.udpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.udpport, "?transport=udp") }), e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }));
            }), t2;
          }
          async updateRtpSenderEncodings(e2, t2) {
            var i2;
            if (!t2) {
              t2 = this.peerConnection.getSenders().find((t3) => {
                var i3;
                return (null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) === e2._mediaStreamTrack.id;
              });
            }
            if (!t2)
              return KC.warn("[".concat(e2.getTrackId(), "] no rtpSender found}"));
            if (!_A().supportSetRtpSenderParameters)
              return KC.warn("Browser not support set rtp-sender parameters");
            const n2 = {}, r2 = {};
            if (e2 instanceof Sb)
              switch (e2._optimizationMode) {
                case "motion":
                  n2.degradationPreference = "maintain-framerate";
                  break;
                case "detail":
                  n2.degradationPreference = "maintain-resolution";
                  break;
                default:
                  n2.degradationPreference = "balanced";
              }
            if (kC("DSCP_TYPE") && kg()) {
              var s2;
              const e3 = kC("DSCP_TYPE");
              Pr(s2 = ["very-low", "low", "medium", "high"]).call(s2, e3) && (r2.networkPriority = e3);
            }
            const o2 = t2.getParameters(), a2 = null === (i2 = o2.encodings) || void 0 === i2 ? void 0 : i2[0];
            a2 && Object.assign(a2, r2), Object.assign(o2, n2), KC.debug("[".concat(e2.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(o2.encodings))), await t2.setParameters(o2);
          }
          async applySendEncodings(e2, t2) {
            try {
              if (!_A().supportSetRtpSenderParameters)
                return;
              if (e2.length !== t2.length)
                return;
              for (let i2 = 0; i2 < e2.length; i2++) {
                const n2 = e2[i2], r2 = t2[i2];
                n2 && r2 && await this.updateRtpSenderEncodings(r2, n2);
              }
            } catch (e3) {
              KC.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
            }
          }
          mungSendOfferSDP(e2, t2) {
            const i2 = KP.parse(e2);
            return t2.forEach((e3, t3) => {
              const n2 = e3._mediaStreamTrack, r2 = i2.mediaDescriptions.find((e4) => e4.attributes.mid === n2.kind);
              r2 && $P(r2, e3);
            }), KP.print(i2);
          }
          bindStatsEvents() {
            this.statsFilter.onFirstAudioReceived = (e2) => {
              var t2;
              null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstVideoReceived = (e2) => {
              var t2;
              null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstAudioDecoded = (e2) => {
              var t2;
              null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstVideoDecoded = (e2, t2, i2) => {
              var n2;
              null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e2, t2, i2);
            }, this.statsFilter.onSelectedLocalCandidateChanged = (e2, t2) => {
              var i2;
              null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
            }, this.statsFilter.onSelectedRemoteCandidateChanged = (e2, t2) => {
              var i2;
              null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
            };
          }
          unbindStatsEvents() {
            this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
          }
          async batchReceive(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
              const t2 = this.remoteSDP.batchSend(e2).map((t3, i3) => {
                let { id: n3, mslabel: r2 } = t3;
                const { kind: s2 } = e2[i3];
                return new tg((e3, t4) => {
                  const i4 = setTimeout(() => {
                    t4(new Error("Cannot receive track, id: ".concat(n3)));
                  }, 1e4), o2 = (t5) => {
                    const a2 = pg();
                    if ("Safari" === a2.name && 11 === Number(a2.version) && t5.track.id !== n3 && t5.streams[0].id === r2) {
                      var c2;
                      const r3 = t5.streams[0].getTracks()[0];
                      return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(s2, n3, t5.track.id), this.peerConnection.removeEventListener("track", o2), clearTimeout(i4), void e3({ track: r3, id: n3 });
                    }
                    if (t5.track.id === n3)
                      return this.peerConnection.removeEventListener("track", o2), clearTimeout(i4), void e3({ track: t5.track, id: n3 });
                  };
                  this.peerConnection.addEventListener("track", o2);
                });
              }), i2 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i2 });
              const n2 = await this.peerConnection.createAnswer();
              return await this.peerConnection.setLocalDescription(n2), await tg.all(t2);
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e3.toString()));
            }
          }
          async getRemoteSSRC(e2) {
            if (!this.remoteSDP)
              return;
            const t2 = this.remoteSDP.getSSRC(e2);
            return null == t2 ? void 0 : t2[0].ssrcId;
          }
          setConfiguration(e2) {
            if (_A().supportPCSetConfiguration) {
              const t2 = ML.resolvePCConfiguration(e2);
              this.peerConnection.setConfiguration(t2);
            }
          }
        }
        function UL(e2, t2, i2) {
          const n2 = e2[t2];
          if ("function" != typeof n2)
            throw new Error("Cannot use mutex on object property.");
          return i2.value = async function() {
            const e3 = this.mutex, i3 = await e3.lock("Locking from P2PConnection.".concat(t2));
            try {
              for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++)
                s2[o2] = arguments[o2];
              return await n2.apply(this, s2);
            } finally {
              i3();
            }
          }, i2;
        }
        function xL(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function VL(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? xL(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : xL(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [Object, Object, Array, Object, String, String]), Uv("design:returntype", tg)], ML.prototype, "connect", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], ML.prototype, "stopSending", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [String, Array, String, Object]), Uv("design:returntype", tg)], ML.prototype, "receive", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], ML.prototype, "stopReceiving", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], ML.prototype, "muteRemote", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], ML.prototype, "unmuteRemote", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], ML.prototype, "muteLocal", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], ML.prototype, "unmuteLocal", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], ML.prototype, "close", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], ML.prototype, "updateEncoderConfig", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], ML.prototype, "updateSendParameters", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [iA, String]), Uv("design:returntype", tg)], ML.prototype, "replaceTrack", null), Mv([UL, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], ML.prototype, "getRemoteSSRC", null);
        const FL = "9", BL = 4e4;
        function jL(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function GL(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? jL(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : jL(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        let WL = class e2 extends PI {
          get currentLocalDescription() {
            return this.peerConnection.currentLocalDescription;
          }
          get currentRemoteDescription() {
            return this.peerConnection.currentRemoteDescription;
          }
          get peerConnectionState() {
            return this.peerConnection.connectionState;
          }
          get iceConnectionState() {
            return this.peerConnection.iceConnectionState;
          }
          get dtlsTransportState() {
            var e3, t2;
            return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e3 ? e3 : null;
          }
          constructor(t2, i2) {
            super(t2, i2), nu(this, "store", void 0), nu(this, "peerConnection", void 0), nu(this, "remoteSDP", void 0), nu(this, "initialOffer", void 0), nu(this, "transportEventReceiver", void 0), nu(this, "statsFilter", void 0), nu(this, "useXR", kC("USE_XR")), nu(this, "localCapabilities", void 0), nu(this, "remoteCodecs", void 0), nu(this, "localCandidateCount", 0), nu(this, "allCandidatesReceived", false), nu(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), nu(this, "establishPromise", void 0), nu(this, "mutex", new YT("P2PConnection-mutex")), this.store = i2, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = PL(this.peerConnection, kC("STATS_UPDATE_INTERVAL"), void 0, Rg() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
          }
          async updateRemoteRTPCapabilities(e3, t2) {
            this.remoteCodecs = t2;
            const i2 = [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map((e4) => e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").filter((e4) => {
              var t3;
              return Pr(t3 = Object.keys(UC)).call(t3, e4);
            }))];
            if (rv.updateRemoteRTPCapabilities(this.store.sessionId, { mids: e3, localCodecs: i2, remoteCodecs: this.remoteCodecs }), !this.remoteSDP)
              return void KC.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(i2, ", codecs: ").concat(t2));
            if (this.remoteSDP.updateRemoteCodec(e3, t2, this.store.codec)) {
              const e4 = await this.peerConnection.createOffer(), t3 = this.logSDPExchange(e4.sdp || "", "offer", "local", "muteLocal");
              await this.peerConnection.setLocalDescription(e4);
              const i3 = this.remoteSDP.toString();
              null == t3 || t3(i3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i3 });
            } else
              KC.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
          }
          async establish() {
            try {
              this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
              const e3 = await this.peerConnection.createOffer();
              if (!e3.sdp)
                throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
              const t2 = zP(e3.sdp), i2 = await sL({ filterRTX: !kC("USE_PUB_RTX") && !kC("USE_SUB_RTX"), filterVideoFec: kC("FILTER_VIDEO_FEC"), filterAudioFec: kC("FILTER_AUDIO_FEC"), filterVideoCodec: kC("FILTER_VIDEO_CODEC") }, { useXR: this.useXR });
              return this.localCapabilities = aL(i2), this.initialOffer = e3, GL(GL({}, t2), {}, { rtpCapabilities: i2, offerSDP: e3.sdp });
            } catch (e3) {
              throw new Vg(xg.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
            }
          }
          async connect(e3, t2, i2, n2, r2, s2) {
            try {
              if (!this.initialOffer)
                throw new Error("Cannot establish P2PConnection without initial offer.");
              this.remoteSDP = new class {
                get localCapabilities() {
                  return bT(this._localCapabilities);
                }
                get rtpCapabilities() {
                  return bT(this._rtpCapabilities);
                }
                get candidates() {
                  return bT(this._candidates);
                }
                get iceParameters() {
                  return bT(this._iceParameters);
                }
                get dtlsParameters() {
                  return bT(this._dtlsParameters);
                }
                constructor(e4) {
                  nu(this, "sessionDesc", void 0), nu(this, "_localCapabilities", void 0), nu(this, "_rtpCapabilities", void 0), nu(this, "_candidates", void 0), nu(this, "_iceParameters", void 0), nu(this, "_dtlsParameters", void 0), nu(this, "setup", void 0), nu(this, "currentMidIndex", void 0), nu(this, "cname", void 0), nu(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e4 = bT(e4);
                  const { remoteIceParameters: t3, remoteDtlsParameters: i3, candidates: n3, remoteRTPCapabilities: r3, remoteSetup: s3, localCapabilities: o3, cname: a3 } = e4, c3 = KP.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");
                  this._rtpCapabilities = r3, this._candidates = n3, this._iceParameters = t3, this._dtlsParameters = i3, this._localCapabilities = o3, this.setup = s3, this.cname = a3;
                  const d3 = this.rtpCapabilities.send;
                  for (const e5 of c3.mediaDescriptions) {
                    if (e5.attributes.iceUfrag = t3.iceUfrag, e5.attributes.icePwd = t3.icePwd, e5.attributes.fingerprints = i3.fingerprints, e5.attributes.candidates = n3, e5.attributes.setup = s3, "video" === e5.media.mediaType && (e5.media.fmts = d3.videoCodecs.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = d3.videoCodecs, e5.attributes.extmaps = d3.videoExtensions, kC("PRELOAD_MEDIA_COUNT") > 0)) {
                      const { ssrcs: t4, ssrcGroups: i4 } = ZP([{ ssrcId: BL, rtx: kC("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
                      e5.attributes.ssrcs = t4, e5.attributes.ssrcGroups = i4;
                    }
                    if ("audio" === e5.media.mediaType && (e5.media.fmts = d3.audioCodecs.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = d3.audioCodecs, e5.attributes.extmaps = d3.audioExtensions, cL(e5), kC("PRELOAD_MEDIA_COUNT") > 0)) {
                      const { ssrcs: t4, ssrcGroups: i4 } = ZP([{ ssrcId: 2e4 }], this.cname);
                      e5.attributes.ssrcs = t4, e5.attributes.ssrcGroups = i4;
                    }
                  }
                  this.sessionDesc = c3, this.currentMidIndex = c3.mediaDescriptions.length - 1;
                }
                preloadRemoteMedia() {
                  const e4 = kC("PRELOAD_MEDIA_COUNT");
                  this.rtpCapabilities;
                  const t3 = this.candidates, i3 = this.dtlsParameters, n3 = this.iceParameters, r3 = this.rtpCapabilities.send;
                  for (let s3 = 1; s3 < e4; s3++) {
                    const e5 = 2 * s3 + 2e4, o3 = 2 * s3 + BL, { ssrcs: a3, ssrcGroups: c3 } = ZP([{ ssrcId: e5 }], this.cname), { ssrcs: d3, ssrcGroups: l3 } = ZP([{ ssrcId: o3, rtx: kC("USE_SUB_RTX") ? o3 + 1 : void 0 }], this.cname);
                    this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: FL, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r3.videoCodecs.map((e6) => e6.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n3.iceUfrag, icePwd: n3.icePwd, unrecognized: [], candidates: t3, extmaps: r3.videoExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d3, ssrcGroups: l3, rtcpFeedbackWildcards: [], payloads: r3.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * s3) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: FL, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r3.audioCodecs.map((e6) => e6.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n3.iceUfrag, icePwd: n3.icePwd, unrecognized: [], candidates: t3, extmaps: r3.audioExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a3, ssrcGroups: c3, rtcpFeedbackWildcards: [], payloads: r3.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * s3 + 1) } }), this.currentMidIndex += 2;
                  }
                  this.updateBundleMids();
                }
                toString() {
                  return KP.print(this.sessionDesc);
                }
                send(e4, t3, i3, n3) {
                  const { ssrcs: r3, ssrcGroups: s3 } = ZP(t3, this.cname, kC("SYNC_GROUP") ? i3 : void 0), o3 = this.findPreloadMediaDesc(r3);
                  if (o3) {
                    if (Rg() && this.firefoxSsrcMidMap.set(r3[0].ssrcId, o3.attributes.mid), n3 && (n3.twcc || n3.remb)) {
                      const e5 = this.sessionDesc.mediaDescriptions.indexOf(o3);
                      return this.sessionDesc.mediaDescriptions[e5] = this.mungSendMediaDesc(o3, n3), { mid: o3.attributes.mid, needExchangeSDP: true };
                    }
                    return { mid: o3.attributes.mid, needExchangeSDP: false };
                  }
                  {
                    const t4 = this.findAvailableMediaIndex(e4, r3);
                    let i4;
                    return -1 === t4 || 1 === t4 && (Sg() || Ag()) || 0 === t4 && kC("USE_SUB_RTX") || bg() ? (i4 = this.createOrRecycleSendMedia(e4, r3, s3, "sendonly", n3), this.updateBundleMids()) : (i4 = bT(this.sessionDesc.mediaDescriptions[t4]), i4.attributes.direction = "sendonly", i4.attributes.ssrcs = r3, i4.attributes.ssrcGroups = s3, this.sessionDesc.mediaDescriptions[t4] = this.mungSendMediaDesc(i4, n3)), Rg() && this.firefoxSsrcMidMap.set(r3[0].ssrcId, i4.attributes.mid), { mid: i4.attributes.mid, needExchangeSDP: true };
                  }
                }
                sendDataChannel() {
                  const { mediaDesc: e4, needExchangeSDP: t3 } = this.createOrRecycleDataChannel();
                  return this.updateBundleMids(), { mid: e4.attributes.mid, needExchangeSDP: t3 };
                }
                batchSend(e4) {
                  const t3 = e4.map((e5) => {
                    let { kind: t4, ssrcMsg: i4, mslabel: n4 } = e5;
                    return this.send(t4, i4, n4);
                  }), i3 = [];
                  let n3 = false;
                  return t3.forEach((e5) => {
                    let { mid: t4, needExchangeSDP: r3 } = e5;
                    r3 && (n3 = true), i3.push(t4);
                  }), { mids: i3, needExchangeSDP: n3 };
                }
                stopSending(e4) {
                  const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && -1 !== e4.indexOf(t4.attributes.mid));
                  if (t3.length !== e4.length)
                    throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
                  t3.forEach((e5) => {
                    "0" === e5.attributes.mid || Rg() || bg() ? e5.attributes.ssrcs = [] : (e5.attributes.ssrcs = [], e5.attributes.direction = "inactive", e5.media.port = "0");
                  }), this.updateBundleMids();
                }
                mute(e4) {
                  const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                  if (!t3)
                    throw new Error("mediaDescription not found with ".concat(e4, " in remote SDP when calling RemoteSDP.mute."));
                  t3.attributes.direction = "inactive";
                }
                unmute(e4) {
                  const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                  if (!t3)
                    throw new Error("mediaDescription not found with ".concat(e4, " in remote SDP when calling RemoteSDP.unmute."));
                  t3.attributes.direction = "sendonly";
                }
                muteRemote(e4) {
                  const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => Pr(e4).call(e4, t4.attributes.mid || ""));
                  if (t3.length !== e4.length)
                    throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                  t3.forEach((e5) => {
                    e5.attributes.direction = "inactive";
                  });
                }
                unmuteRemote(e4) {
                  const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => Pr(e4).call(e4, t4.attributes.mid || ""));
                  if (t3.length !== e4.length)
                    throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                  t3.forEach((e5) => {
                    e5.attributes.direction = "recvonly";
                  });
                }
                receive(e4, t3, i3, n3) {
                  e4.forEach((e5, r3) => {
                    this.createOrRecycleRecvMedia(e5, [], "recvonly", t3, i3, n3[r3]);
                  }), this.updateBundleMids();
                }
                stopReceiving(e4) {
                  const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => -1 !== e4.indexOf(t4.attributes.mid));
                  if (t3.length !== e4.length)
                    throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
                  t3.forEach((e5) => {
                    e5.media.port = "0", e5.attributes.direction = "inactive";
                  }), this.updateBundleMids();
                }
                updateCandidates(e4) {
                  const t3 = this._candidates.filter((e5) => "udp" === e5.transport);
                  if (e4 === uI.TCP) {
                    if (0 === t3.length)
                      return;
                    if (kC("TCP_CANDIDATE_ONLY")) {
                      const e5 = this._candidates.filter((e6) => "tcp" === e6.transport);
                      t3.forEach((t4) => {
                        -1 === e5.findIndex((e6) => e6.connectionAddress === t4.connectionAddress) && e5.push(VL(VL({}, t4), {}, { foundation: "tcpcandidate", priority: Number(t4.priority) - 1 + "", transport: "tcp", port: Number(t4.port) + 90 + "" }));
                      }), this._candidates = e5;
                    } else {
                      const e5 = [];
                      t3.forEach((t4) => {
                        e5.push(VL(VL({}, t4), {}, { foundation: "tcpcandidate", priority: Number(t4.priority) - 1 + "", transport: "tcp", port: Number(t4.port) + 90 + "" }));
                      }), this._candidates = [...t3, ...e5];
                    }
                  } else if (e4 === uI.RELAY) {
                    if (0 !== t3.length)
                      return;
                    {
                      const e5 = this._candidates.filter((e6) => "tcp" === e6.transport);
                      e5.forEach((e6) => {
                        t3.push(VL(VL({}, e6), {}, { foundation: "udpcandidate", priority: Number(e6.priority) + 1 + "", transport: "udp", port: Number(e6.port) - 90 + "" }));
                      }), this._candidates = [...t3, ...e5];
                    }
                  } else
                    0 === t3.length ? (this._candidates.filter((e5) => "tcp" === e5.transport).forEach((e5) => {
                      t3.push(VL(VL({}, e5), {}, { foundation: "udpcandidate", priority: Number(e5.priority) + 1 + "", transport: "udp", port: Number(e5.port) - 90 + "" }));
                    }), this._candidates = t3) : this._candidates = this._candidates.filter((e5) => "tcp" !== e5.transport);
                  for (const e5 of this.sessionDesc.mediaDescriptions)
                    e5.attributes.candidates = this.candidates;
                }
                restartICE(e4) {
                  e4 = bT(e4), this._iceParameters = e4, this.sessionDesc.mediaDescriptions.forEach((t3) => {
                    t3.attributes.iceUfrag = e4.iceUfrag, t3.attributes.icePwd = e4.icePwd;
                  });
                }
                predictReceivingMids(e4) {
                  const t3 = [];
                  for (let i3 = 0; i3 < e4; i3++)
                    t3.push((this.currentMidIndex + i3 + 1).toString(10));
                  return t3;
                }
                findAvailableMediaIndex(e4, t3) {
                  return this.sessionDesc.mediaDescriptions.findIndex((i3) => {
                    const n3 = i3.media.mediaType === e4 && "0" !== i3.media.port && ("sendonly" === i3.attributes.direction || "sendrecv" === i3.attributes.direction) && 0 === i3.attributes.ssrcs.length;
                    if (Rg()) {
                      if (n3) {
                        const e5 = this.firefoxSsrcMidMap.get(t3[0].ssrcId);
                        return !(e5 || "0" !== i3.attributes.mid && "1" !== i3.attributes.mid) || !(!e5 || e5 !== i3.attributes.mid);
                      }
                      return false;
                    }
                    return n3;
                  });
                }
                createOrRecycleDataChannel() {
                  for (const e5 of this.sessionDesc.mediaDescriptions)
                    if ("application" === e5.media.mediaType)
                      return { mediaDesc: e5, needExchangeSDP: false };
                  this.currentMidIndex += 1;
                  const e4 = "".concat(this.currentMidIndex), t3 = { media: { mediaType: "application", port: FL, protos: ["UDP", "DTLS", "SCTP"], fmts: ["webrtc-datachannel"] }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: [], fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [], rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, mid: "".concat(e4), sctpPort: "5000" } };
                  return this.sessionDesc.mediaDescriptions.push(t3), { mediaDesc: t3, needExchangeSDP: true };
                }
                createOrRecycleRecvMedia(e4, t3, i3, n3, r3, s3) {
                  const o3 = e4._mediaStreamTrack.kind, a3 = this.rtpCapabilities.recv, c3 = lL(o3, a3, this.localCapabilities.send, o3 === hI.VIDEO ? n3 : r3), d3 = o3 === hI.VIDEO ? a3.videoExtensions : a3.audioExtensions;
                  this.currentMidIndex += 1;
                  const l3 = "".concat(this.currentMidIndex);
                  let h3 = { media: { mediaType: o3, port: FL, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: c3.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: d3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: c3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i3, rtcpMux: true, rtcpRsize: true, mid: "".concat(l3) } };
                  h3 = this.mungRecvMediaDsec(h3, e4, s3);
                  const u2 = this.findFirstClosedMedia(o3);
                  if (u2) {
                    const e5 = this.sessionDesc.mediaDescriptions.indexOf(u2);
                    this.sessionDesc.mediaDescriptions[e5] = h3;
                  } else
                    this.sessionDesc.mediaDescriptions.push(h3);
                  return h3;
                }
                updateRemoteCodec(e4, t3, i3) {
                  const n3 = [...new Set(this._rtpCapabilities.recv.videoCodecs.map((e5) => e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || "").filter((e5) => {
                    var t4;
                    return Pr(t4 = Object.keys(UC)).call(t4, e5);
                  }))], r3 = new Set(t3);
                  if (n3.every((e5) => r3.has(e5)))
                    return KC.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t3)), false;
                  const s3 = this._rtpCapabilities.recv.videoCodecs.filter((e5) => t3.some((t4) => {
                    var i4;
                    return Pr(i4 = e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || "").call(i4, t4);
                  }));
                  if (0 === s3.length)
                    return KC.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n3, " codecs: ").concat(t3)), false;
                  const o3 = [...new Set(s3.map((e5) => e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || ""))];
                  let a3;
                  if (KC.debug("updateRemoteCodec, from ".concat(n3, " to ").concat(o3)), 0 === e4.length)
                    a3 = this.sessionDesc.mediaDescriptions.filter((e5) => "video" === e5.media.mediaType && "recvonly" === e5.attributes.direction);
                  else if (a3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && Pr(e4).call(e4, t4.attributes.mid) && "recvonly" === t4.attributes.direction), a3.length !== e4.length)
                    return KC.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e4, ", codecs: ").concat(t3)), false;
                  this._rtpCapabilities.recv.videoCodecs = s3;
                  const c3 = this.localCapabilities.send, d3 = this.rtpCapabilities.recv, l3 = lL(hI.VIDEO, d3, c3, i3);
                  return a3.forEach((e5) => {
                    const t4 = l3.map((e6) => e6.payloadType.toString(10));
                    KC.debug("updateRemoteCodec mid: ".concat(e5.attributes.mid, ", from ").concat(e5.attributes.payloads, " to ").concat(l3)), e5.attributes.payloads = l3, e5.media.fmts = t4;
                  }), true;
                }
                createOrRecycleSendMedia(e4, t3, i3, n3, r3) {
                  const s3 = this.rtpCapabilities.send, o3 = e4 === hI.VIDEO ? s3.videoCodecs : s3.audioCodecs, a3 = e4 === hI.VIDEO ? s3.videoExtensions : s3.audioExtensions;
                  this.currentMidIndex += 1;
                  const c3 = "".concat(this.currentMidIndex);
                  let d3 = { media: { mediaType: e4, port: FL, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: o3.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: o3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n3, rtcpMux: true, rtcpRsize: true, mid: "".concat(c3) } };
                  d3 = this.mungSendMediaDesc(d3, r3);
                  const l3 = this.findFirstClosedMedia(e4);
                  if (l3) {
                    const e5 = this.sessionDesc.mediaDescriptions.indexOf(l3);
                    this.sessionDesc.mediaDescriptions[e5] = d3;
                  } else
                    this.sessionDesc.mediaDescriptions.push(d3);
                  return d3;
                }
                updateBundleMids() {
                  this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e4) => "0" !== e4.media.port).map((e4) => e4.attributes.mid);
                }
                mungRecvMediaDsec(e4, t3, i3) {
                  const n3 = bT(e4);
                  return eL(n3), $P(n3, t3), tL(n3, t3), iL(n3), nL(n3, i3, this.localCapabilities.send), n3;
                }
                mungSendMediaDesc(e4, t3) {
                  const i3 = bT(e4);
                  return nL(i3, t3, this.localCapabilities.recv), cL(i3), i3;
                }
                updateRecvMedia(e4, t3) {
                  const i3 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e4);
                  if (-1 !== i3) {
                    const e5 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t3);
                    this.sessionDesc.mediaDescriptions[i3] = e5;
                  }
                }
                bumpMid(e4) {
                  this.currentMidIndex += e4;
                }
                findFirstClosedMedia(e4) {
                  return this.sessionDesc.mediaDescriptions.find((t3) => Rg() ? "0" === t3.media.port && t3.media.mediaType === e4 : "0" === t3.media.port);
                }
                findPreloadMediaDesc(e4) {
                  return this.sessionDesc.mediaDescriptions.find((t3) => {
                    var i3;
                    return (null === (i3 = t3.attributes) || void 0 === i3 || null === (i3 = i3.ssrcs[0]) || void 0 === i3 ? void 0 : i3.ssrcId) === e4[0].ssrcId;
                  });
                }
                getSSRC(e4) {
                  var t3;
                  return null === (t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e4)) || void 0 === t3 ? void 0 : t3.attributes.ssrcs;
                }
              }({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2, remoteSetup: r2, localCapabilities: this.localCapabilities, cname: s2 }), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
              const o2 = this.remoteSDP.toString(), a2 = KP.parse(this.initialOffer.sdp), c2 = a2.mediaDescriptions.find((e4) => "audio" === e4.media.mediaType);
              c2 && cL(c2), this.useXR && dL(a2);
              const d2 = KP.print(a2), l2 = this.logSDPExchange(d2 || "", "offer", "local", "connect");
              this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }), null == l2 || l2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
              const h2 = this.peerConnection.getTransceivers()[0];
              if (null != h2 && h2.receiver && this.tryBindTransportEvents(h2.receiver), kC("PRELOAD_MEDIA_COUNT") > 0) {
                this.remoteSDP.preloadRemoteMedia();
                const e4 = this.remoteSDP.toString();
                await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
                const t3 = await this.peerConnection.createAnswer();
                await this.peerConnection.setLocalDescription(t3);
              }
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
            }
          }
          send(e3, t2, i2) {
            var n2 = this;
            return BP(function* () {
              const r2 = yield jP(n2.mutex.lock("From P2PConnection.send"));
              try {
                if (!n2.remoteSDP)
                  throw new Error("Cannot call P2PConnection.send before remote SDP created");
                const s2 = [];
                e3.forEach((e4) => {
                  const t3 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
                  s2.push(t3), e4._updateRtpTransceiver(t3);
                }), Rg() && true === kC("SIMULCAST") && (yield jP(n2.applySimulcastForFirefox(s2, e3)));
                const o2 = yield jP(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e3.length), c2 = n2.mungSendOfferSDP(o2.sdp, e3, a2), d2 = KP.parse(c2), l2 = a2.map((e4) => {
                  const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                  if (!t3)
                    throw new Error("Cannot extract ssrc from mediaDescription.");
                  return XP(t3, kC("USE_PUB_RTX"));
                });
                let h2;
                try {
                  h2 = yield l2;
                } catch (r3) {
                  h2 = [], n2.remoteSDP.receive(e3, t2, i2, h2);
                  const s3 = n2.remoteSDP.toString();
                  throw yield jP(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield jP(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: s3 })), yield jP(n2.stopSending(a2, true)), r3;
                }
                n2.remoteSDP.receive(e3, t2, i2, h2);
                const u2 = n2.remoteSDP.toString(), p2 = n2.logSDPExchange(c2, "offer", "local", "send");
                return yield jP(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield jP(n2.applySimulcastEncodings(s2, e3)), yield jP(n2.applySendEncodings(s2, e3)), null == p2 || p2(u2), yield jP(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: u2 })), s2.map((e4, t3) => {
                  const i3 = a2[t3];
                  return { localSSRC: l2[t3], id: i3, transceiver: e4 };
                });
              } catch (e4) {
                throw e4 instanceof Vg ? e4 : new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
              } finally {
                r2();
              }
            })();
          }
          async createDataChannels(e3, t2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.createDataChannels before remote SDP created");
              let i2 = this.dataStreamChannelMap.get(e3);
              i2 && "open" === i2.readyState ? KC.debug("[P2PConnection] Channels are already available and can be reused directly.") : (i2 = this.peerConnection.createDataChannel("datastream-channel", { ordered: false, maxRetransmits: kC("DATASTREAM_MAX_RETRANSMITS") }), i2.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e3, i2)), t2.forEach((e4) => {
                e4._updateOriginDataChannel(i2);
              });
              const { needExchangeSDP: n2 } = this.remoteSDP.sendDataChannel();
              if (n2) {
                const e4 = this.remoteSDP.toString();
                await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
                const t3 = await this.peerConnection.createAnswer();
                await this.peerConnection.setLocalDescription(t3), KC.debug("[P2PConnection] createDataChannels by exchanging SDP.");
              } else
                KC.debug("[P2PConnection] createDataChannels no need to exchange SDP.");
              return;
            } catch (e4) {
              throw e4 instanceof Vg ? e4 : new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.createDataChannels failed; ".concat(e4.toString()));
            }
          }
          async stopDataChannels(e3) {
            try {
              const t2 = this.dataStreamChannelMap.get(e3);
              return null == t2 || t2.close(), void this.dataStreamChannelMap.delete(e3);
            } catch (e4) {
              throw e4 instanceof Vg ? e4 : new Vg(xg.DATACHANNEL_FAILED, "P2PConnection.stopDataChannels failed; ".concat(e4.toString()));
            }
          }
          async stopSending(e3, t2) {
            const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
              const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e3.indexOf(t4.mid));
              if (t3.length !== e3.length)
                throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
              t3.map((e4) => {
                var t4;
                e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
              });
              const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
              await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
              const s2 = this.remoteSDP.toString();
              null == r2 || r2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
            } finally {
              i2 && i2();
            }
          }
          async receive(e3, t2, i2, n2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
              const { mid: r2, needExchangeSDP: s2 } = this.remoteSDP.send(e3, t2, i2, n2);
              if (s2) {
                const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
                await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
                const n3 = await this.peerConnection.createAnswer(), s3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
                null == i3 || i3(s3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: s3 }), KC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
              } else
                KC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
              const o2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
              if (!o2)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: o2.receiver.track, id: r2, transceiver: o2 };
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
            }
          }
          async batchReceive(e3) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
              const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e3);
              if (i2) {
                const e4 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e4, "offer", "remote", "receive");
                await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
                const i3 = await this.peerConnection.createAnswer();
                null == t3 || t3(i3.sdp || ""), await this.peerConnection.setLocalDescription(i3), KC.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."));
              } else
                KC.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive no need to exchange SDP."));
              return t2.map((e4) => {
                const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e4);
                if (!t3)
                  throw new Error("Cannot get transceiver after setLocalDescription.");
                return { track: t3.receiver.track, id: e4, transceiver: t3 };
              });
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
            }
          }
          async stopReceiving(e3) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
              this.remoteSDP.stopSending(e3);
              const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const n2 = await this.peerConnection.createAnswer();
              null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
            }
          }
          async muteRemote(e3) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
              this.remoteSDP.mute(e3);
              const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const n2 = await this.peerConnection.createAnswer();
              null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e4.toString()));
            }
          }
          async unmuteRemote(e3) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
              this.remoteSDP.unmute(e3);
              const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const n2 = await this.peerConnection.createAnswer();
              null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e4.toString()));
            }
          }
          async muteLocal(e3) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
              const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
              if (t2.length !== e3.length)
                throw new Error("Transceivers' length doesn't match mids' length.");
              t2.map((e4) => {
                e4.direction = "inactive";
              });
              const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
              await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
              const r2 = this.remoteSDP.toString();
              null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
            }
          }
          async unmuteLocal(e3) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
              const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
              if (t2.length !== e3.length)
                throw new Error("Transceivers' length doesn't match mids' length.");
              t2.map(async (e4, t3) => {
                e4.direction = "sendonly";
              });
              const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
              await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3);
              const r2 = this.remoteSDP.toString();
              null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
            }
          }
          restartICE(e3) {
            var t2 = this;
            return BP(function* () {
              const i2 = yield jP(t2.mutex.lock("From P2PConnection.restartICE"));
              try {
                if (!t2.remoteSDP)
                  throw new Error("Cannot restartICE before remoteSDP created.");
                if (_A().supportPCSetConfiguration) {
                  const i3 = t2.peerConnection.getConfiguration(), n3 = e3 === uI.RELAY ? "relay" : "all";
                  i3.iceTransportPolicy !== n3 && (KC.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
                } else if (e3 === uI.RELAY)
                  return;
                t2.remoteSDP.updateCandidates(e3);
                const n2 = yield jP(t2.peerConnection.createOffer({ iceRestart: true }));
                if (!n2.sdp)
                  throw new Error("Cannot restartICE because restart offer SDP does not exist.");
                const r2 = zP(n2.sdp), { remoteIceParameters: s2 } = yield r2.iceParameters;
                t2.remoteSDP.restartICE(s2);
                const o2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
                t2.store.descriptionStart(), yield jP(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(o2), yield jP(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 }));
              } catch (e4) {
                KC.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
              } finally {
                i2();
              }
            })();
          }
          close() {
            var e3;
            this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear();
          }
          getStats() {
            return this.statsFilter.getStats();
          }
          getRemoteVideoIsReady(e3) {
            return this.statsFilter.getVideoIsReady(e3);
          }
          async updateEncoderConfig(e3, t2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
              const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e3]);
              this.remoteSDP.updateRecvMedia(e3, t2);
              const r2 = this.remoteSDP.toString(), s2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
              await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == s2 || s2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
            } catch (e4) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, e4.toString());
            }
          }
          async updateSendParameters(e3, t2) {
            const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
            1 === i2.length && (this.isVP8Simulcast(t2) ? Rg() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
          }
          setStatsRemoteVideoIsReady(e3, t2) {
            this.statsFilter.setVideoIsReady2(e3, t2);
          }
          async replaceTrack(e3, t2) {
            const i2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
            i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
          }
          async getSelectedCandidatePair() {
            const e3 = this.peerConnection.getReceivers();
            if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
              const t2 = e3[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
              return { local: GL(GL({}, mL), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: GL(GL({}, mL), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
            }
            return this.statsFilter.getSelectedCandidatePair();
          }
          bindPCEvents() {
            this.peerConnection.oniceconnectionstatechange = () => {
              var e3;
              null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
            }, this.peerConnection.onconnectionstatechange = () => {
              var e3;
              null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
            }, this.peerConnection.onicecandidate = (e3) => {
              e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, KC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
            }, setTimeout(() => {
              this.allCandidatesReceived || (this.allCandidatesReceived = true, KC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
            }, kC("CANDIDATE_TIMEOUT"));
          }
          unbindPCEvents() {
            this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
          }
          static resolvePCConfiguration(t2) {
            const i2 = { iceServers: [] };
            return t2.iceServers ? i2.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (_T(t2.turnServer.servers) ? i2.iceServers = t2.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), kC("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t2.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), kC("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
              e3.forceturn && (i2.iceTransportPolicy = "relay");
            }))), kC("ENABLE_ENCODED_TRANSFORM") && _A().supportWebRTCEncodedTransform && (i2.encodedInsertableStreams = true), i2;
          }
          static turnServerConfigToIceServers(e3) {
            const t2 = [];
            return e3.forEach((e4) => {
              e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(_D(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !kC("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
            }), t2;
          }
          tryBindTransportEvents(e3) {
            const t2 = e3.transport;
            if (t2) {
              this.transportEventReceiver = e3, t2.onstatechange = () => {
                var e4;
                null != t2 && t2.state && (null === (e4 = this.onDTLSTransportStateChange) || void 0 === e4 || e4.call(this, t2.state));
              }, t2.onerror = (e4) => {
                var t3;
                null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
              };
              const i2 = t2.iceTransport;
              i2 && (i2.onstatechange = () => {
                const e4 = null == t2 ? void 0 : t2.iceTransport.state;
                var i3;
                e4 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, e4));
              }, i2.getSelectedCandidatePair && (i2.onselectedcandidatepairchange = () => {
                if (i2.getSelectedCandidatePair()) {
                  const { local: e4, remote: t3 } = i2.getSelectedCandidatePair();
                  KC.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e4.type, protocol: e4.protocol }), ", remote ").concat(JSON.stringify({ candidateType: t3.type, protocol: t3.protocol, address: t3.address, port: t3.port }), " )"));
                }
              }));
            }
          }
          tryUnbindTransportEvents() {
            this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
          }
          async updateRtpSenderEncodings(e3, t2) {
            var i2;
            if (!t2) {
              t2 = this.peerConnection.getSenders().find((t3) => t3.track === e3._mediaStreamTrack);
            }
            if (!t2)
              return KC.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
            if (this.isVP8Simulcast(e3))
              return KC.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
            if (!_A().supportSetRtpSenderParameters)
              return KC.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
            const n2 = {}, r2 = {};
            switch (e3._optimizationMode) {
              case "motion":
                n2.degradationPreference = "maintain-framerate";
                break;
              case "detail":
                n2.degradationPreference = "maintain-resolution";
                break;
              default:
                n2.degradationPreference = "balanced";
            }
            if (e3._encoderConfig) {
              var s2;
              const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e3._encoderConfig;
              t3 && (r2.maxBitrate = 1e3 * t3), (Pr(s2 = e3._hints).call(s2, ky.LOW_STREAM) || e3.isUseScaleResolutionDownBy) && (i3 && (r2.maxFramerate = mD(i3)), n3 && n3 >= 1 && (r2.scaleResolutionDownBy = n3));
            }
            if (kC("DSCP_TYPE") && kg()) {
              var o2;
              const e4 = kC("DSCP_TYPE");
              Pr(o2 = ["very-low", "low", "medium", "high"]).call(o2, e4) && (r2.networkPriority = e4);
            }
            const a2 = t2.getParameters(), c2 = null === (i2 = a2.encodings) || void 0 === i2 ? void 0 : i2[0];
            Rg() && !c2 && (n2.encodings = [r2]), c2 && Object.assign(c2, r2), Object.assign(a2, n2), KC.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a2.encodings))), await t2.setParameters(a2);
          }
          async applySendEncodings(e3, t2) {
            try {
              if (!_A().supportSetRtpSenderParameters)
                return;
              if (e3.length !== t2.length)
                return;
              for (let i2 = 0; i2 < e3.length; i2++) {
                const n2 = e3[i2], r2 = t2[i2];
                r2 instanceof Sb && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
              }
            } catch (e4) {
              KC.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
            }
          }
          mungSendOfferSDP(e3, t2, i2) {
            const n2 = KP.parse(e3);
            return t2.forEach((e4, t3) => {
              const r2 = i2[t3], s2 = n2.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
              s2 && ($P(s2, e4), rL(s2, e4, this.store.codec));
            }), KP.print(n2);
          }
          mungReceiveAnswerSDP(e3, t2, i2) {
            const n2 = KP.parse(e3), r2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === t2);
            return r2 && (i2 === hI.AUDIO && "audio" === r2.media.mediaType && cL(r2), this.useXR && dL(n2)), KP.print(n2);
          }
          bindStatsEvents() {
            this.statsFilter.onFirstAudioReceived = (e3) => {
              var t2;
              null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
            }, this.statsFilter.onFirstVideoReceived = (e3) => {
              var t2;
              null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
            }, this.statsFilter.onFirstAudioDecoded = (e3) => {
              var t2;
              null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
            }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i2) => {
              var n2;
              null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i2);
            }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
              var i2;
              null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
            }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
              var i2;
              null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t2);
            }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
              var t2;
              null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
            };
          }
          unbindStatsEvents() {
            this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
          }
          async applySimulcastForFirefox(e3, t2) {
            if (e3.length === t2.length)
              for (let a2 = 0; a2 < e3.length; a2++) {
                var i2, n2, r2, s2, o2;
                const c2 = e3[a2], d2 = t2[a2];
                if (d2 instanceof Sb && !Pr(i2 = d2._hints).call(i2, ky.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (s2 = d2._scalabilityMode) && void 0 !== s2 && s2.numSpatialLayers && (null === (o2 = d2._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                  const e4 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                  e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
                  const i3 = c2.sender.getParameters();
                  await c2.sender.setParameters(Object.assign(i3, e4));
                }
              }
          }
          async applySimulcastEncodings(e3, t2) {
            if (!Rg() && e3.length === t2.length)
              for (let i2 = 0; i2 < e3.length; i2++) {
                const n2 = t2[i2];
                if (n2 instanceof Sb && this.isVP8Simulcast(n2)) {
                  const t3 = e3[i2], r2 = {}, s2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                  r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: s2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: s2.medium, scaleResolutionDownBy: 4 }];
                  const o2 = t3.sender.getParameters();
                  await t3.sender.setParameters(Object.assign(o2, r2));
                }
              }
          }
          isVP8Simulcast(e3) {
            var t2, i2, n2, r2, s2;
            return !!(e3 instanceof Sb && kC("SIMULCAST") && "vp8" === this.store.codec && !Pr(t2 = e3._hints).call(t2, ky.LOW_STREAM) && null !== (i2 = e3._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e3._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (s2 = e3._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1);
          }
          logSDPExchange(e3, t2, i2, n2) {
            if (kC("SDP_LOGGING"))
              return KC.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
                this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n2);
              } : void 0;
          }
          async getRemoteSSRC(e3) {
            if (!this.remoteSDP)
              return;
            const t2 = this.remoteSDP.getSSRC(e3);
            return null == t2 ? void 0 : t2[0].ssrcId;
          }
          setConfiguration(t2) {
            if (_A().supportPCSetConfiguration) {
              const i2 = e2.resolvePCConfiguration(t2);
              this.peerConnection.setConfiguration(i2);
            }
          }
        };
        function HL(e2, t2, i2) {
          const n2 = e2[t2];
          if ("function" != typeof n2)
            throw new Error("Cannot use mutex on object property.");
          return i2.value = async function() {
            const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t2));
            try {
              for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++)
                s2[o2] = arguments[o2];
              return await n2.apply(this, s2);
            } finally {
              i3();
            }
          }, i2;
        }
        function KL(e2, t2) {
          let i2 = document.createElement("video"), n2 = document.createElement("canvas");
          i2.setAttribute("style", "display:none"), n2.setAttribute("style", "display:none"), i2.setAttribute("muted", ""), i2.muted = true, i2.setAttribute("autoplay", ""), i2.autoplay = true, i2.setAttribute("playsinline", ""), n2.width = mD(t2.width), n2.height = mD(t2.height);
          const r2 = mD(t2.framerate || 15);
          document.body.append(i2), document.body.append(n2);
          let s2 = e2._mediaStreamTrack;
          i2.srcObject = new MediaStream([s2]), i2.play();
          const o2 = n2.getContext("2d");
          if (!o2)
            throw new xv(xg.UNEXPECTED_ERROR, "can not get canvas context");
          const a2 = _A(), c2 = n2.captureStream(a2.supportRequestFrame ? 0 : r2).getVideoTracks()[0];
          c2.canvas || (c2.canvas = n2), n2.startCapture = () => {
            if (!i2)
              return n2.stopCapture && n2.stopCapture();
            if (i2.paused && i2.play(), i2.videoHeight > 2 && i2.videoWidth > 2) {
              const e3 = i2.videoWidth, t3 = i2.videoHeight / e3, r3 = n2.width * t3;
              Math.abs(r3 - n2.height) >= 2 && (KC.debug("adjust low stream resolution", "".concat(n2.width, "x").concat(n2.height, " -> ").concat(n2.width, "x").concat(r3)), n2.height = r3);
            }
            o2.drawImage(i2, 0, 0, n2.width, n2.height), c2.requestFrame && c2.requestFrame(), s2 !== e2._mediaStreamTrack && (s2 = e2._mediaStreamTrack, i2.srcObject = new MediaStream([s2]));
          }, n2.stopCapture = uA(() => n2.startCapture && n2.startCapture(), r2);
          const d2 = c2.stop;
          return c2.stop = () => {
            d2.call(c2), i2 && (i2.remove(), i2.srcObject = null, i2 = null), n2 && (n2.width = 0, n2.remove(), n2.stopCapture && n2.stopCapture(), n2.startCapture = void 0, n2.stopCapture = void 0, n2 = null), KC.debug("clean low stream renderer");
          }, c2;
        }
        function YL(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function qL(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? YL(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : YL(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [Array, Array]), Uv("design:returntype", tg)], WL.prototype, "updateRemoteRTPCapabilities", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [Object, Object, Array, Object, String, String]), Uv("design:returntype", tg)], WL.prototype, "connect", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [Object, Array]), Uv("design:returntype", tg)], WL.prototype, "createDataChannels", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [String, Array, String, Object]), Uv("design:returntype", tg)], WL.prototype, "receive", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], WL.prototype, "batchReceive", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], WL.prototype, "stopReceiving", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], WL.prototype, "muteRemote", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], WL.prototype, "unmuteRemote", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], WL.prototype, "muteLocal", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], WL.prototype, "unmuteLocal", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], WL.prototype, "close", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], WL.prototype, "updateEncoderConfig", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], WL.prototype, "updateSendParameters", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [iA, String]), Uv("design:returntype", tg)], WL.prototype, "replaceTrack", null), Mv([HL, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], WL.prototype, "getRemoteSSRC", null);
        const JL = "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n", zL = "9", XL = 2e4, QL = 4e4;
        class ZL {
          get localCapabilities() {
            return bT(this._localCapabilities);
          }
          get rtpCapabilities() {
            return bT(this._rtpCapabilities);
          }
          get candidates() {
            return bT(this._candidates);
          }
          get iceParameters() {
            return bT(this._iceParameters);
          }
          get dtlsParameters() {
            return bT(this._dtlsParameters);
          }
          constructor(e2) {
            nu(this, "sessionDesc", void 0), nu(this, "_localCapabilities", void 0), nu(this, "_rtpCapabilities", void 0), nu(this, "_candidates", void 0), nu(this, "_iceParameters", void 0), nu(this, "_dtlsParameters", void 0), nu(this, "setup", void 0), nu(this, "currentMidIndex", void 0), nu(this, "cname", void 0), nu(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = bT(e2);
            const { remoteIceParameters: t2, remoteDtlsParameters: i2, candidates: n2, remoteRTPCapabilities: r2, remoteSetup: s2, localCapabilities: o2, cname: a2 } = e2, c2 = KP.parse(JL);
            this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i2, this._localCapabilities = o2, this.setup = s2, this.cname = a2;
            const d2 = this.rtpCapabilities.send;
            for (const e3 of c2.mediaDescriptions) {
              if (e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i2.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = s2, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = d2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.videoCodecs, e3.attributes.extmaps = d2.videoExtensions, kC("PRELOAD_MEDIA_COUNT") > 0)) {
                const { ssrcs: t3, ssrcGroups: i3 } = ZP([{ ssrcId: QL, rtx: kC("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
                e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
              }
              if ("audio" === e3.media.mediaType && (e3.media.fmts = d2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.audioCodecs, e3.attributes.extmaps = d2.audioExtensions, cL(e3), kC("PRELOAD_MEDIA_COUNT") > 0)) {
                const { ssrcs: t3, ssrcGroups: i3 } = ZP([{ ssrcId: XL }], this.cname);
                e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
              }
            }
            this.sessionDesc = c2, this.currentMidIndex = c2.mediaDescriptions.length - 1;
          }
          updateRemoteRTPCapabilities(e2) {
            const t2 = KP.parse(JL);
            this._rtpCapabilities = e2;
            const i2 = this.rtpCapabilities.send;
            for (const e3 of t2.mediaDescriptions) {
              if (e3.attributes.iceUfrag = this._iceParameters.iceUfrag, e3.attributes.icePwd = this._iceParameters.icePwd, e3.attributes.fingerprints = this._dtlsParameters.fingerprints, e3.attributes.candidates = this._candidates, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = i2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = i2.videoCodecs, e3.attributes.extmaps = i2.videoExtensions, kC("PRELOAD_MEDIA_COUNT") > 0)) {
                const { ssrcs: t3, ssrcGroups: i3 } = ZP([{ ssrcId: QL, rtx: kC("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
                e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
              }
              if ("audio" === e3.media.mediaType && (e3.media.fmts = i2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = i2.audioCodecs, e3.attributes.extmaps = i2.audioExtensions, kC("PRELOAD_MEDIA_COUNT") > 0)) {
                const { ssrcs: t3, ssrcGroups: i3 } = ZP([{ ssrcId: XL }], this.cname);
                e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i3;
              }
            }
            this.sessionDesc = t2, this.currentMidIndex = t2.mediaDescriptions.length - 1;
          }
          preloadRemoteMedia(e2) {
            this.rtpCapabilities;
            const t2 = this.candidates, i2 = this.dtlsParameters, n2 = this.iceParameters, r2 = this.rtpCapabilities.send;
            for (let s2 = 1; s2 < e2; s2++) {
              const e3 = 2 * s2 + XL, o2 = 2 * s2 + QL, { ssrcs: a2, ssrcGroups: c2 } = ZP([{ ssrcId: e3 }], this.cname), { ssrcs: d2, ssrcGroups: l2 } = ZP([{ ssrcId: o2, rtx: kC("USE_SUB_RTX") ? o2 + 1 : void 0 }], this.cname);
              this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: zL, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.videoCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.videoExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d2, ssrcGroups: l2, rtcpFeedbackWildcards: [], payloads: r2.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * s2 - 1) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: zL, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.audioCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.audioExtensions, fingerprints: i2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a2, ssrcGroups: c2, rtcpFeedbackWildcards: [], payloads: r2.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * s2) } }), this.currentMidIndex += 2;
            }
            this.updateBundleMids();
          }
          toString() {
            return KP.print(this.sessionDesc);
          }
          send(e2, t2, i2, n2) {
            const { ssrcs: r2, ssrcGroups: s2 } = ZP(t2, this.cname, kC("SYNC_GROUP") ? i2 : void 0), o2 = this.findPreloadMediaDesc(r2);
            if (o2) {
              if (Rg() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, o2.attributes.mid), n2 && (n2.twcc || n2.remb)) {
                const e3 = this.sessionDesc.mediaDescriptions.indexOf(o2);
                return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(o2, n2), { mid: o2.attributes.mid, needExchangeSDP: true };
              }
              return { mid: o2.attributes.mid, needExchangeSDP: false };
            }
            {
              const t3 = this.findAvailableMediaIndex(e2, r2);
              let i3;
              return -1 === t3 || Sg() || Cg() || Ag() || 0 === t3 && kC("USE_SUB_RTX") ? (i3 = this.createOrRecycleSendMedia(e2, r2, s2, "sendonly", n2), this.updateBundleMids()) : (i3 = bT(this.sessionDesc.mediaDescriptions[t3]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = r2, i3.attributes.ssrcGroups = s2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i3, n2)), Rg() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, i3.attributes.mid), { mid: i3.attributes.mid, needExchangeSDP: true };
            }
          }
          batchSend(e2) {
            const t2 = e2.map((e3) => {
              let { kind: t3, ssrcMsg: i3, mslabel: n3 } = e3;
              return this.send(t3, i3, n3);
            }), i2 = [];
            let n2 = false;
            return t2.forEach((e3) => {
              let { mid: t3, needExchangeSDP: r2 } = e3;
              r2 && (n2 = true), i2.push(t3);
            }), { mids: i2, needExchangeSDP: n2 };
          }
          stopSending(e2) {
            const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid));
            if (t2.length !== e2.length)
              throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
            t2.forEach((e3) => {
              "0" === e3.attributes.mid || Rg() || Sg() || Cg() ? e3.attributes.ssrcs = [] : (e3.attributes.ssrcs = [], e3.attributes.direction = "inactive", e3.media.port = "0");
            }), this.updateBundleMids();
          }
          mute(e2) {
            const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
            if (!t2)
              throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
            t2.attributes.direction = "inactive";
          }
          unmute(e2) {
            const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
            if (!t2)
              throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
            t2.attributes.direction = "sendonly";
          }
          muteRemote(e2) {
            const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => Pr(e2).call(e2, t3.attributes.mid || ""));
            if (t2.length !== e2.length)
              throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
            t2.forEach((e3) => {
              e3.attributes.direction = "inactive";
            });
          }
          unmuteRemote(e2) {
            const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => Pr(e2).call(e2, t3.attributes.mid || ""));
            if (t2.length !== e2.length)
              throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
            t2.forEach((e3) => {
              e3.attributes.direction = "recvonly";
            });
          }
          receive(e2, t2, i2, n2) {
            e2.forEach((e3, r2) => {
              this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i2, n2[r2]);
            }), this.updateBundleMids();
          }
          stopReceiving(e2) {
            const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e2.indexOf(t3.attributes.mid));
            if (t2.length !== e2.length)
              throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
            t2.forEach((e3) => {
              e3.media.port = "0", e3.attributes.direction = "inactive";
            }), this.updateBundleMids();
          }
          updateCandidates(e2) {
            e2 === uI.TCP ? this._candidates.forEach((e3) => {
              -1 === this._candidates.findIndex((t2) => "tcp" === t2.transport && t2.connectionAddress === e3.connectionAddress && t2.port === e3.port) && this._candidates.push(qL(qL({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
            }) : this._candidates = this._candidates.filter((e3) => "tcp" !== e3.transport);
            for (const e3 of this.sessionDesc.mediaDescriptions)
              e3.attributes.candidates = this.candidates;
          }
          restartICE(e2) {
            e2 = bT(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
              t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
            });
          }
          predictReceivingMids(e2) {
            const t2 = [];
            for (let i2 = 0; i2 < e2; i2++)
              t2.push((this.currentMidIndex + i2 + 1).toString(10));
            return t2;
          }
          findAvailableMediaIndex(e2, t2) {
            return this.sessionDesc.mediaDescriptions.findIndex((i2) => {
              const n2 = i2.media.mediaType === e2 && "0" !== i2.media.port && ("sendonly" === i2.attributes.direction || "sendrecv" === i2.attributes.direction) && 0 === i2.attributes.ssrcs.length;
              if (Rg()) {
                if (n2) {
                  const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
                  return !(e3 || "0" !== i2.attributes.mid && "1" !== i2.attributes.mid) || !(!e3 || e3 !== i2.attributes.mid);
                }
                return false;
              }
              return n2;
            });
          }
          createOrRecycleRecvMedia(e2, t2, i2, n2, r2, s2) {
            const o2 = e2._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = lL(o2, a2, this.localCapabilities.send, o2 === hI.VIDEO ? n2 : r2), d2 = o2 === hI.VIDEO ? a2.videoExtensions : a2.audioExtensions;
            this.currentMidIndex += 1;
            const l2 = "".concat(this.currentMidIndex);
            let h2 = { media: { mediaType: o2, port: zL, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: c2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: d2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: c2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(l2) } };
            h2 = this.mungRecvMediaDsec(h2, e2, s2);
            const u2 = this.findFirstClosedMedia(o2);
            if (u2) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
              this.sessionDesc.mediaDescriptions[e3] = h2;
            } else
              this.sessionDesc.mediaDescriptions.push(h2);
            return h2;
          }
          updateRemoteCodec(e2, t2, i2) {
            const n2 = [...new Set(this._rtpCapabilities.recv.videoCodecs.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").filter((e3) => {
              var t3;
              return Pr(t3 = Object.keys(UC)).call(t3, e3);
            }))], r2 = new Set(t2);
            if (n2.every((e3) => r2.has(e3)))
              return KC.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t2)), false;
            const s2 = this._rtpCapabilities.recv.videoCodecs.filter((e3) => t2.some((t3) => {
              var i3;
              return Pr(i3 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(i3, t3);
            }));
            if (0 === s2.length)
              return KC.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n2, " codecs: ").concat(t2)), false;
            const o2 = [...new Set(s2.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || ""))];
            let a2;
            if (KC.debug("updateRemoteCodec, from ".concat(n2, " to ").concat(o2)), 0 === e2.length)
              a2 = this.sessionDesc.mediaDescriptions.filter((e3) => "video" === e3.media.mediaType && "recvonly" === e3.attributes.direction);
            else if (a2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && Pr(e2).call(e2, t3.attributes.mid) && "recvonly" === t3.attributes.direction), a2.length !== e2.length)
              return KC.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e2, ", codecs: ").concat(t2)), false;
            this._rtpCapabilities.recv.videoCodecs = s2;
            const c2 = this.localCapabilities.send, d2 = this.rtpCapabilities.recv, l2 = lL(hI.VIDEO, d2, c2, i2);
            return a2.forEach((e3) => {
              const t3 = l2.map((e4) => e4.payloadType.toString(10));
              KC.debug("updateRemoteCodec mid: ".concat(e3.attributes.mid, ", from ").concat(e3.attributes.payloads, " to ").concat(l2)), e3.attributes.payloads = l2, e3.media.fmts = t3;
            }), true;
          }
          createOrRecycleSendMedia(e2, t2, i2, n2, r2) {
            const s2 = this.rtpCapabilities.send, o2 = e2 === hI.VIDEO ? s2.videoCodecs : s2.audioCodecs, a2 = e2 === hI.VIDEO ? s2.videoExtensions : s2.audioExtensions;
            this.currentMidIndex += 1;
            const c2 = "".concat(this.currentMidIndex);
            let d2 = { media: { mediaType: e2, port: zL, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: o2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: o2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
            d2 = this.mungSendMediaDesc(d2, r2);
            const l2 = this.findFirstClosedMedia(e2);
            if (l2) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(l2);
              this.sessionDesc.mediaDescriptions[e3] = d2;
            } else
              this.sessionDesc.mediaDescriptions.push(d2);
            return d2;
          }
          updateBundleMids() {
            this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
          }
          mungRecvMediaDsec(e2, t2, i2) {
            const n2 = bT(e2);
            return eL(n2), $P(n2, t2), tL(n2, t2), iL(n2), nL(n2, i2, this.localCapabilities.send), n2;
          }
          mungSendMediaDesc(e2, t2) {
            const i2 = bT(e2);
            return nL(i2, t2, this.localCapabilities.recv), cL(i2), i2;
          }
          updateRecvMedia(e2, t2) {
            const i2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
            if (-1 !== i2) {
              const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t2);
              this.sessionDesc.mediaDescriptions[i2] = e3;
            }
          }
          bumpMid(e2) {
            this.currentMidIndex += e2;
          }
          findFirstClosedMedia(e2) {
            return this.sessionDesc.mediaDescriptions.find((t2) => Rg() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port);
          }
          findPreloadMediaDesc(e2) {
            return this.sessionDesc.mediaDescriptions.find((t2) => {
              var i2;
              return (null === (i2 = t2.attributes) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId) === e2[0].ssrcId;
            });
          }
          getSSRC(e2) {
            var t2;
            return null === (t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2)) || void 0 === t2 ? void 0 : t2.attributes.ssrcs;
          }
        }
        function $L(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function ek(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? $L(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : $L(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class tk extends PI {
          get currentLocalDescription() {
            return this.peerConnection.currentLocalDescription;
          }
          get currentRemoteDescription() {
            return this.peerConnection.currentRemoteDescription;
          }
          get peerConnectionState() {
            return this.peerConnection.connectionState;
          }
          get iceConnectionState() {
            return this.peerConnection.iceConnectionState;
          }
          constructor(e2, t2, i2) {
            super(e2, t2), nu(this, "store", void 0), nu(this, "peerConnection", void 0), nu(this, "remoteSDP", void 0), nu(this, "initialOffer", void 0), nu(this, "transportEventReceiver", void 0), nu(this, "statsFilter", void 0), nu(this, "useXR", kC("USE_XR")), nu(this, "localCapabilities", void 0), nu(this, "localCandidateCount", 0), nu(this, "allCandidatesReceived", false), nu(this, "remoteCodecs", void 0), nu(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), nu(this, "establishPromise", void 0), nu(this, "mutex", new YT("NVExtentionsConnection-mutex")), nu(this, "rtcMedia", void 0), this.store = t2, this.peerConnection = i2, this.statsFilter = PL(this.peerConnection, kC("STATS_UPDATE_INTERVAL"), void 0, Rg() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
          }
          async establish(e2) {
            try {
              const e3 = await this.peerConnection.createOffer();
              if (!e3.sdp)
                throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
              const t2 = zP(e3.sdp), i2 = await sL({ filterRTX: !kC("USE_PUB_RTX") && !kC("USE_SUB_RTX"), filterVideoFec: kC("FILTER_VIDEO_FEC"), filterAudioFec: kC("FILTER_AUDIO_FEC"), filterVideoCodec: kC("FILTER_VIDEO_CODEC") }, { useXR: this.useXR });
              return this.localCapabilities = i2, this.initialOffer = e3, ek(ek({}, t2), {}, { rtpCapabilities: i2, offerSDP: e3.sdp });
            } catch (e3) {
              throw new xv(xg.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
            }
          }
          async connect(e2, t2, i2, n2, r2, s2) {
            try {
              if (!this.initialOffer)
                throw new Error("Cannot establish NVConnection without initial offer.");
              this.remoteSDP = new ZL({ remoteIceParameters: e2, remoteDtlsParameters: t2, candidates: i2, remoteRTPCapabilities: n2, remoteSetup: r2, localCapabilities: aL(this.localCapabilities), cname: s2 });
              const o2 = this.remoteSDP.toString(), a2 = KP.parse(this.initialOffer.sdp), c2 = a2.mediaDescriptions.find((e3) => "audio" === e3.media.mediaType);
              c2 && cL(c2), this.useXR && dL(a2);
              const d2 = KP.print(a2), l2 = this.logSDPExchange(d2 || "", "offer", "local", "connect");
              await this.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }), null == l2 || l2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NV.connect failed; ".concat(e3.toString()));
            }
          }
          async updateRemoteRTPCapabilities(e2, t2) {
            let i2;
            this.remoteCodecs = t2, this.localCapabilities && (i2 = aL(this.localCapabilities));
            const n2 = [...new Set(i2 && i2.send.videoCodecs.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").filter((e3) => {
              var t3;
              return Pr(t3 = Object.keys(UC)).call(t3, e3);
            }))];
            if (rv.updateRemoteRTPCapabilities(this.store.sessionId, { mids: e2, localCodecs: n2, remoteCodecs: this.remoteCodecs }), !this.remoteSDP)
              return void KC.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(n2, ", codecs: ").concat(t2));
            if (this.remoteSDP.updateRemoteCodec(e2, t2, this.store.codec)) {
              const e3 = await this.peerConnection.createOffer(), t3 = this.logSDPExchange(e3.sdp || "", "offer", "local", "muteLocal");
              await this.peerConnection.setLocalDescription(e3);
              const i3 = this.remoteSDP.toString();
              null == t3 || t3(i3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i3 });
            } else
              KC.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
          }
          async updateRemoteConnect(e2) {
            var t2, i2, n2, r2;
            (null === (t2 = this.remoteSDP) || void 0 === t2 || t2.updateRemoteRTPCapabilities(e2), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0) && (null === (r2 = this.remoteSDP) || void 0 === r2 || r2.updateRemoteCodec([], this.remoteCodecs, this.store.codec));
            null === (i2 = this.remoteSDP) || void 0 === i2 || i2.preloadRemoteMedia(2);
            const s2 = null === (n2 = this.remoteSDP) || void 0 === n2 ? void 0 : n2.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
            const o2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(o2), KC.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.");
          }
          send(e2, t2, i2) {
            var n2 = this;
            return BP(function* () {
              const r2 = yield jP(n2.mutex.lock("From NVExtentionsConnection.send"));
              try {
                if (!n2.remoteSDP)
                  throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created");
                const s2 = [];
                e2.forEach((e3) => {
                  const t3 = n2.peerConnection.addTransceiver(e3._mediaStreamTrack, { direction: "sendonly" });
                  s2.push(t3);
                }), Rg() && true === kC("SIMULCAST") && (yield jP(n2.applySimulcastForFirefox(s2, e2)));
                const o2 = yield jP(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e2.length), c2 = n2.mungSendOfferSDP(o2.sdp, e2, a2), d2 = KP.parse(c2), l2 = a2.map((e3) => {
                  const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e3);
                  if (!t3)
                    throw new Error("Cannot extract ssrc from mediaDescription.");
                  return XP(t3, kC("USE_PUB_RTX"));
                });
                let h2;
                try {
                  h2 = yield l2;
                } catch (r3) {
                  h2 = [], n2.remoteSDP.receive(e2, t2, i2, h2);
                  const s3 = n2.remoteSDP.toString();
                  throw yield jP(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield jP(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: s3 })), yield jP(n2.stopSending(a2, true)), r3;
                }
                n2.remoteSDP.receive(e2, t2, i2, h2);
                const u2 = n2.remoteSDP.toString(), p2 = n2.logSDPExchange(c2, "offer", "local", "send");
                return yield jP(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield jP(n2.applySimulcastEncodings(s2, e2)), yield jP(n2.applySendEncodings(s2, e2)), null == p2 || p2(u2), yield jP(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: u2 })), s2.map((e3, t3) => {
                  const i3 = a2[t3];
                  return { localSSRC: l2[t3], id: i3, transceiver: e3 };
                });
              } catch (e3) {
                throw e3 instanceof xv ? e3 : new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.send failed; ".concat(e3.toString()));
              } finally {
                r2();
              }
            })();
          }
          async stopSending(e2, t2) {
            const i2 = t2 ? void 0 : await this.mutex.lock("From NVExtentionsConnection.stopSending");
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created");
              const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e2.indexOf(t4.mid));
              if (t3.length !== e2.length)
                throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.");
              t3.map((e3) => {
                var t4;
                e3.direction = "inactive", null === (t4 = e3.stop) || void 0 === t4 || t4.call(e3);
              });
              const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
              await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e2);
              const s2 = this.remoteSDP.toString();
              null == r2 || r2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.stopSending failed; ".concat(e3.toString()));
            } finally {
              i2 && i2();
            }
          }
          async createDataChannels(e2, t2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.createDataChannels before remote SDP created");
              let i2 = this.dataStreamChannelMap.get(e2);
              return i2 && "open" === i2.readyState ? KC.debug("[P2PConnection] Channels are already available and can be reused directly.") : (i2 = this.peerConnection.createDataChannel("datastream-channel", { ordered: false, maxRetransmits: kC("DATASTREAM_MAX_RETRANSMITS") }), i2.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e2, i2)), void t2.forEach((e3) => {
                e3._updateOriginDataChannel(i2);
              });
            } catch (e3) {
              throw e3 instanceof xv ? e3 : new xv(xg.DATACHANNEL_FAILED, "NVExtentionsConnection.createDataChannels failed; ".concat(e3.toString()));
            }
          }
          async stopDataChannels(e2) {
            try {
              const t2 = this.dataStreamChannelMap.get(e2);
              return null == t2 || t2.close(), void this.dataStreamChannelMap.delete(e2);
            } catch (e3) {
              throw e3 instanceof xv ? e3 : new xv(xg.DATACHANNEL_FAILED, "NVExtentionsConnection.stopDataChannels failed; ".concat(e3.toString()));
            }
          }
          async receive(e2, t2, i2, n2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e2, " before remoteSDP created."));
              const { mid: r2, needExchangeSDP: s2 } = this.remoteSDP.send(e2, t2, i2, n2);
              if (s2) {
                const t3 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t3, "offer", "remote", "receive");
                await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
                const n3 = await this.peerConnection.createAnswer(), s3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e2);
                null == i3 || i3(s3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: s3 }), KC.debug("[NVExtentionsConnection] receive ".concat(e2, " by exchanging SDP."));
              } else
                KC.debug("[NVExtentionsConnection] receive ".concat(e2, " no need to exchange SDP."));
              const o2 = this.peerConnection.getTransceivers().find((e3) => e3.mid === r2);
              if (!o2)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: o2.receiver.track, id: r2 };
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e3.toString()));
            }
          }
          async batchReceive(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.");
              const { mids: t2, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e2);
              if (i2) {
                const e3 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e3, "offer", "remote", "receive");
                await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e3 });
                const i3 = await this.peerConnection.createAnswer();
                null == t3 || t3(i3.sdp || ""), await this.peerConnection.setLocalDescription(i3), KC.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.");
              } else
                KC.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP.");
              return t2.map((e3) => {
                const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e3);
                if (!t3)
                  throw new Error("Cannot get transceiver after setLocalDescription.");
                return { track: t3.receiver.track, id: e3 };
              });
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e3.toString()));
            }
          }
          async stopReceiving(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.");
              this.remoteSDP.stopSending(e2);
              const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const n2 = await this.peerConnection.createAnswer();
              null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection stopReceiving failed; ".concat(e3.toString()));
            }
          }
          async muteRemote(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e2, " before remote SDP created."));
              this.remoteSDP.mute(e2);
              const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const n2 = await this.peerConnection.createAnswer();
              null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteRemote failed; ".concat(e3.toString()));
            }
          }
          async unmuteRemote(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e2, " before remote SDP created."));
              this.remoteSDP.unmute(e2);
              const t2 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const n2 = await this.peerConnection.createAnswer();
              null == i2 || i2(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteRemote failed; ".concat(e3.toString()));
            }
          }
          async muteLocal(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created.");
              const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e2.indexOf(t3.mid));
              if (t2.length !== e2.length)
                throw new Error("Transceivers' length doesn't match mids' length.");
              t2.map((e3) => {
                e3.direction = "inactive";
              });
              const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
              await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e2);
              const r2 = this.remoteSDP.toString();
              null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteLocal failed; ".concat(e3.toString()));
            }
          }
          async unmuteLocal(e2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.");
              const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e2.indexOf(t3.mid));
              if (t2.length !== e2.length)
                throw new Error("Transceivers' length doesn't match mids' length.");
              t2.map(async (e3, t3) => {
                e3.direction = "sendonly";
              });
              const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
              await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e2);
              const r2 = this.remoteSDP.toString();
              null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteLocal failed; ".concat(e3.toString()));
            }
          }
          restartICE(e2) {
            var t2 = this;
            return BP(function* () {
              const i2 = yield jP(t2.mutex.lock("From NVExtentionsConnection.restartICE"));
              try {
                if (!t2.remoteSDP)
                  throw new Error("Cannot restartICE before remoteSDP created.");
                if (_A().supportPCSetConfiguration) {
                  const i3 = t2.peerConnection.getConfiguration(), n3 = e2 === uI.RELAY ? "relay" : "all";
                  i3.iceTransportPolicy !== n3 && (KC.debug("restartICE change iceTransportPolicy from [".concat(i3.iceTransportPolicy, "] to [").concat(n3, "]")), i3.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i3));
                } else if (e2 === uI.RELAY)
                  return;
                e2 !== uI.RELAY && t2.remoteSDP.updateCandidates(e2);
                const n2 = yield jP(t2.peerConnection.createOffer({ iceRestart: true }));
                if (!n2.sdp)
                  throw new Error("Cannot restartICE because restart offer SDP does not exist.");
                const r2 = zP(n2.sdp), { remoteIceParameters: s2 } = yield r2.iceParameters;
                t2.remoteSDP.restartICE(s2);
                const o2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
                yield jP(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(o2), yield jP(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 }));
              } catch (e3) {
                KC.warning("restart ICE failed, abort operation", e3);
              } finally {
                i2();
              }
            })();
          }
          close() {
            var e2;
            null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear();
          }
          getStats() {
            return this.statsFilter.getStats();
          }
          getRemoteVideoIsReady(e2) {
            return this.statsFilter.getVideoIsReady(e2);
          }
          async updateEncoderConfig(e2, t2) {
            try {
              if (!this.remoteSDP)
                throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.");
              const i2 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i2.sdp, [t2], [e2]);
              this.remoteSDP.updateRecvMedia(e2, t2);
              const r2 = this.remoteSDP.toString(), s2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
              await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == s2 || s2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
            } catch (e3) {
              throw new xv(xg.EXCHANGE_SDP_FAILED, e3.toString());
            }
          }
          async updateSendParameters(e2, t2) {
            const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e2);
            1 === i2.length && (this.isVP8Simulcast(t2) ? Rg() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
          }
          setStatsRemoteVideoIsReady(e2, t2) {
            this.statsFilter.setVideoIsReady2(e2, t2);
          }
          async replaceTrack(e2, t2) {
            const i2 = this.peerConnection.getTransceivers().find((e3) => e3.mid === t2);
            i2 && await i2.sender.replaceTrack(e2._mediaStreamTrack);
          }
          getP2PConnectionParams() {
            var e2;
            if (null === (e2 = this.peerConnection.currentLocalDescription) || void 0 === e2 || !e2.sdp || !this.localCapabilities)
              throw new Error();
            return ek(ek({}, zP(this.peerConnection.currentLocalDescription.sdp)), {}, { rtpCapabilities: this.localCapabilities });
          }
          bindPCEvents() {
            this.peerConnection.oniceconnectionstatechange = () => {
              var e2;
              null === (e2 = this.onICEConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.iceConnectionState);
            }, this.peerConnection.onconnectionstatechange = () => {
              var e2;
              null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.connectionState);
            }, this.peerConnection.onicecandidate = (e2) => {
              e2.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, KC.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
            }, setTimeout(() => {
              this.allCandidatesReceived || (this.allCandidatesReceived = true, KC.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
            }, kC("CANDIDATE_TIMEOUT"));
          }
          unbindPCEvents() {
            this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
          }
          static resolvePCConfiguration(e2) {
            const t2 = { iceServers: [] };
            return e2.iceServers ? t2.iceServers = e2.iceServers : e2.turnServer && "off" !== e2.turnServer.mode && (_T(e2.turnServer.servers) ? t2.iceServers = e2.turnServer.servers : (t2.iceServers && t2.iceServers.push(...tk.turnServerConfigToIceServers(e2.turnServer.servers)), kC("USE_TURN_SERVER_OF_GATEWAY") && t2.iceServers && e2.turnServer.serversFromGateway && t2.iceServers.push(...tk.turnServerConfigToIceServers(e2.turnServer.serversFromGateway)), kC("FORCE_TURN_TCP") ? t2.iceTransportPolicy = "relay" : e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).forEach((e3) => {
              e3.forceturn && (t2.iceTransportPolicy = "relay");
            }))), t2;
          }
          static turnServerConfigToIceServers(e2) {
            const t2 = [];
            return e2.forEach((e3) => {
              e3.security ? e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turns:".concat(_D(e3.turnServerURL), ":").concat(e3.tcpport, "?transport=tcp") }) : (e3.udpport && !kC("FORCE_TURN_TCP") && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.udpport, "?transport=udp") }), e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }));
            }), t2;
          }
          async applySendEncodings(e2, t2) {
            try {
              if (!_A().supportSetRtpSenderParameters)
                return;
              if (e2.length !== t2.length)
                return;
              for (let l2 = 0; l2 < e2.length; l2++) {
                const h2 = e2[l2], u2 = t2[l2];
                if (u2 && u2 instanceof Sb) {
                  var i2, n2, r2;
                  if (this.isVP8Simulcast(u2))
                    continue;
                  const e3 = {}, t3 = {};
                  switch (u2._optimizationMode) {
                    case "motion":
                      e3.degradationPreference = "maintain-framerate";
                      break;
                    case "detail":
                      e3.degradationPreference = "maintain-resolution";
                      break;
                    default:
                      e3.degradationPreference = "balanced";
                  }
                  var s2, o2, a2, c2;
                  if (null !== (i2 = u2._encoderConfig) && void 0 !== i2 && i2.bitrateMax)
                    t3.maxBitrate = 1e3 * (null === (s2 = u2._encoderConfig) || void 0 === s2 ? void 0 : s2.bitrateMax);
                  if (Pr(n2 = u2._hints).call(n2, ky.LOW_STREAM))
                    null !== (o2 = u2._encoderConfig) && void 0 !== o2 && o2.frameRate && (t3.maxFramerate = mD(u2._encoderConfig.frameRate)), null !== (a2 = u2._encoderConfig) && void 0 !== a2 && a2.scaleResolutionDownBy && (null === (c2 = u2._encoderConfig) || void 0 === c2 ? void 0 : c2.scaleResolutionDownBy) > 1 && (t3.scaleResolutionDownBy = u2._encoderConfig.scaleResolutionDownBy);
                  if (kC("DSCP_TYPE") && kg()) {
                    var d2;
                    const e4 = kC("DSCP_TYPE");
                    Pr(d2 = ["very-low", "low", "medium", "high"]).call(d2, e4) && (t3.networkPriority = e4);
                  }
                  const l3 = h2.sender.getParameters(), p2 = null === (r2 = l3.encodings) || void 0 === r2 ? void 0 : r2[0];
                  Rg() && !p2 && (e3.encodings = [t3]), p2 && Object.assign(p2, t3), Object.assign(l3, e3), await h2.sender.setParameters(l3);
                }
              }
            } catch (e3) {
              KC.debug("Apply RTPSendEncodings failed.");
            }
          }
          mungSendOfferSDP(e2, t2, i2) {
            const n2 = KP.parse(e2);
            return t2.forEach((e3, t3) => {
              const r2 = i2[t3], s2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === r2);
              s2 && ($P(s2, e3), rL(s2, e3, this.store.codec));
            }), KP.print(n2);
          }
          mungReceiveAnswerSDP(e2, t2, i2) {
            const n2 = KP.parse(e2), r2 = n2.mediaDescriptions.find((e3) => e3.attributes.mid === t2);
            return r2 && i2 === hI.AUDIO && "audio" === r2.media.mediaType && cL(r2), this.useXR && dL(n2), KP.print(n2);
          }
          bindStatsEvents() {
            this.statsFilter.onFirstAudioReceived = (e2) => {
              var t2;
              null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstVideoReceived = (e2) => {
              var t2;
              null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstAudioDecoded = (e2) => {
              var t2;
              null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstVideoDecoded = (e2, t2, i2) => {
              var n2;
              null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e2, t2, i2);
            }, this.statsFilter.onSelectedLocalCandidateChanged = (e2, t2) => {
              var i2;
              null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
            }, this.statsFilter.onSelectedRemoteCandidateChanged = (e2, t2) => {
              var i2;
              null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
            }, this.statsFilter.onFirstVideoDecodedTimeout = (e2) => {
              var t2;
              null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e2);
            };
          }
          unbindStatsEvents() {
            this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
          }
          async applySimulcastForFirefox(e2, t2) {
            if (e2.length === t2.length)
              for (let a2 = 0; a2 < e2.length; a2++) {
                var i2, n2, r2, s2, o2;
                const c2 = e2[a2], d2 = t2[a2];
                if (d2 instanceof Sb && !Pr(i2 = d2._hints).call(i2, ky.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (s2 = d2._scalabilityMode) && void 0 !== s2 && s2.numSpatialLayers && (null === (o2 = d2._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                  const e3 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                  e3.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
                  const i3 = c2.sender.getParameters();
                  await c2.sender.setParameters(Object.assign(i3, e3));
                }
              }
          }
          async applySimulcastEncodings(e2, t2) {
            if (!Rg() && e2.length === t2.length)
              for (let i2 = 0; i2 < e2.length; i2++) {
                const n2 = t2[i2];
                if (n2 instanceof Sb && this.isVP8Simulcast(n2)) {
                  const t3 = e2[i2], r2 = {}, s2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                  r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: s2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: s2.medium, scaleResolutionDownBy: 4 }];
                  const o2 = t3.sender.getParameters();
                  await t3.sender.setParameters(Object.assign(o2, r2));
                }
              }
          }
          isVP8Simulcast(e2) {
            var t2, i2, n2, r2, s2;
            return !!(e2 instanceof Sb && kC("SIMULCAST") && "vp8" === this.store.codec && !Pr(t2 = e2._hints).call(t2, ky.LOW_STREAM) && null !== (i2 = e2._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e2._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e2._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (s2 = e2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1);
          }
          logSDPExchange(e2, t2, i2, n2) {
            if (kC("SDP_LOGGING"))
              return KC.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during NVExtentionsConnection.").concat(n2, "\n"), e2), "offer" === t2 ? (e3) => {
                this.logSDPExchange(e3, "answer", "local" === i2 ? "remote" : "local", n2);
              } : void 0;
          }
          async getRemoteSSRC(e2) {
            if (!this.remoteSDP)
              return;
            const t2 = this.remoteSDP.getSSRC(e2);
            return null == t2 ? void 0 : t2[0].ssrcId;
          }
          setConfiguration(e2) {
            if (_A().supportPCSetConfiguration) {
              const t2 = tk.resolvePCConfiguration(e2);
              this.peerConnection.setConfiguration(t2);
            }
          }
        }
        function ik(e2, t2, i2) {
          const n2 = e2[t2];
          if ("function" != typeof n2)
            throw new Error("Cannot use mutex on object property.");
          return i2.value = async function() {
            const e3 = this.mutex, i3 = await e3.lock("From NVExtentionsConnection.".concat(t2));
            try {
              for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++)
                s2[o2] = arguments[o2];
              return await n2.apply(this, s2);
            } finally {
              i3();
            }
          }, i2;
        }
        function nk(e2) {
          var t2, i2, n2, r2 = 2;
          for ("undefined" != typeof Symbol && (i2 = WP, n2 = Symbol.iterator); r2--; ) {
            if (i2 && null != (t2 = e2[i2]))
              return t2.call(e2);
            if (n2 && null != (t2 = e2[n2]))
              return new rk(t2.call(e2));
            i2 = "@@asyncIterator", n2 = "@@iterator";
          }
          throw new TypeError("Object is not async iterable");
        }
        function rk(e2) {
          function t2(e3) {
            if (Object(e3) !== e3)
              return tg.reject(new TypeError(e3 + " is not an object."));
            var t3 = e3.done;
            return tg.resolve(e3.value).then(function(e4) {
              return { value: e4, done: t3 };
            });
          }
          return rk = function(e3) {
            this.s = e3, this.n = e3.next;
          }, rk.prototype = { s: null, n: null, next: function() {
            return t2(this.n.apply(this.s, arguments));
          }, return: function(e3) {
            var i2 = this.s.return;
            return void 0 === i2 ? tg.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
          }, throw: function(e3) {
            var i2 = this.s.return;
            return void 0 === i2 ? tg.reject(e3) : t2(i2.apply(this.s, arguments));
          } }, new rk(e2);
        }
        Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [Object, Object, Array, Object, String, String]), Uv("design:returntype", tg)], tk.prototype, "connect", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [Array, Array]), Uv("design:returntype", tg)], tk.prototype, "updateRemoteRTPCapabilities", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], tk.prototype, "updateRemoteConnect", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [Object, Array]), Uv("design:returntype", tg)], tk.prototype, "createDataChannels", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [String, Array, String, Object]), Uv("design:returntype", tg)], tk.prototype, "receive", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], tk.prototype, "batchReceive", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], tk.prototype, "stopReceiving", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], tk.prototype, "muteRemote", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], tk.prototype, "unmuteRemote", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], tk.prototype, "muteLocal", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], tk.prototype, "unmuteLocal", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], tk.prototype, "close", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], tk.prototype, "updateEncoderConfig", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], tk.prototype, "updateSendParameters", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [iA, String]), Uv("design:returntype", tg)], tk.prototype, "replaceTrack", null), Mv([ik, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], tk.prototype, "getRemoteSSRC", null);
        class sk extends PI {
          get currentLocalDescription() {
            return this.peerConnection.currentLocalDescription;
          }
          get currentRemoteDescription() {
            return this.peerConnection.currentRemoteDescription;
          }
          get peerConnectionState() {
            return this.peerConnection.connectionState;
          }
          get iceConnectionState() {
            return this.peerConnection.iceConnectionState;
          }
          constructor(e2, t2) {
            super(e2, t2), nu(this, "store", void 0), nu(this, "peerConnection", void 0), nu(this, "cname", void 0), nu(this, "mutex", new YT("DataChannelConnection-mutex")), nu(this, "dataChannel", void 0), nu(this, "_p2pConnection", void 0), nu(this, "establishPromise", void 0), nu(this, "_nvMedia", void 0), this.store = t2, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(sk.resolvePCConfiguration(e2), { optional: [{ googDscp: true }] }), this.dataChannel = this.peerConnection.createDataChannel("agora-signal", { ordered: false, maxPacketLifeTime: 50 }), this.dataChannel.binaryType = "arraybuffer", this._p2pConnection = new tk(e2, t2, this.peerConnection), this.bindPCEvents(), this.establishPromise = this._p2pConnection.establishPromise;
          }
          async establish() {
            var e2;
            const t2 = null === (e2 = this._nvMedia) || void 0 === e2 ? void 0 : e2.getLocalRtpCapabilities();
            return await this._p2pConnection.establish(t2);
          }
          getP2PConnectionParams() {
            return this._p2pConnection.getP2PConnectionParams();
          }
          async connect(e2, t2, i2, n2, r2, s2) {
            return this.cname = s2, await this._p2pConnection.connect(e2, t2, i2, n2, r2, s2), await new tg((e3, t3) => {
              const n3 = setTimeout(() => {
                this.closeSignal(), t3(new xv(xg.DATACHANNEL_CONNECTION_TIMEOUT, "Datachannel connection timed out, candidates: ".concat(JSON.stringify(i2))));
              }, 2e3);
              this.dataChannel.onopen = () => {
                if ("open" === this.dataChannel.readyState)
                  return clearTimeout(n3), void e3();
              }, this.dataChannel.onerror = (e4) => {
                this.closeSignal(), t3(e4);
              };
            }), { transmitter: this.dataChannel, close: this.closeSignal.bind(this) };
          }
          async updateRemoteRTPCapabilities(e2, t2) {
            return this._p2pConnection.updateRemoteRTPCapabilities(e2, t2);
          }
          send(e2, t2, i2) {
            var n2 = this;
            return BP(function* () {
              const r2 = yield jP(n2.mutex.lock("From DataChannelConnection.send"));
              try {
                return yield* GP(nk(n2._p2pConnection.send(e2, t2, i2)));
              } finally {
                r2();
              }
            })();
          }
          async stopSending(e2, t2) {
            return this._p2pConnection.stopSending(e2, t2);
          }
          async createDataChannels(e2, t2) {
            return this._p2pConnection.createDataChannels(e2, t2);
          }
          async stopDataChannels(e2) {
            return this._p2pConnection.stopDataChannels(e2);
          }
          async receive(e2, t2, i2, n2) {
            return this._nvMedia ? (KC.debug("[DataChannelConnection] receive ".concat(e2, " by DataChannel.")), await this._nvMedia.reveiveByRTCMedia(e2, t2, this.cname)) : (KC.debug("[DataChannelConnection] receive ".concat(e2, " by WebRTC.")), await this._p2pConnection.receive(e2, t2, i2, n2));
          }
          async batchReceive(e2) {
            return [...await this._p2pConnection.batchReceive(e2)];
          }
          async stopReceiving(e2) {
            return await this._p2pConnection.stopReceiving(e2);
          }
          async muteRemote(e2) {
            return await this._p2pConnection.muteRemote(e2);
          }
          async unmuteRemote(e2) {
            return await this._p2pConnection.unmuteRemote(e2);
          }
          async muteLocal(e2) {
            return await this._p2pConnection.muteLocal(e2);
          }
          async unmuteLocal(e2) {
            return await this._p2pConnection.unmuteLocal(e2);
          }
          restartICE(e2) {
            var t2 = this;
            return BP(function* () {
              return yield* GP(nk(t2._p2pConnection.restartICE(e2)));
            })();
          }
          close() {
            var e2;
            null === (e2 = this._nvMedia) || void 0 === e2 || e2.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection);
          }
          getStats() {
            return this._p2pConnection.getStats();
          }
          getRemoteVideoIsReady(e2) {
            return this._p2pConnection.getRemoteVideoIsReady(e2);
          }
          updateRemoteConnect(e2) {
            var t2;
            null === (t2 = this._nvMedia) || void 0 === t2 || t2.setRemoteRtpCapabilities(e2), this._p2pConnection.updateRemoteConnect(e2);
          }
          async updateEncoderConfig(e2, t2) {
            return await this._p2pConnection.updateEncoderConfig(e2, t2);
          }
          async updateSendParameters(e2, t2) {
            return await this._p2pConnection.updateSendParameters(e2, t2);
          }
          setStatsRemoteVideoIsReady(e2, t2) {
            this._p2pConnection.setStatsRemoteVideoIsReady(e2, t2);
          }
          async replaceTrack(e2, t2) {
            return await this._p2pConnection.replaceTrack(e2, t2);
          }
          async getRemoteSSRC(e2) {
            return this._p2pConnection.getRemoteSSRC(e2);
          }
          logSDPExchange(e2, t2, i2, n2) {
            if (kC("SDP_LOGGING"))
              return KC.upload("exchanging ".concat(i2, " ").concat(t2, " SDP during DataChannelConnection.").concat(n2, "\n"), e2), "offer" === t2 ? (e3) => {
                this.logSDPExchange(e3, "answer", "local" === i2 ? "remote" : "local", n2);
              } : void 0;
          }
          static resolvePCConfiguration(e2) {
            const t2 = { iceServers: [] };
            return e2.iceServers ? t2.iceServers = e2.iceServers : e2.turnServer && "off" !== e2.turnServer.mode && (_T(e2.turnServer.servers) ? t2.iceServers = e2.turnServer.servers : (t2.iceServers && t2.iceServers.push(...sk.turnServerConfigToIceServers(e2.turnServer.servers)), kC("USE_TURN_SERVER_OF_GATEWAY") && t2.iceServers && e2.turnServer.serversFromGateway && t2.iceServers.push(...sk.turnServerConfigToIceServers(e2.turnServer.serversFromGateway)), kC("FORCE_TURN_TCP") ? t2.iceTransportPolicy = "relay" : e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).forEach((e3) => {
              e3.forceturn && (t2.iceTransportPolicy = "relay");
            }))), t2;
          }
          static turnServerConfigToIceServers(e2) {
            const t2 = [];
            return e2.forEach((e3) => {
              e3.security ? e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turns:".concat(_D(e3.turnServerURL), ":").concat(e3.tcpport, "?transport=tcp") }) : (e3.udpport && !kC("FORCE_TURN_TCP") && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.udpport, "?transport=udp") }), e3.tcpport && t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=tcp") }));
            }), t2;
          }
          bindPCEvents() {
            this._p2pConnection.onICEConnectionStateChange = (e2) => {
              var t2;
              return null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onConnectionStateChange = (e2) => {
              var t2;
              return null === (t2 = this.onConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onDTLSTransportStateChange = (e2) => {
              var t2;
              return null === (t2 = this.onDTLSTransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onDTLSTransportError = (e2) => {
              var t2;
              return null === (t2 = this.onDTLSTransportError) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onICETransportStateChange = (e2) => {
              var t2;
              return null === (t2 = this.onICETransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onFirstAudioReceived = (e2) => {
              var t2;
              return null === (t2 = this.onFirstAudioReceived) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onFirstVideoReceived = (e2) => {
              var t2;
              return null === (t2 = this.onFirstVideoReceived) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onFirstAudioDecoded = (e2) => {
              var t2;
              return null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onFirstVideoDecoded = (e2, t2, i2) => {
              var n2;
              return null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 ? void 0 : n2.call(this, e2, t2, i2);
            }, this._p2pConnection.onFirstVideoDecodedTimeout = (e2) => {
              var t2;
              return null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 ? void 0 : t2.call(this, e2);
            }, this._p2pConnection.onSelectedLocalCandidateChanged = (e2, t2) => {
              var i2;
              return null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 ? void 0 : i2.call(this, e2, t2);
            }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e2, t2) => {
              var i2;
              return null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 ? void 0 : i2.call(this, e2, t2);
            };
          }
          closeSignal() {
            this.dataChannel.close(), this.peerConnection.close();
          }
          unbindConnectionEvents(e2) {
            e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0;
          }
          setConfiguration(e2) {
            this._p2pConnection.setConfiguration(e2);
          }
        }
        function ok(e2, t2, i2) {
          const n2 = e2[t2];
          if ("function" != typeof n2)
            throw new Error("Cannot use mutex on object property.");
          return i2.value = async function() {
            const e3 = this.mutex, i3 = await e3.lock("From DataChannelConnection.".concat(t2));
            try {
              for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++)
                s2[o2] = arguments[o2];
              return await n2.apply(this, s2);
            } finally {
              i3();
            }
          }, i2;
        }
        function ak(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function ck(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? ak(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ak(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [Object, Object, Array, Object, String, String]), Uv("design:returntype", tg)], sk.prototype, "connect", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [Array, Array]), Uv("design:returntype", tg)], sk.prototype, "updateRemoteRTPCapabilities", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [Object, Array]), Uv("design:returntype", tg)], sk.prototype, "createDataChannels", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [String, Array, String, Object]), Uv("design:returntype", tg)], sk.prototype, "receive", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], sk.prototype, "stopReceiving", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], sk.prototype, "muteRemote", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], sk.prototype, "unmuteRemote", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], sk.prototype, "muteLocal", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], sk.prototype, "unmuteLocal", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], sk.prototype, "close", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], sk.prototype, "updateEncoderConfig", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], sk.prototype, "updateSendParameters", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [iA, String]), Uv("design:returntype", tg)], sk.prototype, "replaceTrack", null), Mv([ok, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], sk.prototype, "getRemoteSSRC", null);
        class dk extends iT {
          constructor() {
            super(), nu(this, "uplinkStatsUploadInterval", void 0), nu(this, "uplinkRelatedStatsUploadInterval", void 0), nu(this, "uplinkDenoiserStatsUploadInterval", void 0), nu(this, "transportStatsUploadInterval", void 0), nu(this, "uplinkExtensionStatsUploadInterval", void 0), nu(this, "downlinkExtensionStatsUploadInterval", void 0), nu(this, "extensionUsageStatsUploadInterval", void 0), nu(this, "downlinkStatsUploadInterval", void 0), nu(this, "downlinkRelatedStatsUploadInterval", void 0), nu(this, "lastStats", void 0), nu(this, "uploadUnplinkStarted", false), nu(this, "uploadDownlinkStarted", false), nu(this, "uploadTransportStarted", false), nu(this, "uploadExtensionUsageStarted", false), nu(this, "requestStats", void 0), nu(this, "requestTransportStats", void 0), nu(this, "requestLocalMedia", void 0), nu(this, "requestRemoteMedia", void 0), nu(this, "requestAllTracks", void 0), nu(this, "requestVideoIsReady", void 0), nu(this, "requestUpload", void 0);
          }
          startUploadTransportStats(e2) {
            this.uploadTransportStarted || (this.uploadTransportStarted = true, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = window.setInterval(() => {
              var t2;
              const i2 = null === (t2 = this.requestStats) || void 0 === t2 ? void 0 : t2.call(this);
              if (i2) {
                const t3 = gD(i2);
                if (e2) {
                  var n2;
                  const e3 = null === (n2 = this.requestStats) || void 0 === n2 ? void 0 : n2.call(this, true);
                  if (e3) {
                    const i3 = gD(e3);
                    t3.connectionType += i3.connectionType << 3;
                  }
                  t3.connectionType += 110;
                } else
                  t3.connectionType += 100;
                AT(() => {
                  var e3;
                  null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, Sv.TRANSPORT_STATS, t3);
                });
              }
            }, 1e3));
          }
          startUploadExtensionUsageStats() {
            if (this.uploadExtensionUsageStarted)
              return;
            this.uploadExtensionUsageStarted = true, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval);
            const e2 = /* @__PURE__ */ new Map();
            this.extensionUsageStatsUploadInterval = window.setInterval(async () => {
              var t2, i2, n2;
              const r2 = Date.now(), s2 = { connectionInterval: kC("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: r2 };
              let o2 = [];
              const a2 = (null === (t2 = this.requestAllTracks) || void 0 === t2 ? void 0 : t2.call(this)) || [];
              for (const e3 of a2)
                !e3.muted && e3.enabled && (o2 = o2.concat(await e3.getProcessorUsage()));
              const c2 = (null === (i2 = this.requestRemoteMedia) || void 0 === i2 ? void 0 : i2.call(this)) || [];
              for (const [e3, t3] of c2)
                t3.has(hI.VIDEO) && e3.videoTrack && (o2 = o2.concat(await e3.videoTrack.getProcessorUsage())), t3.has(hI.AUDIO) && e3.audioTrack && (o2 = o2.concat(await e3.audioTrack.getProcessorUsage()));
              if (0 === o2.length)
                return;
              s2.details = function(e3, t3) {
                const i3 = {};
                for (const { id: o3, value: a3, level: c3, direction: d3 } of e3) {
                  var n3;
                  const e4 = null !== (n3 = t3.get(o3)) && void 0 !== n3 ? n3 : 0, l3 = 2 === a3 ? e4 + kC("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e4;
                  var r3, s3;
                  t3.set(o3, l3), i3[o3] ? (2 === a3 && (i3[o3].value = a3), c3 > i3[o3].level && (i3[o3].level = c3), "remote" === d3 && (i3[o3].remoteUidCount += 1), i3[o3].totalTs = null !== (r3 = t3.get(o3)) && void 0 !== r3 ? r3 : 0) : i3[o3] = { value: a3, level: c3, remoteUidCount: "local" === d3 ? 0 : 1, totalTs: null !== (s3 = t3.get(o3)) && void 0 !== s3 ? s3 : 0 };
                }
                return Object.keys(i3).map((e4) => {
                  const { level: t4, value: n4, totalTs: r4 } = i3[e4];
                  return { id: e4, level: t4, value: n4, totalTs: r4 };
                });
              }(o2, e2);
              const d2 = Date.now(), l2 = d2 > r2 ? d2 : r2 + 1;
              null === (n2 = this.requestUpload) || void 0 === n2 || n2.call(this, Sv.EXTENSION_USAGE_STATS, { usageStats: s2, sendTs: l2 });
            }, kC("EXTENSION_USAGE_UPLOAD_INTERVAL"));
          }
          startUploadUplinkStats() {
            this.uploadUnplinkStarted || (this.uploadUnplinkStarted = true, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkStatsUploadInterval = window.setInterval(() => {
              var e2;
              const t2 = null === (e2 = this.requestStats) || void 0 === e2 ? void 0 : e2.call(this);
              t2 && (this.uploadUplinkStats(t2), this.lastStats = t2);
            }, 3e3), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkRelatedStatsUploadInterval = window.setInterval(() => {
              var e2;
              const t2 = null === (e2 = this.requestStats) || void 0 === e2 ? void 0 : e2.call(this);
              t2 && this.uploadRelatedUplinkStats(t2, this.lastStats), this.lastStats = t2;
            }, 1e3), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval = window.setInterval(() => {
              var e2;
              const t2 = null === (e2 = this.requestAllTracks) || void 0 === e2 ? void 0 : e2.call(this);
              t2 && this.uploadDenoiserStats(t2);
            }, 2e3), this.uplinkExtensionStatsUploadInterval && window.clearInterval(this.uplinkExtensionStatsUploadInterval), this.uplinkExtensionStatsUploadInterval = window.setInterval(() => {
              var e2;
              const t2 = null === (e2 = this.requestAllTracks) || void 0 === e2 ? void 0 : e2.call(this);
              t2 && this.uploadExtensionStats(t2);
            }, 2e3));
          }
          uploadUplinkStats(e2) {
            var t2;
            ((null === (t2 = this.requestLocalMedia) || void 0 === t2 ? void 0 : t2.call(this)) || []).forEach((t3) => {
              let [i2, { track: n2, ssrcs: r2 }] = t3;
              switch (i2) {
                case _I.LocalVideoLowTrack:
                case _I.LocalVideoTrack: {
                  const t4 = function(e3, t5, i3) {
                    var n3;
                    const r3 = t5.videoSend.find((t6) => t6.ssrc === e3);
                    if (!r3)
                      return null;
                    const s3 = { id: xT(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: r3.ssrc.toString() };
                    switch (s3.A_vstd = i3._originMediaStreamTrack && !i3._originMediaStreamTrack.enabled || i3._mediaStreamTrack && !i3._mediaStreamTrack.enabled ? "1" : "0", r3.sentFrame && (s3.A_fhs = r3.sentFrame.height.toString(), s3.A_frs = r3.sentFrame.frameRate.toString(), s3.A_fws = r3.sentFrame.width.toString()), r3.adaptionChangeReason) {
                      case "none":
                        s3.A_ac = "0";
                        break;
                      case "cpu":
                        s3.A_ac = "1";
                        break;
                      case "bandwidth":
                        s3.A_ac = "2";
                        break;
                      case "other":
                        s3.A_ac = "3";
                    }
                    return s3.A_lvps = $y[i3._player ? i3._player.videoElementStatus : "uninit"].toString(), s3.A_nr = null === (n3 = r3.nacksCount) || void 0 === n3 ? void 0 : n3.toString(), r3.avgEncodeMs && (s3.A_aem = r3.avgEncodeMs.toFixed(0).toString()), kC("P2P") && (r3.bytes && (s3.bytesSent = r3.bytes.toString()), "number" == typeof r3.packetsLost && (s3.packetsLost = r3.packetsLost.toString()), r3.packets && (s3.packetsSent = r3.packets.toString())), s3;
                  }(r2[0].ssrcId, e2, n2), s2 = i2 === _I.LocalVideoTrack ? function(e3, t5, i3) {
                    var n3, r3, s3, o3, a2, c2, d2, l2;
                    const h2 = t5.videoSend.find((t6) => t6.ssrc === e3);
                    if (!h2)
                      return null;
                    const u2 = { id: xT(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: h2.ssrc.toString() }, p2 = null !== (n3 = null !== (r3 = null === (s3 = h2.inputFrame) || void 0 === s3 ? void 0 : s3.height) && void 0 !== r3 ? r3 : null == i3 ? void 0 : i3._videoHeight) && void 0 !== n3 ? n3 : 0, _2 = null !== (o3 = null !== (a2 = null === (c2 = h2.inputFrame) || void 0 === c2 ? void 0 : c2.width) && void 0 !== a2 ? a2 : null == i3 ? void 0 : i3._videoWidth) && void 0 !== o3 ? o3 : 0, E2 = null !== (d2 = null === (l2 = h2.inputFrame) || void 0 === l2 ? void 0 : l2.frameRate) && void 0 !== d2 ? d2 : 0;
                    return p2 && (u2.A_fhi = p2 + ""), _2 && (u2.A_fwi = _2 + ""), E2 && (u2.A_fri = E2 + ""), u2;
                  }(r2[0].ssrcId, e2, n2) : null;
                  t4 && AT(() => {
                    var e3;
                    return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, Sv.PUBLISH_STATS, { stream_type: i2 === _I.LocalVideoLowTrack ? "low" : "high", stats: ck(ck({}, t4), s2) });
                  });
                  const o2 = function(e3) {
                    const t5 = { id: "bweforvideo", timestamp: new Date(e3.timestamp).toISOString(), type: "VideoBwe" };
                    return e3.bitrate.retransmit && (t5.A_rb = e3.bitrate.retransmit.toString()), e3.bitrate.targetEncoded && (t5.A_teb = e3.bitrate.targetEncoded.toString()), t5.A_aeb = e3.bitrate.actualEncoded.toString(), t5.A_tb = e3.bitrate.transmit.toString(), void 0 !== e3.sendBandwidth && (t5.A_asb = e3.sendBandwidth.toString()), t5;
                  }(e2);
                  o2 && setTimeout(() => {
                    var e3;
                    return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, Sv.PUBLISH_STATS, { stream_type: i2 === _I.LocalVideoLowTrack ? "low" : "high", stats: o2 });
                  }, 1e3);
                  break;
                }
                case _I.LocalAudioTrack: {
                  const t4 = function(e3, t5, i3) {
                    const n3 = t5.audioSend.find((t6) => t6.ssrc === e3);
                    if (!n3)
                      return null;
                    const r3 = { id: xT(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: n3.ssrc.toString() };
                    return r3.A_astd = i3._originMediaStreamTrack && !i3._originMediaStreamTrack.enabled || i3._mediaStreamTrack && !i3._mediaStreamTrack.enabled ? "1" : "0", n3.inputLevel ? r3.A_ail = Math.round(100 * n3.inputLevel).toString() : r3.A_ail = Math.round(100 * i3._source.getAccurateVolumeLevel()).toString(), r3.A_apil = Math.round(100 * i3._source.getAccurateVolumeLevel()).toString(), n3.aecReturnLoss && (r3.A_ecrl = Math.round(n3.aecReturnLoss).toString()), n3.aecReturnLossEnhancement && (r3.A_ecrle = Math.round(n3.aecReturnLossEnhancement).toString()), kC("P2P") && (n3.bytes && (r3.bytesSent = n3.bytes.toString()), "number" == typeof n3.packetsLost && (r3.packetsLost = n3.packetsLost.toString()), n3.packets && (r3.packetsSent = n3.packets.toString())), r3;
                  }(r2[0].ssrcId, e2, n2);
                  t4 && AT(() => {
                    var e3;
                    return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, Sv.PUBLISH_STATS, { stream_type: "high", stats: t4 });
                  });
                  break;
                }
              }
            });
          }
          uploadRelatedUplinkStats(e2, t2) {
            var i2;
            ((null === (i2 = this.requestLocalMedia) || void 0 === i2 ? void 0 : i2.call(this)) || []).filter((e3) => {
              let [t3] = e3;
              return t3 === _I.LocalVideoLowTrack || t3 === _I.LocalVideoTrack;
            }).forEach((t3) => {
              let [i3, { ssrcs: n2 }] = t3;
              const r2 = function(e3, t4) {
                const i4 = t4.videoSend.find((t5) => t5.ssrc === e3);
                return i4 ? { mediaType: "video", isVideoMute: false, frameRateInput: i4.inputFrame && i4.inputFrame.frameRate.toString(), frameRateSent: i4.sentFrame && i4.sentFrame.frameRate.toString(), googRtt: i4.rttMs.toString(), qpSumPerFrame: Math.floor(i4.qpSumPerFrame).toString() } : null;
              }(n2[0].ssrcId, e2);
              r2 && AT(() => {
                var e3;
                null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, Sv.PUBLISH_RELATED_STATS, { stream_type: i3 === _I.LocalVideoLowTrack ? "low" : "high", stats: r2 });
              });
            });
          }
          uploadDenoiserStats(e2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              const s2 = e2[r2];
              if (s2 instanceof $A) {
                var t2, i2, n2;
                const e3 = null === (t2 = (i2 = s2._external).getDenoiserStats) || void 0 === t2 ? void 0 : t2.call(i2);
                return void (e3 && (null === (n2 = this.requestUpload) || void 0 === n2 || n2.call(this, Sv.DENOISER_STATS, e3)));
              }
            }
          }
          uploadExtensionStats(e2) {
            for (let t2 = 0; t2 < e2.length; t2++) {
              e2[t2].getProcessorStats().forEach((e3) => {
                var t3;
                null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e3.type, e3.stats);
              });
            }
          }
          stopUploadUplinkStats() {
            this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkStatsUploadInterval = void 0, this.uplinkRelatedStatsUploadInterval = void 0, this.uplinkDenoiserStatsUploadInterval = void 0);
          }
          startUploadDownlinkStats() {
            if (this.uploadDownlinkStarted)
              return;
            let e2;
            this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
            let t2 = false;
            this.downlinkStatsUploadInterval = window.setInterval(() => {
              var i2;
              const n2 = null === (i2 = this.requestStats) || void 0 === i2 ? void 0 : i2.call(this, true);
              n2 && (this.uploadDownlinkStats(n2, t2, e2), e2 = n2), t2 = !t2;
            }, 3e3), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkRelatedStatsUploadInterval = window.setInterval(() => {
              var e3;
              const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this, true);
              t3 && (this.uploadRelatedDownlinkStats(t3, this.lastStats), this.lastStats = t3);
            }, 1e3), this.downlinkExtensionStatsUploadInterval && window.clearInterval(this.downlinkExtensionStatsUploadInterval), this.downlinkExtensionStatsUploadInterval = window.setInterval(() => {
              var e3;
              const t3 = null === (e3 = this.requestRemoteMedia) || void 0 === e3 ? void 0 : e3.call(this);
              t3 && this.uploadDownlinkExtensionStats(t3);
            }, 2e3);
          }
          uploadDownlinkStats(e2, t2, i2) {
            var n2;
            ((null === (n2 = this.requestRemoteMedia) || void 0 === n2 ? void 0 : n2.call(this)) || []).forEach((n3) => {
              let [r2, s2] = n3;
              if (s2.has(hI.VIDEO) && r2.videoTrack) {
                const n4 = r2.videoTrack ? function(e3, t3, i3, n5, r3) {
                  const s3 = t3.videoRecv.find((t4) => t4.ssrc === e3);
                  if (!s3)
                    return null;
                  const o2 = { id: xT(10, ""), timestamp: new Date(t3.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: s3.ssrc.toString() };
                  var a2, c2;
                  if (o2.bytesReceived = s3.bytes.toString(), o2.packetsLost = s3.packetsLost.toString(), o2.packetsReceived = s3.packets.toString(), s3.framesRateFirefox && (o2.A_frr = s3.framesRateFirefox.toString()), s3.receivedFrame ? (o2.A_frr = s3.receivedFrame.frameRate.toString(), o2.A_fhr = s3.receivedFrame.height.toString(), o2.A_fwr = s3.receivedFrame.width.toString()) : (o2.A_fhr = null === (a2 = n5._videoHeight) || void 0 === a2 ? void 0 : a2.toString(), o2.A_fwr = null === (c2 = n5._videoWidth) || void 0 === c2 ? void 0 : c2.toString()), o2.A_frd = s3.decodeFrameRate.toString(), s3.outputFrame && (o2.A_fro = s3.outputFrame.frameRate.toString()), void 0 !== s3.jitterBufferMs && (o2.A_jbm = Math.floor(s3.jitterBufferMs).toString()), void 0 !== s3.currentDelayMs && (o2.A_cdm = Math.floor(s3.currentDelayMs).toString()), o2.A_fs = s3.firsCount.toString(), o2.A_ns = s3.nacksCount.toString(), o2.A_ps = s3.plisCount.toString(), n5 && (o2.A_vrtd = n5._originMediaStreamTrack.enabled && n5._mediaStreamTrack.enabled ? "0" : "1"), n5._player && n5._player.freezeTimeCounterList.length > 0 && (o2.A_vrft = Math.round(n5._player.freezeTimeCounterList.splice(0, 1)[0]).toString()), r3 && n5._player && "visible" === db.visibility) {
                    const e4 = Math.min(6e3, n5._player.renderFreezeAccTime);
                    o2.A_vrrft = Math.round(e4).toString(), n5._player.renderFreezeAccTime = Math.max(0, n5._player.renderFreezeAccTime - e4);
                  }
                  if (o2.A_rvps = $y[n5._player ? n5._player.videoElementStatus : "uninit"].toString(), i3) {
                    const t4 = i3.videoRecv.find((t5) => t5.ssrc === e3);
                    if (t4 && void 0 !== s3.totalInterFrameDelay && void 0 !== s3.totalSquaredInterFrameDelay && void 0 !== t4.totalInterFrameDelay && void 0 !== t4.totalSquaredInterFrameDelay) {
                      const e4 = s3.totalInterFrameDelay - t4.totalInterFrameDelay, i4 = s3.totalSquaredInterFrameDelay - t4.totalSquaredInterFrameDelay, n6 = s3.framesDecodeCount - t4.framesDecodeCount, r4 = e4 / n6 * 1e3, a3 = Math.round(1e3 * Math.sqrt((i4 - Math.pow(e4, 2) / n6) / n6));
                      !isNaN(a3) && r4 + a3 > Math.max(3 * r4, r4 + 150) && (o2.A_ifdsd = a3.toString());
                    }
                  }
                  return o2;
                }(r2._videoSSRC, e2, i2, r2.videoTrack, t2) : void 0;
                n4 && AT(() => {
                  var e3;
                  return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, Sv.SUBSCRIBE_STATS, { stream_id: r2.uid, stats: n4 });
                });
              }
              if (s2.has(hI.AUDIO) && r2.audioTrack) {
                const t3 = r2.audioTrack ? function(e3, t4, i3, n4) {
                  const r3 = t4.audioRecv.find((t5) => t5.ssrc === e3);
                  if (!r3)
                    return null;
                  const s3 = { id: xT(10, ""), timestamp: new Date(t4.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: r3.ssrc.toString() };
                  if (s3.bytesReceived = r3.bytes.toString(), s3.packetsLost = r3.packetsLost.toString(), s3.packetsReceived = r3.packets.toString(), r3.outputLevel ? s3.A_aol = Math.round(100 * r3.outputLevel).toString() : s3.A_aol = Math.round(100 * n4._source.getAccurateVolumeLevel()).toString(), s3.A_apol = Math.round(100 * n4._source.getAccurateVolumeLevel()).toString(), n4 && (s3.A_artd = n4._originMediaStreamTrack.enabled && n4._mediaStreamTrack.enabled ? "0" : "1"), s3.A_jr = r3.jitterMs.toString(), s3.A_jbm = Math.floor(r3.jitterBufferMs).toString(), s3.A_cdm = Math.floor(r3.jitterBufferMs).toString(), s3.A_raps = $y[xA.getPlayerState(n4.getTrackId())].toString(), i3) {
                    const t5 = i3.audioRecv.find((t6) => t6.ssrc === e3);
                    if (t5) {
                      const e4 = r3.concealedSamples - t5.concealedSamples;
                      e4 > 0 && (s3.A_cs = Math.round(e4).toString());
                    }
                  }
                  return s3;
                }(r2._audioSSRC, e2, i2, r2.audioTrack) : void 0;
                t3 && AT(() => {
                  var e3;
                  return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, Sv.SUBSCRIBE_STATS, { stream_id: r2.uid, stats: t3 });
                });
              }
            });
          }
          uploadRelatedDownlinkStats(e2, t2) {
            var i2;
            ((null === (i2 = this.requestRemoteMedia) || void 0 === i2 ? void 0 : i2.call(this)) || []).forEach((i3) => {
              let [n2, r2] = i3;
              if (r2.has(hI.VIDEO) && n2.videoTrack) {
                var s2;
                const i4 = true === (n2._videoSSRC && (null === (s2 = this.requestVideoIsReady) || void 0 === s2 ? void 0 : s2.call(this, n2._videoSSRC)) || false), r3 = function(e3, t3, i5, n3, r4, s3) {
                  const o2 = i5.videoRecv.find((t4) => t4.ssrc === e3), a2 = r4 ? r4.videoRecv.find((t4) => t4.ssrc === e3) : void 0;
                  if (!o2)
                    return null;
                  const c2 = hD.isRemoteVideoFreeze(s3, o2, a2) && t3, d2 = { mediaType: "video", isVideoMute: false, peerId: n3, frameRateReceived: o2.receivedFrame && o2.receivedFrame.frameRate.toString(), frameRateDecoded: o2.decodedFrame && o2.decodedFrame.frameRate.toString(), isFreeze: c2, bytesReceived: o2.bytes.toString(), packetsReceived: o2.packets.toString(), packetsLost: o2.packetsLost.toString(), qpSumPerFrame: Math.floor(o2.qpSumPerFrame).toString() };
                  return o2.framesRateFirefox && (d2.frameRateDecoded = o2.framesRateFirefox.toString(), d2.frameRateReceived = o2.framesRateFirefox.toString()), d2;
                }(n2._videoSSRC, i4, e2, n2.uid, t2, n2.videoTrack);
                r3 && AT(() => {
                  var e3;
                  null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, Sv.SUBSCRIBE_RELATED_STATS, { stream_id: n2.uid, stats: r3 });
                });
              }
              if (r2.has(hI.AUDIO) && n2.audioTrack) {
                const t3 = function(e3, t4, i4, n3) {
                  const r3 = t4.audioRecv.find((t5) => t5.ssrc === e3);
                  if (!r3)
                    return null;
                  const s3 = hD.isRemoteAudioFreeze(n3);
                  return { mediaType: "audio", isAudioMute: false, peerId: i4, googJitterReceived: r3.jitterMs.toString(), isFreeze: s3, bytesReceived: r3.bytes.toString(), packetsReceived: r3.packets.toString(), packetsLost: r3.packetsLost.toString(), frameReceived: r3.receivedFrames.toString(), frameDropped: r3.droppedFrames.toString() };
                }(n2._audioSSRC, e2, n2.uid, n2.audioTrack);
                t3 && AT(() => {
                  var e3;
                  null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, Sv.SUBSCRIBE_RELATED_STATS, { stream_id: n2.uid, stats: t3 });
                });
              }
            });
          }
          stopUploadDownlinkStats() {
            this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkStatsUploadInterval = void 0, this.downlinkRelatedStatsUploadInterval = void 0);
          }
          stopUploadTransportStats() {
            this.uploadTransportStarted && (this.uploadTransportStarted = false, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = void 0);
          }
          stopUploadExtensionUsageStats() {
            this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval), this.extensionUsageStatsUploadInterval = void 0);
          }
          uploadDownlinkExtensionStats(e2) {
            e2.forEach((e3) => {
              let [t2, i2] = e3;
              if (i2.has(hI.VIDEO) && t2.videoTrack) {
                t2.videoTrack.getProcessorStats().forEach((e4) => {
                  var t3;
                  null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e4.type, e4.stats);
                });
              }
              if (i2.has(hI.AUDIO) && t2.audioTrack) {
                t2.audioTrack.getProcessorStats().forEach((e4) => {
                  var t3;
                  null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e4.type, e4.stats);
                });
              }
            });
          }
        }
        function lk(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function hk(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? lk(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : lk(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        function uk(e2) {
          var t2, i2, n2, r2 = 2;
          for ("undefined" != typeof Symbol && (i2 = WP, n2 = Symbol.iterator); r2--; ) {
            if (i2 && null != (t2 = e2[i2]))
              return t2.call(e2);
            if (n2 && null != (t2 = e2[n2]))
              return new pk(t2.call(e2));
            i2 = "@@asyncIterator", n2 = "@@iterator";
          }
          throw new TypeError("Object is not async iterable");
        }
        function pk(e2) {
          function t2(e3) {
            if (Object(e3) !== e3)
              return tg.reject(new TypeError(e3 + " is not an object."));
            var t3 = e3.done;
            return tg.resolve(e3.value).then(function(e4) {
              return { value: e4, done: t3 };
            });
          }
          return pk = function(e3) {
            this.s = e3, this.n = e3.next;
          }, pk.prototype = { s: null, n: null, next: function() {
            return t2(this.n.apply(this.s, arguments));
          }, return: function(e3) {
            var i2 = this.s.return;
            return void 0 === i2 ? tg.resolve({ value: e3, done: true }) : t2(i2.apply(this.s, arguments));
          }, throw: function(e3) {
            var i2 = this.s.return;
            return void 0 === i2 ? tg.reject(e3) : t2(i2.apply(this.s, arguments));
          } }, new pk(e2);
        }
        class _k extends iT {
          get state() {
            return this._state;
          }
          set state(e2) {
            const t2 = this._state;
            this._state = e2, this.emit(mI.StateChange, t2, this._state);
          }
          constructor(e2, t2) {
            super(), nu(this, "store", void 0), nu(this, "statsUploader", void 0), nu(this, "connection", void 0), nu(this, "localTrackMap", /* @__PURE__ */ new Map()), nu(this, "remoteUserMap", /* @__PURE__ */ new Map()), nu(this, "localDataChannels", []), nu(this, "remoteDataChannelMap", /* @__PURE__ */ new Map()), nu(this, "pendingLocalTracks", []), nu(this, "pendingRemoteTracks", []), nu(this, "pendingLocalDataChannels", []), nu(this, "pendingRemoteDataChannels", []), nu(this, "statsCollector", void 0), nu(this, "isPlanB", false), nu(this, "shouldForwardP2PCreation", void 0), nu(this, "iceFailedCount", 0), nu(this, "dtlsFailedCount", 0), nu(this, "mutex", new YT("P2PChannel-mutex")), nu(this, "_state", EI.Disconnected), nu(this, "_pcStatsUploadType", kC("NEW_ICE_RESTART") ? pI.FIRST_CONNECTION : pI.OLD_FIRST_CONNECTION), nu(this, "_isInRestartIce", false), nu(this, "_isStartRestartIce", false), nu(this, "_restartStates", ["disconnected", "failed"]), nu(this, "_restartTimer", void 0), nu(this, "_isFirstConnected", true), nu(this, "handleMuteLocalTrack", async (e3, t3, i2) => {
              const n2 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
              try {
                if (!this.connection || this.state !== EI.Connected)
                  return void i2(new Vg(xg.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
                const r2 = this.filterTobeMutedTracks(e3);
                if (0 === r2.length)
                  return void t3();
                const s2 = r2.find((e4) => "videoLowTrack" === e4[0]);
                if (s2) {
                  s2[1].track._originMediaStreamTrack.stop();
                }
                await this.connection.muteLocal(r2.map((e4) => {
                  let [, { id: t4 }] = e4;
                  return t4;
                }));
                const o2 = this.createMuteMessage(r2);
                await gT(this, mI.RequestMuteLocal, o2), t3();
              } catch (e4) {
                i2(e4);
              } finally {
                n2();
              }
            }), nu(this, "handleUnmuteLocalTrack", async (e3, t3, i2) => {
              const n2 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
              try {
                if (!this.connection || this.state !== EI.Connected)
                  return void i2(new Vg(xg.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
                const r2 = this.filterTobeUnmutedTracks(e3);
                if (0 === r2.length)
                  return void t3();
                const s2 = r2.find((e4) => "videoLowTrack" === e4[0]);
                if (s2) {
                  const t4 = s2[1];
                  if (t4.track._originMediaStreamTrack.stop(), !kC("DISABLE_DUAL_STREAM_USE_ENCODING") && _A().supportDualStreamEncoding) {
                    const i3 = e3._mediaStreamTrack.clone();
                    t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
                  } else {
                    const i3 = KL(e3, ST(this, mI.RequestLowStreamParameter));
                    t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3;
                  }
                  await new tg((e4, i3) => {
                    this.handleReplaceTrack(t4.track, e4, i3, true);
                  });
                }
                await this.connection.unmuteLocal(r2.map((e4) => {
                  let [, { id: t4 }] = e4;
                  return t4;
                }));
                const o2 = this.createUnmuteMessage(r2);
                await gT(this, mI.RequestUnmuteLocal, o2), t3();
              } catch (e4) {
                i2(e4);
              } finally {
                n2();
              }
            }), nu(this, "handleUpdateVideoEncoder", async (e3, t3, i2) => {
              const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
              try {
                const i3 = this.localTrackMap.get(_I.LocalVideoTrack);
                if (!this.connection || !i3 || i3.track !== e3 || this.state !== EI.Connected)
                  return void t3();
                const { id: r2, track: s2 } = i3;
                await this.connection.updateSendParameters(r2, s2), await this.connection.updateEncoderConfig(r2, s2), this.emit(mI.UpdateVideoEncoder, s2), t3();
              } catch (e4) {
                i2(e4);
              } finally {
                n2();
              }
            }), nu(this, "handleSetOptimizationMode", async (e3, t3, i2) => {
              const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");
              try {
                const i3 = this.localTrackMap.get(_I.LocalVideoTrack);
                if (!this.connection || !i3 || i3.track !== e3 || this.state !== EI.Connected)
                  return;
                const { id: r2, track: s2 } = i3;
                await this.connection.updateSendParameters(r2, s2), t3();
              } catch (e4) {
                i2(e4);
              } finally {
                n2();
              }
            }), nu(this, "handleReplaceTrack", async (e3, t3, i2, n2) => {
              let r2;
              KC.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
              try {
                var s2;
                const i3 = Array.from(this.localTrackMap.entries()).find((t4) => {
                  let [, { track: i4 }] = t4;
                  return e3 === i4;
                });
                if (!this.connection || !i3 || this.state !== EI.Connected)
                  return void t3();
                if (await (null === (s2 = this.connection) || void 0 === s2 ? void 0 : s2.replaceTrack(e3, i3[1].id)), this.isPlanB) {
                  const t4 = i3[1];
                  t4.id = e3._mediaStreamTrack.id, this.localTrackMap.set(i3[0], t4);
                }
                if (i3[0] === _I.LocalVideoTrack && !kC("DISABLE_DUAL_STREAM_USE_ENCODING") && _A().supportDualStreamEncoding) {
                  const t4 = this.localTrackMap.get(_I.LocalVideoLowTrack);
                  if (t4) {
                    const i4 = e3._mediaStreamTrack.clone();
                    t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new tg((e4, i5) => {
                      this.handleReplaceTrack(t4.track, e4, i5, true);
                    });
                  }
                }
                t3();
              } catch (e4) {
                i2(e4);
              } finally {
                var o2;
                null === (o2 = r2) || void 0 === o2 || o2();
              }
            }), nu(this, "handleGetRTCStats", (e3) => {
              e3(this.statsCollector.getRTCStats());
            }), nu(this, "handleGetLocalVideoStats", (e3) => {
              e3(this.statsCollector.getLocalVideoTrackStats());
            }), nu(this, "handleGetLocalAudioStats", (e3) => {
              e3(this.statsCollector.getLocalAudioTrackStats());
            }), nu(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), nu(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new dk(), this.bindStatsUploaderEvents(), this.isPlanB = !_A().supportUnifiedPlan || kC("CHROME_FORCE_PLAN_B") && kg(), this.shouldForwardP2PCreation = kC("FORWARD_P2P_CREATION") && _A().supportPCSetConfiguration && function() {
              const e3 = _g();
              return e3 === ag.ANDROID || e3 === ag.IOS || e3 === ag.HARMONY_OS;
            }(), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new sk({}, this.store) : this.isPlanB ? new ML({}, this.store) : new WL({}, this.store), this.bindConnectionEvents(this.connection));
          }
          async startP2PConnection(e2, t2) {
            var i2;
            this.state = EI.New;
            const n2 = this.shouldForwardP2PCreation && "closed" === (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.peerConnectionState);
            if (this.shouldForwardP2PCreation && !n2 || (n2 && this.connection && (KC.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.connection.close(), this.unbindConnectionEvents(this.connection)), this.connection = this.store.useDataChannel ? new sk(e2, this.store) : this.isPlanB ? new ML(e2, this.store) : new WL(e2, this.store), this.bindConnectionEvents(this.connection)), !this.connection)
              throw new Vg(xg.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
            return this._pcStatsUploadType = kC("NEW_ICE_RESTART") ? pI.FIRST_CONNECTION : pI.OLD_FIRST_CONNECTION, this._isFirstConnected = true, this._isInRestartIce = false, this._isStartRestartIce = false, this.connection.setConfiguration(e2), this.connection.establishPromise;
          }
          async connect(e2, t2, i2, n2, r2, s2) {
            if (!this.connection)
              throw new Vg(xg.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
            this.connection instanceof sk ? this.connection.updateRemoteConnect(n2) : (this.store.peerConnectionStart(), await this.connection.connect(e2, t2, i2, n2, r2, s2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = EI.Connected);
          }
          updateRemoteRTPCapabilities(e2) {
            const t2 = Array.from(this.localTrackMap.entries()).filter((e3) => {
              var t3;
              let [i2] = e3;
              return Pr(t3 = [_I.LocalVideoLowTrack, _I.LocalVideoTrack]).call(t3, i2);
            }).map((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            });
            if (this.connection instanceof WL) {
              if (!Pr(e2).call(e2, this.store.codec)) {
                const t3 = ["vp8", "h264"].find((t4) => Pr(e2).call(e2, t4));
                t3 && (this.store.codec = t3, KC.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, " updateRemoteRTPCapabilities] default codec is not available, hence the fallback to ").concat(t3, ".")));
              }
              this.connection.updateRemoteRTPCapabilities(t2, e2);
            }
          }
          async preConnect(e2, t2, i2, n2, r2, s2) {
            if (!this.connection)
              throw new Vg(xg.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
            this.store.peerConnectionStart();
            const o2 = await this.connection.connect(e2, t2, i2, n2, r2, s2);
            return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = EI.Connected, o2;
          }
          getEstablishParams() {
            if (this.connection instanceof sk)
              return this.connection.getP2PConnectionParams();
            throw new Error("Only DataChannelConnection needs to obtain establishParams");
          }
          async publishDataChannel(e2) {
            if (!this.connection) {
              if (this.state === EI.Disconnected)
                throw new Vg(xg.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
              const t3 = e2.filter((e3) => -1 !== this.pendingLocalDataChannels.findIndex((t4) => t4.id === e3.id));
              return void (this.pendingLocalDataChannels = this.pendingLocalDataChannels.concat(t3));
            }
            const t2 = this.filterTobePublishedDataChannels(e2);
            0 !== t2.length && (t2.forEach((e3) => {
              const t3 = Date.now();
              this.store.publish(e3.id.toString(), "datachannel", t3);
            }), await this.connection.createDataChannels(this.store.uid, t2), t2.forEach((e3) => {
              this.localDataChannels.push(e3);
              const t3 = Date.now();
              this.store.publish(e3.id + "", "datachannel", void 0, t3);
            }));
          }
          publish(e2, t2, i2) {
            var n2 = this;
            return BP(function* () {
              const r2 = yield jP(n2.mutex.lock("From P2PChannel.publish"));
              try {
                if (!n2.connection || n2.state !== EI.Connected) {
                  if (n2.state === EI.Disconnected)
                    throw new Vg(xg.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                  n2.throwIfTrackTypeNotMatch(e2);
                  const t3 = e2.filter((e3) => -1 === n2.pendingLocalTracks.indexOf(e3));
                  return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
                }
                n2.store.pubId = n2.store.pubId + 1, cD.markPublishStart(n2.store.clientId, n2.store.pubId);
                const s2 = n2.filterTobePublishedTracks(e2, t2, i2);
                if (0 === s2.length)
                  return void (yield jP(n2.tryToUnmuteAudio(e2)));
                yield* GP(uk(n2.doPublish(n2.connection, s2)));
              } finally {
                r2();
              }
            })();
          }
          doPublish(e2, t2) {
            var i2 = this;
            return BP(function* () {
              t2.forEach((e3) => {
                let { track: t3, type: n3 } = e3;
                const r3 = Date.now();
                i2.store.publish(t3.getTrackId(), n3 === _I.LocalAudioTrack ? "audio" : "video", r3);
              }), i2.bindLocalTrackEvents(t2);
              const n2 = yield jP(e2.send(t2.map((e3) => {
                let { track: t3 } = e3;
                return t3;
              }), i2.store.codec, i2.store.audioCodec)), r2 = (yield jP(n2.next())).value, s2 = i2.createGatewayPublishMessage(t2, r2);
              let o2;
              try {
                o2 = yield s2;
              } catch (e3) {
                throw n2.throw(e3), (null == e3 ? void 0 : e3.code) === xg.WS_ABORT && t2.forEach((e4) => {
                  let { track: t3 } = e4;
                  -1 === i2.pendingLocalTracks.indexOf(t3) && i2.pendingLocalTracks.push(t3);
                }), i2.unbindLocalTrackEvents(t2), e3;
              }
              const a2 = i2.mapPubResToRemoteConfig(s2, o2), c2 = (yield jP(n2.next(a2))).value;
              t2.forEach((e3) => {
                let { type: t3 } = e3;
                i2.statsCollector.addLocalStats(t3);
              }), i2.assignLocalTracks(t2, c2), i2.statsUploader.startUploadUplinkStats(), t2.forEach((e3) => {
                let { track: t3, type: n3 } = e3;
                const r3 = Date.now();
                i2.store.publish(t3.getTrackId(), n3 === _I.LocalAudioTrack ? "audio" : "video", void 0, r3);
              });
            })();
          }
          async updateVideoStreamParameter(e2, t2) {
            const i2 = this.localTrackMap.get(t2);
            if (!i2)
              return;
            if (!(i2.track instanceof Sb))
              return KC.warn("[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack");
            if (!(this.connection instanceof WL || this.connection instanceof ML))
              return KC.warn("[updateVideoStreamParameter]: connection is not P2PConnection or P2PConnectionPlanB");
            const { track: n2 } = i2, r2 = function(e3, t3) {
              const i3 = {};
              return e3.height && e3.width && (i3.scaleResolutionDownBy = CD(e3, t3)), i3.maxFramerate = e3.framerate ? mD(e3.framerate) : void 0, i3.maxBitrate = e3.bitrate ? 1e3 * e3.bitrate : void 0, i3;
            }(e2, n2);
            if (n2._encoderConfig || (n2._encoderConfig = {}), t2 !== _I.LocalVideoLowTrack || !kC("DISABLE_DUAL_STREAM_USE_ENCODING") && _A().supportDualStreamEncoding)
              null != r2.scaleResolutionDownBy && (n2._encoderConfig.scaleResolutionDownBy = r2.scaleResolutionDownBy);
            else {
              const t3 = n2._originMediaStreamTrack;
              if (!t3.canvas)
                return KC.warn("[".concat(n2.getTrackId(), "] no canvas on track"));
              !function(e3, t4) {
                const i3 = e3.canvas;
                t4.width && (i3.width = mD(t4.width)), t4.height && (i3.height = mD(t4.height)), t4.framerate && (i3.stopCapture && i3.stopCapture(), i3.stopCapture = uA(() => {
                  !i3.startCapture && i3.stopCapture && i3.stopCapture(), i3.startCapture && i3.startCapture();
                }, mD(t4.framerate)));
              }(t3, e2);
            }
            null != r2.maxBitrate && (n2._encoderConfig.bitrateMax = r2.maxBitrate / 1e3), null != r2.maxFramerate && (n2._encoderConfig.frameRate && "object" == typeof n2._encoderConfig.frameRate ? n2._encoderConfig.frameRate.max = r2.maxFramerate : n2._encoderConfig.frameRate = { max: r2.maxFramerate }), KC.debug("[".concat(n2.getTrackId(), "] LowStreamEncoderConfig: , ").concat(JSON.stringify(n2._encoderConfig))), await this.connection.updateRtpSenderEncodings(n2);
          }
          publishLowStream(e2) {
            var t2 = this;
            return BP(function* () {
              if (!t2.connection || t2.state !== EI.Connected)
                return;
              const i2 = yield jP(t2.mutex.lock("Locking from P2PChannel.publishLowStream"));
              try {
                const r2 = t2.localTrackMap.get(_I.LocalVideoTrack);
                if (!r2)
                  throw new Vg(xg.UNEXPECTED_ERROR, "Could not find high stream");
                if (t2.localTrackMap.has(_I.LocalVideoLowTrack))
                  throw new Vg(xg.UNEXPECTED_ERROR, "[".concat(t2.store.clientId, "] Can't publish low stream when stream already publish"));
                const s2 = [{ track: t2.getLowVideoTrack(r2.track, e2), type: _I.LocalVideoLowTrack }];
                if (yield* GP(uk(t2.doPublish(t2.connection, s2))), r2.track.muted || !r2.track.enabled) {
                  var n2;
                  const e3 = null === (n2 = t2.localTrackMap.get(_I.LocalVideoLowTrack)) || void 0 === n2 ? void 0 : n2.id;
                  void 0 !== e3 && (yield jP(t2.connection.muteLocal([e3])));
                }
              } finally {
                i2();
              }
            })();
          }
          async republish() {
            this.pendingLocalTracks.length > 0 && (KC.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await fT(this, mI.RequestRePublish, this.pendingLocalTracks), this.emit(mI.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []), this.pendingLocalDataChannels.length > 0 && (KC.debug("Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."), await fT(this, mI.RequestRePublishDataChannel, this.pendingLocalDataChannels), this.pendingLocalDataChannels = []);
          }
          async reSubscribe(e2) {
            for (let e3 = this.pendingRemoteTracks.length - 1; e3 >= 0; e3--) {
              const { user: t2, kind: i2 } = this.pendingRemoteTracks[e3];
              (i2 !== hI.AUDIO || t2._audio_added_ && t2._audioSSRC) && (i2 !== hI.VIDEO || t2._video_added_ && t2._videoSSRC) || this.pendingRemoteTracks.splice(e3, 1);
            }
            if (e2)
              await fT(this, mI.RequestReSubscribe, this.pendingRemoteTracks);
            else
              for (const { user: e3, kind: t2 } of this.pendingRemoteTracks)
                await this.subscribe(e3, t2, t2 === hI.VIDEO ? e3._videoSSRC : e3._audioSSRC);
            this.pendingRemoteTracks.forEach((e3) => {
              let { user: t2 } = e3;
              this.emit(mI.MediaReconnectEnd, t2.uid);
            }), this.pendingRemoteTracks = [];
          }
          async unpublish(e2) {
            if (!this.connection || this.state !== EI.Connected)
              return void e2.forEach((e3) => {
                const t3 = this.pendingLocalTracks.indexOf(e3);
                -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
              });
            const t2 = this.filterTobeUnpublishedTracks(e2);
            if (0 === t2.length)
              return;
            const i2 = t2.find((e3) => "videoLowTrack" === e3[0]);
            if (i2) {
              i2[1].track.close();
            }
            return this.doUnpublish(this.connection, t2);
          }
          async unpublishDataChannel(e2) {
            if (!this.connection || this.state !== EI.Connected)
              return void e2.forEach((e3) => {
                const t3 = this.pendingLocalDataChannels.indexOf(e3);
                -1 !== t3 && this.pendingLocalDataChannels.splice(t3, 1);
              });
            const t2 = this.filterTobeUnpublishedDataChannels(e2);
            return 0 !== t2.length ? (t2.forEach((e3) => {
              const t3 = this.localDataChannels.indexOf(e3);
              -1 !== t3 && this.localDataChannels.splice(t3, 1);
            }), 0 === this.localDataChannels.length && await this.connection.stopDataChannels(this.store.uid), t2.map((e3) => e3.id)) : void 0;
          }
          async unpublishLowStream() {
            if (!this.connection || this.state !== EI.Connected)
              return;
            const e2 = this.localTrackMap.get(_I.LocalVideoLowTrack);
            if (!e2)
              return;
            e2.track.close();
            const t2 = [[_I.LocalVideoLowTrack, e2]];
            return this.doUnpublish(this.connection, t2);
          }
          async doUnpublish(e2, t2) {
            const i2 = this.createGatewayUnpublishMessage(t2);
            return await e2.stopSending(t2.map((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
              let [t3, { track: i3 }] = e3;
              return { type: t3, track: i3 };
            })), t2.forEach((e3) => {
              let [t3] = e3;
              this.statsCollector.removeLocalStats(t3);
            }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadUplinkStats(), i2;
          }
          async subscribeDataChannel(e2, t2) {
            if (!this.connection || this.state !== EI.Connected)
              throw new Vg(xg.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
            const i2 = t2.filter((t3) => {
              var i3;
              return !(null !== (i3 = this.remoteDataChannelMap.get(e2)) && void 0 !== i3 && i3.get(t3.id));
            });
            if (0 !== i2.length)
              return await this.connection.createDataChannels(e2.uid, i2), i2.forEach((t3) => {
                var i3;
                this.remoteDataChannelMap.has(e2) ? null === (i3 = this.remoteDataChannelMap.get(e2)) || void 0 === i3 || i3.set(t3.id, t3) : this.remoteDataChannelMap.set(e2, /* @__PURE__ */ new Map([[t3.id, t3]]));
                const n2 = this.pendingRemoteDataChannels.findIndex((i4) => {
                  let { user: n3, id: r2 } = i4;
                  return n3.uid === e2.uid && r2 === t3.id;
                });
                -1 !== n2 && this.pendingRemoteDataChannels.splice(n2, 1);
              }), i2.map((e3) => e3.id);
          }
          async subscribe(e2, t2, i2, n2, r2) {
            var s2;
            if (!this.connection || this.state !== EI.Connected)
              throw new Vg(xg.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
            if (null !== (s2 = this.remoteUserMap.get(e2)) && void 0 !== s2 && s2.has(t2))
              return;
            let o2, a2, c2;
            if (r2) {
              const i3 = r2.find((e3) => {
                let { stream_type: i4 } = e3;
                return i4 === t2;
              });
              if (!i3)
                throw new Vg(xg.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t2, " for user: ").concat(e2.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t2, "."));
              const n3 = await this.connection.receive(t2, i3.ssrcs, String(e2._uintid), i3.attributes);
              this.connection instanceof WL && (c2 = n3.transceiver), o2 = n3.track, a2 = n3.id;
            } else {
              const r3 = await this.connection.receive(t2, [{ ssrcId: i2, rtx: n2 }], String(e2._uintid), void 0);
              this.connection instanceof WL && (c2 = r3.transceiver), o2 = r3.track, a2 = r3.id;
            }
            t2 === hI.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(o2) : (e2._audioTrack = new Ob(o2, e2.uid, e2._uintid, this.store), KC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), c2 && e2._audioTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(o2) : (e2._videoTrack = new wb(o2, e2.uid, e2._uintid, this.store), KC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), c2 && e2._videoTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._videoTrack));
            const d2 = this.remoteUserMap.get(e2);
            d2 ? d2.set(t2, a2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, a2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadDownlinkStats();
            const l2 = this.pendingRemoteTracks.findIndex((i3) => {
              let { user: n3, kind: r3 } = i3;
              return n3.uid === e2.uid && t2 === r3;
            });
            -1 !== l2 && (this.pendingRemoteTracks.splice(l2, 1), this.emit(mI.MediaReconnectEnd, e2.uid));
          }
          async massSubscribe(e2) {
            return this.massSubscribeNoLock(e2);
          }
          async massSubscribeNoLock(e2) {
            if (!this.connection || this.state !== EI.Connected)
              throw new Vg(xg.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
            e2 = e2.filter((e3) => {
              var t3;
              let { user: i2, mediaType: n2 } = e3;
              return !(null !== (t3 = this.remoteUserMap.get(i2)) && void 0 !== t3 && t3.has(n2));
            });
            const t2 = await this.connection.batchReceive(e2.map((e3) => {
              let { user: t3, mediaType: i2, ssrcId: n2, rtxSsrcId: r2 } = e3;
              return { kind: i2, ssrcMsg: [{ ssrcId: n2, rtx: r2 }], mslabel: String(t3._uintid) };
            }));
            e2.forEach((e3, i2) => {
              let { user: n2, mediaType: r2 } = e3;
              const { track: s2, id: o2, transceiver: a2 } = t2[i2];
              r2 === hI.AUDIO ? (n2._audioTrack ? n2._audioTrack._updateOriginMediaStreamTrack(s2) : (n2._audioTrack = new Ob(s2, n2.uid, n2._uintid, this.store), KC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(n2._audioTrack.getTrackId()))), a2 && n2._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(n2, n2._audioTrack)) : (n2._videoTrack ? n2._videoTrack._updateOriginMediaStreamTrack(s2) : (n2._videoTrack = new wb(s2, n2.uid, n2._uintid, this.store), KC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(n2._videoTrack.getTrackId()))), a2 && n2._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(n2, n2._videoTrack));
              const c2 = this.remoteUserMap.get(n2);
              c2 ? c2.set(r2, o2) : this.remoteUserMap.set(n2, /* @__PURE__ */ new Map([[r2, o2]])), this.statsCollector.addRemoteStats(n2.uid), this.statsUploader.startUploadDownlinkStats();
              const d2 = this.pendingRemoteTracks.findIndex((e4) => {
                let { user: t3, kind: i3 } = e4;
                return t3.uid === n2.uid && r2 === i3;
              });
              -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(mI.MediaReconnectEnd, n2.uid));
            });
          }
          async unsubscribe(e2, t2, i2) {
            const n2 = this.pendingRemoteTracks.filter((i3) => {
              let { user: n3, kind: r3 } = i3;
              return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
            });
            if (n2.forEach((e3) => {
              const t3 = this.pendingRemoteTracks.indexOf(e3);
              this.pendingRemoteTracks.splice(t3, 1);
            }), this.connection && this.state === EI.Connected || i2 || n2.forEach((t3) => {
              let { kind: i3 } = t3;
              var n3;
              if (i3 === hI.AUDIO)
                null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
              else if (i3 === hI.VIDEO) {
                var r3;
                null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
              }
            }), !this.connection || this.state !== EI.Connected)
              return;
            const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
            if (0 === r2.length)
              return;
            await this.connection.stopReceiving(r2.map((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            }));
            const s2 = this.createUnsubscribeMessage(r2);
            return this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), r2.forEach((e3) => {
              let [t3, { kind: n3 }] = e3;
              var r3, s3;
              n3 === hI.VIDEO && t3._videoSSRC && (null === (r3 = this.connection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
              if (n3 === hI.VIDEO)
                this.unbindRemoteTrackEvents(t3._videoTrack), i2 || (null === (s3 = t3._videoTrack) || void 0 === s3 || s3._destroy(), t3._videoTrack = void 0);
              else if (n3 === hI.AUDIO) {
                var o2;
                if (this.unbindRemoteTrackEvents(t3._audioTrack), !i2)
                  null === (o2 = t3._audioTrack) || void 0 === o2 || o2._destroy(), t3._audioTrack = void 0;
              }
            }), s2;
          }
          async unsubscribeDataChannel(e2, t2) {
            if (t2.forEach((e3) => {
              const t3 = this.pendingRemoteDataChannels.findIndex((t4) => t4.id === e3.id);
              -1 !== t3 && this.pendingRemoteDataChannels.splice(t3, 1);
            }), !this.connection)
              return;
            const i2 = this.filterTobeUnSubscribedDataChannels(e2, t2);
            if (0 === i2.length)
              return;
            t2.forEach((e3) => {
              e3._close();
            });
            const n2 = this.remoteDataChannelMap.get(e2);
            return i2.forEach((e3) => {
              n2 && n2.delete(e3.id);
            }), n2 && 0 === n2.size && (this.remoteDataChannelMap.delete(e2), await this.connection.stopDataChannels(e2.uid)), i2.map((e3) => e3.id);
          }
          async massUnsubscribe(e2) {
            return this.massUnsubscribeNoLock(e2);
          }
          async massUnsubscribeNoLock(e2) {
            let t2 = [];
            for (const { user: i3, mediaType: n3 } of e2) {
              const e3 = this.pendingRemoteTracks.filter((e4) => {
                let { user: t3, kind: r2 } = e4;
                return void 0 !== n3 ? t3.uid === i3.uid && n3 === r2 : t3.uid === i3.uid;
              });
              e3.forEach((e4) => {
                const t3 = this.pendingRemoteTracks.indexOf(e4);
                this.pendingRemoteTracks.splice(t3, 1);
              }), t2 = t2.concat(e3);
            }
            if (!this.connection || this.state !== EI.Connected)
              return void t2.forEach((e3) => {
                let { user: t3, kind: i3 } = e3;
                var n3;
                if (i3 === hI.AUDIO)
                  null === (n3 = t3._audioTrack) || void 0 === n3 || n3._destroy(), t3._audioTrack = void 0;
                else if (i3 === hI.VIDEO) {
                  var r2;
                  null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
                }
              });
            const i2 = cS(e2).call(e2, (e3, t3) => {
              let { user: i3, mediaType: n3 } = t3;
              const r2 = this.filterTobeUnSubscribedTracks(i3, n3);
              return e3.concat(r2);
            }, []);
            if (0 === i2.length)
              return;
            await this.connection.stopReceiving(i2.map((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            }));
            const n2 = this.createUnsubscribeAllMessage(i2);
            return this.withdrawRemoteTracks(i2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), i2.forEach((e3) => {
              let [t3, { kind: i3 }] = e3;
              var n3, r2;
              i3 === hI.VIDEO && t3._videoSSRC && (null === (n3 = this.connection) || void 0 === n3 || n3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
              if (i3 === hI.VIDEO)
                this.unbindRemoteTrackEvents(t3._videoTrack), null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
              else if (i3 === hI.AUDIO) {
                var s2;
                this.unbindRemoteTrackEvents(t3._audioTrack), null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
              }
            }), n2;
          }
          async muteRemote(e2, t2) {
            if (!this.connection)
              return;
            const i2 = this.remoteUserMap.get(e2);
            if (!i2)
              return void KC.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, "."));
            if (!i2.get(t2))
              return void KC.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
            const n2 = t2 === hI.VIDEO ? e2._videoSSRC : e2._audioSSRC;
            void 0 !== n2 && this.connection.setStatsRemoteVideoIsReady(n2, false);
          }
          async unmuteRemote(e2, t2) {
            return this.unmuteRemoteNoLock(e2, t2);
          }
          async unmuteRemoteNoLock(e2, t2) {
            if (!this.connection)
              return;
            const i2 = this.remoteUserMap.get(e2);
            if (!i2)
              return void KC.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, "."));
            i2.get(t2) || KC.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          }
          getAllTracks(e2) {
            const t2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if ((null == t2 ? void 0 : t2.track) instanceof tb) {
              const i2 = t2.track;
              return Array.from(this.localTrackMap.entries()).filter((e3) => {
                let [t3] = e3;
                return t3 !== _I.LocalAudioTrack;
              }).filter((t3) => {
                let [i3] = t3;
                return !(e2 && i3 === _I.LocalVideoLowTrack);
              }).map((e3) => {
                let [, { track: t3 }] = e3;
                return t3;
              }).concat(i2.trackList);
            }
            return Array.from(this.localTrackMap.entries()).filter((t3) => {
              let [i2] = t3;
              return !(e2 && i2 === _I.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            });
          }
          getAllDataChannels() {
            return this.localDataChannels;
          }
          reportPublishEvent(e2, t2, i2, n2, r2) {
            if (e2) {
              const i3 = this.localTrackMap.get(_I.LocalAudioTrack), s3 = n2 ? this.localTrackMap.get(_I.LocalVideoLowTrack) : this.localTrackMap.get(_I.LocalVideoTrack);
              rv.publish(this.store.sessionId, { eventElapse: cD.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == s3 ? void 0 : s3.track.getTrackLabel(), screenshare: -1 !== (null == s3 ? void 0 : s3.track._hints.indexOf(ky.SCREEN_TRACK)), audio: !!i3, video: !!s3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
            } else {
              var s2;
              i2 || (i2 = []);
              const o2 = i2.find((e3) => e3 instanceof ZA), a2 = n2 ? null === (s2 = this.localTrackMap.get(_I.LocalVideoTrack)) || void 0 === s2 ? void 0 : s2.track : i2.find((e3) => e3 instanceof Sb);
              rv.publish(this.store.sessionId, { eventElapse: cD.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == o2 ? void 0 : o2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(ky.SCREEN_TRACK)), audio: !!o2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
            }
          }
          reportSubscribeEvent(e2, t2, i2, n2) {
            const r2 = n2 === hI.VIDEO ? i2._videoSSRC : i2._audioSSRC;
            r2 && rv.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === hI.VIDEO, audio: n2 === hI.AUDIO, peerid: i2.uid, subscribeRequestid: n2 === hI.VIDEO ? i2._videoSSRC : i2._audioSSRC, p2pid: this.store.p2pId, eventElapse: cD.measureFromSubscribeStart(this.store.clientId, r2) });
          }
          reset() {
            KC.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new YT("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new sk({}, this.store) : this.isPlanB ? new ML({}, this.store) : new WL({}, this.store), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
            const e2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if ((null == e2 ? void 0 : e2.track) instanceof tb) {
              if (e2.track.trackList.length > 0) {
                const t2 = e2.track;
                e2.track.trackList.forEach((e3) => {
                  t2.removeAudioTrack(e3);
                });
              }
              e2.track.close();
            }
            this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.localDataChannels = [], this.remoteDataChannelMap.clear(), this.pendingLocalDataChannels = [], this.pendingRemoteDataChannels = [], this.state = EI.Disconnected;
          }
          getStats() {
            var e2;
            return null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.getStats();
          }
          getRemoteVideoIsReady(e2) {
            var t2;
            return (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
          }
          getLocalAudioVolume() {
            const e2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if (e2)
              return e2.track.getVolumeLevel();
          }
          getLocalVideoSize() {
            const e2 = this.localTrackMap.get(_I.LocalVideoTrack);
            if (e2)
              return { width: e2.track._videoWidth || 0, height: e2.track._videoHeight || 0 };
          }
          getEncoderConfig(e2) {
            const t2 = this.localTrackMap.get(e2);
            return t2 && t2.track instanceof Sb || t2 && t2.track instanceof ZA ? t2.track._encoderConfig : void 0;
          }
          getLocalMedia(e2) {
            return this.localTrackMap.get(e2);
          }
          hasLocalMedia() {
            return this.localTrackMap.size > 0;
          }
          hasRemoteMedia(e2, t2) {
            if (!e2)
              return this.remoteUserMap.size > 0;
            const i2 = this.remoteUserMap.get(e2);
            return !!i2 && (!t2 || i2.has(t2));
          }
          async hasRemoteMediaWithLock(e2, t2) {
            if (!e2)
              return this.remoteUserMap.size > 0;
            const i2 = this.remoteUserMap.get(e2);
            return !!i2 && (!t2 || i2.has(t2));
          }
          getRemoteMedia(e2) {
            var t2;
            const i2 = Array.from(hu(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
            return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
          }
          getAudioLevels() {
            let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
              let [t3] = e3;
              return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
            });
            const t2 = this.localTrackMap.get(_I.LocalAudioTrack);
            return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = Zu(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
          }
          async disconnectForReconnect() {
            this.connection && (KC.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = EI.Reconnecting, kC("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
              let [t2] = e2;
              var i2;
              t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
            }), this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new sk({}, this.store) : this.isPlanB ? new ML({}, this.store) : new WL({}, this.store), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
              var t2;
              let [i2, { track: n2 }] = e2;
              switch (i2) {
                case _I.LocalVideoTrack:
                  Pr(t2 = n2._hints).call(t2, ky.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
                  break;
                case _I.LocalAudioTrack:
                  n2 instanceof tb ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
                case _I.LocalVideoLowTrack:
              }
            }), this.emit(mI.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              Array.from(hu(i2).call(i2)).forEach((e3) => {
                this.setPendingRemoteMedia(t2, e3);
              }), this.emit(mI.MediaReconnectStart, t2.uid);
            }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), 0 !== this.localDataChannels.length && (this.localDataChannels.forEach((e2) => {
              this.pendingLocalDataChannels.push(e2);
            }), this.localDataChannels.length = 0), 0 !== this.remoteDataChannelMap.size && (Array.from(this.remoteDataChannelMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              Array.from(hu(i2).call(i2)).forEach((e3) => {
                this.setPendingRemoteDataChannel(t2, e3);
              });
            }), this.remoteDataChannelMap.clear()), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), KC.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
          }
          hasPendingRemoteDataChannel(e2, t2) {
            for (const i2 of this.pendingRemoteDataChannels) {
              const { user: n2, id: r2 } = i2;
              if ((e2 instanceof NP ? e2.uid : e2) === n2.uid && r2 === t2)
                return true;
            }
            return false;
          }
          setPendingRemoteDataChannel(e2, t2) {
            this.hasPendingRemoteDataChannel(e2, t2) || this.pendingRemoteDataChannels.push({ user: e2, id: t2 });
          }
          hasPendingRemoteMedia(e2, t2) {
            for (const i2 of this.pendingRemoteTracks) {
              const { user: n2, kind: r2 } = i2;
              if ((e2 instanceof NP ? e2.uid : e2) === n2.uid && t2 === r2)
                return true;
            }
            return false;
          }
          setPendingRemoteMedia(e2, t2) {
            this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
          }
          restartICE(e2) {
            var t2 = this;
            return BP(function* () {
              if (!t2.connection || t2.state !== EI.Connected || t2.connection instanceof sk)
                return;
              const i2 = yield jP(t2.mutex.lock("From P2PChannel.restartICE"));
              let n2;
              try {
                n2 = yield jP(t2.connection.restartICE(e2));
                const r3 = yield jP(n2.next());
                if (r3.done)
                  return;
                const s2 = r3.value, o2 = yield s2;
                switch (t2.reportPCDisconnectedOrFailed(e2), e2) {
                  case uI.TCP:
                    t2._pcStatsUploadType = pI.TCP_RESTART;
                    break;
                  case uI.RELAY:
                    t2._pcStatsUploadType = pI.RELAY_RESTART;
                    break;
                  default:
                    t2._pcStatsUploadType = pI.OLD_RESTART;
                }
                t2._isInRestartIce = true, n2.next(o2);
              } catch (e3) {
                var r2;
                null === (r2 = n2) || void 0 === r2 || r2.throw(e3);
              } finally {
                i2();
              }
            })();
          }
          getUplinkNetworkQuality() {
            if (!this.connection)
              return 0;
            const e2 = this.connection.getStats(), t2 = this.localTrackMap.get(_I.LocalVideoTrack), i2 = this.localTrackMap.get(_I.LocalAudioTrack), n2 = e2.videoSend.find((e3) => e3.ssrc === (null == t2 ? void 0 : t2.ssrcs[0].ssrcId)), r2 = e2.audioSend.find((e3) => e3.ssrc === (null == i2 ? void 0 : i2.ssrcs[0].ssrcId));
            if (!n2 || !r2)
              return 1;
            const s2 = TT(this, mI.NeedSignalRTT), o2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = o2 && a2 ? (o2 + a2) / 2 : o2 || a2, d2 = (c2 && s2 ? (c2 + s2) / 2 : c2 || s2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, h2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, u2 = null == t2 ? void 0 : t2.track;
            if (u2 && u2._encoderConfig && -1 === u2._hints.indexOf(ky.SCREEN_TRACK)) {
              const t3 = u2._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
              if (t3 && i3) {
                const e3 = (1e3 * t3 - i3) / (1e3 * t3);
                return av[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][h2];
              }
            }
            return h2;
          }
          getDownlinkNetworkQuality() {
            if (!this.connection)
              return 0;
            const e2 = this.connection.getStats();
            let t2 = 0;
            return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
              let [n2] = i2;
              const r2 = n2._audioSSRC, s2 = n2._videoSSRC, o2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a2 = e2.videoRecv.find((e3) => e3.ssrc === s2);
              if (!o2 && !a2)
                return void (t2 += 1);
              const c2 = TT(this, mI.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, h2 = o2 ? o2.jitterMs : void 0, u2 = e2.recvPacketLossRate;
              let p2 = 0.7 * u2 * 100 / 50 + 0.3 * l2 / 1500;
              h2 && (p2 = 0.6 * u2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * h2 / 400);
              t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
            }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
          }
          async muteLocalTrack(e2) {
            return new tg((t2, i2) => {
              this.handleMuteLocalTrack(e2, t2, i2);
            });
          }
          filterTobePublishedTracks(e2, t2, i2) {
            const n2 = [], r2 = _A(), s2 = this.getAllTracks();
            e2 = yT(e2 = e2.filter((e3) => -1 === s2.indexOf(e3)));
            let o2 = false, a2 = false;
            for (const s3 of e2) {
              if (s3 instanceof Sb && (this.localTrackMap.has(_I.LocalVideoTrack) || o2 ? new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: s3, type: _I.LocalVideoTrack }), o2 = true), t2)) {
                const e3 = this.getLowVideoTrack(s3, i2);
                n2.push({ track: e3, type: _I.LocalVideoLowTrack });
              }
              if (s3 instanceof ZA) {
                const e3 = this.localTrackMap.get(_I.LocalAudioTrack);
                if (e3) {
                  if (!(e3.track instanceof tb))
                    throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                  if (s3._bypassWebAudio)
                    throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                  e3.track.addAudioTrack(s3), this.bindLocalAudioTrackEvents(s3, true);
                } else if (a2) {
                  const e4 = n2.find((e5) => {
                    let { type: t3 } = e5;
                    return t3 === _I.LocalAudioTrack;
                  });
                  if (!(e4.track instanceof tb))
                    throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                  if (s3._bypassWebAudio)
                    throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                  e4.track.addAudioTrack(s3);
                } else {
                  if (!r2.webAudioMediaStreamDest || s3 instanceof tb || s3._bypassWebAudio)
                    n2.push({ track: s3, type: _I.LocalAudioTrack });
                  else {
                    const e4 = new tb();
                    e4.addAudioTrack(s3), n2.push({ track: e4, type: _I.LocalAudioTrack });
                  }
                  a2 = true;
                }
              }
            }
            return n2;
          }
          filterTobeUnpublishedTracks(e2) {
            const t2 = [], i2 = this.getAllTracks();
            e2 = yT(e2 = e2.filter((e3) => -1 !== i2.indexOf(e3)));
            for (const i3 of e2) {
              if (i3 instanceof ZA) {
                const e3 = this.localTrackMap.get(_I.LocalAudioTrack);
                if (!e3)
                  continue;
                e3.track instanceof tb ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t2.push([_I.LocalAudioTrack, e3]), e3.track.close())) : t2.push([_I.LocalAudioTrack, e3]);
              }
              if (i3 instanceof Sb) {
                const e3 = this.localTrackMap.get(_I.LocalVideoTrack);
                if (!e3)
                  continue;
                t2.push([_I.LocalVideoTrack, e3]);
                const i4 = this.localTrackMap.get(_I.LocalVideoLowTrack);
                i4 && t2.push([_I.LocalVideoLowTrack, i4]);
              }
            }
            return t2;
          }
          filterTobePublishedDataChannels(e2) {
            return e2 = (e2 = yT(e2)).filter((e3) => -1 === this.localDataChannels.findIndex((t2) => t2.id === e3.id));
          }
          filterTobeUnpublishedDataChannels(e2) {
            return e2 = (e2 = (e2 = yT(e2)).filter((e3) => -1 !== this.localDataChannels.indexOf(e3))).filter((e3) => e3._originDataChannel);
          }
          bindLocalTrackEvents(e2) {
            e2.forEach((e3) => {
              let { track: t2, type: i2 } = e3;
              switch (i2) {
                case _I.LocalVideoTrack:
                  t2.addListener(Ly.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(Ly.GET_RTC_STATS, this.handleGetRTCStats), t2.addListener(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(Ly.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(Ly.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.addListener(Ly.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                  break;
                case _I.LocalAudioTrack:
                  this.bindLocalAudioTrackEvents(t2);
                case _I.LocalVideoLowTrack:
              }
            });
          }
          bindLocalAudioTrackEvents(e2, t2) {
            e2 instanceof tb ? e2.trackList.forEach((e3) => {
              e3.addListener(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(Ly.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
            }) : (e2.addListener(Ly.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e2.addListener(Ly.NEED_REPLACE_TRACK, this.handleReplaceTrack));
          }
          unbindLocalTrackEvents(e2) {
            e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
              let [t2, { track: i2 }] = e3;
              return { track: i2, type: t2 };
            })), e2.forEach((e3) => {
              let { track: t2, type: i2 } = e3;
              switch (i2) {
                case _I.LocalVideoTrack:
                  t2.off(Ly.GET_STATS, this.handleGetLocalVideoStats), t2.off(Ly.GET_RTC_STATS, this.handleGetRTCStats), t2.off(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(Ly.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(Ly.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.off(Ly.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                  break;
                case _I.LocalAudioTrack:
                  this.unbindLocalAudioTrackEvents(t2);
                case _I.LocalVideoLowTrack:
              }
            });
          }
          unbindLocalAudioTrackEvents(e2) {
            e2 instanceof tb ? e2.trackList.forEach((e3) => {
              e3.off(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(Ly.GET_STATS, this.handleGetLocalAudioStats), e3.off(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
            }) : (e2.off(Ly.GET_STATS, this.handleGetLocalAudioStats), e2.off(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(Ly.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
          }
          bindRemoteTrackEvents(e2, t2) {
            t2 instanceof wb && t2.addListener(Ly.GET_STATS, (t3) => {
              t3(this.handleGetRemoteVideoStats(e2));
            }), t2 instanceof Ob && t2.addListener(Ly.GET_STATS, (t3) => {
              t3(this.handleGetRemoteAudioStats(e2));
            });
          }
          unbindRemoteTrackEvents(e2) {
            e2 && e2.removeAllListeners(Ly.GET_STATS);
          }
          unbindAllRemoteTrackEvents() {
            Array.from(this.remoteUserMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              i2.has(hI.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(hI.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
            });
          }
          createGatewayPublishMessage(e2, t2) {
            return e2.map((e3, i2) => {
              var n2;
              let r2, s2, { track: o2, type: a2 } = e3;
              switch (a2) {
                case _I.LocalAudioTrack:
                  r2 = $v.Audio, s2 = { dtx: o2 instanceof $A && o2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                  break;
                case _I.LocalVideoTrack:
                  r2 = Pr(n2 = o2._hints).call(n2, ky.SCREEN_TRACK) ? $v.Screen : $v.High, s2 = hk(hk({}, fD(o2)), {}, { codec: this.store.codec });
                  break;
                case _I.LocalVideoLowTrack:
                  r2 = $v.Low, s2 = hk(hk({}, fD(o2)), {}, { codec: this.store.codec });
              }
              return { stream_type: r2, attributes: s2, ssrcs: t2[i2] };
            });
          }
          createGatewayUnpublishMessage(e2) {
            return e2.map((e3) => {
              var t2;
              let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
              switch (n2) {
                case _I.LocalVideoTrack:
                  i2 = Pr(t2 = r2._hints).call(t2, ky.SCREEN_TRACK) ? $v.Screen : $v.High;
                  break;
                case _I.LocalAudioTrack:
                  i2 = $v.Audio;
                  break;
                case _I.LocalVideoLowTrack:
                  i2 = $v.Low;
              }
              return { stream_type: i2, ssrcs: s2, mid: o2 };
            });
          }
          assignLocalTracks(e2, t2) {
            e2.forEach((e3, i2) => {
              let { track: n2, type: r2 } = e3;
              this.localTrackMap.set(r2, { track: n2, id: t2[i2].id, ssrcs: t2[i2].localSSRC });
            });
          }
          withdrawLocalTracks(e2) {
            e2.forEach((e3) => {
              let [t2] = e3;
              this.localTrackMap.delete(t2);
            });
          }
          bindConnectionEvents(e2) {
            e2.onConnectionStateChange = async (t2) => {
              if (KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), this.emit(mI.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (this._restartTimer && (clearTimeout(this._restartTimer), this._restartTimer = void 0), (this._isFirstConnected || this._isInRestartIce) && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isInRestartIce = false, this._isFirstConnected = false, this._isStartRestartIce = false), kC("NEW_ICE_RESTART")) {
                var i2;
                if (Pr(i2 = this._restartStates).call(i2, t2)) {
                  if (this._isStartRestartIce)
                    return;
                  this._isStartRestartIce = true;
                  const t3 = (t4) => {
                    if ("disconnected" === e2.iceConnectionState || "checking" === e2.iceConnectionState || "failed" === e2.iceConnectionState) {
                      KC.debug("[".concat(this.store.clientId, "] [P2PChannel] start use restartICE, type is ").concat(t4));
                      "CONNECTED" === TT(this, mI.QueryClientConnectionState) && this.emit(mI.RequestRestartICE, t4);
                    }
                  }, i3 = () => {
                    "disconnected" !== e2.iceConnectionState && "checking" !== e2.iceConnectionState && "failed" !== e2.iceConnectionState || (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), KC.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout(() => this.emit(mI.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
                  }, n2 = kC("ICE_RESTART_INTERVAL");
                  return void (this._restartTimer = window.setTimeout(() => {
                    if (kC("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && _A().supportPCSetConfiguration)
                      t3(uI.RELAY), this._restartTimer = window.setTimeout(i3, n2);
                    else if (Rg())
                      t3(uI.UDP), this._restartTimer = window.setTimeout(i3, 4e3);
                    else {
                      if (t3(uI.TCP), _A().supportPCSetConfiguration)
                        return void (this._restartTimer = window.setTimeout(() => {
                          t3(uI.RELAY), this._restartTimer = window.setTimeout(i3, n2);
                        }, n2));
                      this._restartTimer = window.setTimeout(i3, n2);
                    }
                  }, 800));
                }
              } else {
                if ("disconnected" === t2 && "disconnected" === e2.iceConnectionState)
                  return setTimeout(() => {
                    if ("disconnected" === e2.iceConnectionState && kC("ICE_RESTART")) {
                      "CONNECTED" === TT(this, mI.QueryClientConnectionState) && this.emit(mI.RequestRestartICE);
                    }
                  }, 800), void setTimeout(() => {
                    "disconnected" === e2.peerConnectionState && (KC.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isInRestartIce = false, setTimeout(() => this.emit(mI.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
                  }, 4e3);
                "failed" === t2 && (KC.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCDisconnectedOrFailed(), setTimeout(() => this.emit(mI.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
              }
            }, e2.onICEConnectionStateChange = (e3) => {
              "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), rv.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: oT.TRACER }).onSuccess(), this.emit(mI.IceConnectionStateChange, e3);
            }, e2.onICETransportStateChange = (e3) => {
              KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
            }, e2.onDTLSTransportStateChange = (e3) => {
              KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
            }, e2.onDTLSTransportError = (e3) => {
              KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
            }, e2.onFirstAudioDecoded = (e3) => {
              var t2;
              const i2 = Array.from(hu(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
              var n2;
              i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(By.FIRST_FRAME_DECODED), rv.firstRemoteFrame(this.store.sessionId, XC.FIRST_AUDIO_DECODE, QC.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: cD.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
            }, e2.onFirstAudioReceived = (e3) => {
              var t2;
              const i2 = Array.from(hu(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
              i2 && rv.firstRemoteFrame(this.store.sessionId, XC.FIRST_AUDIO_RECEIVED, QC.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: cD.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
            }, e2.onFirstVideoDecoded = (e3, t2, i2) => {
              this.reportVideoFirstFrameDecoded(e3, t2, i2);
            }, e2.onFirstVideoReceived = (e3) => {
              var t2;
              const i2 = Array.from(hu(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
              i2 && rv.firstRemoteFrame(this.store.sessionId, XC.FIRST_VIDEO_RECEIVED, QC.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: cD.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
            }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
              const i2 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
              "unknown" !== t2.candidateType && i2 === n2 || this.emit(mI.ConnectionTypeChange, i2), KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(vD(t2)), " -> ").concat(JSON.stringify(vD(e3)), ")"));
            }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
              KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(vD(t2)), " -> ").concat(JSON.stringify(vD(e3)), ")"));
            }, e2.onFirstVideoDecodedTimeout = (e3) => {
              this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
            };
          }
          unbindConnectionEvents(e2) {
            e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0;
          }
          filterTobeMutedTracks(e2) {
            const t2 = [];
            if (-1 === this.getAllTracks().indexOf(e2))
              return t2;
            const i2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if (e2 instanceof ZA && (null == i2 ? void 0 : i2.track) instanceof tb)
              return i2.track.isActive || t2.push([_I.LocalAudioTrack, i2]), t2;
            const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
              let [, { track: i3 }] = t3;
              return e2 === i3;
            });
            if (n2 && (t2.push(n2), n2[0] === _I.LocalVideoTrack)) {
              const e3 = this.localTrackMap.get(_I.LocalVideoLowTrack);
              e3 && t2.push([_I.LocalVideoLowTrack, e3]);
            }
            return t2;
          }
          filterTobeUnmutedTracks(e2) {
            const t2 = [], i2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if (e2 instanceof ZA && (null == i2 ? void 0 : i2.track) instanceof tb)
              return i2.track.isActive && t2.push([_I.LocalAudioTrack, i2]), t2;
            const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
              let [, { track: i3 }] = t3;
              return e2 === i3;
            });
            if (n2)
              if (n2[0] === _I.LocalVideoTrack) {
                t2.push(n2);
                const e3 = this.localTrackMap.get(_I.LocalVideoLowTrack);
                e3 && t2.push([_I.LocalVideoLowTrack, e3]);
              } else
                t2.push(n2);
            return t2;
          }
          createMuteMessage(e2) {
            return e2.map((e3) => {
              var t2;
              let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
              switch (n2) {
                case _I.LocalAudioTrack:
                  i2 = $v.Audio;
                  break;
                case _I.LocalVideoTrack:
                  i2 = Pr(t2 = r2._hints).call(t2, ky.SCREEN_TRACK) ? $v.Screen : $v.High;
                  break;
                case _I.LocalVideoLowTrack:
                  i2 = $v.Low;
              }
              return { stream_type: i2, ssrcs: s2, mid: o2 };
            });
          }
          createUnmuteMessage(e2) {
            return e2.map((e3) => {
              var t2;
              let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
              switch (n2) {
                case _I.LocalAudioTrack:
                  i2 = $v.Audio;
                  break;
                case _I.LocalVideoTrack:
                  i2 = Pr(t2 = r2._hints).call(t2, ky.SCREEN_TRACK) ? $v.Screen : $v.High;
                  break;
                case _I.LocalVideoLowTrack:
                  i2 = $v.Low;
              }
              return { stream_type: i2, ssrcs: s2, mid: o2 };
            });
          }
          filterTobeUnSubscribedTracks(e2, t2) {
            const i2 = [], n2 = this.remoteUserMap.get(e2);
            if (!n2)
              return i2;
            if (t2) {
              const r2 = n2.get(t2);
              if (!r2)
                return i2;
              i2.push([e2, { kind: t2, id: r2 }]);
            } else
              Array.from(n2.entries()).forEach((t3) => {
                let [n3, r2] = t3;
                i2.push([e2, { kind: n3, id: r2 }]);
              });
            return i2;
          }
          filterTobeUnSubscribedDataChannels(e2, t2) {
            const i2 = [];
            return t2.forEach((t3) => {
              var n2;
              null !== (n2 = this.remoteDataChannelMap.get(e2)) && void 0 !== n2 && n2.has(t3.id) && i2.push(t3);
            }), i2;
          }
          createUnsubscribeMessage(e2) {
            const t2 = [];
            return e2.forEach((e3) => {
              let [i2, { kind: n2, id: r2 }] = e3;
              switch (n2) {
                case hI.VIDEO:
                  return void (i2._videoSSRC && t2.push({ stream_type: hI.VIDEO, ssrcId: i2._videoSSRC }));
                case hI.AUDIO:
                  return void (i2._audioSSRC && t2.push({ stream_type: hI.AUDIO, ssrcId: i2._audioSSRC }));
              }
            }), t2;
          }
          createUnsubscribeAllMessage(e2) {
            const t2 = /* @__PURE__ */ new Map();
            return e2.forEach((e3) => {
              let [i2, { kind: n2 }] = e3;
              if (t2.has(i2)) {
                let e4 = t2.get(i2);
                n2 === hI.VIDEO ? e4 |= iI.Video : e4 |= iI.Audio, t2.set(i2, e4);
              } else
                n2 === hI.VIDEO ? t2.set(i2, iI.Video) : t2.set(i2, iI.Audio);
            }), { users: Array.from(t2.entries()).map((e3) => {
              let [t3, i2] = e3;
              return { stream_id: t3.uid, stream_type: i2 };
            }) };
          }
          withdrawRemoteTracks(e2) {
            e2.forEach((e3) => {
              let [t2, { kind: i2 }] = e3;
              const n2 = this.remoteUserMap.get(t2);
              n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
            });
          }
          async updateBitrateLimit(e2) {
            const t2 = this.localTrackMap.get(_I.LocalVideoTrack), i2 = this.localTrackMap.get(_I.LocalVideoLowTrack);
            t2 && await t2.track.setBitrateLimit(e2.uplink), i2 && e2.low_stream_uplink && await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 });
          }
          isP2PDisconnected() {
            if (this.connection) {
              return "connected" !== this.connection.peerConnectionState;
            }
            return true;
          }
          mapPubResToRemoteConfig(e2, t2) {
            return e2.map((e3, i2) => {
              var n2;
              let { stream_type: r2 } = e3;
              return null === (n2 = t2.find((e4) => {
                let { stream_type: t3 } = e4;
                return r2 === t3;
              })) || void 0 === n2 ? void 0 : n2.attributes;
            });
          }
          async tryToUnmuteAudio(e2) {
            for (let i2 = 0; i2 < e2.length; i2++)
              if (e2[i2] instanceof ZA) {
                var t2;
                const n2 = this.filterTobeUnmutedTracks(e2[i2]);
                if (0 === n2.length)
                  continue;
                await (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.unmuteLocal(n2.map((e3) => {
                  let [, { id: t3 }] = e3;
                  return t3;
                })));
                const r2 = this.createUnmuteMessage(n2);
                return void await gT(this, mI.RequestUnmuteLocal, r2);
              }
          }
          bindStatsUploaderEvents() {
            this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
              var t2;
              return !(null === (t2 = this.connection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
            }, this.statsUploader.requestUpload = (e2, t2) => this.emit(mI.RequestUploadStats, e2, t2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
          }
          unbindStatsUploaderEvents() {
            this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
          }
          async requestReconnect() {
            this.dtlsFailedCount += 1, await UT(zT(this.dtlsFailedCount, JT)), this.emit(mI.RequestReconnect);
          }
          async reconnectP2P() {
            const e2 = Array.from(this.localTrackMap.entries()), t2 = this.createGatewayUnpublishMessage(e2);
            Array.from(this.remoteUserMap.entries()), t2.length > 0 && await fT(this, mI.RequestUnpublishForReconnectPC, t2), this.disconnectForReconnect(), this.emit(mI.RequestReconnectPC);
          }
          canPublishLowStream() {
            return this.localTrackMap.has(_I.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof Sb);
          }
          throwIfTrackTypeNotMatch(e2) {
            if (e2.filter((e3) => e3 instanceof Sb).length > 1)
              throw new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (e2.filter((e3) => e3 instanceof ZA).length > 1 && (e2.some((e3) => e3 instanceof ZA && e3._bypassWebAudio) || !_A().webAudioMediaStreamDest))
              throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
            for (const t2 of e2) {
              if (t2 instanceof Sb && this.pendingLocalTracks.some((e3) => e3 instanceof Sb))
                throw new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
              if (t2 instanceof ZA && this.pendingLocalTracks.some((e3) => e3 instanceof ZA) && (!_A().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof ZA && e3._bypassWebAudio)))
                throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
            }
          }
          getLowVideoTrack(e2, t2) {
            const i2 = !kC("DISABLE_DUAL_STREAM_USE_ENCODING") && _A().supportDualStreamEncoding, n2 = hk(hk({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
            let r2;
            r2 = i2 ? e2._mediaStreamTrack.clone() : KL(e2, n2);
            const s2 = xT(8, "track-low-"), o2 = new Sb(r2, hk(hk({}, i2 && { scaleResolutionDownBy: CD(n2, e2) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, s2);
            return o2.on(Vy.TRANSCEIVER_UPDATED, (t3) => {
              e2._updateRtpTransceiver(t3, My.LOW_STREAM);
            }), o2._hints.push(ky.LOW_STREAM), e2.addListener(Ly.NEED_CLOSE, () => {
              o2.close();
            }), o2;
          }
          async globalLock() {
            return this.mutex.lock("From P2PChannel.globalLock");
          }
          async reportPCStats(e2, t2, i2) {
            let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            if (this.connection && this.connection instanceof WL) {
              var r2, s2, o2, a2;
              const c2 = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d2, dtlsTransportState: l2, peerConnectionState: h2 } = this.connection, { local: u2, remote: p2 } = await this.connection.getSelectedCandidatePair();
              rv.pcStats(this.store.sessionId, { startTime: c2, eventElapse: e2 - c2 || 0, iceconnectionsate: d2, dtlsstate: l2, connectionstate: h2, intSucc: t2 ? 1 : 2, error: n2, selectedLocalCandidateProtocol: null !== (r2 = null == u2 ? void 0 : u2.protocol) && void 0 !== r2 ? r2 : "", selectedLocalCandidateType: null !== (s2 = u2.candidateType) && void 0 !== s2 ? s2 : "", selectedLocalCandidateAddress: "".concat(u2.address, ":").concat(u2.port), selectedRemoteCandidateProtocol: null !== (o2 = p2.protocol) && void 0 !== o2 ? o2 : "", selectedRemoteCandidateType: null !== (a2 = p2.candidateType) && void 0 !== a2 ? a2 : "", selectedRemoteCandidateAddress: "".concat(p2.address, ":").concat(p2.port), restartCnt: i2 });
            }
          }
          reportVideoFirstFrameDecoded(e2, t2, i2, n2) {
            var r2;
            const s2 = Array.from(hu(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e2);
            if (s2) {
              n2 || this.store.subscribe(s2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
              const r3 = this.store.keyMetrics, o2 = r3.subscribe.find((e3) => e3.userId === s2.uid && "video" === e3.type);
              rv.firstRemoteVideoDecode(this.store.sessionId, XC.FIRST_VIDEO_DECODE, QC.FIRST_VIDEO_DECODE, { peer: s2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: cD.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == o2 ? void 0 : o2.subscribeEnd) || 0, subscriberStart: (null == o2 ? void 0 : o2.subscribeStart) || 0, videoAddNotify: (null == o2 ? void 0 : o2.streamAdded) || 0, state: n2 ? 1 : 0 });
            }
          }
          async remoteMediaSsrcChanged(e2, t2, i2) {
            if (!this.connection)
              return false;
            const n2 = this.remoteUserMap.get(e2);
            if (!n2)
              return false;
            const r2 = n2.get(t2);
            if (!r2)
              return false;
            const s2 = await this.connection.getRemoteSSRC(r2);
            return void 0 !== s2 && s2 !== i2;
          }
          resetConnection(e2) {
            KC.debug("[".concat(this.store.clientId, "] [P2PChannel] reset connection to ").concat(e2)), this.state === EI.Connected ? (KC.debug("[".concat(this.store.clientId, "] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first")), this.disconnectForReconnect()) : (this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = e2 === nI.datachannel ? new sk({}, this.store) : this.isPlanB ? new ML({}, this.store) : new WL({}, this.store), this.bindConnectionEvents(this.connection)));
          }
          unbindRtpTransceiver() {
            0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
              let [t2, { track: i2 }] = e2;
              t2 === _I.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, My.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
            });
          }
          reportPCDisconnectedOrFailed(e2) {
            this.connection && this.connection instanceof WL && ("disconnected" !== this.connection.iceConnectionState && "checking" !== this.connection.iceConnectionState && "failed" !== this.connection.iceConnectionState || (this._isFirstConnected ? (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isFirstConnected = false) : this._pcStatsUploadType === pI.TCP_RESTART && e2 === uI.RELAY ? this.reportPCStats(Date.now(), false, this._pcStatsUploadType) : this.reportPCStats(Date.now(), false, pI.DISCONNECTED_OR_FAILED)));
          }
        }
        function Ek(e2, t2, i2) {
          const n2 = e2[t2];
          if ("function" != typeof n2)
            throw new Error("Cannot use mutex on object property.");
          return i2.value = async function() {
            const e3 = this.mutex, i3 = await e3.lock("From P2PChannel.".concat(t2));
            try {
              for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++)
                s2[o2] = arguments[o2];
              return await n2.apply(this, s2);
            } finally {
              i3();
            }
          }, i2;
        }
        function mk(e2) {
          let t2 = bk();
          return function(e3, t3) {
            let i2 = e3.appId;
            void 0 !== i2 && (jk(t3, 10), kk(t3, i2));
            let n2 = e3.cid;
            void 0 !== n2 && (jk(t3, 16), jk(t3, n2));
            let r2 = e3.cname;
            void 0 !== r2 && (jk(t3, 26), kk(t3, r2));
            let s2 = e3.deviceId;
            void 0 !== s2 && (jk(t3, 34), kk(t3, s2));
            let o2 = e3.elapse;
            void 0 !== o2 && (jk(t3, 40), Gk(t3, o2));
            let a2 = e3.fileSize;
            void 0 !== a2 && (jk(t3, 48), Gk(t3, yk(a2)));
            let c2 = e3.height;
            void 0 !== c2 && (jk(t3, 56), Gk(t3, yk(c2)));
            let d2 = e3.jpg;
            void 0 !== d2 && (jk(t3, 66), jk(t3, d2.length), function(e4, t4) {
              let i3 = Dk(e4, t4.length);
              e4.bytes.set(t4, i3);
            }(t3, d2));
            let l2 = e3.networkType;
            void 0 !== l2 && (jk(t3, 72), Gk(t3, yk(l2)));
            let h2 = e3.osType;
            void 0 !== h2 && (jk(t3, 80), Gk(t3, yk(h2)));
            let u2 = e3.requestId;
            void 0 !== u2 && (jk(t3, 90), kk(t3, u2));
            let p2 = e3.sdkVersion;
            void 0 !== p2 && (jk(t3, 98), kk(t3, p2));
            let _2 = e3.sequence;
            void 0 !== _2 && (jk(t3, 104), Gk(t3, yk(_2)));
            let E2 = e3.sid;
            void 0 !== E2 && (jk(t3, 114), kk(t3, E2));
            let m2 = e3.timestamp;
            void 0 !== m2 && (jk(t3, 120), Gk(t3, m2));
            let f2 = e3.uid;
            void 0 !== f2 && (jk(t3, 128), jk(t3, f2));
            let g2 = e3.vid;
            void 0 !== g2 && (jk(t3, 136), jk(t3, g2));
            let T2 = e3.width;
            void 0 !== T2 && (jk(t3, 144), Gk(t3, yk(T2)));
            let S2 = e3.service;
            void 0 !== S2 && (jk(t3, 152), jk(t3, S2));
            let R2 = e3.callbackData;
            void 0 !== R2 && (jk(t3, 162), kk(t3, R2));
            let C2 = e3.jpgEncryption;
            void 0 !== C2 && (jk(t3, 168), jk(t3, C2));
            let v2 = e3.requestType;
            void 0 !== v2 && (jk(t3, 176), jk(t3, v2));
            let I2 = e3.scorePorn;
            void 0 !== I2 && (jk(t3, 185), Fk(t3, I2));
            let y2 = e3.scoreSexy;
            void 0 !== y2 && (jk(t3, 193), Fk(t3, y2));
            let A2 = e3.scoreNeutral;
            void 0 !== A2 && (jk(t3, 201), Fk(t3, A2));
            let b2 = e3.scene;
            void 0 !== b2 && (jk(t3, 208), jk(t3, b2));
            let w2 = e3.ossFilePrefix;
            void 0 !== w2 && (jk(t3, 218), kk(t3, w2));
            let O2 = e3.serviceVendor;
            if (void 0 !== O2)
              for (let e4 of O2) {
                jk(t3, 226);
                let i3 = bk();
                Tk(e4, i3), jk(t3, i3.limit), Mk(t3, i3), wk(i3);
              }
          }(e2, t2), function(e3) {
            let t3 = e3.bytes, i2 = e3.limit;
            return t3.length === i2 ? t3 : t3.subarray(0, i2);
          }(t2);
        }
        function fk(e2) {
          return function(e3) {
            let t3 = {};
            e:
              for (; !Nk(e3); ) {
                let i2 = Bk(e3);
                switch (i2 >>> 3) {
                  case 0:
                    break e;
                  case 1:
                    t3.code = Bk(e3);
                    break;
                  case 2:
                    t3.msg = Lk(e3, Bk(e3));
                    break;
                  case 3: {
                    let i3 = Sk(e3);
                    t3.data = gk(e3), e3.limit = i3;
                    break;
                  }
                  default:
                    Rk(e3, 7 & i2);
                }
              }
            return t3;
          }({ bytes: t2 = e2, offset: 0, limit: t2.length });
          var t2;
        }
        function gk(e2) {
          let t2 = {};
          e:
            for (; !Nk(e2); ) {
              let i2 = Bk(e2);
              switch (i2 >>> 3) {
                case 0:
                  break e;
                case 1:
                  t2.requestId = Lk(e2, Bk(e2));
                  break;
                case 2:
                  t2.requestType = Bk(e2) >>> 0;
                  break;
                case 3:
                  t2.scorePorn = Vk(e2);
                  break;
                case 4:
                  t2.scoreSexy = Vk(e2);
                  break;
                case 5:
                  t2.scoreNeutral = Vk(e2);
                  break;
                case 6:
                  t2.requestScene = Bk(e2) >>> 0;
                  break;
                case 7:
                  t2.scene = Bk(e2) >>> 0;
                  break;
                default:
                  Rk(e2, 7 & i2);
              }
            }
          return t2;
        }
        function Tk(e2, t2) {
          let i2 = e2.service;
          void 0 !== i2 && (jk(t2, 8), jk(t2, i2));
          let n2 = e2.vendor;
          void 0 !== n2 && (jk(t2, 16), jk(t2, n2));
          let r2 = e2.token;
          void 0 !== r2 && (jk(t2, 26), kk(t2, r2));
          let s2 = e2.callbackUrl;
          void 0 !== s2 && (jk(t2, 34), kk(t2, s2));
        }
        function Sk(e2) {
          let t2 = Bk(e2), i2 = e2.limit;
          return e2.limit = e2.offset + t2, i2;
        }
        function Rk(e2, t2) {
          switch (t2) {
            case 0:
              for (; 128 & Uk(e2); )
                ;
              break;
            case 2:
              Ok(e2, Bk(e2));
              break;
            case 5:
              Ok(e2, 4);
              break;
            case 1:
              Ok(e2, 8);
              break;
            default:
              throw new Error("Unimplemented type: " + t2);
          }
        }
        Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Object, Boolean]), Uv("design:returntype", tg)], _k.prototype, "startP2PConnection", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Object, Object, Array, Object, String, String]), Uv("design:returntype", tg)], _k.prototype, "connect", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", void 0)], _k.prototype, "updateRemoteRTPCapabilities", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Object, Object, Array, Object, String, String]), Uv("design:returntype", tg)], _k.prototype, "preConnect", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], _k.prototype, "publishDataChannel", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], _k.prototype, "unpublish", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], _k.prototype, "unpublishDataChannel", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], _k.prototype, "unpublishLowStream", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [NP, Array]), Uv("design:returntype", tg)], _k.prototype, "subscribeDataChannel", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [NP, String, Number, Number, Array]), Uv("design:returntype", tg)], _k.prototype, "subscribe", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], _k.prototype, "massSubscribe", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [NP, String, Boolean]), Uv("design:returntype", tg)], _k.prototype, "unsubscribe", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [NP, Array]), Uv("design:returntype", tg)], _k.prototype, "unsubscribeDataChannel", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], _k.prototype, "massUnsubscribe", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [NP, String]), Uv("design:returntype", tg)], _k.prototype, "muteRemote", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [NP, String]), Uv("design:returntype", tg)], _k.prototype, "unmuteRemote", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [NP, String]), Uv("design:returntype", tg)], _k.prototype, "hasRemoteMediaWithLock", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], _k.prototype, "disconnectForReconnect", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], _k.prototype, "updateBitrateLimit", null), Mv([Ek, Uv("design:type", Function), Uv("design:paramtypes", [NP, String, Number]), Uv("design:returntype", tg)], _k.prototype, "remoteMediaSsrcChanged", null);
        let Ck = new Float32Array(1);
        new Uint8Array(Ck.buffer);
        let vk = new Float64Array(1), Ik = new Uint8Array(vk.buffer);
        function yk(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        let Ak = [];
        function bk() {
          const e2 = Ak.pop();
          return e2 ? (e2.offset = e2.limit = 0, e2) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
        }
        function wk(e2) {
          Ak.push(e2);
        }
        function Ok(e2, t2) {
          if (e2.offset + t2 > e2.limit)
            throw new Error("Skip past limit");
          e2.offset += t2;
        }
        function Nk(e2) {
          return e2.offset >= e2.limit;
        }
        function Dk(e2, t2) {
          let i2 = e2.bytes, n2 = e2.offset, r2 = e2.limit, s2 = n2 + t2;
          if (s2 > i2.length) {
            let t3 = new Uint8Array(2 * s2);
            t3.set(i2), e2.bytes = t3;
          }
          return e2.offset = s2, s2 > r2 && (e2.limit = s2), n2;
        }
        function Pk(e2, t2) {
          let i2 = e2.offset;
          if (i2 + t2 > e2.limit)
            throw new Error("Read past limit");
          return e2.offset += t2, i2;
        }
        function Lk(e2, t2) {
          let i2 = Pk(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, s2 = "\uFFFD", o2 = "";
          for (let e3 = 0; e3 < t2; e3++) {
            let a2, c2, d2, l2, h2 = r2[e3 + i2];
            0 == (128 & h2) ? o2 += n2(h2) : 192 == (224 & h2) ? e3 + 1 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], 128 != (192 & a2) ? o2 += s2 : (l2 = (31 & h2) << 6 | 63 & a2, l2 < 128 ? o2 += s2 : (o2 += n2(l2), e3++))) : 224 == (240 & h2) ? e3 + 2 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? o2 += s2 : (l2 = (15 & h2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? o2 += s2 : (o2 += n2(l2), e3 += 2))) : 240 == (248 & h2) ? e3 + 3 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? o2 += s2 : (l2 = (7 & h2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? o2 += s2 : (l2 -= 65536, o2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : o2 += s2;
          }
          return o2;
        }
        function kk(e2, t2) {
          let i2 = t2.length, n2 = 0;
          for (let e3 = 0; e3 < i2; e3++) {
            let r3 = t2.charCodeAt(e3);
            r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
          }
          jk(e2, n2);
          let r2 = Dk(e2, n2), s2 = e2.bytes;
          for (let e3 = 0; e3 < i2; e3++) {
            let n3 = t2.charCodeAt(e3);
            n3 >= 55296 && n3 <= 56319 && e3 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? s2[r2++] = n3 : (n3 < 2048 ? s2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? s2[r2++] = n3 >> 12 & 15 | 224 : (s2[r2++] = n3 >> 18 & 7 | 240, s2[r2++] = n3 >> 12 & 63 | 128), s2[r2++] = n3 >> 6 & 63 | 128), s2[r2++] = 63 & n3 | 128);
          }
        }
        function Mk(e2, t2) {
          let i2 = Dk(e2, t2.limit), n2 = e2.bytes, r2 = t2.bytes;
          for (let e3 = 0, s2 = t2.limit; e3 < s2; e3++)
            n2[e3 + i2] = r2[e3];
        }
        function Uk(e2) {
          return e2.bytes[Pk(e2, 1)];
        }
        function xk(e2, t2) {
          let i2 = Dk(e2, 1);
          e2.bytes[i2] = t2;
        }
        function Vk(e2) {
          let t2 = Pk(e2, 8), i2 = e2.bytes;
          return Ik[0] = i2[t2++], Ik[1] = i2[t2++], Ik[2] = i2[t2++], Ik[3] = i2[t2++], Ik[4] = i2[t2++], Ik[5] = i2[t2++], Ik[6] = i2[t2++], Ik[7] = i2[t2++], vk[0];
        }
        function Fk(e2, t2) {
          let i2 = Dk(e2, 8), n2 = e2.bytes;
          vk[0] = t2, n2[i2++] = Ik[0], n2[i2++] = Ik[1], n2[i2++] = Ik[2], n2[i2++] = Ik[3], n2[i2++] = Ik[4], n2[i2++] = Ik[5], n2[i2++] = Ik[6], n2[i2++] = Ik[7];
        }
        function Bk(e2) {
          let t2, i2 = 0, n2 = 0;
          do {
            t2 = Uk(e2), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
          } while (128 & t2);
          return n2;
        }
        function jk(e2, t2) {
          for (t2 >>>= 0; t2 >= 128; )
            xk(e2, 127 & t2 | 128), t2 >>>= 7;
          xk(e2, t2);
        }
        function Gk(e2, t2) {
          let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, s2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, o2 = Dk(e2, s2), a2 = e2.bytes;
          switch (s2) {
            case 10:
              a2[o2 + 9] = r2 >>> 7 & 1;
            case 9:
              a2[o2 + 8] = 9 !== s2 ? 128 | r2 : 127 & r2;
            case 8:
              a2[o2 + 7] = 8 !== s2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
            case 7:
              a2[o2 + 6] = 7 !== s2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
            case 6:
              a2[o2 + 5] = 6 !== s2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
            case 5:
              a2[o2 + 4] = 5 !== s2 ? 128 | n2 : 127 & n2;
            case 4:
              a2[o2 + 3] = 4 !== s2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
            case 3:
              a2[o2 + 2] = 3 !== s2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
            case 2:
              a2[o2 + 1] = 2 !== s2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
            case 1:
              a2[o2] = 1 !== s2 ? 128 | i2 : 127 & i2;
          }
        }
        function Wk(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        const Hk = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
        class Kk extends iT {
          get connectionState() {
            return this._connectionState;
          }
          set connectionState(e2) {
            if (this._connectionState === e2)
              return;
            const t2 = this._connectionState;
            this._connectionState = e2, this.emit(SI.CONNECTION_STATE_CHANGE, t2, e2);
          }
          get inspectType() {
            return this._inspectType;
          }
          set inspectType(e2) {
            var t2;
            this._inspectMode = cS(t2 = e2.map((e3) => Hk.get(e3) || 0)).call(t2, (e3, t3) => e3 + t3), this._inspectType = e2;
          }
          get quality() {
            return this._quality;
          }
          set quality(e2) {
            this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
              this.quality = this._quality / this.qualityRatio;
            }, 6e4));
          }
          constructor(e2) {
            super(), nu(this, "name", "AgoraRTCVideoContentInspect"), nu(this, "_connectionState", gI.CONNECTING), nu(this, "_innerConnectionState", void 0), nu(this, "sequence", 0), nu(this, "inspectStartTime", void 0), nu(this, "workerManagerConnection", void 0), nu(this, "workerConnection", void 0), nu(this, "workerMessageLengthLimit", void 0), nu(this, "inspectIntervalMinimum", void 0), nu(this, "qualityRatio", void 0), nu(this, "_connectInfo", void 0), nu(this, "_cancelTokenSource", EC.CancelToken.source()), nu(this, "_retryConfig", void 0), nu(this, "wmSequence", 0), nu(this, "inspectInterval", void 0), nu(this, "inspectTimer", null), nu(this, "ossFilePrefix", void 0), nu(this, "extraInfo", void 0), nu(this, "_inspectType", void 0), nu(this, "_inspectMode", void 0), nu(this, "_quality", 1), nu(this, "qualityTimer", null), nu(this, "_inspectId", void 0), nu(this, "_needWorkUrlOnly", false), nu(this, "inspectImage", () => {
              if (this.connectionState !== gI.CONNECTED)
                throw new xv(xg.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
              this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
                this.connectionState === gI.CONNECTED ? this.requestToInspectImage() : KC.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
              }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
            }), this._inspectId = xT(5, "inspect-"), this.workerMessageLengthLimit = kC("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = kC("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = kC("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e2.interval, this.ossFilePrefix = e2.ossFilePrefix, this.extraInfo = e2.extraInfo, this.inspectType = e2.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new XI("worker-manager-" + this._inspectId, JT), this.on(SI.STATE_CHANGE, (e3, t2) => {
              this._innerConnectionState = e3, KC.debug("[".concat(this._inspectId, "] Inspect operation :").concat(TI[e3], " ").concat(t2 || ""));
            }), this.handleWorkerManagerEvents(), this.workerConnection = new XI("worker-" + this._inspectId, JT), this.handleWorkerEvents();
          }
          async init(e2, t2) {
            this.emit(SI.STATE_CHANGE, TI.CONNECT_AP), this._connectInfo = e2;
            const i2 = this._cancelTokenSource.token;
            return this._retryConfig = t2, new tg((n2, r2) => {
              this.on(SI.CONNECTION_STATE_CHANGE, (e3, t3) => {
                t3 === gI.CONNECTED && n2();
              }), this.requestAP(e2, i2, t2).then((e3) => {
                this.connectWorkerManager(e3);
              }).catch((e3) => {
                r2(e3);
              });
            });
          }
          async requestAP(e2, t2, i2) {
            const n2 = kC("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i3, n3) {
              let { appId: r3, areaCode: s3, cname: o2, sid: a2, token: c2, uid: d2 } = t3;
              oP++;
              const l2 = "image_moderation_api", h2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: s3, cname: o2, command: "allocateEdge", requestId: oP, seq: oP, sid: a2, token: c2, ts: Date.now(), uid: d2 + "" }) };
              let u2, p2, _2 = e3[0];
              return XT(async () => {
                u2 = Date.now();
                const e4 = await VD(_2, { data: h2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
                if (p2 = Date.now() - u2, 0 !== e4.code) {
                  const t5 = new xv(xg.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e4.code, { retry: true, responseTime: p2 });
                  throw KC.error(t5.toString()), t5;
                }
                const t4 = JSON.parse(e4.json_body);
                if (200 !== t4.code) {
                  const e5 = new xv(xg.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
                  throw KC.error(e5.toString()), e5;
                }
                if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                  const e5 = new xv(xg.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t4.code, responseTime: p2 });
                  throw KC.error(e5.toString()), e5;
                }
                const n4 = kC("VIDEO_INSPECT_WORKER_MANAGER_HOST"), r4 = kC("VIDEO_INSPECT_WORKER_MANAGER_PORT");
                return { addressList: t4.servers.map((e5) => {
                  let { address: t5, wss: i4 } = e5;
                  if (t5 && i4)
                    return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(r4 || i4);
                }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, responseTime: p2 };
              }, (t4, i4) => (rv.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false), (t4, i4) => (rv.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t4.code !== xg.OPERATION_ABORTED && t4.code !== xg.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true)), n3);
            }(n2, e2, t2, i2);
            this.emit(SI.STATE_CHANGE, TI.AP_CONNECTED);
            const { addressList: s2 } = r2;
            return this.wmSequence++, s2;
          }
          async connectWorkerManager(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            this._needWorkUrlOnly = t2, this.emit(SI.STATE_CHANGE, TI.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e2, 1e4);
          }
          async connectWorker(e2) {
            await this.workerConnection.init([e2]);
          }
          handleWorkerManagerEvents() {
            this.workerManagerConnection.on(Iv.CONNECTED, async () => {
              this.emit(SI.STATE_CHANGE, TI.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.19.3", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
            }), this.workerManagerConnection.on(Iv.CLOSED, () => {
              this._innerConnectionState < TI.GET_WORKER_MANAGER_RESPONSE && KC.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
            }), this.workerManagerConnection.on(Iv.FAILED, () => {
              this._innerConnectionState < TI.GET_WORKER_MANAGER_RESPONSE && KC.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
            }), this.workerManagerConnection.on(Iv.RECONNECTING, () => {
              this._innerConnectionState < TI.GET_WORKER_MANAGER_RESPONSE && KC.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
            }), this.workerManagerConnection.on(Iv.ON_MESSAGE, async (e2) => {
              this.emit(SI.STATE_CHANGE, TI.GET_WORKER_MANAGER_RESPONSE);
              const t2 = this.workerManagerConnection.url;
              this.workerManagerConnection.close();
              const i2 = JSON.parse(e2.data);
              if (200 !== i2.code)
                throw KC.error("[".concat(this._inspectId, "] Unexpected code ").concat(i2.code, " from worker manager")), new xv(xg.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i2);
              if (!(i2.serverResponse && i2.serverResponse.portWss && t2))
                throw KC.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i2))), new xv(xg.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i2);
              {
                const e3 = kC("VIDEO_INSPECT_WORKER_PORT") || i2.serverResponse.portWss, n2 = t2.replace(/:\d+\/?$/, ":".concat(e3));
                this.emit(SI.STATE_CHANGE, TI.CONNECT_WORKER, n2), this._needWorkUrlOnly ? this.emit(SI.REQUEST_NEW_WORKER_URL, n2) : await this.connectWorker(n2);
              }
            }), this.workerManagerConnection.on(Iv.WILL_RECONNECT, (e2, t2, i2) => {
              i2(e2);
            }), this.workerManagerConnection.on(Iv.REQUEST_NEW_URLS, (e2, t2) => {
              this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
            });
          }
          handleWorkerEvents() {
            this.workerConnection.on(Iv.CONNECTED, async () => {
              this.emit(SI.STATE_CHANGE, TI.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = gI.CONNECTED;
            }), this.workerConnection.on(Iv.ON_MESSAGE, async (e2) => {
              if (e2.data instanceof ArrayBuffer) {
                const i2 = fk(new Uint8Array(e2.data));
                if (kC("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && KC.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i2)), 200 === i2.code) {
                  if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0])
                    return void this.emit(SI.INSPECT_RESULT, void 0, void 0);
                  if (i2.data && i2.data.scorePorn && i2.data.scoreSexy && i2.data.scoreNeutral) {
                    var t2;
                    const e3 = { porn: i2.data.scorePorn, sexy: i2.data.scoreSexy, neutral: i2.data.scoreNeutral }, n2 = cS(t2 = Object.keys(e3)).call(t2, (t3, i3) => e3[t3] > e3[i3] ? t3 : i3, "porn"), r2 = Object.keys(e3).find((e4) => e4 === n2);
                    this.emit(SI.INSPECT_RESULT, r2);
                  } else
                    this.emit(SI.INSPECT_RESULT, void 0, new xv(xg.UNEXPECTED_RESPONSE, i2.code + "", "There is an unexpected data on message"));
                } else
                  this.emit(SI.INSPECT_RESULT, void 0, new xv(xg.UNEXPECTED_RESPONSE, i2.code + "", i2.msg));
              } else
                KC.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(SI.INSPECT_RESULT, void 0, new xv(xg.UNEXPECTED_RESPONSE, "invalid worker message type"));
            }), this.workerConnection.on(Iv.CLOSED, () => {
              this.connectionState = gI.CLOSED;
            }), this.workerConnection.on(Iv.FAILED, () => {
              this.connectionState = gI.CLOSED;
            }), this.workerConnection.on(Iv.RECONNECTING, () => {
              this.connectionState = this.connectionState === gI.CONNECTED ? gI.RECONNECTING : gI.CONNECTING;
            }), this.workerConnection.on(Iv.WILL_RECONNECT, (e2, t2, i2) => {
              "recover" === e2 && i2(e2), i2("tryNext");
            }), this.workerConnection.on(Iv.REQUEST_NEW_URLS, (e2, t2) => {
              this.workerManagerConnection.close(), this.once(SI.REQUEST_NEW_WORKER_URL, (t3) => {
                e2([t3]);
              }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e3) => {
                this.connectWorkerManager(e3, true);
              }).catch((e3) => {
                t2(e3);
              });
            });
          }
          static intToLong(e2) {
            return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
          }
          async requestToInspectImage() {
            this.sequence++;
            const e2 = TT(this, SI.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
            if (e2) {
              if (!e2.isPlaying)
                return void this.emit(SI.INSPECT_RESULT, void 0, new xv(xg.INVALID_OPERATION, "Only the track being played can be inspected"));
              const i2 = await this.generateRequestData(e2, t2);
              this.workerConnection.sendMessage(i2, true, true);
            } else
              this.emit(SI.INSPECT_RESULT, void 0, new xv(xg.INVALID_OPERATION, "Only the track being published can be inspected"));
          }
          async generateRequestData(e2, t2) {
            let { appId: i2, cname: n2, cid: r2, vid: s2, sid: o2, uid: a2 } = t2;
            const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await fb(d2, i2, n2), h2 = this.sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + xT(12, ""), u2 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: Kk.intToLong(Number(c2 - this.inspectStartTime)), fileSize: l2.byteLength, jpgEncryption: 2, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: h2, sdkVersion: "4.19.3", sequence: this.sequence, sid: o2, timestamp: Kk.intToLong(c2), uid: a2, vid: s2, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
            void 0 === this.extraInfo && delete u2.callbackData, void 0 === this.ossFilePrefix && delete u2.ossFilePrefix;
            const p2 = mk(u2);
            if (p2.byteLength < this.workerMessageLengthLimit) {
              if (kC("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
                const e3 = function(e4) {
                  for (var t3 = 1; t3 < arguments.length; t3++) {
                    var i3 = null != arguments[t3] ? arguments[t3] : {};
                    t3 % 2 ? Wk(Object(i3), true).forEach(function(t4) {
                      nu(e4, t4, i3[t4]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : Wk(Object(i3)).forEach(function(t4) {
                      Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
                    });
                  }
                  return e4;
                }({}, u2);
                delete e3.jpg, KC.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e3));
              }
              return p2;
            }
            {
              const t3 = this.quality * this.qualityRatio;
              return this.quality = t3, await this.generateRequestData(e2, { appId: i2, cname: n2, cid: r2, vid: s2, sid: o2, uid: a2 });
            }
          }
          close() {
            this._cancelTokenSource.cancel(), this._cancelTokenSource = EC.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = gI.CLOSED, this.emit(SI.STATE_CHANGE, TI.CLOSED);
          }
        }
        function Yk(e2) {
          let t2 = function() {
            const e3 = Xk.pop();
            return e3 ? (e3.offset = e3.limit = 0, e3) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
          }();
          return function(e3, t3) {
            let i2 = e3.appId;
            void 0 !== i2 && (aM(t3, 10), nM(t3, i2));
            let n2 = e3.cid;
            void 0 !== n2 && (aM(t3, 16), aM(t3, n2));
            let r2 = e3.cname;
            void 0 !== r2 && (aM(t3, 26), nM(t3, r2));
            let s2 = e3.deviceId;
            void 0 !== s2 && (aM(t3, 34), nM(t3, s2));
            let o2 = e3.elapse;
            void 0 !== o2 && (aM(t3, 40), dM(t3, o2));
            let a2 = e3.fileSize;
            void 0 !== a2 && (aM(t3, 48), dM(t3, zk(a2)));
            let c2 = e3.height;
            void 0 !== c2 && (aM(t3, 56), dM(t3, zk(c2)));
            let d2 = e3.jpg;
            void 0 !== d2 && (aM(t3, 66), aM(t3, d2.length), tM(t3, d2));
            let l2 = e3.networkType;
            void 0 !== l2 && (aM(t3, 72), dM(t3, zk(l2)));
            let h2 = e3.osType;
            void 0 !== h2 && (aM(t3, 80), dM(t3, zk(h2)));
            let u2 = e3.requestId;
            void 0 !== u2 && (aM(t3, 90), nM(t3, u2));
            let p2 = e3.sdkVersion;
            void 0 !== p2 && (aM(t3, 98), nM(t3, p2));
            let _2 = e3.sequence;
            void 0 !== _2 && (aM(t3, 104), dM(t3, zk(_2)));
            let E2 = e3.sid;
            void 0 !== E2 && (aM(t3, 114), nM(t3, E2));
            let m2 = e3.timestamp;
            void 0 !== m2 && (aM(t3, 120), dM(t3, m2));
            let f2 = e3.uid;
            void 0 !== f2 && (aM(t3, 128), aM(t3, f2));
            let g2 = e3.vid;
            void 0 !== g2 && (aM(t3, 136), aM(t3, g2));
            let T2 = e3.width;
            void 0 !== T2 && (aM(t3, 144), dM(t3, zk(T2)));
            let S2 = e3.service;
            void 0 !== S2 && (aM(t3, 152), aM(t3, S2));
            let R2 = e3.callbackData;
            void 0 !== R2 && (aM(t3, 162), aM(t3, R2.length), tM(t3, R2));
            let C2 = e3.ticket;
            void 0 !== C2 && (aM(t3, 170), nM(t3, C2));
          }(e2, t2), function(e3) {
            let t3 = e3.bytes, i2 = e3.limit;
            return t3.length === i2 ? t3 : t3.subarray(0, i2);
          }(t2);
        }
        function qk(e2) {
          return function(e3) {
            let t3 = {};
            e:
              for (; !Zk(e3); ) {
                let i2 = oM(e3);
                switch (i2 >>> 3) {
                  case 0:
                    break e;
                  case 1:
                    t3.code = oM(e3);
                    break;
                  case 2:
                    t3.msg = iM(e3, oM(e3));
                    break;
                  case 3:
                    t3.requestId = iM(e3, oM(e3));
                    break;
                  case 4:
                    t3.timestamp = cM(e3, false);
                    break;
                  default:
                    Jk(e3, 7 & i2);
                }
              }
            return t3;
          }({ bytes: t2 = e2, offset: 0, limit: t2.length });
          var t2;
        }
        function Jk(e2, t2) {
          switch (t2) {
            case 0:
              for (; 128 & rM(e2); )
                ;
              break;
            case 2:
              Qk(e2, oM(e2));
              break;
            case 5:
              Qk(e2, 4);
              break;
            case 1:
              Qk(e2, 8);
              break;
            default:
              throw new Error("Unimplemented type: " + t2);
          }
        }
        function zk(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        let Xk = [];
        function Qk(e2, t2) {
          if (e2.offset + t2 > e2.limit)
            throw new Error("Skip past limit");
          e2.offset += t2;
        }
        function Zk(e2) {
          return e2.offset >= e2.limit;
        }
        function $k(e2, t2) {
          let i2 = e2.bytes, n2 = e2.offset, r2 = e2.limit, s2 = n2 + t2;
          if (s2 > i2.length) {
            let t3 = new Uint8Array(2 * s2);
            t3.set(i2), e2.bytes = t3;
          }
          return e2.offset = s2, s2 > r2 && (e2.limit = s2), n2;
        }
        function eM(e2, t2) {
          let i2 = e2.offset;
          if (i2 + t2 > e2.limit)
            throw new Error("Read past limit");
          return e2.offset += t2, i2;
        }
        function tM(e2, t2) {
          let i2 = $k(e2, t2.length);
          e2.bytes.set(t2, i2);
        }
        function iM(e2, t2) {
          let i2 = eM(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, s2 = "\uFFFD", o2 = "";
          for (let e3 = 0; e3 < t2; e3++) {
            let a2, c2, d2, l2, h2 = r2[e3 + i2];
            0 == (128 & h2) ? o2 += n2(h2) : 192 == (224 & h2) ? e3 + 1 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], 128 != (192 & a2) ? o2 += s2 : (l2 = (31 & h2) << 6 | 63 & a2, l2 < 128 ? o2 += s2 : (o2 += n2(l2), e3++))) : 224 == (240 & h2) ? e3 + 2 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? o2 += s2 : (l2 = (15 & h2) << 12 | (63 & a2) << 6 | 63 & c2, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? o2 += s2 : (o2 += n2(l2), e3 += 2))) : 240 == (248 & h2) ? e3 + 3 >= t2 ? o2 += s2 : (a2 = r2[e3 + i2 + 1], c2 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? o2 += s2 : (l2 = (7 & h2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? o2 += s2 : (l2 -= 65536, o2 += n2(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : o2 += s2;
          }
          return o2;
        }
        function nM(e2, t2) {
          let i2 = t2.length, n2 = 0;
          for (let e3 = 0; e3 < i2; e3++) {
            let r3 = t2.charCodeAt(e3);
            r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
          }
          aM(e2, n2);
          let r2 = $k(e2, n2), s2 = e2.bytes;
          for (let e3 = 0; e3 < i2; e3++) {
            let n3 = t2.charCodeAt(e3);
            n3 >= 55296 && n3 <= 56319 && e3 + 1 < i2 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? s2[r2++] = n3 : (n3 < 2048 ? s2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? s2[r2++] = n3 >> 12 & 15 | 224 : (s2[r2++] = n3 >> 18 & 7 | 240, s2[r2++] = n3 >> 12 & 63 | 128), s2[r2++] = n3 >> 6 & 63 | 128), s2[r2++] = 63 & n3 | 128);
          }
        }
        function rM(e2) {
          return e2.bytes[eM(e2, 1)];
        }
        function sM(e2, t2) {
          let i2 = $k(e2, 1);
          e2.bytes[i2] = t2;
        }
        function oM(e2) {
          let t2, i2 = 0, n2 = 0;
          do {
            t2 = rM(e2), i2 < 32 && (n2 |= (127 & t2) << i2), i2 += 7;
          } while (128 & t2);
          return n2;
        }
        function aM(e2, t2) {
          for (t2 >>>= 0; t2 >= 128; )
            sM(e2, 127 & t2 | 128), t2 >>>= 7;
          sM(e2, t2);
        }
        function cM(e2, t2) {
          let i2, n2 = 0, r2 = 0, s2 = 0;
          return i2 = rM(e2), n2 = 127 & i2, 128 & i2 && (i2 = rM(e2), n2 |= (127 & i2) << 7, 128 & i2 && (i2 = rM(e2), n2 |= (127 & i2) << 14, 128 & i2 && (i2 = rM(e2), n2 |= (127 & i2) << 21, 128 & i2 && (i2 = rM(e2), r2 = 127 & i2, 128 & i2 && (i2 = rM(e2), r2 |= (127 & i2) << 7, 128 & i2 && (i2 = rM(e2), r2 |= (127 & i2) << 14, 128 & i2 && (i2 = rM(e2), r2 |= (127 & i2) << 21, 128 & i2 && (i2 = rM(e2), s2 = 127 & i2, 128 & i2 && (i2 = rM(e2), s2 |= (127 & i2) << 7))))))))), { low: n2 | r2 << 28, high: r2 >>> 4 | s2 << 24, unsigned: t2 };
        }
        function dM(e2, t2) {
          let i2 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, s2 = 0 === r2 ? 0 === n2 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, o2 = $k(e2, s2), a2 = e2.bytes;
          switch (s2) {
            case 10:
              a2[o2 + 9] = r2 >>> 7 & 1;
            case 9:
              a2[o2 + 8] = 9 !== s2 ? 128 | r2 : 127 & r2;
            case 8:
              a2[o2 + 7] = 8 !== s2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
            case 7:
              a2[o2 + 6] = 7 !== s2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
            case 6:
              a2[o2 + 5] = 6 !== s2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
            case 5:
              a2[o2 + 4] = 5 !== s2 ? 128 | n2 : 127 & n2;
            case 4:
              a2[o2 + 3] = 4 !== s2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
            case 3:
              a2[o2 + 2] = 3 !== s2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
            case 2:
              a2[o2 + 1] = 2 !== s2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
            case 1:
              a2[o2] = 1 !== s2 ? 128 | i2 : 127 & i2;
          }
        }
        const lM = {}, hM = {}, uM = 4294967296, pM = uM * uM, _M = pM / 2, EM = SM(0, true), mM = SM(0), fM = RM(0, -2147483648, false), gM = RM(-1, 2147483647, false), TM = RM(-1, -1, true);
        function SM(e2, t2) {
          let i2, n2, r2;
          return t2 ? (r2 = 0 <= (e2 >>>= 0) && e2 < 256) && (n2 = hM[e2], n2) ? n2 : (i2 = RM(e2, 0, true), r2 && (hM[e2] = i2), i2) : (r2 = -128 <= (e2 |= 0) && e2 < 128) && (n2 = lM[e2], n2) ? n2 : (i2 = RM(e2, e2 < 0 ? -1 : 0, false), r2 && (lM[e2] = i2), i2);
        }
        function RM(e2, t2, i2) {
          return { low: 0 | e2, high: 0 | t2, unsigned: !!i2 };
        }
        function CM(e2, t2) {
          if (isNaN(e2))
            return t2 ? EM : mM;
          if (t2) {
            if (e2 < 0)
              return EM;
            if (e2 >= pM)
              return TM;
          } else {
            if (e2 <= -_M)
              return fM;
            if (e2 + 1 >= _M)
              return gM;
          }
          return e2 < 0 ? t2 ? EM : mM : RM(e2 % uM | 0, e2 / uM | 0, t2);
        }
        function vM(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        class IM extends iT {
          get connectionState() {
            return this._connectionState;
          }
          set connectionState(e2) {
            if (this._connectionState === e2)
              return;
            const t2 = this._connectionState;
            this._connectionState = e2, this.emit(AI.CONNECTION_STATE_CHANGE, e2, t2);
          }
          get quality() {
            return this._quality;
          }
          set quality(e2) {
            this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {
              this.quality = this._quality / this._qualityRatio;
            }, 6e4));
          }
          constructor(e2) {
            var t2;
            super(), nu(this, "name", "AgoraRTCImageModeration"), nu(this, "_connectionState", yI.CONNECTING), nu(this, "_sequence", 0), nu(this, "_moderationStartTime", void 0), nu(this, "_workerConnection", void 0), nu(this, "_workerMessageLengthLimit", void 0), nu(this, "_qualityRatio", void 0), nu(this, "_connectInfo", void 0), nu(this, "_cancelTokenSource", EC.CancelToken.source()), nu(this, "_retryConfig", void 0), nu(this, "_moderationInterval", void 0), nu(this, "_moderationTimer", null), nu(this, "_moderationMode", 1), nu(this, "_quality", 1), nu(this, "_qualityTimer", null), nu(this, "_ticket", void 0), nu(this, "_moderationIntervalMinimum", void 0), nu(this, "_uploadFailedNum", 0), nu(this, "_uploadNum", 0), nu(this, "_uploadTimer", null), nu(this, "_moderationId", void 0), nu(this, "inspectImage", () => {
              if (this.connectionState !== yI.CONNECTED)
                throw new xv(xg.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
              this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {
                this.connectionState === yI.CONNECTED ? this.requestToInspectImage() : KC.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
              }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
            }), this._moderationId = xT(5, "image-moderation-"), this._workerMessageLengthLimit = kC("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = kC("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, this._qualityRatio = kC("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new XI("worker-" + this._moderationId, JT), this.on(AI.STATE_CHANGE, (e3, t3) => {
              KC.debug("[".concat(this._moderationId, "] Moderation operation :").concat(bI[e3], " ").concat(t3 || ""));
            }), this.handleWorkerEvents();
          }
          async init(e2, t2) {
            this.emit(AI.STATE_CHANGE, bI.CONNECT_AP), this._connectInfo = e2;
            const i2 = this._cancelTokenSource.token;
            return this._retryConfig = t2, new tg((n2, r2) => {
              this.on(AI.CONNECTION_STATE_CHANGE, (e3, t3) => {
                e3 === yI.CONNECTED && n2();
              }), this.requestAP(e2, i2, t2).then((e3) => {
                this.connectWorker(e3);
              }).catch((e3) => {
                r2(e3);
              });
            });
          }
          updateConfig(e2) {
            var t2;
            this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, KC.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e2))), this.connectionState === yI.CONNECTED && this.inspectImage();
          }
          async requestAP(e2, t2, i2) {
            const n2 = kC("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i3, n3) {
              let { appId: r3, areaCode: s3, cname: o3, sid: a2, token: c2, uid: d2 } = t3;
              oP++;
              const l2 = "moderation_plugin", h2 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: s3, cname: o3, command: "allocateEdge", requestId: oP, seq: oP, sid: a2, appToken: c2, ts: Date.now(), uid: d2 + "" }) };
              let u2, p2, _2 = e3[0];
              return XT(async () => {
                u2 = Date.now();
                const e4 = await VD(_2, { data: h2, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
                if (p2 = Date.now() - u2, 0 !== e4.code) {
                  const t5 = new xv(xg.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e4.code, { retry: true, responseTime: p2 });
                  throw KC.error(t5.toString()), t5;
                }
                const t4 = JSON.parse(e4.json_body);
                if (200 !== t4.code) {
                  const e5 = new xv(xg.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p2 });
                  throw KC.error(e5.toString()), e5;
                }
                if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
                  const e5 = new xv(xg.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t4.code, responseTime: p2 });
                  throw KC.error(e5.toString()), e5;
                }
                if (!t4.servers.some((e5) => !!e5.wss)) {
                  const e5 = new xv(xg.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t4.code, responseTime: p2 });
                  throw KC.error(e5.toString()), e5;
                }
                const n4 = kC("IMAGE_MODERATION_WORKER_HOST");
                return { addressList: t4.servers.map((e5) => {
                  let { address: t5, wss: i4 } = e5;
                  if (t5 && i4)
                    return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(i4, "/moderation");
                }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, ticket: t4.appTicket, responseTime: p2 };
              }, (t4, i4) => (rv.apworkerEvent(a2, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false), (t4, i4) => (rv.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t4.code !== xg.OPERATION_ABORTED && t4.code !== xg.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true)), n3);
            }(n2, e2, t2, i2);
            this.emit(AI.STATE_CHANGE, bI.AP_CONNECTED);
            const { addressList: s2, ticket: o2 } = r2;
            return this._ticket = o2, s2;
          }
          async connectWorker(e2) {
            this.emit(AI.STATE_CHANGE, bI.CONNECT_WORKER), await this._workerConnection.init(e2, 1e4);
          }
          handleWorkerEvents() {
            this._workerConnection.on(Iv.CONNECTED, async () => {
              this.emit(AI.STATE_CHANGE, bI.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = yI.CONNECTED;
            }), this._workerConnection.on(Iv.CLOSED, () => {
              this.connectionState = yI.CLOSED;
            }), this._workerConnection.on(Iv.FAILED, () => {
              this.connectionState = yI.CLOSED;
            }), this._workerConnection.on(Iv.RECONNECTING, () => {
              this.connectionState = this.connectionState === yI.CONNECTED ? yI.RECONNECTING : yI.CONNECTING;
            }), this._workerConnection.on(Iv.ON_MESSAGE, async (e2) => {
              if (e2.data instanceof ArrayBuffer) {
                const t2 = qk(new Uint8Array(e2.data));
                kC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && KC.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t2)), this._uploadNum++, void 0 === t2.code || 0 === t2.code || (this._uploadFailedNum++, KC.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t2.code, ", msg is ").concat(t2.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {
                  rv.reportApiInvoke(this._connectInfo.sid || null, { name: sT.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t2.code], tag: oT.TRACER }).onError(new xv(xg.IMAGE_MODERATION_UPLOAD_FAILED, t2.msg)), this._uploadTimer = null;
                }, kC("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
              } else
                KC.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
            }), this._workerConnection.on(Iv.WILL_RECONNECT, (e2, t2, i2) => {
              "recover" === e2 && i2(e2), i2("tryNext");
            }), this._workerConnection.on(Iv.REQUEST_NEW_URLS, (e2, t2) => {
              this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
            });
          }
          static intToLong(e2) {
            return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
          }
          async requestToInspectImage() {
            const e2 = TT(this, AI.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
            if (e2) {
              if (!e2.isPlaying)
                return void (kC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && KC.debug("Only the track being played can be inspected"));
              this._sequence++;
              const i2 = await this.generateRequestData(e2, t2);
              this._workerConnection.sendMessage(i2, true, true);
            } else
              kC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && KC.debug("Only the track being published can be inspected");
          }
          async generateRequestData(e2, t2) {
            let { appId: i2, cname: n2, cid: r2, vid: s2, sid: o2, uid: a2 } = t2;
            const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await fb(d2, i2, n2), h2 = this._sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + xT(12, ""), u2 = { appId: i2, cid: r2, cname: n2, deviceId: "", elapse: IM.intToLong(Number(c2 - this._moderationStartTime)), fileSize: d2.buffer.byteLength, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: h2, sdkVersion: "4.19.3", sequence: this._sequence, sid: o2, timestamp: CM(c2), uid: a2, vid: s2, service: this._moderationMode, ticket: this._ticket }, p2 = Yk(u2);
            if (p2.byteLength < this._workerMessageLengthLimit) {
              if (kC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
                const e3 = function(e4) {
                  for (var t3 = 1; t3 < arguments.length; t3++) {
                    var i3 = null != arguments[t3] ? arguments[t3] : {};
                    t3 % 2 ? vM(Object(i3), true).forEach(function(t4) {
                      nu(e4, t4, i3[t4]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : vM(Object(i3)).forEach(function(t4) {
                      Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i3, t4));
                    });
                  }
                  return e4;
                }({}, u2);
                delete e3.jpg, KC.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e3));
              }
              return p2;
            }
            {
              const t3 = this.quality * this._qualityRatio;
              return this.quality = t3, await this.generateRequestData(e2, { appId: i2, cname: n2, cid: r2, vid: s2, sid: o2, uid: a2 });
            }
          }
          close() {
            this._cancelTokenSource.cancel(), this._cancelTokenSource = EC.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = yI.CLOSED, this.emit(AI.STATE_CHANGE, bI.CLOSED);
          }
        }
        function yM(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function AM(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? yM(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yM(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        class bM extends DI {
          get currentLocalDescription() {
            return this.peerConnection.currentLocalDescription;
          }
          get currentRemoteDescription() {
            return this.peerConnection.currentRemoteDescription;
          }
          get peerConnectionState() {
            return this.peerConnection.connectionState;
          }
          get iceConnectionState() {
            return this.peerConnection.iceConnectionState;
          }
          get dtlsTransportState() {
            var e2, t2;
            return null !== (e2 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (t2 = t2.transport) || void 0 === t2 ? void 0 : t2.state) && void 0 !== e2 ? e2 : null;
          }
          constructor(e2, t2, i2) {
            super(e2, t2), nu(this, "direction", void 0), nu(this, "store", void 0), nu(this, "peerConnection", void 0), nu(this, "transportEventReceiver", void 0), nu(this, "statsFilter", void 0), nu(this, "localCandidateCount", 0), nu(this, "allCandidatesReceived", false), nu(this, "mutex", new YT("P2PConnection-mutex")), nu(this, "dataChannel", void 0), nu(this, "onLocalCandidate", void 0), this.store = t2, this.peerConnection = new RTCPeerConnection(bM.resolvePCConfiguration(e2), { optional: [{ googDscp: true }] }), this.direction = null != i2 ? i2 : vv.SEND_ONLY, this.dataChannel = this.peerConnection.createDataChannel("agora-p2p-signal", { ordered: true }), this.statsFilter = PL(this.peerConnection, kC("STATS_UPDATE_INTERVAL"), void 0, Rg() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
          }
          async establish(e2) {
            try {
              if (e2) {
                await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e2 });
                const t2 = await this.peerConnection.createAnswer();
                if (await this.peerConnection.setLocalDescription(t2), !t2.sdp)
                  throw new Error("Cannot get answer sdp when trying to establish PeerConnection.");
                return t2.sdp;
              }
              {
                const e3 = await this.peerConnection.createOffer();
                if (!e3.sdp)
                  throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
                return await this.peerConnection.setLocalDescription(e3), e3.sdp;
              }
            } catch (e3) {
              throw new Vg(xg.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
            }
          }
          async connect(e2) {
            try {
              await this.peerConnection.setRemoteDescription({ type: "answer", sdp: e2 });
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e3.toString()));
            }
          }
          async addRemoteCandidate(e2) {
            try {
              await this.peerConnection.addIceCandidate(e2);
            } catch (e3) {
              throw new Vg(xg.ADD_CANDIDATE_FAILED, "P2PConnection.addRemoteCandidate failed; ".concat(e3.toString()));
            }
          }
          async send(e2) {
            try {
              const t2 = [];
              e2.forEach((e3) => {
                const i3 = this.peerConnection.addTransceiver(e3._mediaStreamTrack, { direction: "sendonly" });
                t2.push(i3);
              }), Rg() && true === kC("SIMULCAST") && await this.applySimulcastForFirefox(t2, e2), await this.applySimulcastEncodings(t2, e2), await this.applySendEncodings(t2, e2);
              const i2 = await this.peerConnection.createOffer();
              if (await this.peerConnection.setLocalDescription(i2), !i2.sdp)
                throw new Error("Cannot get offer.sdp when trying to send PeerConnection.");
              const n2 = t2.map((e3) => {
                const t3 = this.getLocalSSRC(e3.mid, i2.sdp);
                if (!t3)
                  throw new Error("Cannot get ssrc when trying to send PeerConnection.");
                return { mid: e3.mid, localSSRC: [{ ssrcId: t3 }] };
              });
              return { sdp: i2.sdp, trackMessage: n2 };
            } catch (e3) {
              throw e3 instanceof Vg ? e3 : new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e3.toString()));
            }
          }
          async stopSending(e2, t2) {
            const i2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
            try {
              const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e2.indexOf(t4.mid));
              if (t3.length !== e2.length)
                throw new Error("Transceivers' length (".concat(t3.length, ") doesn't match mids' length (").concat(e2.length, ") when trying to call P2PConnection.stopSending."));
              t3.map((e3) => {
                var t4;
                e3.direction = "inactive", null === (t4 = e3.stop) || void 0 === t4 || t4.call(e3), this.peerConnection.removeTrack(e3.sender);
              });
              const n2 = await this.peerConnection.createOffer();
              if (await this.peerConnection.setLocalDescription(n2), !n2.sdp)
                throw new Error("Cannot get offer.sdp when trying to send PeerConnection.");
              return n2.sdp;
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e3.toString()));
            } finally {
              i2 && i2();
            }
          }
          async receive(e2, t2, i2) {
            try {
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const n2 = await this.peerConnection.createAnswer();
              if (!n2.sdp)
                throw new Error("Cannot get answer sdp when trying to receive track.");
              await this.peerConnection.setLocalDescription(n2), KC.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e2, " by exchanging SDP."));
              const r2 = this.getRemoteMid(i2, t2);
              if (void 0 === r2)
                throw new Error("Cannot get transceiver mid when trying to receive track.");
              const s2 = this.peerConnection.getTransceivers().find((e3) => e3.mid === r2);
              if (!s2 || null === s2.mid)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: s2.receiver.track, mid: s2.mid, sdp: n2.sdp };
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e3.toString()));
            }
          }
          async setDescription(e2, t2) {
            try {
              if ("remote" === e2) {
                await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
                const i2 = await this.peerConnection.createAnswer();
                if (!i2.sdp)
                  throw new Error("Cannot get answer sdp when trying to receive track.");
                return await this.peerConnection.setLocalDescription(i2), KC.debug("[".concat(this.store.clientId, "] [P2PConnection] exchanging SDP, type is ").concat(e2)), i2.sdp;
              }
              await this.peerConnection.setRemoteDescription({ type: "answer", sdp: t2 });
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection.setDescription failed; ".concat(e3.toString()));
            }
          }
          async stopReceiving(e2, t2) {
            try {
              const i2 = this.peerConnection.getTransceivers().filter((t3) => -1 !== e2.indexOf(t3.mid));
              if (i2.length !== e2.length)
                throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
              i2.map((e3) => {
                var t3;
                e3.direction = "inactive", null === (t3 = e3.stop) || void 0 === t3 || t3.call(e3);
              }), await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
              const n2 = await this.peerConnection.createAnswer();
              if (await this.peerConnection.setLocalDescription(n2), !n2.sdp)
                throw new Error("Cannot get answer sdp when trying to receive track.");
              return n2.sdp;
            } catch (e3) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e3.toString()));
            }
          }
          async restartICE() {
            try {
              const e2 = await this.peerConnection.createOffer({ iceRestart: true });
              if (!e2.sdp)
                throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              return this.store.descriptionStart(), await this.peerConnection.setLocalDescription(e2), e2.sdp;
            } catch (e2) {
              throw new Vg(xg.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e2.toString()));
            }
          }
          close() {
            var e2;
            this.peerConnection.close(), null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.transportEventReceiver = void 0, this.statsFilter.destroy();
          }
          getStats() {
            return this.statsFilter.getStats();
          }
          getRemoteVideoIsReady(e2) {
            return this.statsFilter.getVideoIsReady(e2);
          }
          async updateEncoderConfig(e2, t2) {
          }
          async updateSendParameters(e2, t2) {
            const i2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e2);
            1 === i2.length && (this.isVP8Simulcast(t2) ? Rg() || await this.applySimulcastEncodings(i2, [t2]) : await this.applySendEncodings(i2, [t2]));
          }
          setStatsRemoteVideoIsReady(e2, t2) {
            this.statsFilter.setVideoIsReady2(e2, t2);
          }
          async replaceTrack(e2, t2) {
            const i2 = this.peerConnection.getTransceivers().find((e3) => e3.mid === t2);
            i2 && await i2.sender.replaceTrack(e2._mediaStreamTrack);
          }
          async getSelectedCandidatePair() {
            const e2 = this.peerConnection.getReceivers();
            if (e2.length > 0 && e2[0].transport && e2[0].transport.iceTransport && e2[0].transport.iceTransport.getSelectedCandidatePair && e2[0].transport.iceTransport.getSelectedCandidatePair()) {
              const t2 = e2[0].transport.iceTransport, { local: i2, remote: n2 } = t2.getSelectedCandidatePair();
              return { local: AM(AM({}, mL), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: AM(AM({}, mL), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
            }
            return this.statsFilter.getSelectedCandidatePair();
          }
          bindPCEvents() {
            this.peerConnection.oniceconnectionstatechange = () => {
              var e2;
              null === (e2 = this.onICEConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.iceConnectionState);
            }, this.peerConnection.onconnectionstatechange = () => {
              var e2;
              null === (e2 = this.onConnectionStateChange) || void 0 === e2 || e2.call(this, this.peerConnection.connectionState);
            }, this.peerConnection.onicecandidate = (e2) => {
              var t2;
              e2.candidate && (null === (t2 = this.onLocalCandidate) || void 0 === t2 || t2.call(this, e2.candidate));
              e2.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, KC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
            }, setTimeout(() => {
              this.allCandidatesReceived || (this.allCandidatesReceived = true, KC.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
            }, kC("CANDIDATE_TIMEOUT"));
          }
          unbindPCEvents() {
            this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
          }
          static resolvePCConfiguration(e2) {
            const t2 = { iceServers: [] };
            return e2.iceServers ? t2.iceServers = e2.iceServers : e2.turnServer && "off" !== e2.turnServer.mode && (_T(e2.turnServer.servers) ? t2.iceServers = e2.turnServer.servers : (t2.iceServers && t2.iceServers.push(...bM.turnServerConfigToIceServers(e2.turnServer.servers)), kC("USE_TURN_SERVER_OF_GATEWAY") && t2.iceServers && e2.turnServer.serversFromGateway && t2.iceServers.push(...bM.turnServerConfigToIceServers(e2.turnServer.serversFromGateway)), kC("FORCE_TURN_TCP") ? t2.iceTransportPolicy = "relay" : e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).forEach((e3) => {
              e3.forceturn && (t2.iceTransportPolicy = "relay");
            }))), kC("ENABLE_ENCODED_TRANSFORM") && _A().supportWebRTCEncodedTransform && (t2.encodedInsertableStreams = true), t2;
          }
          static turnServerConfigToIceServers(e2) {
            const t2 = [];
            return e2.forEach((e3) => {
              e3.tcpport && (t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turns:".concat(_D(e3.turnServerURL), ":").concat(e3.tcpport, "?transport=tcp") }), t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "turn:".concat(e3.turnServerURL, ":").concat(e3.tcpport, "?transport=udp") }), t2.push({ username: e3.username, credential: e3.password, credentialType: "password", urls: "stun:".concat(e3.turnServerURL, ":").concat(e3.tcpport) }));
            }), t2;
          }
          tryBindTransportEvents(e2) {
            const t2 = e2.transport;
            if (t2) {
              this.transportEventReceiver = e2, t2.onstatechange = () => {
                var e3;
                null != t2 && t2.state && (null === (e3 = this.onDTLSTransportStateChange) || void 0 === e3 || e3.call(this, t2.state));
              }, t2.onerror = (e3) => {
                var t3;
                null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e3 ? e3.error : e3);
              };
              const i2 = t2.iceTransport;
              i2 && (i2.onstatechange = () => {
                const e3 = null == t2 ? void 0 : t2.iceTransport.state;
                var i3;
                e3 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, e3));
              }, i2.getSelectedCandidatePair && (i2.onselectedcandidatepairchange = () => {
                if (i2.getSelectedCandidatePair()) {
                  const { local: e3, remote: t3 } = i2.getSelectedCandidatePair();
                  KC.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e3.type, protocol: e3.protocol }), ", remote ").concat(JSON.stringify({ candidateType: t3.type, protocol: t3.protocol, address: t3.address, port: t3.port }), " )"));
                }
              }));
            }
          }
          tryUnbindTransportEvents() {
            this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
          }
          async updateRtpSenderEncodings(e2, t2) {
            var i2;
            if (!t2) {
              t2 = this.peerConnection.getSenders().find((t3) => t3.track === e2._mediaStreamTrack);
            }
            if (!t2)
              return KC.warn("[".concat(e2.getTrackId(), "] no rtpSender found}"));
            if (this.isVP8Simulcast(e2))
              return KC.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
            if (!_A().supportSetRtpSenderParameters)
              return KC.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
            const n2 = {}, r2 = {};
            switch (e2._optimizationMode) {
              case "motion":
                n2.degradationPreference = "maintain-framerate";
                break;
              case "detail":
                n2.degradationPreference = "maintain-resolution";
                break;
              default:
                n2.degradationPreference = "balanced";
            }
            if (e2._encoderConfig) {
              var s2;
              const { bitrateMax: t3, frameRate: i3, scaleResolutionDownBy: n3 } = e2._encoderConfig;
              t3 && (r2.maxBitrate = 1e3 * t3), Pr(s2 = e2._hints).call(s2, ky.LOW_STREAM) && (i3 && (r2.maxFramerate = mD(i3)), n3 && n3 >= 1 && (r2.scaleResolutionDownBy = n3));
            }
            if (kC("DSCP_TYPE") && kg()) {
              var o2;
              const e3 = kC("DSCP_TYPE");
              Pr(o2 = ["very-low", "low", "medium", "high"]).call(o2, e3) && (r2.networkPriority = e3);
            }
            const a2 = t2.getParameters(), c2 = null === (i2 = a2.encodings) || void 0 === i2 ? void 0 : i2[0];
            Rg() && !c2 && (n2.encodings = [r2]), c2 && Object.assign(c2, r2), Object.assign(a2, n2), KC.debug("[".concat(e2.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a2.encodings))), await t2.setParameters(a2);
          }
          async applySendEncodings(e2, t2) {
            try {
              if (!_A().supportSetRtpSenderParameters)
                return;
              if (e2.length !== t2.length)
                return;
              for (let i2 = 0; i2 < e2.length; i2++) {
                const n2 = e2[i2], r2 = t2[i2];
                r2 instanceof Sb && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n2.sender);
              }
            } catch (e3) {
              KC.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
            }
          }
          mungSendOfferSDP(e2, t2, i2) {
            const n2 = KP.parse(e2);
            return t2.forEach((e3, t3) => {
              const r2 = i2[t3], s2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === r2);
              s2 && ($P(s2, e3), rL(s2, e3, this.store.codec));
            }), KP.print(n2);
          }
          bindStatsEvents() {
            this.statsFilter.onFirstAudioReceived = (e2) => {
              var t2;
              null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstVideoReceived = (e2) => {
              var t2;
              null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstAudioDecoded = (e2) => {
              var t2;
              null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e2);
            }, this.statsFilter.onFirstVideoDecoded = (e2, t2, i2) => {
              var n2;
              null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e2, t2, i2);
            }, this.statsFilter.onSelectedLocalCandidateChanged = (e2, t2) => {
              var i2;
              null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
            }, this.statsFilter.onSelectedRemoteCandidateChanged = (e2, t2) => {
              var i2;
              null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e2, t2);
            }, this.statsFilter.onFirstVideoDecodedTimeout = (e2) => {
              var t2;
              null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e2);
            };
          }
          unbindStatsEvents() {
            this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
          }
          async applySimulcastForFirefox(e2, t2) {
            if (e2.length === t2.length)
              for (let a2 = 0; a2 < e2.length; a2++) {
                var i2, n2, r2, s2, o2;
                const c2 = e2[a2], d2 = t2[a2];
                if (d2 instanceof Sb && !Pr(i2 = d2._hints).call(i2, ky.LOW_STREAM) && null !== (n2 = d2._encoderConfig) && void 0 !== n2 && n2.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (s2 = d2._scalabilityMode) && void 0 !== s2 && s2.numSpatialLayers && (null === (o2 = d2._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                  const e3 = {}, t3 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                  e3.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
                  const i3 = c2.sender.getParameters();
                  await c2.sender.setParameters(Object.assign(i3, e3));
                }
              }
          }
          async applySimulcastEncodings(e2, t2) {
            if (!Rg() && e2.length === t2.length)
              for (let i2 = 0; i2 < e2.length; i2++) {
                const n2 = t2[i2];
                if (n2 instanceof Sb && this.isVP8Simulcast(n2)) {
                  const t3 = e2[i2], r2 = {}, s2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                  r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: s2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: s2.medium, scaleResolutionDownBy: 4 }];
                  const o2 = t3.sender.getParameters();
                  await t3.sender.setParameters(Object.assign(o2, r2));
                }
              }
          }
          isVP8Simulcast(e2) {
            var t2, i2, n2, r2, s2;
            return !!(e2 instanceof Sb && kC("SIMULCAST") && "vp8" === this.store.codec && !Pr(t2 = e2._hints).call(t2, ky.LOW_STREAM) && null !== (i2 = e2._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n2 = e2._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = e2._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (s2 = e2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1);
          }
          logSDPExchange(e2, t2, i2, n2) {
            if (kC("SDP_LOGGING"))
              return KC.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e2), "offer" === t2 ? (e3) => {
                this.logSDPExchange(e3, "answer", "local" === i2 ? "remote" : "local", n2);
              } : void 0;
          }
          getLocalSSRC(e2, t2) {
            var i2, n2;
            if (t2 = null !== (i2 = t2) && void 0 !== i2 ? i2 : null === (n2 = this.currentLocalDescription) || void 0 === n2 ? void 0 : n2.sdp) {
              var r2;
              const i3 = null === (r2 = KP.parse(t2).mediaDescriptions.find((t3) => t3.attributes.mid === e2)) || void 0 === r2 ? void 0 : r2.attributes.ssrcs;
              return null == i3 ? void 0 : i3[0].ssrcId;
            }
          }
          getRemoteMid(e2, t2) {
            var i2, n2;
            if (t2 = null !== (i2 = t2) && void 0 !== i2 ? i2 : null === (n2 = this.currentRemoteDescription) || void 0 === n2 ? void 0 : n2.sdp) {
              var r2;
              return null === (r2 = KP.parse(t2).mediaDescriptions.find((t3) => t3.attributes.ssrcs.some((t4) => t4.ssrcId === e2))) || void 0 === r2 ? void 0 : r2.attributes.mid;
            }
          }
          async getRemoteSSRC(e2, t2) {
            var i2, n2;
            if (t2 = null !== (i2 = t2) && void 0 !== i2 ? i2 : null === (n2 = this.currentRemoteDescription) || void 0 === n2 ? void 0 : n2.sdp) {
              var r2;
              const i3 = null === (r2 = KP.parse(t2).mediaDescriptions.find((t3) => t3.attributes.mid === e2)) || void 0 === r2 ? void 0 : r2.attributes.ssrcs;
              return null == i3 ? void 0 : i3[0].ssrcId;
            }
          }
        }
        function wM(e2, t2, i2) {
          const n2 = e2[t2];
          if ("function" != typeof n2)
            throw new Error("Cannot use mutex on object property.");
          return i2.value = async function() {
            const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t2));
            try {
              for (var r2 = arguments.length, s2 = new Array(r2), o2 = 0; o2 < r2; o2++)
                s2[o2] = arguments[o2];
              return await n2.apply(this, s2);
            } finally {
              i3();
            }
          }, i2;
        }
        var OM;
        function NM(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function DM(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? NM(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : NM(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], bM.prototype, "establish", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], bM.prototype, "connect", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [RTCIceCandidate]), Uv("design:returntype", tg)], bM.prototype, "addRemoteCandidate", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], bM.prototype, "send", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [String, String, Number]), Uv("design:returntype", tg)], bM.prototype, "receive", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [String, String]), Uv("design:returntype", tg)], bM.prototype, "setDescription", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [Array, String]), Uv("design:returntype", tg)], bM.prototype, "stopReceiving", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], bM.prototype, "restartICE", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], bM.prototype, "close", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], bM.prototype, "updateEncoderConfig", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [String, iA]), Uv("design:returntype", tg)], bM.prototype, "updateSendParameters", null), Mv([wM, Uv("design:type", Function), Uv("design:paramtypes", [iA, String]), Uv("design:returntype", tg)], bM.prototype, "replaceTrack", null), function(e2) {
          e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY";
        }(OM || (OM = {}));
        class PM extends iT {
          get state() {
            return this._state;
          }
          set state(e2) {
            const t2 = this._state;
            this._state = e2, this.emit(mI.StateChange, t2, this._state);
          }
          constructor(e2, t2) {
            super(), nu(this, "store", void 0), nu(this, "statsUploader", void 0), nu(this, "sendConnection", void 0), nu(this, "recvConnection", void 0), nu(this, "localTrackMap", /* @__PURE__ */ new Map()), nu(this, "remoteUserMap", /* @__PURE__ */ new Map()), nu(this, "localDataChannels", []), nu(this, "pendingLocalTracks", []), nu(this, "pendingRemoteTracks", []), nu(this, "statsCollector", void 0), nu(this, "dtlsFailedCount", 0), nu(this, "sendMutex", new YT("P2PChannel2-send-mutex")), nu(this, "recvMutex", new YT("P2PChannel2-recv-mutex")), nu(this, "_state", EI.Disconnected), nu(this, "_restartStates", ["disconnected", "failed"]), nu(this, "_restartTimer", void 0), nu(this, "handleMuteLocalTrack", async (e3, t3, i2) => {
              const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleMuteLocalTrack");
              try {
                if (!this.sendConnection || this.state !== EI.Connected)
                  return void i2(new Vg(xg.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established."));
                const o2 = this.filterTobeMutedTracks(e3);
                if (0 === o2.length)
                  return void t3();
                const a2 = o2.find((e4) => "videoLowTrack" === e4[0]);
                if (a2) {
                  a2[1].track._originMediaStreamTrack.stop();
                }
                let c2 = false;
                var r2, s2;
                if ("video" === e3.trackMediaType)
                  c2 = !(null === (r2 = this.localTrackMap.get(_I.LocalAudioTrack)) || void 0 === r2 || !r2.track._muted);
                else
                  c2 = void 0 === (null === (s2 = this.localTrackMap.get(_I.LocalVideoTrack)) || void 0 === s2 ? void 0 : s2.id);
                const d2 = o2.filter((e4) => {
                  let [t4, i3] = e4;
                  return (t4 !== _I.LocalAudioTrack || c2) && void 0 !== i3.id;
                }).map((e4) => {
                  let [, t4] = e4;
                  return t4;
                });
                let l2;
                d2.length > 0 && (l2 = await this.sendConnection.stopSending(d2.map((e4) => e4.id)), d2.forEach((e4) => {
                  e4.id = void 0, e4.ssrcs = void 0;
                }));
                const h2 = this.createMuteMessage(o2), u2 = "video" === e3.trackMediaType ? OI.MUTE_LOCAL_VIDEO : OI.MUTE_LOCAL_AUDIO, p2 = await fT(this, mI.RequestP2PMuteLocal, { action: u2, sdp: l2, message: h2, isMuteAll: c2 });
                p2 && await this.sendConnection.setDescription("local", p2), (l2 || "audio" === e3.trackMediaType) && await gT(this, mI.RequestMuteLocal, h2), t3();
              } catch (e4) {
                i2(e4);
              } finally {
                n2();
              }
            }), nu(this, "handleUnmuteLocalTrack", async (e3, t3, i2) => {
              const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUnmuteLocalTrack");
              try {
                if (!this.sendConnection || this.state !== EI.Connected)
                  return void i2(new Vg(xg.INVALID_OPERATION, "Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established."));
                const r2 = this.filterTobeUnmutedTracks(e3);
                if (0 === r2.length)
                  return void t3();
                const s2 = this.createUnmuteMessage(r2), o2 = "video" === e3.trackMediaType ? OI.UNMUTE_LOCAL_VIDEO : OI.UNMUTE_LOCAL_AUDIO;
                await gT(this, mI.RequestP2PMuteLocal, { action: o2, message: s2 }), t3();
              } catch (e4) {
                i2(e4);
              } finally {
                n2();
              }
            }), nu(this, "handleUpdateVideoEncoder", async (e3, t3, i2) => {
              const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleSetVideoEncoder");
              try {
                const i3 = this.localTrackMap.get(_I.LocalVideoTrack);
                if (!this.sendConnection || !i3 || i3.track !== e3 || this.state !== EI.Connected)
                  return void t3();
                const { id: r2, track: s2 } = i3;
                r2 && (await this.sendConnection.updateSendParameters(r2, s2), await this.sendConnection.updateEncoderConfig(r2, s2), this.emit(mI.UpdateVideoEncoder, s2)), t3();
              } catch (e4) {
                i2(e4);
              } finally {
                n2();
              }
            }), nu(this, "handleSetOptimizationMode", async (e3, t3, i2) => {
              const n2 = await this.sendMutex.lock("Locking from P2PChannel2.handleSetOptimizationMode");
              try {
                const i3 = this.localTrackMap.get(_I.LocalVideoTrack);
                if (!this.sendConnection || !i3 || i3.track !== e3 || this.state !== EI.Connected)
                  return;
                const { id: r2, track: s2 } = i3;
                r2 && await this.sendConnection.updateSendParameters(r2, s2), t3();
              } catch (e4) {
                i2(e4);
              } finally {
                n2();
              }
            }), nu(this, "handleReplaceTrack", async (e3, t3, i2, n2) => {
              let r2;
              KC.debug("[".concat(this.store.clientId, "] P2PChannel2 handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.sendMutex.lock("From P2PChannel2.handleReplaceTrack"));
              try {
                var s2;
                const i3 = Array.from(this.localTrackMap.entries()).find((t4) => {
                  let [, { track: i4 }] = t4;
                  return e3 === i4;
                });
                if (!this.sendConnection || !i3 || void 0 === i3[1].id || this.state !== EI.Connected)
                  return void t3();
                if (await (null === (s2 = this.sendConnection) || void 0 === s2 ? void 0 : s2.replaceTrack(e3, i3[1].id)), i3[0] === _I.LocalVideoTrack && _A().supportDualStreamEncoding) {
                  const t4 = this.localTrackMap.get(_I.LocalVideoLowTrack);
                  if (t4) {
                    const i4 = e3._mediaStreamTrack.clone();
                    t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4, await new tg((e4, i5) => {
                      this.handleReplaceTrack(t4.track, e4, i5, true);
                    });
                  }
                }
                t3();
              } catch (e4) {
                i2(e4);
              } finally {
                var o2;
                null === (o2 = r2) || void 0 === o2 || o2();
              }
            }), nu(this, "handleGetLocalVideoStats", (e3) => {
              e3(this.statsCollector.getLocalVideoTrackStats());
            }), nu(this, "handleGetLocalAudioStats", (e3) => {
              e3(this.statsCollector.getLocalAudioTrackStats());
            }), nu(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), nu(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new dk(), this.bindStatsUploaderEvents();
          }
          async startP2PConnection(e2, t2) {
            throw new Vg(xg.NOT_SUPPORTED, "p2p mode does not support startP2PConnection.");
          }
          async connect(e2, t2, i2, n2, r2, s2) {
            throw new Vg(xg.NOT_SUPPORTED, "p2p mode does not support connect.");
          }
          async startP2P(e2, t2) {
            if (this.state = EI.New, this.sendConnection && (KC.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset P2PConnection.")), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection)), this.recvConnection && (KC.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset P2PConnection.")), this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection)), this.sendConnection = new bM(e2, this.store), this.bindConnectionEvents(this.sendConnection), this.recvConnection = new bM(e2, this.store, vv.RECEIVE_ONLY), this.bindConnectionEvents(this.recvConnection), t2) {
              this.store.peerConnectionStart(), await this.recvConnection.establish(t2);
              const e3 = await this.sendConnection.establish(t2);
              return this.statsUploader.startUploadTransportStats(true), this.statsUploader.startUploadExtensionUsageStats(), this.state = EI.Connected, e3;
            }
            return await this.recvConnection.establish(t2), this.sendConnection.establish(t2);
          }
          async p2pConnect(e2) {
            if (!this.sendConnection || !this.recvConnection)
              throw new Vg(xg.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.startP2PConnection .");
            this.store.peerConnectionStart(), await this.recvConnection.connect(e2), await this.sendConnection.connect(e2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = EI.Connected;
          }
          async addRemoteCandidate(e2) {
            if (!this.sendConnection || !this.recvConnection)
              throw new Vg(xg.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.recvConnection.addRemoteCandidate(e2), await this.sendConnection.addRemoteCandidate(e2);
          }
          async publish(e2, t2, i2) {
            if (!this.sendConnection || this.state !== EI.Connected) {
              this.throwIfTrackTypeNotMatch(e2);
              const t3 = e2.filter((e3) => -1 === this.pendingLocalTracks.indexOf(e3));
              return void (this.pendingLocalTracks = this.pendingLocalTracks.concat(t3));
            }
            this.store.pubId = this.store.pubId + 1, cD.markPublishStart(this.store.clientId, this.store.pubId);
            const n2 = this.filterTobePublishedTracks(e2, t2, i2);
            if (0 === n2.length)
              return void await this.tryToUnmuteAudio(e2);
            n2.forEach((e3) => {
              let { track: t3, type: i3 } = e3;
              const n3 = Date.now();
              this.store.publish(t3.getTrackId(), i3 === _I.LocalAudioTrack ? "audio" : "video", n3);
            }), this.bindLocalTrackEvents(n2);
            const r2 = this.createGatewayPublishMessage(n2);
            return this.assignLocalTracks(n2), n2.forEach((e3) => {
              let { track: t3, type: i3 } = e3;
              const n3 = Date.now();
              this.store.publish(t3.getTrackId(), i3 === _I.LocalAudioTrack ? "audio" : "video", void 0, n3);
            }), r2;
          }
          async dopublish(e2) {
            if (!this.sendConnection || this.state !== EI.Connected)
              return;
            const t2 = this.localTrackMap.get(e2);
            if (t2) {
              const { sdp: i2, trackMessage: n2 } = await this.sendConnection.send([t2.track]), { mid: r2, localSSRC: s2 } = n2[0];
              t2.id = r2, t2.ssrcs = s2, this.statsCollector.addLocalStats(e2), this.statsUploader.startUploadUplinkStats();
              const o2 = await fT(this, mI.RequestP2PPublish, { kind: e2 === _I.LocalAudioTrack ? hI.AUDIO : hI.VIDEO, sdp: i2, ssrcId: s2[0].ssrcId });
              await this.sendConnection.setDescription("local", o2);
              const a2 = this.createUnmuteMessage([[e2, t2]]);
              await gT(this, mI.RequestUnmuteLocal, a2);
            } else
              ;
          }
          async setDescription(e2, t2) {
            let i2, n2;
            "local" === e2 ? (i2 = await this.sendMutex.lock("From P2PChannel.restartICE"), n2 = this.sendConnection) : (i2 = await this.recvMutex.lock("From P2PChannel.restartICE"), n2 = this.recvConnection);
            try {
              if (!n2 || this.state !== EI.Connected)
                return;
              return await n2.setDescription(e2, t2);
            } finally {
              i2();
            }
          }
          publishLowStream(e2) {
            return BP(function* () {
              throw new Vg(xg.NOT_SUPPORTED, "p2p mode does not support publishLowStream.");
            })();
          }
          async republish() {
            this.pendingLocalTracks.length > 0 && (KC.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await fT(this, mI.RequestRePublish, this.pendingLocalTracks), this.emit(mI.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
          }
          async unpublish(e2) {
            if (!this.sendConnection || this.state !== EI.Connected)
              return void (0 === e2.length ? this.pendingLocalTracks.length = 0 : this.pendingLocalTracks = this.pendingLocalTracks.filter((t3) => !Pr(e2).call(e2, t3)));
            const t2 = this.filterTobeUnpublishedTracks(e2);
            if (0 === t2.length)
              return;
            this.unbindLocalTrackEvents(t2.map((e3) => {
              let [t3, { track: i3 }] = e3;
              return { type: t3, track: i3 };
            }));
            const i2 = t2.filter((e3) => {
              let [, { id: t3 }] = e3;
              return void 0 !== t3;
            });
            if (!this.sendConnection || this.state !== EI.Connected)
              return void e2.forEach((e3) => {
                const t3 = this.pendingLocalTracks.indexOf(e3);
                -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
              });
            const n2 = t2.find((e3) => "videoLowTrack" === e3[0]);
            if (n2) {
              n2[1].track.close();
            }
            let r2;
            const s2 = this.createGatewayUnpublishMessage(t2);
            i2.length > 0 && (r2 = await this.sendConnection.stopSending(i2.map((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            }))), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
              let [t3, { track: i3 }] = e3;
              return { type: t3, track: i3 };
            })), t2.forEach((e3) => {
              let [t3] = e3;
              this.statsCollector.removeLocalStats(t3);
            }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadUplinkStats();
            const o2 = this.createMuteMessage(t2);
            return await tg.all(o2.map(async (e3) => {
              await gT(this, mI.RequestMuteLocal, [e3]);
            })), { sdp: r2, unpubMsg: s2 };
          }
          async unpublishLowStream() {
            throw new Vg(xg.NOT_SUPPORTED, "p2p mode does not support unpublishLowStream.");
          }
          async doUnpublish(e2) {
            if (!this.sendConnection || this.state !== EI.Connected)
              return;
            const t2 = [];
            if (e2 !== hI.AUDIO) {
              const e3 = this.localTrackMap.get(_I.LocalVideoTrack);
              void 0 !== (null == e3 ? void 0 : e3.id) && t2.push([_I.LocalVideoTrack, e3]);
              const i2 = this.localTrackMap.get(_I.LocalVideoLowTrack);
              void 0 !== (null == i2 ? void 0 : i2.id) && t2.push([_I.LocalVideoLowTrack, i2]), this.statsCollector.removeLocalStats(_I.LocalVideoTrack), this.statsCollector.removeLocalStats(_I.LocalVideoLowTrack);
            }
            if (e2 !== hI.VIDEO) {
              const e3 = this.localTrackMap.get(_I.LocalAudioTrack);
              void 0 !== (null == e3 ? void 0 : e3.id) && t2.push([_I.LocalAudioTrack, e3]), this.statsCollector.removeLocalStats(_I.LocalAudioTrack);
            }
            if (t2.length > 0) {
              const i2 = await this.sendConnection.stopSending(t2.map((e3) => {
                let [, t3] = e3;
                return t3.id;
              }));
              t2.forEach((e3) => {
                let [, t3] = e3;
                t3.id = void 0, t3.ssrcs = void 0;
              });
              const n2 = await fT(this, mI.RequestP2PUnPublish, { sdp: i2, kind: e2 });
              await this.sendConnection.setDescription("local", n2);
              const r2 = this.createMuteMessage(t2);
              await tg.all(r2.map(async (e3) => {
                await gT(this, mI.RequestMuteLocal, [e3]);
              }));
            } else
              ;
          }
          async subscribe(e2, t2, i2, n2) {
            var r2;
            if (!this.recvConnection || this.state !== EI.Connected)
              throw new Vg(xg.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
            if (null !== (r2 = this.remoteUserMap.get(e2)) && void 0 !== r2 && r2.has(t2))
              return;
            const { track: s2, mid: o2, sdp: a2 } = await this.recvConnection.receive(t2, i2, n2);
            t2 === hI.AUDIO ? (e2._audioSSRC = n2, e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(s2) : (e2._audioTrack = new Ob(s2, e2.uid, e2._uintid, this.store), KC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoSSRC = n2, e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(s2) : (e2._videoTrack = new wb(s2, e2.uid, e2._uintid, this.store), KC.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(e2, e2._videoTrack));
            const c2 = this.remoteUserMap.get(e2);
            c2 ? c2.set(t2, o2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, o2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadDownlinkStats(), await gT(this, mI.RequestP2PUnmuteRemote, t2);
            const d2 = this.pendingRemoteTracks.findIndex((i3) => {
              let { user: n3, kind: r3 } = i3;
              return n3.uid === e2.uid && t2 === r3;
            });
            return -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(mI.MediaReconnectEnd, e2.uid)), a2;
          }
          async unsubscribe(e2, t2, i2, n2) {
            const r2 = this.pendingRemoteTracks.filter((t3) => {
              let { user: n3, kind: r3 } = t3;
              return void 0 !== i2 ? n3.uid === e2.uid && i2 === r3 : n3.uid === e2.uid;
            });
            if (r2.forEach((e3) => {
              const t3 = this.pendingRemoteTracks.indexOf(e3);
              this.pendingRemoteTracks.splice(t3, 1);
            }), this.recvConnection && this.state === EI.Connected || n2 || r2.forEach((t3) => {
              let { kind: i3 } = t3;
              var n3;
              if (i3 === hI.AUDIO)
                null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
              else if (i3 === hI.VIDEO) {
                var r3;
                null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
              }
            }), !this.recvConnection || this.state !== EI.Connected)
              return;
            const s2 = this.filterTobeUnSubscribedTracks(e2, i2);
            if (0 === s2.length)
              return void (i2 !== hI.VIDEO && gT(this, mI.RequestP2PMuteRemote, hI.AUDIO));
            const o2 = await this.recvConnection.stopReceiving(s2.map((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            }), t2);
            return this.withdrawRemoteTracks(s2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), s2.forEach((e3) => {
              let [t3, { kind: i3 }] = e3;
              var r3, s3;
              i3 === hI.VIDEO && t3._videoSSRC && (null === (r3 = this.recvConnection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
              if (i3 === hI.VIDEO)
                this.unbindRemoteTrackEvents(t3._videoTrack), n2 || (null === (s3 = t3._videoTrack) || void 0 === s3 || s3._destroy(), t3._videoTrack = void 0);
              else if (i3 === hI.AUDIO) {
                var o3;
                if (this.unbindRemoteTrackEvents(t3._audioTrack), !n2)
                  null === (o3 = t3._audioTrack) || void 0 === o3 || o3._destroy(), t3._audioTrack = void 0;
              }
            }), s2.filter((e3) => {
              let [, { kind: t3 }] = e3;
              return t3 !== hI.AUDIO;
            }).forEach((e3) => {
              let [, { kind: t3 }] = e3;
              gT(this, mI.RequestP2PMuteRemote, t3);
            }), i2 !== hI.VIDEO && gT(this, mI.RequestP2PMuteRemote, hI.AUDIO), o2;
          }
          getAllDataChannels() {
            return this.localDataChannels;
          }
          async massSubscribe(e2) {
            throw new Vg(xg.NOT_SUPPORTED, "p2p mode does not support massSubscribe.");
          }
          async massSubscribeNoLock(e2) {
            throw new Vg(xg.NOT_SUPPORTED, "p2p mode does not support massSubscribeNoLock.");
          }
          async massUnsubscribe(e2) {
            throw new Vg(xg.NOT_SUPPORTED, "p2p mode does not support massUnsubscribe.");
          }
          async massUnsubscribeNoLock(e2) {
            throw new Vg(xg.NOT_SUPPORTED, "p2p mode does not support massUnsubscribeNoLock.");
          }
          async muteRemote(e2, t2) {
            if (!this.recvConnection)
              return;
            const i2 = this.remoteUserMap.get(e2);
            if (!i2)
              return void KC.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, "."));
            if (!i2.get(t2))
              return void KC.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
            const n2 = t2 === hI.VIDEO ? e2._videoSSRC : e2._audioSSRC;
            void 0 !== n2 && this.recvConnection.setStatsRemoteVideoIsReady(n2, false);
          }
          async unmuteRemote(e2, t2) {
            return this.unmuteRemoteNoLock(e2, t2);
          }
          async unmuteRemoteNoLock(e2, t2) {
            if (!this.recvConnection)
              return;
            const i2 = this.remoteUserMap.get(e2);
            if (!i2)
              return void KC.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, "."));
            i2.get(t2) || KC.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
          }
          getAllTracks(e2) {
            const t2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if ((null == t2 ? void 0 : t2.track) instanceof tb) {
              const i2 = t2.track;
              return Array.from(this.localTrackMap.entries()).filter((e3) => {
                let [t3] = e3;
                return t3 !== _I.LocalAudioTrack;
              }).filter((t3) => {
                let [i3] = t3;
                return !(e2 && i3 === _I.LocalVideoLowTrack);
              }).map((e3) => {
                let [, { track: t3 }] = e3;
                return t3;
              }).concat(i2.trackList);
            }
            return Array.from(this.localTrackMap.entries()).filter((t3) => {
              let [i2] = t3;
              return !(e2 && i2 === _I.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            });
          }
          reportPublishEvent(e2, t2, i2, n2, r2) {
            if (e2) {
              const i3 = this.localTrackMap.get(_I.LocalAudioTrack), s3 = n2 ? this.localTrackMap.get(_I.LocalVideoLowTrack) : this.localTrackMap.get(_I.LocalVideoTrack);
              rv.publish(this.store.sessionId, { eventElapse: cD.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == s3 ? void 0 : s3.track.getTrackLabel(), screenshare: -1 !== (null == s3 ? void 0 : s3.track._hints.indexOf(ky.SCREEN_TRACK)), audio: !!i3, video: !!s3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
            } else {
              var s2;
              i2 || (i2 = []);
              const o2 = i2.find((e3) => e3 instanceof ZA), a2 = n2 ? null === (s2 = this.localTrackMap.get(_I.LocalVideoTrack)) || void 0 === s2 ? void 0 : s2.track : i2.find((e3) => e3 instanceof Sb);
              rv.publish(this.store.sessionId, { eventElapse: cD.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == o2 ? void 0 : o2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(ky.SCREEN_TRACK)), audio: !!o2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
            }
          }
          reportSubscribeEvent(e2, t2, i2, n2) {
            const r2 = n2 === hI.VIDEO ? i2._videoSSRC : i2._audioSSRC;
            r2 && rv.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === hI.VIDEO, audio: n2 === hI.AUDIO, peerid: i2.uid, subscribeRequestid: n2 === hI.VIDEO ? i2._videoSSRC : i2._audioSSRC, p2pid: this.store.p2pId, eventElapse: cD.measureFromSubscribeStart(this.store.clientId, r2) });
          }
          reset() {
            KC.debug("[".concat(this.store.clientId, "] P2PChannel2.reset")), this.sendMutex = new YT("P2PChannel2-send-mutex"), this.sendMutex = new YT("P2PChannel2-recv-mutex"), this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
            const e2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if ((null == e2 ? void 0 : e2.track) instanceof tb) {
              if (e2.track.trackList.length > 0) {
                const t2 = e2.track;
                e2.track.trackList.forEach((e3) => {
                  t2.removeAudioTrack(e3);
                });
              }
              e2.track.close();
            }
            this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.state = EI.Disconnected;
          }
          getStats(e2) {
            var t2, i2;
            return e2 ? null === (i2 = this.recvConnection) || void 0 === i2 ? void 0 : i2.getStats() : null === (t2 = this.sendConnection) || void 0 === t2 ? void 0 : t2.getStats();
          }
          getRemoteVideoIsReady(e2) {
            var t2;
            return (null === (t2 = this.recvConnection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
          }
          getLocalAudioVolume() {
            const e2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if (e2)
              return e2.track.getVolumeLevel();
          }
          getLocalVideoSize() {
            const e2 = this.localTrackMap.get(_I.LocalVideoTrack);
            if (e2)
              return { width: e2.track._videoWidth || 0, height: e2.track._videoHeight || 0 };
          }
          getEncoderConfig(e2) {
            const t2 = this.localTrackMap.get(e2);
            return t2 && t2.track instanceof Sb || t2 && t2.track instanceof ZA ? t2.track._encoderConfig : void 0;
          }
          getLocalMedia(e2) {
            return this.localTrackMap.get(e2);
          }
          hasLocalMedia() {
            return this.localTrackMap.size > 0;
          }
          hasRemoteMedia(e2, t2) {
            if (!e2)
              return this.remoteUserMap.size > 0;
            const i2 = this.remoteUserMap.get(e2);
            return !!i2 && (!t2 || i2.has(t2));
          }
          async hasRemoteMediaWithLock(e2, t2) {
            if (!e2)
              return this.remoteUserMap.size > 0;
            const i2 = this.remoteUserMap.get(e2);
            return !!i2 && (!t2 || i2.has(t2));
          }
          getRemoteMedia(e2) {
            var t2;
            const i2 = Array.from(hu(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
            return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
          }
          getAudioLevels() {
            let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
              let [t3] = e3;
              return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
            });
            const t2 = this.localTrackMap.get(_I.LocalAudioTrack);
            return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = Zu(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
          }
          async disconnectForReconnect() {
            this.sendConnection && this.recvConnection && (KC.debug("[".concat(this.store.clientId, "] P2PChannel2.disconnectForReconnect closing P2PConnection")), this.state = EI.Reconnecting, kC("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
              let [t2] = e2;
              var i2;
              t2._videoTrack && t2._videoTrack._player && (null === (i2 = t2._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
            }), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0, this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
              var t2;
              let [i2, { track: n2 }] = e2;
              switch (i2) {
                case _I.LocalVideoTrack:
                  Pr(t2 = n2._hints).call(t2, ky.LOW_STREAM) ? n2.close() : this.pendingLocalTracks.push(n2);
                  break;
                case _I.LocalAudioTrack:
                  n2 instanceof tb ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n2.trackList) : this.pendingLocalTracks.push(n2);
                case _I.LocalVideoLowTrack:
              }
            }), this.emit(mI.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              Array.from(hu(i2).call(i2)).forEach((e3) => {
                this.setPendingRemoteMedia(t2, e3);
              }), this.emit(mI.MediaReconnectStart, t2.uid);
            }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), KC.debug("[".concat(this.store.clientId, "] P2PChannel2 disconnected, waiting to reconnect.")));
          }
          hasPendingRemoteMedia(e2, t2) {
            for (const i2 of this.pendingRemoteTracks) {
              const { user: n2, kind: r2 } = i2;
              if ((e2 instanceof NP ? e2.uid : e2) === n2.uid && t2 === r2)
                return true;
            }
            return false;
          }
          setPendingRemoteMedia(e2, t2) {
            this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
          }
          async restartICE(e2) {
            let t2;
            t2 = e2.direction === vv.SEND_ONLY ? await this.sendMutex.lock("From P2PChannel.restartICE") : await this.recvMutex.lock("From P2PChannel.restartICE");
            try {
              const i2 = await e2.restartICE(), n2 = await fT(this, mI.RequestP2PRestartICE, i2);
              e2.setDescription("local", n2);
            } finally {
              t2();
            }
          }
          getUplinkNetworkQuality() {
            if (!this.sendConnection)
              return 0;
            const e2 = this.sendConnection.getStats(), t2 = this.localTrackMap.get(_I.LocalVideoTrack), i2 = this.localTrackMap.get(_I.LocalAudioTrack), n2 = e2.videoSend.find((e3) => {
              var i3;
              return e3.ssrc === (null == t2 || null === (i3 = t2.ssrcs) || void 0 === i3 ? void 0 : i3[0].ssrcId);
            }), r2 = e2.audioSend.find((e3) => {
              var t3;
              return e3.ssrc === (null == i2 || null === (t3 = i2.ssrcs) || void 0 === t3 ? void 0 : t3[0].ssrcId);
            });
            if (!n2 || !r2)
              return 1;
            const s2 = TT(this, mI.NeedSignalRTT), o2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = o2 && a2 ? (o2 + a2) / 2 : o2 || a2, d2 = (c2 && s2 ? (c2 + s2) / 2 : c2 || s2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, h2 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, u2 = null == t2 ? void 0 : t2.track;
            if (u2 && u2._encoderConfig && -1 === u2._hints.indexOf(ky.SCREEN_TRACK)) {
              const t3 = u2._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
              if (t3 && i3) {
                const e3 = (1e3 * t3 - i3) / (1e3 * t3);
                return av[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][h2];
              }
            }
            return h2;
          }
          getDownlinkNetworkQuality() {
            if (!this.recvConnection)
              return 0;
            const e2 = this.recvConnection.getStats();
            let t2 = 0;
            return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
              let [n2] = i2;
              const r2 = n2._audioSSRC, s2 = n2._videoSSRC, o2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a2 = e2.videoRecv.find((e3) => e3.ssrc === s2);
              if (!o2 && !a2)
                return void (t2 += 1);
              const c2 = TT(this, mI.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, h2 = o2 ? o2.jitterMs : void 0, u2 = e2.recvPacketLossRate;
              let p2 = 0.7 * u2 * 100 / 50 + 0.3 * l2 / 1500;
              h2 && (p2 = 0.6 * u2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * h2 / 400);
              t2 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
            }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
          }
          async muteLocalTrack(e2) {
            return new tg((t2, i2) => {
              this.handleMuteLocalTrack(e2, t2, i2);
            });
          }
          filterTobePublishedTracks(e2, t2, i2) {
            const n2 = [], r2 = _A(), s2 = this.getAllTracks();
            e2 = yT(e2 = e2.filter((e3) => -1 === s2.indexOf(e3)));
            let o2 = false, a2 = false;
            for (const s3 of e2) {
              if (s3 instanceof Sb && (this.localTrackMap.has(_I.LocalVideoTrack) || o2 ? new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: s3, type: _I.LocalVideoTrack }), o2 = true), t2)) {
                const e3 = this.getLowVideoTrack(s3, i2);
                n2.push({ track: e3, type: _I.LocalVideoLowTrack });
              }
              if (s3 instanceof ZA) {
                const e3 = this.localTrackMap.get(_I.LocalAudioTrack);
                if (e3) {
                  if (!(e3.track instanceof tb))
                    throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                  if (s3._bypassWebAudio)
                    throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                  e3.track.addAudioTrack(s3), this.bindLocalAudioTrackEvents(s3, true);
                } else if (a2) {
                  const e4 = n2.find((e5) => {
                    let { type: t3 } = e5;
                    return t3 === _I.LocalAudioTrack;
                  });
                  if (!(e4.track instanceof tb))
                    throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                  if (s3._bypassWebAudio)
                    throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                  e4.track.addAudioTrack(s3);
                } else {
                  if (!r2.webAudioMediaStreamDest || s3 instanceof tb || s3._bypassWebAudio)
                    n2.push({ track: s3, type: _I.LocalAudioTrack });
                  else {
                    const e4 = new tb();
                    e4.addAudioTrack(s3), n2.push({ track: e4, type: _I.LocalAudioTrack });
                  }
                  a2 = true;
                }
              }
            }
            return n2;
          }
          filterTobeUnpublishedTracks(e2) {
            const t2 = [], i2 = this.getAllTracks();
            e2 = yT(e2 = e2.filter((e3) => -1 !== i2.indexOf(e3)));
            for (const i3 of e2) {
              if (i3 instanceof ZA) {
                const e3 = this.localTrackMap.get(_I.LocalAudioTrack);
                if (!e3)
                  continue;
                e3.track instanceof tb ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t2.push([_I.LocalAudioTrack, e3]), e3.track.close())) : t2.push([_I.LocalAudioTrack, e3]);
              }
              if (i3 instanceof Sb) {
                const e3 = this.localTrackMap.get(_I.LocalVideoTrack);
                if (!e3)
                  continue;
                t2.push([_I.LocalVideoTrack, e3]);
                const i4 = this.localTrackMap.get(_I.LocalVideoLowTrack);
                i4 && t2.push([_I.LocalVideoLowTrack, i4]);
              }
            }
            return t2;
          }
          bindLocalTrackEvents(e2) {
            e2.forEach((e3) => {
              let { track: t2, type: i2 } = e3;
              switch (i2) {
                case _I.LocalVideoTrack:
                  t2.addListener(Ly.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(Ly.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(Ly.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.addListener(Ly.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                  break;
                case _I.LocalAudioTrack:
                  this.bindLocalAudioTrackEvents(t2);
                case _I.LocalVideoLowTrack:
              }
            });
          }
          bindLocalAudioTrackEvents(e2, t2) {
            e2 instanceof tb ? e2.trackList.forEach((e3) => {
              e3.addListener(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(Ly.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
            }) : (e2.addListener(Ly.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e2.addListener(Ly.NEED_REPLACE_TRACK, this.handleReplaceTrack));
          }
          unbindLocalTrackEvents(e2) {
            e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
              let [t2, { track: i2 }] = e3;
              return { track: i2, type: t2 };
            })), e2.forEach((e3) => {
              let { track: t2, type: i2 } = e3;
              switch (i2) {
                case _I.LocalVideoTrack:
                  t2.off(Ly.GET_STATS, this.handleGetLocalVideoStats), t2.off(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(Ly.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(Ly.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.off(Ly.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                  break;
                case _I.LocalAudioTrack:
                  this.unbindLocalAudioTrackEvents(t2);
                case _I.LocalVideoLowTrack:
              }
            });
          }
          unbindLocalAudioTrackEvents(e2) {
            e2 instanceof tb ? e2.trackList.forEach((e3) => {
              e3.off(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(Ly.GET_STATS, this.handleGetLocalAudioStats), e3.off(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
            }) : (e2.off(Ly.GET_STATS, this.handleGetLocalAudioStats), e2.off(Ly.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(Ly.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(Ly.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(Ly.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(Ly.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
          }
          bindRemoteTrackEvents(e2, t2) {
            t2 instanceof wb && t2.addListener(Ly.GET_STATS, (t3) => {
              t3(this.handleGetRemoteVideoStats(e2));
            }), t2 instanceof Ob && t2.addListener(Ly.GET_STATS, (t3) => {
              t3(this.handleGetRemoteAudioStats(e2));
            });
          }
          unbindRemoteTrackEvents(e2) {
            e2 && e2.removeAllListeners(Ly.GET_STATS);
          }
          unbindAllRemoteTrackEvents() {
            Array.from(this.remoteUserMap.entries()).forEach((e2) => {
              let [t2, i2] = e2;
              i2.has(hI.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i2.has(hI.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
            });
          }
          createGatewayPublishMessage(e2) {
            return e2.map((e3) => {
              var t2;
              let i2, n2, { track: r2, type: s2 } = e3;
              switch (s2) {
                case _I.LocalAudioTrack:
                  i2 = $v.Audio, n2 = { dtx: r2 instanceof $A && r2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                  break;
                case _I.LocalVideoTrack:
                  i2 = Pr(t2 = r2._hints).call(t2, ky.SCREEN_TRACK) ? $v.Screen : $v.High, n2 = DM(DM({}, fD(r2)), {}, { codec: this.store.codec });
                  break;
                case _I.LocalVideoLowTrack:
                  i2 = $v.Low, n2 = DM(DM({}, fD(r2)), {}, { codec: this.store.codec });
              }
              return { kind: s2 === _I.LocalAudioTrack ? hI.AUDIO : hI.VIDEO, stream_type: i2, attributes: n2, isMuted: r2.muted || !r2.enabled };
            });
          }
          createGatewayUnpublishMessage(e2) {
            return e2.map((e3) => {
              var t2;
              let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
              switch (n2) {
                case _I.LocalVideoTrack:
                  i2 = Pr(t2 = r2._hints).call(t2, ky.SCREEN_TRACK) ? $v.Screen : $v.High;
                  break;
                case _I.LocalAudioTrack:
                  i2 = $v.Audio;
                  break;
                case _I.LocalVideoLowTrack:
                  i2 = $v.Low;
              }
              return { stream_type: i2, ssrcs: s2, mid: o2 };
            });
          }
          assignLocalTracks(e2) {
            e2.forEach((e3) => {
              let { track: t2, type: i2 } = e3;
              this.localTrackMap.set(i2, { track: t2 });
            });
          }
          withdrawLocalTracks(e2) {
            e2.forEach((e3) => {
              let [t2] = e3;
              this.localTrackMap.delete(t2);
            });
          }
          bindConnectionEvents(e2) {
            e2.onConnectionStateChange = async (t2) => {
              var i2;
              if (KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), this.emit(mI.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), Pr(i2 = this._restartStates).call(i2, t2) || e2.direction === vv.SEND_ONLY) {
                if (this._restartTimer)
                  return;
                const t3 = () => {
                  if ("disconnected" === e2.iceConnectionState || "checking" === e2.iceConnectionState || "failed" === e2.iceConnectionState) {
                    KC.debug("[".concat(this.store.clientId, "] [P2PChannel] start use restartICE"));
                    "CONNECTED" === TT(this, mI.QueryClientConnectionState) && this.restartICE(e2);
                  }
                };
                this._restartTimer = window.setTimeout(() => {
                  t3(), this._restartTimer = void 0;
                }, 800);
              } else
                ;
            }, e2.onICEConnectionStateChange = (e3) => {
              "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), rv.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: oT.TRACER }).onSuccess(), this.emit(mI.IceConnectionStateChange, e3);
            }, e2.onICETransportStateChange = (e3) => {
              KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
            }, e2.onDTLSTransportStateChange = (e3) => {
              KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
            }, e2.onDTLSTransportError = (e3) => {
              KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
            }, e2.onFirstAudioDecoded = (e3) => {
              var t2;
              const i2 = Array.from(hu(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
              var n2;
              i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i2.audioTrack) || void 0 === n2 || n2.emit(By.FIRST_FRAME_DECODED), rv.firstRemoteFrame(this.store.sessionId, XC.FIRST_AUDIO_DECODE, QC.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: cD.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
            }, e2.onFirstAudioReceived = (e3) => {
              var t2;
              const i2 = Array.from(hu(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
              i2 && rv.firstRemoteFrame(this.store.sessionId, XC.FIRST_AUDIO_RECEIVED, QC.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: cD.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
            }, e2.onFirstVideoDecoded = (e3, t2, i2) => {
              this.reportVideoFirstFrameDecoded(e3, t2, i2);
            }, e2.onFirstVideoReceived = (e3) => {
              var t2;
              const i2 = Array.from(hu(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
              i2 && rv.firstRemoteFrame(this.store.sessionId, XC.FIRST_VIDEO_RECEIVED, QC.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: cD.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
            }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
              const i2 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
              "unknown" !== t2.candidateType && i2 === n2 || this.emit(mI.ConnectionTypeChange, i2), KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(vD(t2)), " -> ").concat(JSON.stringify(vD(e3)), ")"));
            }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
              KC.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(vD(t2)), " -> ").concat(JSON.stringify(vD(e3)), ")"));
            }, e2.onFirstVideoDecodedTimeout = (e3) => {
              this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
            }, e2.onLocalCandidate = (e3) => {
              this.emit(mI.LocalCandidate, e3);
            };
          }
          unbindConnectionEvents(e2) {
            e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0, e2.onLocalCandidate = void 0;
          }
          filterTobeMutedTracks(e2) {
            const t2 = [];
            if (-1 === this.getAllTracks().indexOf(e2))
              return t2;
            const i2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if (e2 instanceof ZA && (null == i2 ? void 0 : i2.track) instanceof tb)
              return i2.track.isActive || t2.push([_I.LocalAudioTrack, i2]), t2;
            const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
              let [, { track: i3 }] = t3;
              return e2 === i3;
            });
            if (n2 && (t2.push(n2), n2[0] === _I.LocalVideoTrack)) {
              const e3 = this.localTrackMap.get(_I.LocalVideoLowTrack);
              e3 && t2.push([_I.LocalVideoLowTrack, e3]);
            }
            return t2;
          }
          filterTobeUnmutedTracks(e2) {
            const t2 = [], i2 = this.localTrackMap.get(_I.LocalAudioTrack);
            if (e2 instanceof ZA && (null == i2 ? void 0 : i2.track) instanceof tb)
              return i2.track.isActive && t2.push([_I.LocalAudioTrack, i2]), t2;
            const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
              let [, { track: i3 }] = t3;
              return e2 === i3;
            });
            if (n2)
              if (n2[0] === _I.LocalVideoTrack) {
                t2.push(n2);
                const e3 = this.localTrackMap.get(_I.LocalVideoLowTrack);
                e3 && t2.push([_I.LocalVideoLowTrack, e3]);
              } else
                t2.push(n2);
            return t2;
          }
          createMuteMessage(e2) {
            return e2.map((e3) => {
              var t2;
              let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
              switch (n2) {
                case _I.LocalAudioTrack:
                  i2 = $v.Audio;
                  break;
                case _I.LocalVideoTrack:
                  i2 = Pr(t2 = r2._hints).call(t2, ky.SCREEN_TRACK) ? $v.Screen : $v.High;
                  break;
                case _I.LocalVideoLowTrack:
                  i2 = $v.Low;
              }
              return { stream_type: i2, ssrcs: s2, mid: o2 };
            });
          }
          createUnmuteMessage(e2) {
            return e2.map((e3) => {
              var t2;
              let i2, [n2, { track: r2, ssrcs: s2, id: o2 }] = e3;
              switch (n2) {
                case _I.LocalAudioTrack:
                  i2 = $v.Audio;
                  break;
                case _I.LocalVideoTrack:
                  i2 = Pr(t2 = r2._hints).call(t2, ky.SCREEN_TRACK) ? $v.Screen : $v.High;
                  break;
                case _I.LocalVideoLowTrack:
                  i2 = $v.Low;
              }
              return { stream_type: i2, ssrcs: s2, mid: o2 };
            });
          }
          filterTobeUnSubscribedTracks(e2, t2) {
            const i2 = [], n2 = this.remoteUserMap.get(e2);
            if (!n2)
              return i2;
            if (t2) {
              const r2 = n2.get(t2);
              if (!r2)
                return i2;
              i2.push([e2, { kind: t2, id: r2 }]);
            } else
              Array.from(n2.entries()).forEach((t3) => {
                let [n3, r2] = t3;
                i2.push([e2, { kind: n3, id: r2 }]);
              });
            return i2;
          }
          createUnsubscribeMessage(e2) {
            const t2 = [];
            return e2.forEach((e3) => {
              let [i2, { kind: n2, id: r2 }] = e3;
              switch (n2) {
                case hI.VIDEO:
                  return void (i2._videoSSRC && t2.push({ stream_type: hI.VIDEO, ssrcId: i2._videoSSRC }));
                case hI.AUDIO:
                  return void (i2._audioSSRC && t2.push({ stream_type: hI.AUDIO, ssrcId: i2._audioSSRC }));
              }
            }), t2;
          }
          withdrawRemoteTracks(e2) {
            e2.forEach((e3) => {
              let [t2, { kind: i2 }] = e3;
              const n2 = this.remoteUserMap.get(t2);
              n2 && (n2.delete(i2), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
            });
          }
          async updateBitrateLimit(e2) {
            const t2 = this.localTrackMap.get(_I.LocalVideoTrack), i2 = this.localTrackMap.get(_I.LocalVideoLowTrack);
            t2 && await t2.track.setBitrateLimit(e2.uplink), i2 && e2.low_stream_uplink && await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 });
          }
          isP2PDisconnected() {
            if (this.sendConnection && this.recvConnection) {
              const e2 = this.sendConnection.peerConnectionState, t2 = this.recvConnection.peerConnectionState;
              return "connected" !== e2 && "connected" !== t2;
            }
            return true;
          }
          async tryToUnmuteAudio(e2) {
            for (let t2 = 0; t2 < e2.length; t2++)
              if (e2[t2] instanceof ZA) {
                const i2 = this.filterTobeUnmutedTracks(e2[t2]);
                if (0 === i2.length)
                  continue;
                const n2 = this.createUnmuteMessage(i2);
                return void await gT(this, mI.RequestUnmuteLocal, n2);
              }
          }
          bindStatsUploaderEvents() {
            this.statsUploader.requestStats = (e2) => this.getStats(e2), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()).filter((e2) => {
              let [, { ssrcs: t2 }] = e2;
              return !!t2;
            }), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
              var t2;
              return !(null === (t2 = this.recvConnection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
            }, this.statsUploader.requestUpload = (e2, t2) => this.emit(mI.RequestUploadStats, e2, t2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
          }
          unbindStatsUploaderEvents() {
            this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
          }
          async requestReconnect() {
            this.dtlsFailedCount += 1, await UT(zT(this.dtlsFailedCount, JT)), this.emit(mI.RequestReconnect);
          }
          async reconnectP2P() {
          }
          canPublishLowStream() {
            return this.localTrackMap.has(_I.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof Sb);
          }
          throwIfTrackTypeNotMatch(e2) {
            if (e2.filter((e3) => e3 instanceof Sb).length > 1)
              throw new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (e2.filter((e3) => e3 instanceof ZA).length > 1 && (e2.some((e3) => e3 instanceof ZA && e3._bypassWebAudio) || !_A().webAudioMediaStreamDest))
              throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
            for (const t2 of e2) {
              if (t2 instanceof Sb && this.pendingLocalTracks.some((e3) => e3 instanceof Sb))
                throw new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
              if (t2 instanceof ZA && this.pendingLocalTracks.some((e3) => e3 instanceof ZA) && (!_A().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof ZA && e3._bypassWebAudio)))
                throw new Vg(xg.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
            }
          }
          getLowVideoTrack(e2, t2) {
            const i2 = !kC("DISABLE_DUAL_STREAM_USE_ENCODING") && _A().supportDualStreamEncoding, n2 = DM(DM({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
            let r2;
            r2 = i2 ? e2._mediaStreamTrack.clone() : KL(e2, n2);
            const s2 = xT(8, "track-low-"), o2 = new Sb(r2, DM(DM({}, i2 && { scaleResolutionDownBy: CD(n2, e2) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, s2);
            return o2.on(Vy.TRANSCEIVER_UPDATED, (t3) => {
              e2._updateRtpTransceiver(t3, My.LOW_STREAM);
            }), o2._hints.push(ky.LOW_STREAM), e2.addListener(Ly.NEED_CLOSE, () => {
              o2.close();
            }), o2;
          }
          async globalLock() {
            return this.recvMutex.lock("From P2PChannel2.globalLock");
          }
          reportVideoFirstFrameDecoded(e2, t2, i2, n2) {
            var r2;
            const s2 = Array.from(hu(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e2);
            if (s2) {
              n2 || this.store.subscribe(s2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
              const r3 = this.store.keyMetrics, o2 = r3.subscribe.find((e3) => e3.userId === s2.uid && "video" === e3.type);
              rv.firstRemoteVideoDecode(this.store.sessionId, XC.FIRST_VIDEO_DECODE, QC.FIRST_VIDEO_DECODE, { peer: s2._uintid, videowidth: t2, videoheight: i2, subscribeElapse: cD.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == o2 ? void 0 : o2.subscribeEnd) || 0, subscriberStart: (null == o2 ? void 0 : o2.subscribeStart) || 0, videoAddNotify: (null == o2 ? void 0 : o2.streamAdded) || 0, state: n2 ? 1 : 0 });
            }
          }
          async remoteMediaSsrcChanged(e2, t2, i2) {
            if (!this.recvConnection)
              return false;
            const n2 = this.remoteUserMap.get(e2);
            if (!n2)
              return false;
            const r2 = n2.get(t2);
            if (!r2)
              return false;
            const s2 = await this.recvConnection.getRemoteSSRC(r2);
            return void 0 !== s2 && s2 !== i2;
          }
          resetConnection(e2) {
            KC.debug("[".concat(this.store.clientId, "] [P2PChannel2] reset connection to ").concat(e2)), this.state === EI.Connected ? (KC.debug("[".concat(this.store.clientId, "] [P2PChannel2] fallback to websocket but P2PChannel2 state still connected, disconnect first")), this.disconnectForReconnect()) : (this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0));
          }
          async publishDataChannel(e2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          async unpublishDataChannel(e2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          async subscribeDataChannel(e2, t2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          async unsubscribeDataChannel(e2, t2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          hasPendingRemoteDataChannel(e2, t2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          setPendingRemoteDataChannel(e2, t2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          async preConnect(e2, t2, i2, n2, r2, s2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          getEstablishParams() {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          async reSubscribe(e2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          async updateVideoStreamParameter(e2, t2) {
            throw new Vg(xg.NOT_SUPPORTED);
          }
          unbindRtpTransceiver() {
            0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
              let [t2, { track: i2 }] = e2;
              t2 === _I.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, My.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
            });
          }
        }
        function LM(e2) {
          return function(t2, i2, n2) {
            const r2 = t2[i2];
            if ("function" != typeof r2)
              throw new Error("Cannot use mutex on object property.");
            return n2.value = async function() {
              for (var t3 = arguments.length, n3 = new Array(t3), s2 = 0; s2 < t3; s2++)
                n3[s2] = arguments[s2];
              switch (e2) {
                case OM.SEND_ONLY: {
                  const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i2));
                  try {
                    return await r2.apply(this, n3);
                  } finally {
                    e3();
                  }
                }
                case OM.RECEIVE_ONLY: {
                  const e3 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
                  try {
                    return await r2.apply(this, n3);
                  } finally {
                    e3();
                  }
                }
                default: {
                  const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i2)), t4 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
                  try {
                    return await r2.apply(this, n3);
                  } finally {
                    e3(), t4();
                  }
                }
              }
            }, n2;
          };
        }
        function kM(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function MM(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? kM(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : kM(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        Mv([LM(), Uv("design:type", Function), Uv("design:paramtypes", [Object, String]), Uv("design:returntype", tg)], PM.prototype, "startP2P", null), Mv([LM(), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], PM.prototype, "p2pConnect", null), Mv([LM(OM.SEND_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], PM.prototype, "dopublish", null), Mv([LM(OM.SEND_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], PM.prototype, "unpublish", null), Mv([LM(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], PM.prototype, "unpublishLowStream", null), Mv([LM(OM.SEND_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], PM.prototype, "doUnpublish", null), Mv([LM(OM.RECEIVE_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [NP, String, String, Number]), Uv("design:returntype", tg)], PM.prototype, "subscribe", null), Mv([LM(OM.RECEIVE_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [NP, String, String, Boolean]), Uv("design:returntype", tg)], PM.prototype, "unsubscribe", null), Mv([LM(OM.RECEIVE_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [NP, String]), Uv("design:returntype", tg)], PM.prototype, "muteRemote", null), Mv([LM(OM.RECEIVE_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [NP, String]), Uv("design:returntype", tg)], PM.prototype, "unmuteRemote", null), Mv([LM(OM.RECEIVE_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [NP, String]), Uv("design:returntype", tg)], PM.prototype, "hasRemoteMediaWithLock", null), Mv([LM(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], PM.prototype, "disconnectForReconnect", null), Mv([LM(OM.RECEIVE_ONLY), Uv("design:type", Function), Uv("design:paramtypes", [NP, String, Number]), Uv("design:returntype", tg)], PM.prototype, "remoteMediaSsrcChanged", null);
        const UM = Date.now(), xM = 20, VM = /* @__PURE__ */ new Map(), FM = /* @__PURE__ */ new Map();
        async function BM(e2) {
          const t2 = VM.get(e2), i2 = Array.isArray(t2) && t2[t2.length - 1], n2 = FM.get(e2);
          if (!i2)
            return void (n2.isSyncing = false);
          const r2 = { uid: i2.uid, payload: DT(i2.payload) };
          0 === n2.firstRecvTs && (n2.firstRecvTs = i2.recvTs, n2.firstSendTs = i2.sendTs);
          const s2 = i2.sendTs - n2.firstSendTs, o2 = s2 - (Date.now() - n2.firstRecvTs);
          o2 > 0 && (n2.firstRecvTs = Date.now() - s2);
          let a2 = i2.mediaDelay + o2;
          a2 <= 0 ? (t2.pop(), jM(i2.context, r2), a2 = 0) : a2 = Math.min(a2, xM), setTimeout(() => t2.length && BM(e2), a2);
        }
        function jM(e2, t2) {
          e2.safeEmit(dT.STREAM_MESSAGE, t2.uid, t2.payload), e2.onStreamMessage && e2.onStreamMessage(t2);
        }
        function GM(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
          if (!e2.syncWithAudio)
            return jM(i2, { uid: e2.uid, payload: DT(e2.payload) });
          const n2 = "".concat(i2.id, "-").concat(e2.uid), r2 = VM.get(n2) || [], s2 = r2.findIndex((t3) => e2.sendTs >= t3.sendTs), o2 = MM(MM({}, e2), {}, { context: i2, mediaDelay: t2, recvTs: Date.now() });
          -1 === s2 ? r2.push(o2) : r2.splice(s2, 0, o2), VM.set(n2, r2);
          let a2 = false;
          var c2;
          FM.has(n2) ? a2 = !(null === (c2 = FM.get(n2)) || void 0 === c2 || !c2.isSyncing) : FM.set(n2, { isSyncing: a2, firstRecvTs: 0, firstSendTs: 0 });
          a2 || BM(n2);
        }
        const WM = pg().name;
        function HM() {
          return !function(e2, t2, i2) {
            const n2 = pg();
            if (n2.os !== ag.IOS || !n2.osVersion)
              return false;
            const r2 = n2.osVersion.split(".");
            return i2 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) < t2 || Number(r2[0]) < e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) <= t2 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
          }(16, 0, true) && !function(e2, t2, i2) {
            const n2 = pg();
            if (n2.name !== cg.SAFARI || !n2.osVersion)
              return false;
            const r2 = n2.version.split(".");
            return i2 ? t2 && Number(r2[0]) === e2 && Number(r2[1]) < t2 || Number(r2[0]) < e2 : t2 ? Number(r2[0]) === e2 && Number(r2[1]) <= t2 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
          }(16, 0, true);
        }
        function KM(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function YM(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? KM(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : KM(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        YT.setLogger(KC);
        class qM extends iT {
          get connectionState() {
            return this._gateway.state;
          }
          get remoteUsers() {
            return this._users;
          }
          get localTracks() {
            return this._p2pChannel.getAllTracks(true);
          }
          get uid() {
            return this._uid;
          }
          get channelName() {
            return this._channelName;
          }
          get localDataChannels() {
            return this._p2pChannel.getAllDataChannels();
          }
          get mode() {
            return this._config.mode;
          }
          get role() {
            var e2;
            return (null === (e2 = this._config) || void 0 === e2 ? void 0 : e2.role) || "audience";
          }
          get codec() {
            return this._config.codec;
          }
          get audioCodec() {
            return this._config.audioCodec || "opus";
          }
          get isStringUID() {
            return !!this._joinInfo && !!this._joinInfo.stringUid;
          }
          get __className__() {
            return "Client";
          }
          constructor(e2) {
            let t2;
            if (super(), nu(this, "store", void 0), nu(this, "_uid", void 0), nu(this, "_channelName", void 0), nu(this, "_uintUid", void 0), nu(this, "_users", []), nu(this, "_config", void 0), nu(this, "_clientId", void 0), nu(this, "_appId", void 0), nu(this, "_sessionId", null), nu(this, "_key", void 0), nu(this, "_joinInfo", void 0), nu(this, "_gateway", void 0), nu(this, "_statsCollector", void 0), nu(this, "_configDistribute", void 0), nu(this, "_leaveMutex", new YT("client-leave")), nu(this, "_publishMutex", new YT("client-publish")), nu(this, "_renewTokenMutex", new YT("client-renewtoken")), nu(this, "_subscribeMutex", new YT("client-subscribe")), nu(this, "_encryptionMode", "none"), nu(this, "_encryptionSecret", null), nu(this, "_encryptionSalt", null), nu(this, "_proxyServer", void 0), nu(this, "_turnServer", { servers: [], mode: "auto" }), nu(this, "_cloudProxyServerMode", "disabled"), nu(this, "_isDualStreamEnabled", false), nu(this, "_defaultStreamFallbackType", void 0), nu(this, "_lowStreamParameter", void 0), nu(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), nu(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), nu(this, "_axiosCancelSource", EC.CancelToken.source()), nu(this, "_audioVolumeIndicationInterval", void 0), nu(this, "_networkQualityInterval", void 0), nu(this, "_userOfflineTimeout", void 0), nu(this, "_streamRemovedTimeout", void 0), nu(this, "_injectStreamingClient", void 0), nu(this, "_liveTranscodeStreamingClient", void 0), nu(this, "_liveRawStreamingClient", void 0), nu(this, "_channelMediaRelayClient", void 0), nu(this, "_networkQualitySensitivity", "normal"), nu(this, "_p2pChannel", void 0), nu(this, "_useLocalAccessPoint", false), nu(this, "_setLocalAPVersion", void 0), nu(this, "_joinAndNotLeaveYet", false), nu(this, "_numberOfJoinCount", 0), nu(this, "_remoteDefaultVideoStreamType", void 0), nu(this, "_inspect", void 0), nu(this, "_moderation", void 0), nu(this, "_license", void 0), nu(this, "_pendingPublishedUsers", []), nu(this, "ntpAlignErrorCount", 0), nu(this, "remoteInboundOffset", 0), nu(this, "_handleLocalTrackEnable", (e3, t3, i2) => {
              this.publish(e3, false).then(t3).catch(i2);
            }), nu(this, "_handleLocalTrackDisable", (e3, t3, i2) => {
              this.unpublish(e3).then(t3).catch(i2);
            }), nu(this, "_handleUserOnline", (e3) => {
              if (kC("BLOCK_LOCAL_CLIENT") && dv(e3.uid, this.channelName))
                return void KC.debug("[".concat(e3.uid, "] will be ignored in local"));
              this.isStringUID && "string" != typeof e3.uid && KC.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
              const t3 = this._users.find((t4) => t4.uid === e3.uid);
              if (t3)
                t3._trust_in_room_ = true;
              else {
                const t4 = new NP(e3.uid, e3.uint_id || e3.uid);
                this._users.push(t4), KC.debug("[".concat(this._clientId, "] user online"), e3.uid), this.safeEmit(dT.USER_JOINED, t4);
              }
            }), nu(this, "_handleUserOffline", (e3) => {
              if (kC("BLOCK_LOCAL_CLIENT") && dv(e3.uid, this.channelName))
                return;
              const t3 = this._users.find((t4) => t4.uid === e3.uid);
              t3 && (this._handleRemoveStream(e3), this._handleRemoveDataChannels(e3), IT(this._users, t3), this._remoteStreamTypeCacheMap.delete(t3.uid), this._streamFallbackTypeCacheMap.delete(t3.uid), KC.debug("[".concat(this._clientId, "] user offline"), e3.uid, "reason:", e3.reason), this.safeEmit(dT.USER_LEAVED, t3, e3.reason));
            }), nu(this, "_handleAddAudioOrVideoStream", (e3, t3, i2, n2, r2, s2, o2) => {
              if (kC("BLOCK_LOCAL_CLIENT") && dv(t3, this.channelName))
                return;
              const a2 = this._users.find((e4) => e4.uid === t3);
              if (!a2)
                return void KC.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
              KC.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(a2.uid, e3, void 0, void 0, void 0, Date.now());
              const c2 = "audio" === e3 ? a2.hasAudio : a2.hasVideo;
              a2._uintid || (a2._uintid = r2 || t3), "audio" === e3 ? a2._trust_audio_stream_added_state_ = true : a2._trust_video_stream_added_state_ = true, "audio" === e3 ? (a2._audio_added_ = true, void 0 !== i2 && (a2._audioSSRC = i2), void 0 !== n2 && (a2._cname = n2), s2 && (a2._audioOrtc = s2)) : (a2._video_added_ = true, void 0 !== i2 && (a2._videoSSRC = i2), void 0 !== n2 && (a2._cname = n2), void 0 !== o2 && (a2._rtxSsrcId = o2), s2 && (a2._videoOrtc = s2)), ("audio" === e3 ? a2.hasAudio : a2.hasVideo) && !c2 && (KC.info("[".concat(this._clientId, "] remote user ").concat(a2.uid, " published ").concat(e3)), this.safeEmit(dT.USER_PUBLISHED, a2, e3)), "video" === e3 ? rv.onGatewayStream(this._sessionId, XC.ON_ADD_VIDEO_STREAM, QC.ON_ADD_VIDEO_STREAM, { peer: r2 || t3, ssrc: a2._videoSSRC }) : rv.onGatewayStream(this._sessionId, XC.ON_ADD_AUDIO_STREAM, QC.ON_ADD_AUDIO_STREAM, { peer: r2 || t3, ssrc: a2._audioSSRC }), this._p2pChannel.remoteMediaSsrcChanged(a2, e3, i2).then((t4) => {
                if (t4 && (KC.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after rejoin because SSRC id changed.")), this._p2pChannel instanceof _k))
                  return this._p2pChannel.unsubscribe(a2, e3, true).then(() => this._subscribe(a2, e3, true).catch((e4) => {
                    KC.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
                  }));
              }), this._p2pChannel.hasPendingRemoteMedia(a2, e3) && (KC.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after reconnect.")), this._subscribe(a2, e3, true).catch((e4) => {
                KC.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
              }));
            }), nu(this, "_handleRemoveStream", (e3, t3, i2) => {
              if (kC("BLOCK_LOCAL_CLIENT") && dv(e3.uid, this.channelName))
                return;
              const n2 = this._users.find((t4) => t4.uid === e3.uid);
              if (!n2)
                return void KC.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
              KC.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e3.uid));
              let r2 = () => {
              };
              if (n2.hasAudio && n2.hasVideo ? r2 = () => {
                KC.info("[".concat(this._clientId, "] remote user ").concat(n2.uid, " unpublished audio track")), this.safeEmit(dT.USER_UNPUBLISHED, n2, "audio"), KC.info("[".concat(this._clientId, "] remote user ").concat(n2.uid, " unpublished video track")), this.safeEmit(dT.USER_UNPUBLISHED, n2, "video");
              } : n2.hasVideo ? r2 = () => {
                KC.info("[".concat(this._clientId, "] remote user ").concat(n2.uid, " unpublished video track")), this.safeEmit(dT.USER_UNPUBLISHED, n2, "video");
              } : n2.hasAudio && (r2 = () => {
                KC.info("[".concat(this._clientId, "] remote user ").concat(n2.uid, " unpublished audio track")), this.safeEmit(dT.USER_UNPUBLISHED, n2, "audio");
              }), n2._trust_audio_stream_added_state_ = true, n2._trust_video_stream_added_state_ = true, n2._audio_added_ = false, n2._video_added_ = false, this._p2pChannel instanceof _k)
                this._p2pChannel.unsubscribe(n2).then((e4) => {
                  if (e4)
                    return this._gateway.unsubscribe(e4, n2.uid);
                });
              else if (t3 && i2)
                if (e3.sdp) {
                  const { sdp: r3 } = e3;
                  this._p2pChannel.unsubscribe(n2, r3).then((e4) => {
                    e4 && t3(e4);
                  }).catch(i2);
                } else
                  t3 && t3();
              n2._audioSSRC = void 0, n2._videoSSRC = void 0, n2._audioOrtc = void 0, n2._videoOrtc = void 0, n2._rtxSsrcId = void 0, rv.onGatewayStream(this._sessionId, XC.ON_REMOVE_STREAM, QC.ON_REMOVE_STREAM, { peer: e3.uint_id || e3.uid }), r2();
            }), nu(this, "_handleSetStreamLocalEnable", (e3, t3, i2) => {
              if (kC("BLOCK_LOCAL_CLIENT") && dv(t3, this.channelName))
                return;
              const n2 = this._users.find((e4) => e4.uid === t3);
              if (!n2)
                return void KC.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
              KC.debug("[".concat(this._clientId, "] local ").concat(e3, " ").concat(i2 ? "enabled" : "disabled", " with uid ").concat(t3));
              const r2 = "audio" === e3 ? n2.hasAudio : n2.hasVideo;
              if ("audio" === e3) {
                n2._trust_audio_enabled_state_ = true;
                const e4 = n2._audio_enabled_;
                if (n2._audio_enabled_ = i2, n2._audio_enabled_ === e4)
                  return;
                {
                  const e5 = n2._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                  KC.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(dT.USER_INFO_UPDATED, t3, e5);
                }
              } else {
                n2._trust_video_enabled_state_ = true;
                const e4 = n2._video_enabled_;
                if (n2._video_enabled_ = i2, n2._video_enabled_ === e4)
                  return;
                {
                  const e5 = n2._video_enabled_ ? "enable-local-video" : "disable-local-video";
                  KC.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(dT.USER_INFO_UPDATED, t3, e5);
                }
              }
              const s2 = "audio" === e3 ? n2.hasAudio : n2.hasVideo;
              return r2 !== s2 ? !r2 && s2 ? (KC.info("[".concat(this._clientId, "] remote user ").concat(t3, " published ").concat(e3)), void this.safeEmit(dT.USER_PUBLISHED, n2, e3)) : ("video" === e3 && n2._videoTrack && n2._videoTrack._destroy(), "audio" === e3 && n2._audioTrack, this._p2pChannel.muteRemote(n2, e3), KC.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished ").concat(e3)), void this.safeEmit(dT.USER_UNPUBLISHED, n2, e3)) : void 0;
            }), nu(this, "_handleMuteStream", (e3, t3, i2, n2, r2, s2) => {
              if (kC("BLOCK_LOCAL_CLIENT") && dv(e3, this.channelName))
                return;
              KC.debug("[".concat(this._clientId, "] receive mute message"), e3, t3, i2);
              const o2 = this._users.find((t4) => t4.uid === e3);
              if (!o2)
                return void KC.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e3));
              const a2 = "audio" === t3 ? o2.hasAudio : o2.hasVideo;
              if ("audio" === t3) {
                o2._trust_audio_mute_state_ = true;
                const t4 = o2._audio_muted_;
                if (o2._audio_muted_ = i2, o2._audio_muted_ === t4)
                  return;
                {
                  const t5 = o2._audio_muted_ ? "mute-audio" : "unmute-audio";
                  KC.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(dT.USER_INFO_UPDATED, e3, t5);
                }
              } else {
                o2._trust_video_mute_state_ = true;
                const t4 = o2._video_muted_;
                if (o2._video_muted_ = i2, o2._video_muted_ === t4)
                  return;
                {
                  const t5 = o2._video_muted_ ? "mute-video" : "unmute-video";
                  KC.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(dT.USER_INFO_UPDATED, e3, t5);
                }
              }
              const c2 = "audio" === t3 ? o2.hasAudio : o2.hasVideo;
              if (a2 !== c2) {
                if (!a2 && c2) {
                  if (!this.store.useP2P) {
                    if (!("audio" === t3 ? o2._audioSSRC : o2._videoSSRC))
                      return void KC.warning("[".concat(this._clientId, "] remote user ").concat(e3, " receive ").concat(t3, " unmute message  before add stream message, ").concat(t3, " SSRC doesn't exist yet."));
                  }
                  return KC.info("[".concat(this._clientId, "] remote user ").concat(e3, " published ").concat(t3)), void this.safeEmit(dT.USER_PUBLISHED, o2, t3);
                }
                "video" === t3 && o2._videoTrack && o2._videoTrack._destroy(), "audio" === t3 && o2._audioTrack, r2 && s2 && this._p2pChannel instanceof PM && (n2 ? this._p2pChannel.unsubscribe(o2, n2, t3).then((e4) => {
                  r2(e4);
                }).catch(s2) : r2()), this._p2pChannel.muteRemote(o2, t3), KC.info("[".concat(this._clientId, "] remote user ").concat(e3, " unpublished ").concat(t3)), this.safeEmit(dT.USER_UNPUBLISHED, o2, t3);
              }
            }), nu(this, "_handleP2PLost", async (e3) => {
              KC.debug("[".concat(this._clientId, "] receive p2p lost"), e3), parseInt(e3.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : KC.warning("[".concat(this._clientId, "] P2PLost stream not found"), e3);
            }), nu(this, "_handleTokenWillExpire", () => {
              KC.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(dT.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
            }), nu(this, "_handleBeforeUnload", (e3) => {
              "beforeunload" === e3.type && void 0 !== e3.returnValue && "" !== e3.returnValue || (this.leave(), KC.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
            }), nu(this, "_handleUpdateNetworkQuality", () => {
              if ("normal" === this._networkQualitySensitivity)
                return;
              if (navigator && void 0 !== navigator.onLine && !navigator.onLine)
                return void this.safeEmit(dT.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
              const e3 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
              e3.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e3.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(dT.NETWORK_QUALITY, e3);
            }), nu(this, "_handleP2PAddAudioOrVideoStream", (e3, t3) => {
              const i2 = this._users.find((e4) => e4.uid === t3);
              if (!i2)
                return void KC.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
              KC.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(i2.uid, e3, void 0, void 0, void 0, Date.now());
              const n2 = "audio" === e3 ? i2.hasAudio : i2.hasVideo;
              "audio" === e3 ? i2._trust_audio_stream_added_state_ = true : i2._trust_video_stream_added_state_ = true, "audio" === e3 ? i2._audio_added_ = true : i2._video_added_ = true, ("audio" === e3 ? i2.hasAudio : i2.hasVideo) && !n2 && (KC.info("[".concat(this._clientId, "] remote user ").concat(i2.uid, " published ").concat(e3)), this.safeEmit(dT.USER_PUBLISHED, i2, e3)), this._p2pChannel.hasPendingRemoteMedia(i2, e3) && (KC.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(i2.uid, " after reconnect.")), this._subscribe(i2, e3, true).catch((e4) => {
                KC.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
              }));
            }), this._config = e2, this._clientId = xT(5, "client-"), this.store = new wC(e2.codec, e2.audioCodec, e2.mode, this._clientId), this.store.clientCreated(), e2.proxyServer && this.setProxyServer(e2.proxyServer, true), e2.turnServer && this.setTurnServer(e2.turnServer, true), KC.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(OC, " build: ").concat(DC, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e2.clientRoleOptions)
              try {
                mT(e2.clientRoleOptions), t2 = Object.assign({}, e2.clientRoleOptions);
              } catch (e3) {
                KC.warning("[".concat(this._clientId, "] ").concat(e3.toString()));
              }
            this._statsCollector = new hD(this.store), this._statsCollector.onStatsException = (e3, t3, i2) => {
              KC.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e3, ", msg: ").concat(t3, ", uid: ").concat(i2)), this.safeEmit(dT.EXCEPTION, { code: e3, msg: t3, uid: i2 });
            }, this._statsCollector.onUploadPublishDuration = (e3, t3, i2, n2) => {
              const r2 = this._users.find((t4) => t4.uid === e3);
              r2 && rv.peerPublishStatus(this._sessionId, { subscribeElapse: n2, audioPublishDuration: t3, videoPublishDuration: i2, peer: r2._uintid });
            }, this.store.useDataChannel = _A().supportDataChannel && kC("SIGNAL_CHANNEL"), this.store.useP2P = kC("P2P"), this._gateway = new MD(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e2.websocketRetryConfig || JT, httpRetryConfig: e2.httpRetryConfig || JT, forceWaitGatewayResponse: void 0 === e2.forceWaitGatewayResponse || e2.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e2.role, clientRoleOptions: t2 }), this._configDistribute = new TP(), this.store.useP2P ? (this._p2pChannel = new PM(this.store, this._statsCollector), this._handleP2PEvents()) : this._p2pChannel = new _k(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
          }
          async joinMeta(e2, t2, i2, n2, r2) {
            let s2 = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], o2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
            LC("JOIN_GATEWAY_USE_443PORT_ONLY", s2), LC("JOIN_GATEWAY_USE_DUAL_DOMAIN", o2);
            const a2 = this._gateway.signal.websocket;
            return a2 instanceof zI && (a2.use443PortOnly = s2, a2.tryDoubleDomain = o2), async function(e3, t3, i3) {
              rg.get(e3) || rg.set(e3, []), sg.get(e3) || sg.set(e3, t3), og.get(e3) || og.set(e3, 0);
              const n3 = rg.get(e3), r3 = sg.get(e3);
              if (!n3 || !r3)
                throw new Error("concurrent: deferQueue or maxConcurrency is null");
              if (og.get(e3) === r3) {
                const e4 = ng();
                n3.push(e4), await e4.promise;
              }
              og.set(e3, og.get(e3) + 1);
              for (var s3 = arguments.length, o3 = new Array(s3 > 3 ? s3 - 3 : 0), a3 = 3; a3 < s3; a3++)
                o3[a3 - 3] = arguments[a3];
              const c2 = await i3(...o3);
              return og.set(e3, og.get(e3) - 1), og.get(e3) === r3 - 1 && n3.length > 0 && (n3[0].resolve(), n3.shift()), 0 === og.get(e3) && (rg.set(e3, []), sg.set(e3, 0), og.set(e3, 0)), c2;
            }("client.join", kC("JOIN_MAX_CONCURRENCY"), this.join.bind(this), e2, t2, i2, n2, r2);
          }
          async join(e2, t2, i2, n2, r2) {
            const s2 = ++this._numberOfJoinCount;
            this.store.joinStart(), n2 && (this.store.uid = n2);
            const o2 = vC(), a2 = IC() ? window.isSecureContext : "Browser Not Support";
            if (!IC() && !o2 || !window.isSecureContext) {
              const e3 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
              KC.warning(e3);
            }
            const c2 = VT();
            "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), KC.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));
            const d2 = rv.reportApiInvoke(c2, { name: sT.JOIN, options: [e2, t2, i2, n2], states: { isHttps: o2, isSecureContext: a2 }, tag: oT.TRACER });
            rv.setAppId(e2);
            try {
              if (!i2 && null !== i2)
                throw new xv(xg.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
              i2 && Wg(i2, "token", 1, 2047), Wg(e2, "appid", 1, 2047), Vv(t2), n2 && Fv(n2), r2 && Wg(r2, "optionalInfo", 1, 2047);
            } catch (e3) {
              throw d2.onError(e3), e3;
            }
            if (KC.info("[".concat(this._clientId, "] start join channel ").concat(t2, ", join number: ").concat(s2)), this._leaveMutex.isLocked) {
              KC.debug("[".concat(this._clientId, "] join: waiting leave operation"));
              (await this._leaveMutex.lock())(), KC.debug("[".concat(this._clientId, "] join: continue"));
            }
            if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
              const e3 = new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
              throw d2.onError(e3), e3;
            }
            this._sessionId || (this._sessionId = c2, this.store.sessionId = this._sessionId), this._gateway.state = "CONNECTING";
            const l2 = YM({ clientId: this._clientId, appId: e2, sid: this._sessionId, cname: t2, uid: "string" != typeof n2 ? n2 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i2 || e2, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: r2, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType });
            if (this._useLocalAccessPoint && (l2.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n2 && (l2.stringUid = n2, this._uintUid ? (l2.uid = this._uintUid, this._uintUid = void 0) : l2.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
              if (l2.aesmode = this._encryptionMode, l2.aespassword = await eT(this._encryptionSecret), !this._joinAndNotLeaveYet)
                throw new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
              this._encryptionSalt && (l2.aessalt = this._encryptionSalt);
            }
            this._startSession(this._sessionId, { channel: t2, appId: e2 });
            const h2 = this._sessionId;
            setTimeout(() => {
              "CONNECTING" === this.connectionState && h2 === this._sessionId && rv.joinChannelTimeout(this._sessionId, 5);
            }, 5e3);
            try {
              var u2;
              let n3;
              const r3 = l2.cloudProxyServer;
              if (Pr(u2 = ["proxy3", "proxy4", "proxy5"]).call(u2, r3)) {
                const e3 = kC("PROXY_SERVER_TYPE3");
                Array.isArray(e3) ? l2.proxyServer = e3[0] : l2.proxyServer = e3;
              }
              if (rv.setProxyServer(l2.proxyServer), KC.setProxyServer(l2.proxyServer), this.store.requestAPStart(), l2.stringUid && !l2.uid) {
                const e3 = await hP(l2.stringUid, l2, this._axiosCancelSource.token, this._config.httpRetryConfig || JT, this.store);
                KC.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(l2.stringUid, " => ").concat(e3)), l2.uid = e3, n3 = await lP(l2, this._axiosCancelSource.token, this._config.httpRetryConfig || JT, true, this.store);
              } else
                n3 = await lP(l2, this._axiosCancelSource.token, this._config.httpRetryConfig || JT, true, this.store);
              if (!this._joinAndNotLeaveYet)
                throw new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
              this.store.requestAPEnd(), setTimeout(() => {
                this._configDistribute.startGetConfigDistribute(l2, this._axiosCancelSource.token), this._configDistribute.on(dI.UPDATE_BITRATE_LIMIT, (e3) => {
                  this._p2pChannel.updateBitrateLimit(e3);
                });
              }, 0), this._key = i2 || e2;
              const s3 = n3.gatewayInfo;
              this._joinInfo = YM(YM({}, l2), {}, { cid: s3.cid, uid: l2.uid ? l2.uid : s3.uid, vid: s3.vid, apResponse: s3.res, uni_lbs_ip: s3.uni_lbs_ip, gatewayAddrs: s3.gatewayAddrs });
              const o3 = await this._joinGateway();
              if (!this._joinAndNotLeaveYet)
                throw new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
              d2.onSuccess(o3), this._appId = e2, this._channelName = l2.cname, this._uid = o3, this.store.uid = o3, setTimeout(() => {
                this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(Sg() ? "beforeunload" : "pagehide", this._handleBeforeUnload);
              }, 0);
              const a3 = l2.stringUid ? "string uid: ".concat(l2.stringUid, ",uid: ").concat(l2.uid) : "uid: ".concat(this._uid);
              return KC.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t2, ",").concat(a3)), setTimeout(() => {
                KC.startUpload();
              }, 5e3), this.store.joinEnd(), p2 = this, Pr(cv).call(cv, p2) || cv.push(p2), o3;
            } catch (e3) {
              const t3 = Array.isArray(e3) ? e3[0] : e3;
              throw t3 && t3.code === xg.OPERATION_ABORTED ? KC.warning("[".concat(this._clientId, "] join number: ").concat(s2, ", Joining channel failed, rollback"), t3) : KC.error("[".concat(this._clientId, "] join number: ").concat(s2, ", Joining channel failed, rollback"), t3), t3.code !== xg.OPERATION_ABORTED && this._numberOfJoinCount === s2 && (this._gateway.state = "DISCONNECTED", this._reset()), d2.onError(t3), t3;
            }
            var p2;
          }
          _joinGateway() {
            if (!this._joinInfo || !this._key)
              throw new xv(xg.INVALID_OPERATION);
            return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !kC("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then((e2) => e2).catch((e2) => {
              if (e2.code === xg.INIT_WEBSOCKET_TIMEOUT)
                return this._gateway.leave(true, cT.FALLBACK), e2;
              if (e2.code === xg.INIT_DATACHANNEL_TIMEOUT)
                return this._gateway.leave(true, cT.FALLBACK), e2;
              throw e2;
            }).then((e2) => {
              if (e2 instanceof xv) {
                if (e2.code === xg.INIT_WEBSOCKET_TIMEOUT) {
                  if (KC.info("[".concat(this._clientId, "] join timeout, fallback to proxy")), !this._joinInfo || !this._key)
                    throw new xv(xg.INVALID_OPERATION);
                  this._joinInfo.cloudProxyServer = "fallback", this._cloudProxyServerMode = "fallback", this.store.cloudProxyServerMode = "fallback";
                  const e3 = kC("PROXY_SERVER_TYPE3");
                  if (Array.isArray(e3))
                    if (this._joinInfo.apUrl) {
                      const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(this._joinInfo.apUrl)[1].split("."), i2 = t3.slice(t3.length - 2).join(".");
                      e3.forEach((e4) => {
                        this._joinInfo && Pr(e4).call(e4, i2) && (this._joinInfo.proxyServer = e4);
                      }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e3[0]);
                    } else
                      this._joinInfo.proxyServer = e3[0];
                  else
                    this._joinInfo.proxyServer = e3;
                  const t2 = kC("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/);
                  t2 && t2[1] && "443" !== t2[1] && KC.setProxyServer(this._joinInfo.proxyServer), "443" !== kC("STATS_COLLECTOR_PORT").toString() && rv.setProxyServer(this._joinInfo.proxyServer);
                  return rv.reportApiInvoke(this._sessionId, { name: sT.JOIN_FALLBACK_TO_PROXY, options: [this._joinInfo.proxyServer], tag: oT.TRACER }).onSuccess(), this.safeEmit(dT.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), kC("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && this._joinInfo.turnServer.servers.forEach((e4) => {
                    "forceturn" in e4 && (e4.forceturn = true);
                  }), this._gateway.join(this._joinInfo, this._key);
                }
                if (KC.info("[".concat(this._clientId, "] join by datachannel timeout, fallback to websocket")), !this._joinInfo || !this._key)
                  throw new xv(xg.INVALID_OPERATION);
                return rv.reportApiInvoke(this._sessionId, { name: sT.DATACHANNEL_FAILBACK, options: [this.store.clientId], tag: oT.TRACER }).onSuccess(), this._joinGateway();
              }
              return e2;
            }).then((e2) => e2);
          }
          async leave() {
            KC.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(Sg() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e3) {
              const t2 = cv.indexOf(e3);
              -1 !== t2 && cv.splice(t2, 1);
            }(this);
            const e2 = await this._leaveMutex.lock();
            if ("DISCONNECTED" === this.connectionState)
              return KC.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e2();
            await this._gateway.leave("CONNECTED" !== this.connectionState), KC.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), e2();
          }
          async publish(e2) {
            let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (!Array.isArray(e2)) {
              if (!(e2 instanceof iA))
                return this._publishDataChannel(e2);
              e2 = [e2];
            }
            if (0 === e2.length)
              throw new xv(xg.INVALID_PARAMS, "param list is empty");
            const i2 = e2;
            if ("audience" === this._gateway.role)
              throw new xv(xg.INVALID_OPERATION, "audience can not publish stream");
            for (const e3 of i2) {
              if (!(e3 instanceof iA))
                throw new xv(xg.INVALID_PARAMS, "parameter is not local track");
              if (!e3._enabled && t2)
                throw new xv(xg.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(e3.getTrackId()));
            }
            KC.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(i2.map((e3) => "".concat(e3.getTrackId(), " "))));
            const n2 = await this._publishMutex.lock();
            await this._configDistribute.awaitConfigDistributeComplete(), t2 && i2.forEach((e3) => {
              const t3 = this._configDistribute.getBitrateLimit();
              e3 instanceof Sb && t3 && e3.setBitrateLimit(t3.uplink);
            });
            try {
              await this._publishHighStream(i2), KC.info("[".concat(this._clientId, "] Publish success, id ").concat(i2.map((e3) => "".concat(e3.getTrackId(), " "))));
            } catch (e3) {
              throw KC.error("[".concat(this._clientId, "] publish error"), e3.toString()), e3;
            } finally {
              n2();
            }
          }
          async _publishDataChannel(e2) {
            jg(e2.id, "id", 0, 65535, true), Fg(e2.ordered, "ordered"), Wg(e2.metadata, "metadata", 0, 512), KC.info("[".concat(this._clientId, "] Publishing datachannels, id ").concat(e2.id));
            const t2 = await this._publishMutex.lock();
            try {
              if (-1 !== this._p2pChannel.getAllDataChannels().findIndex((t3) => t3.id === e2.id))
                throw new xv(xg.INVALID_PARAMS, "Invalid id: ".concat(e2.id, ". If you want to republish the datachannel, unpublish first"));
              if (!this._joinInfo || void 0 === this._uid)
                throw new xv(xg.INVALID_OPERATION, "Can't publish datachannel, haven't joined yet!");
              if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
                throw new xv(xg.INVALID_OPERATION, "can not publish datachannel in ".concat(this.connectionState, " state"));
              if ("auto" === this._turnServer.mode && kC("FORCE_TURN") && !kC("TURN_ENABLE_TCP") && !kC("TURN_ENABLE_UDP"))
                throw new xv(xg.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
              const i2 = new sD(e2);
              await this._p2pChannel.publishDataChannel([i2]);
              try {
                const t3 = { streamId: e2.id, ordered: e2.ordered, maxRetransmits: kC("DATASTREAM_MAX_RETRANSMITS"), metadata: e2.metadata, channelId: i2._originDataChannelId };
                await this._gateway.publishDataChannel(this._uid, t3, true);
              } catch (e3) {
                if (e3.code !== xg.DISCONNECT_P2P)
                  throw e3;
              }
              return await i2._waitTillOpen(), KC.info("[".concat(this._clientId, "] Publish dataChannels success, id ").concat(i2.id)), i2;
            } catch (e3) {
              throw KC.error("[".concat(this._clientId, "] publish datachannels error"), e3.toString()), e3;
            } finally {
              t2();
            }
          }
          async unpublish(e2) {
            if (!this._joinInfo || void 0 === this._uid)
              throw new xv(xg.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
            let t2 = [];
            if (e2)
              if (Array.isArray(e2))
                t2 = e2;
              else {
                if (!(e2 instanceof iA))
                  return this._unpublishDataChannel([e2]);
                t2 = [e2];
              }
            else
              this.store.useP2P || await this._unpublishDataChannel(), t2 = this._p2pChannel.getAllTracks(true);
            KC.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(t2.map((e3) => "".concat(e3.getTrackId(), " ")), " "));
            const i2 = await this._publishMutex.lock();
            try {
              if (this._p2pChannel instanceof PM) {
                const e3 = await this._p2pChannel.unpublish(t2);
                if (e3) {
                  const t3 = await this._gateway.sendExtensionMessage(wI.UNPUBLISH, e3);
                  t3 && await this._p2pChannel.setDescription("local", t3);
                }
              } else {
                const e3 = await this._p2pChannel.unpublish(t2);
                e3 && await this._gateway.unpublish(e3, this._uid), KC.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(t2.map((e4) => "".concat(e4.getTrackId()))));
              }
            } catch (e3) {
              throw KC.error("[".concat(this._clientId, "] unpublish error"), e3.toString()), e3;
            } finally {
              i2 && i2();
            }
          }
          async _unpublishDataChannel(e2) {
            void 0 !== e2 && 0 !== e2.length || (e2 = this._p2pChannel.getAllDataChannels()), KC.info("[".concat(this._clientId, "] Unpublish datachannels, datachannels ").concat(e2.map((e3) => "".concat(e3.id, " ")), " "));
            const t2 = await this._publishMutex.lock();
            try {
              const i2 = await this._p2pChannel.unpublishDataChannel(e2);
              i2 && await this._gateway.unpublishDataChannel(i2), KC.info("[".concat(this._clientId, "] Unpublish dataChannel success,dataChannel ").concat(e2.map((e3) => "".concat(e3.id))));
            } catch (e3) {
              throw KC.error("[".concat(this._clientId, "] unpublish dataChannel error"), e3.toString()), e3;
            } finally {
              t2 && t2();
            }
          }
          async subscribe(e2, t2, i2) {
            return "datachannel" === t2 ? this._subscribeDataChannel(e2, i2) : this._subscribe(e2, t2);
          }
          async _subscribeDataChannel(e2, t2) {
            var i2;
            if (jg(t2, "channelId", 0, 65535, true), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "Can't subscribe datachannel, not joined");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "Can't subscribe datachannel in ".concat(this.connectionState, " state"));
            if (!this._users.find((t3) => t3 === e2))
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), new xv(xg.INVALID_REMOTE_USER, "user is not in the channel");
            if (!e2.hasAudio && !e2.hasVideo && 0 === e2._dataChannels.length)
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), new xv(xg.INVALID_REMOTE_USER, "user is not published");
            const n2 = null === (i2 = e2._dataChannels) || void 0 === i2 ? void 0 : i2.find((e3) => e3.id === t2);
            if (!n2)
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, remote datachannel is not published")), new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);
            const r2 = await this._subscribeMutex.lock();
            KC.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: datachannel"));
            try {
              const t3 = await this._p2pChannel.subscribeDataChannel(e2, [n2]);
              if (t3 && Pr(t3).call(t3, n2.id))
                try {
                  var s2;
                  if (!n2._originDataChannelId)
                    throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, cannot get RTCDatachannel")), new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);
                  const t4 = { id: n2.id, datachannelId: n2._originDataChannelId, ordered: n2.ordered, maxRetransmits: n2.maxRetransmits, metadata: null !== (s2 = n2.metadata) && void 0 !== s2 ? s2 : "" };
                  await this._gateway.subscribeDataChannel(e2.uid, t4, true);
                } catch (t4) {
                  if ((null == t4 ? void 0 : t4.code) !== xg.WS_ABORT)
                    throw await this._p2pChannel.unsubscribeDataChannel(e2, [n2]), t4;
                  await this._p2pChannel.unsubscribeDataChannel(e2, [n2]), this._p2pChannel.setPendingRemoteDataChannel(e2, n2.id);
                }
              return await n2._waitTillOpen(), KC.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: datachannel")), n2;
            } finally {
              r2();
            }
          }
          async _p2pSubscribe(e2, t2, i2) {
            if (Bg(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "Can't subscribe stream, not joined");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
            if (!this._users.find((t3) => t3 === e2)) {
              const t3 = new xv(xg.INVALID_REMOTE_USER, "user is not in the channel");
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
            }
            if (!e2.hasAudio && !e2.hasVideo) {
              const t3 = new xv(xg.INVALID_REMOTE_USER, "user is not published");
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
            }
            if (!i2 && ("audio" === t2 && !e2.hasAudio || "video" === t2 && !e2.hasVideo)) {
              const i3 = new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
            }
            const n2 = await this._subscribeMutex.lock();
            KC.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
            const r2 = "audio" === t2 ? _I.LocalAudioTrack : this._joinInfo.defaultVideoStream === Uy.LOW_STREAM ? _I.LocalVideoLowTrack : _I.LocalVideoTrack;
            try {
              await this._p2pChannel.hasRemoteMediaWithLock(e2, t2) ? await this._p2pChannel.unmuteRemote(e2, t2) : (this.store.subscribe(e2.uid, t2, Date.now()), this._p2pChannel instanceof PM && await this._gateway.sendExtensionMessage(wI.SUBSCRIBE, { trackType: r2 })), KC.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
                KC.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
              });
              const i3 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
              if (!i3)
                throw new xv(xg.UNEXPECTED_ERROR, "can not find remote track in user object");
              return i3;
            } catch (t3) {
              throw KC.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
            } finally {
              n2();
            }
          }
          async _subscribe(e2, t2, i2) {
            if (this._p2pChannel instanceof PM)
              return this._p2pSubscribe(e2, t2);
            if (Bg(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "Can't subscribe stream, not joined");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
            if (!this._users.find((t3) => t3 === e2)) {
              const t3 = new xv(xg.INVALID_REMOTE_USER, "user is not in the channel");
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
            }
            if (!e2.hasAudio && !e2.hasVideo) {
              const t3 = new xv(xg.INVALID_REMOTE_USER, "user is not published");
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
            }
            if (!(i2 || ("audio" !== t2 || e2.hasAudio && void 0 !== e2._audioSSRC) && ("video" !== t2 || e2.hasVideo && void 0 !== e2._videoSSRC))) {
              const i3 = new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);
              throw KC.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i3;
            }
            let n2 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, r2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t2 ? e2._rtxSsrcId : void 0, o2 = { stream_type: "audio" === t2 ? hI.AUDIO : hI.VIDEO, ssrcId: n2 };
            const a2 = await this._subscribeMutex.lock();
            KC.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
            try {
              if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2))
                await this._p2pChannel.unmuteRemote(e2, t2);
              else
                try {
                  const i4 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC;
                  void 0 !== i4 && i4 !== n2 && (n2 = i4, r2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t2 ? e2._rtxSsrcId : void 0, o2 = { stream_type: "audio" === t2 ? hI.AUDIO : hI.VIDEO, ssrcId: n2 }), cD.markSubscribeStart(this.store.clientId, n2), this.store.subscribe(e2.uid, t2, Date.now()), await this._p2pChannel.subscribe(e2, t2, n2, s2, r2);
                  try {
                    await this._gateway.subscribe(e2.uid, o2, true);
                  } catch (i5) {
                    if ((null == i5 ? void 0 : i5.code) !== xg.WS_ABORT)
                      throw await this._p2pChannel.unsubscribe(e2, t2), i5;
                    await this._p2pChannel.unsubscribe(e2, t2, true), this._p2pChannel.setPendingRemoteMedia(e2, t2);
                  }
                  this.store.subscribe(e2.uid, t2, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e2, t2);
                } catch (i4) {
                  throw this._p2pChannel.reportSubscribeEvent(false, null == i4 ? void 0 : i4.code, e2, t2), i4;
                }
              KC.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
                KC.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
              });
              const i3 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
              if (!i3)
                throw new xv(xg.UNEXPECTED_ERROR, "can not find remote track in user object");
              return i3;
            } catch (t3) {
              throw KC.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
            } finally {
              a2();
            }
          }
          async massSubscribe(e2) {
            if (Hg(e2, "subscribeList"), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "Can't subscribe stream, not joined");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
            const t2 = Date.now(), i2 = /* @__PURE__ */ new Map(), n2 = await this._subscribeMutex.lock();
            KC.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e2.map((e3) => {
              let { user: t3, mediaType: i3 } = e3;
              return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i3);
            }).join("; ")));
            const r2 = (e2 = [...e2]).map((e3) => {
              let { user: t3, mediaType: i3 } = e3;
              return { user: t3, mediaType: i3 };
            }), s2 = await this._p2pChannel.globalLock();
            try {
              var o2;
              for (let t3 = e2.length - 1; t3 >= 0; t3--) {
                const n3 = e2[t3], { user: s3, mediaType: o3 } = n3;
                if (Bg(o3, "mediaType", ["audio", "video"]), !s3) {
                  const e3 = new xv(xg.INVALID_PARAMS, "user property does not exist in subscribeList item");
                  throw KC.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e3;
                }
                if (!this._users.find((e3) => e3 === s3)) {
                  const i3 = new xv(xg.INVALID_REMOTE_USER, "user is not in the channel");
                  KC.error("[".concat(this._clientId, "] can not massSubscribe ").concat(s3.uid, ", this user is not in the channel")), r2[t3].error = i3, e2.splice(t3, 1);
                  continue;
                }
                if ("audio" === o3 && (!s3.hasAudio || void 0 === s3._audioSSRC) || "video" === o3 && (!s3.hasVideo || void 0 === s3._videoSSRC)) {
                  const i3 = new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);
                  KC.error("[".concat(this._clientId, "] can not subscribe ").concat(s3.uid, " with mediaType ").concat(o3, ", remote user is not published")), r2[t3].error = i3, e2.splice(t3, 1);
                  continue;
                }
                const a3 = iI.Video | iI.LwoVideo, c2 = i2.get(s3);
                if (c2) {
                  if ("video" === o3 ? c2 & a3 : c2 & iI.Audio) {
                    e2.splice(t3, 1), KC.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(s3.uid, ", mediaType:").concat(o3, " twice"));
                    continue;
                  }
                  i2.set(s3, c2 | ("video" === o3 ? a3 : iI.Audio));
                } else
                  i2.set(s3, "video" === o3 ? a3 : iI.Audio);
              }
              for (let t3 = e2.length - 1; t3 >= 0; t3--) {
                const n3 = e2[t3], { user: r3, mediaType: s3 } = n3, o3 = iI.Video | iI.LwoVideo;
                if (this._p2pChannel.hasRemoteMedia(r3, s3)) {
                  await this._p2pChannel.unmuteRemoteNoLock(r3, s3);
                  const n4 = i2.get(r3);
                  i2.set(r3, "video" === s3 ? n4 ^ o3 : n4 ^ iI.Audio), e2.splice(t3, 1);
                }
              }
              this.store.massSubscribe(e2.map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), t2);
              const a2 = cS(o2 = Array.from(i2.entries())).call(o2, (e3, t3) => {
                let [i3, n3] = t3;
                if (0 === n3)
                  return e3;
                const r3 = { stream_id: i3.uid, stream_type: n3 };
                return n3 & iI.Audio && (r3.audio_ssrc = i3._audioSSRC), n3 & iI.Video && (r3.video_ssrc = i3._videoSSRC), e3.push(r3), e3;
              }, []);
              try {
                e2.length > 0 && await this._p2pChannel.massSubscribeNoLock(e2.map((e3) => {
                  let { user: t3, mediaType: i4 } = e3;
                  return { user: t3, mediaType: i4, ssrcId: i4 === hI.VIDEO ? t3._videoSSRC : t3._audioSSRC, rtxSsrcId: i4 === hI.VIDEO ? t3._rtxSsrcId : void 0 };
                }));
                const i3 = /* @__PURE__ */ new Map();
                if (a2.length > 0) {
                  const e3 = await this._gateway.subscribeAll(a2, true);
                  ((null == e3 ? void 0 : e3.users) || []).forEach((e4) => {
                    let { stream_id: t3, video_error_code: n3, audio_error_code: r3, error_code: s3 } = e4;
                    (n3 || r3 || s3) && i3.set(t3, { video_error_code: n3, audio_error_code: r3, error_code: s3 });
                  });
                }
                if (Array.from(i3.entries()).length > 0) {
                  const e3 = Array.from(i3.entries()).map((e4) => {
                    let t3, [i4, n3] = e4;
                    n3.error_code || n3.video_error_code && n3.audio_error_code ? t3 = void 0 : n3.video_error_code ? t3 = hI.VIDEO : n3.audio_error_code && (t3 = hI.AUDIO);
                    return { user: this.remoteUsers.find((e5) => e5.uid === i4), mediaType: t3 };
                  });
                  await this._p2pChannel.massUnsubscribeNoLock(e3);
                }
                for (const e3 of r2) {
                  const t3 = i3.get(e3.user.uid);
                  if (t3) {
                    const i4 = t3.error_code || "audio" === e3.mediaType && t3.audio_error_code || "video" === e3.mediaType && t3.video_error_code;
                    if (i4) {
                      const t4 = UI(i4);
                      KC.error("user:".concat(e3.user.uid, " mediaType:").concat(e3.mediaType, " has massSubscribe error ").concat(t4.desc)), e3.error = new xv(xg.SUBSCRIBE_FAILED, "code ".concat(i4, ": ").concat(t4.desc));
                    }
                  }
                  e3.error || ("video" === e3.mediaType ? e3.track = e3.user.videoTrack : e3.track = e3.user.audioTrack);
                }
                return this.store.massSubscribe(r2.filter((e3) => !e3.error).map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), void 0, Date.now()), r2.forEach((e3) => {
                  var i4;
                  rv.subscribe(this.store.sessionId, { succ: !!e3.error, ec: (null === (i4 = e3.error) || void 0 === i4 ? void 0 : i4.code) || null, video: e3.mediaType === hI.VIDEO, audio: e3.mediaType === hI.AUDIO, peerid: e3.user.uid, subscribeRequestid: e3.mediaType === hI.VIDEO ? e3.user._videoSSRC : e3.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t2) }, true);
                }), KC.info("[".concat(this._clientId, "] massSubscribe success ").concat(e2.map((e3) => {
                  let { user: t3, mediaType: i4 } = e3;
                  return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i4);
                }).join("; "))), r2;
              } catch (t3) {
                throw await this._p2pChannel.massUnsubscribeNoLock(e2), t3;
              }
            } finally {
              s2(), n2();
            }
          }
          async unsubscribe(e2, t2, i2) {
            if (t2 || this.store.useP2P) {
              if ("datachannel" === t2)
                return this._unsubscribeDataChannel(e2, i2);
            } else
              await this._unsubscribeDataChannel(e2, i2);
            if (t2 && Bg(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
            if (!this._users.find((t3) => t3 === e2)) {
              const t3 = new xv(xg.INVALID_REMOTE_USER, "user is not in the channel");
              throw KC.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
            }
            KC.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
            const n2 = await this._subscribeMutex.lock();
            try {
              if (this._p2pChannel instanceof PM)
                await this._gateway.sendExtensionMessage(wI.UNSUBSCRIBE, { mediaType: t2 });
              else {
                const i3 = await this._p2pChannel.unsubscribe(e2, t2);
                i3 && await this._gateway.unsubscribe(i3, e2.uid), KC.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
              }
            } catch (t3) {
              if (t3.code === xg.DISCONNECT_P2P)
                return void KC.warning("disconnecting p2p, abort unsubscribe request.");
              throw KC.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
            } finally {
              n2();
            }
          }
          async _unsubscribeDataChannel(e2, t2) {
            if (t2 && jg(t2, "id", 0, 65535, true), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "Can't unsubscribe datachannel, haven't joined yet!");
            if (!this._users.find((t3) => t3 === e2)) {
              const t3 = new xv(xg.INVALID_REMOTE_USER, "user is not in the channel");
              throw KC.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
            }
            let i2;
            if ("number" == typeof t2) {
              const n2 = e2._dataChannels.find((e3) => e3.id === t2);
              n2 && (i2 = [n2]);
            } else
              i2 = e2._dataChannels;
            if (void 0 === i2) {
              const i3 = new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);
              throw KC.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, " with channelId ").concat(t2, ", remote datachannel is not published")), i3;
            }
            KC.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(i2.map((e3) => e3.id)));
            try {
              const t3 = await this._p2pChannel.unsubscribeDataChannel(e2, i2);
              t3 && await this._gateway.unsubscribeDataChannel(t3, e2.uid), KC.info("[".concat(this._clientId, "] unsubscribe datachannel success uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(t3));
            } catch (t3) {
              if (t3.code === xg.DISCONNECT_P2P)
                return void KC.warning("disconnecting p2p, abort unsubscribe request.");
              throw KC.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
            }
          }
          async massUnsubscribe(e2) {
            if (Hg(e2, "unsubscribeList"), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
            KC.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e2.map((e3) => {
              let { user: t3, mediaType: i2 } = e3;
              return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i2, ";");
            }).join())), e2 = [...e2];
            const t2 = /* @__PURE__ */ new Map();
            for (let i2 = e2.length - 1; i2 >= 0; i2--) {
              const { user: n2, mediaType: r2 } = e2[i2];
              if (!n2) {
                const e3 = new xv(xg.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
                throw KC.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e3;
              }
              Bg(r2, "mediaType", ["video", "audio", void 0]);
              if (!this._users.find((e3) => e3 === n2)) {
                KC.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n2.uid, ", user is not in the channel")), e2.splice(i2, 1);
                continue;
              }
              const s2 = iI.Video | iI.LwoVideo;
              if (t2.has(n2)) {
                const o2 = t2.get(n2);
                let a2;
                switch (r2) {
                  case "video":
                    a2 = o2 & s2;
                    break;
                  case "audio":
                    a2 = o2 & iI.Audio;
                    break;
                  default:
                    a2 = o2 & (iI.Audio | s2);
                }
                if (a2) {
                  KC.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(n2.uid, ",mediaType:").concat(r2, " twice.")), e2.splice(i2, 1);
                  continue;
                }
                r2 ? "audio" === r2 ? t2.set(n2, o2 | iI.Audio) : "video" === r2 && t2.set(n2, o2 | s2) : t2.set(n2, o2 | iI.Audio | s2);
              } else
                r2 ? "audio" === r2 ? t2.set(n2, iI.Audio) : "video" === r2 && t2.set(n2, s2) : t2.set(n2, iI.Audio | s2);
            }
            try {
              const t3 = await this._p2pChannel.massUnsubscribe(e2);
              t3 && await this._gateway.massUnsubscribe(t3), KC.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e2.map((e3) => {
                let { user: t4, mediaType: i2 } = e3;
                return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i2, ";");
              }).join()));
            } catch (e3) {
              if (e3.code === xg.DISCONNECT_P2P)
                return void KC.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
              throw KC.error("[".concat(this._clientId, "] massUnsubscribe error"), e3.toString()), e3;
            }
          }
          async setLowStreamParameter(e2) {
            !function(e3) {
              if (!e3)
                throw new Vg(xg.INVALID_PARAMS);
              Kg(e3.width) || Gg(e3.width, "streamParameter.width"), Kg(e3.height) || Gg(e3.height, "streamParameter.height"), Kg(e3.framerate) || Gg(e3.framerate, "streamParameter.framerate"), Kg(e3.bitrate) || jg(e3.bitrate, "streamParameter.bitrate");
            }(e2), (!e2.width && e2.height || e2.width && !e2.height) && KC.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), KC.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e2));
            const t2 = this._configDistribute.getLowStreamConfigDistribute();
            if (t2 && t2.bitrate && e2.bitrate && t2.bitrate < e2.bitrate && (e2.bitrate = t2.bitrate), this._lowStreamParameter = e2, this._isDualStreamEnabled)
              return this._p2pChannel.updateVideoStreamParameter(e2, _I.LocalVideoLowTrack);
          }
          async enableDualStream() {
            if (!_A().supportDualStream)
              throw rv.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new xv(xg.NOT_SUPPORTED, "Your browser is not support dual stream");
            if (this._isDualStreamEnabled)
              throw new xv(xg.INVALID_OPERATION, "Dual stream is already enabled");
            if (this._p2pChannel.canPublishLowStream())
              try {
                await this._publishLowStream();
              } catch (e2) {
                throw rv.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e2;
              }
            this._isDualStreamEnabled = true, rv.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), KC.info("[".concat(this._clientId, "] enable dual stream"));
          }
          async disableDualStream() {
            if (this._isDualStreamEnabled) {
              if (!this._joinInfo)
                throw new xv(xg.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
              if (this._p2pChannel.getLocalMedia(_I.LocalVideoLowTrack))
                try {
                  const e2 = await this._p2pChannel.unpublishLowStream();
                  e2 && await this._gateway.unpublish(e2, this._joinInfo.stringUid || this._joinInfo.uid);
                } catch (e2) {
                  throw rv.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e2;
                }
              this._isDualStreamEnabled = false, rv.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), KC.info("[".concat(this._clientId, "] disable dual stream"));
            }
          }
          async setClientRole(e2, t2) {
            if (function(e3) {
              Bg(e3, "role", ["audience", "host"]);
            }(e2), t2 && mT(t2), "rtc" === this.mode)
              throw KC.warning("[".concat(this._clientId, "]rtc mode can not use setClientRole")), new xv(xg.INVALID_OPERATION, "rtc mode can not use setClientRole");
            if (t2 && t2.level && "host" === e2)
              throw new xv(xg.INVALID_OPERATION, "host mode can not set audience latency level");
            if ("audience" === e2 && this._p2pChannel.hasLocalMedia())
              throw new xv(xg.INVALID_OPERATION, "can not set client role to audience when publishing stream");
            await this._gateway.setClientRole(e2, t2), this._config.role = e2, KC.info("[".concat(this._clientId, "] set client role to ").concat(e2, ", level: ").concat(t2 && t2.level));
          }
          getRemoteInboundOffset() {
            var e2;
            const t2 = null === (e2 = this._p2pChannel.getStats()) || void 0 === e2 ? void 0 : e2.audioSend[0];
            if (!t2 || !t2.timestamp)
              return 0;
            const i2 = t2.timestamp - Date.now();
            return Math.abs(i2) > 1e3 + t2.rttMs + 100 ? this.ntpAlignErrorCount += 1 : this.ntpAlignErrorCount = 0, this.ntpAlignErrorCount >= 3 ? i2 : 0;
          }
          getNtpWallTimeInMs() {
            return "visible" === document.visibilityState && (this.remoteInboundOffset = this.getRemoteInboundOffset()), this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset;
          }
          setProxyServer(e2, t2) {
            if (Wg(e2, "proxyServer"), !t2) {
              if ("DISCONNECTED" !== this.connectionState)
                throw new xv(xg.INVALID_OPERATION, "Set proxy server before join channel");
              if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
                throw new xv(xg.INVALID_OPERATION, "You have already set the proxy");
            }
            this._proxyServer = e2, rv.setProxyServer(this._proxyServer), KC.setProxyServer(this._proxyServer), KC.info("[".concat(this._clientId, "] Set proxy server ").concat(t2 ? "by initialize call" : "", " success."));
          }
          setTurnServer(e2, t2) {
            if (Array.isArray(e2) || (e2 = [e2]), !t2) {
              if ("DISCONNECTED" !== this.connectionState)
                throw new xv(xg.INVALID_OPERATION, "Set turn server before join channel");
              if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
                throw new xv(xg.INVALID_OPERATION, "You have already set the proxy");
            }
            if (_T(e2))
              return this._turnServer = { servers: e2, mode: "original-manual" }, void KC.info("[".concat(this._clientId, "] Set original turnserver ").concat(t2 ? "by initialize call" : "", " success: ").concat(e2.map((e3) => e3.urls).join(","), "."));
            e2.forEach((e3) => ET(e3)), this._turnServer = { servers: e2, mode: "manual" }, KC.info("[".concat(this._clientId, "] Set turnserver ").concat(t2 ? "by initialize call" : "", " success."));
          }
          setLicense(e2) {
            if ("DISCONNECTED" !== this.connectionState) {
              throw new xv(xg.INVALID_OPERATION, "you should set license before join channel");
            }
            if (Wg(e2, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e2))
              throw new xv(xg.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
            this._license = e2, KC.info("[".concat(this._clientId, "] set license success"), e2);
          }
          startProxyServer(e2) {
            if ("DISCONNECTED" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "Start proxy server before join channel");
            if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint)
              throw new xv(xg.INVALID_OPERATION, "You have already set the proxy");
            const t2 = [3, 4, 5];
            let i2;
            switch (void 0 === e2 && (e2 = 3), e2) {
              case 1:
              case 2:
                throw new xv(xg.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
              case 3:
                i2 = "proxy3";
                break;
              case 4:
                i2 = "proxy4";
                break;
              case 5:
                i2 = "proxy5";
                break;
              default:
                throw new xv(xg.INVALID_PARAMS, "proxy server mode must be ".concat(t2.join("|")));
            }
            this._cloudProxyServerMode = i2, this.store.cloudProxyServerMode = i2, KC.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
          }
          stopProxyServer() {
            if ("DISCONNECTED" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "Stop proxy server after leave channel");
            rv.setProxyServer(), KC.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", KC.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
          }
          setLocalAccessPointsV2(e2) {
            if (!e2.accessPoints)
              throw new xv(xg.INVALID_PARAMS, "accessPoints is required.");
            Hg(e2.accessPoints.serverList, "accessPoints.serverList"), Wg(e2.accessPoints.domain, "accessPoints.domain");
            const t2 = (e3, t3) => {
              jg(e3, t3, 0, 65535, true);
            };
            let i2 = 443;
            if (e2.accessPoints.port && (t2(e2.accessPoints.port, "accessPoints.port"), i2 = e2.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
              throw new xv(xg.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
            kC("CLOSE_AFB_FOR_LOCAL_AP") && (LC("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), LC("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
            const n2 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r2 = e2.accessPoints.domain, s2 = e2.accessPoints.serverList.map((e3) => n2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(r2) : e3), o2 = s2.map((e3) => "".concat(e3, ":").concat(i2));
            this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, LC("WEBCS_DOMAIN", o2), LC("WEBCS_DOMAIN_BACKUP_LIST", o2), LC("GATEWAY_DOMAINS", [r2]), e2.report && e2.report.hostname && Array.isArray(e2.report.hostname) && e2.report.hostname.length ? (Hg(e2.report.hostname, "report.hostname"), LC("EVENT_REPORT_DOMAIN", e2.report.hostname[0]), LC("EVENT_REPORT_BACKUP_DOMAIN", e2.report.hostname[1] || e2.report.hostname[0])) : (LC("EVENT_REPORT_DOMAIN", s2[0]), LC("EVENT_REPORT_BACKUP_DOMAIN", s2[1] || s2[0]));
            let a2 = 6443;
            e2.report && e2.report.port && (t2(e2.report.port, "report.port"), a2 = e2.report.port), LC("STATS_COLLECTOR_PORT", a2), e2.report ? LC("ENABLE_EVENT_REPORT", true) : LC("ENABLE_EVENT_REPORT", false);
            let c2 = "";
            e2.log && e2.log.hostname && Array.isArray(e2.log.hostname) && e2.log.hostname.length ? (Hg(e2.log.hostname, "log.hostname"), c2 = e2.log.hostname[0]) : c2 = s2[0];
            let d2 = 6444;
            e2.log && e2.log.port && (t2(e2.log.port, "log.port"), d2 = e2.log.port), LC("LOG_UPLOAD_SERVER", "".concat(c2, ":").concat(d2));
            let l2 = [];
            e2.cds && e2.cds.hostname && Array.isArray(e2.cds.hostname) && e2.cds.hostname.length ? (Hg(e2.cds.hostname, "cds.hostname"), l2 = e2.cds.hostname) : l2 = s2;
            let h2 = 443;
            e2.cds && e2.cds.port && (t2(e2.cds.port, "cds.port"), h2 = e2.cds.port), LC("CDS_AP", l2.map((e3) => "".concat(e3, ":").concat(h2))), e2.cds ? LC("ENABLE_CONFIG_DISTRIBUTE", true) : LC("ENABLE_CONFIG_DISTRIBUTE", false), KC.info("set local access point v2 success");
          }
          setLocalAccessPoints(e2, t2) {
            if (Hg(e2, "serverList"), Wg(t2, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
              throw new xv(xg.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
            const i2 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
            e2 = e2.map((e3) => i2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(t2) : e3), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, LC("WEBCS_DOMAIN", e2), LC("WEBCS_DOMAIN_BACKUP_LIST", e2), LC("GATEWAY_DOMAINS", [t2]), LC("EVENT_REPORT_DOMAIN", e2[0]), LC("EVENT_REPORT_BACKUP_DOMAIN", e2[1] || e2[0]), LC("LOG_UPLOAD_SERVER", "".concat(e2[0], ":6444")), KC.info("[".concat(this._clientId, "] set local access point success"));
          }
          async setRemoteDefaultVideoStreamType(e2) {
            if (Bg(e2, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = e2, this._joinInfo)
              try {
                await this._gateway.setDefaultRemoteVideoStreamType(e2), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
              } catch (e3) {
                throw KC.error("[".concat(this._clientId, "] set default remote video stream type error"), e3.toString()), e3;
              }
            else
              KC.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e2));
          }
          async setRemoteVideoStreamType(e2, t2) {
            Bg(t2, "streamType", [0, 1]);
            try {
              await this._gateway.setRemoteVideoStreamType(e2, t2), setTimeout(() => {
                const t3 = this._users.find((t4) => t4.uid === e2);
                t3 && t3.videoTrack && t3.videoTrack.updateMediaStreamTrackResolution();
              }, 2e3);
            } catch (e3) {
              throw KC.error("[".concat(this._clientId, "] set remote video stream type error"), e3.toString()), e3;
            }
            KC.info("[".concat(this._clientId, "] set remote ").concat(e2, " video stream type to ").concat(t2)), this._remoteStreamTypeCacheMap.set(e2, t2);
          }
          async setStreamFallbackOption(e2, t2) {
            Bg(t2, "fallbackType", [0, 1, 2]);
            try {
              await this._gateway.setStreamFallbackOption(e2, t2);
            } catch (e3) {
              throw KC.error("[".concat(this._clientId, "] set stream fallback option"), e3.toString()), e3;
            }
            KC.info("[".concat(this._clientId, "] set remote ").concat(e2, " stream fallback type to ").concat(t2)), this._streamFallbackTypeCacheMap.set(e2, t2);
          }
          setEncryptionConfig(e2, t2, i2) {
            !function(e3) {
              Bg(e3, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
            }(e2), Wg(t2, "secret");
            const n2 = ["aes-128-gcm2", "aes-256-gcm2"];
            if (Pr(n2).call(n2, e2)) {
              if (!i2 || !(i2 instanceof Uint8Array && 32 === i2.length))
                throw new xv(xg.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
            } else if (i2)
              throw new xv(xg.INVALID_PARAMS, "current encrypt mode does not need salt");
            new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t2) || KC.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e2, this._encryptionSecret = t2, i2 && (this._encryptionSalt = PT(i2));
          }
          async renewToken(e2) {
            if (Wg(e2, "token", 1, 2047), !this._key || !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "renewToken should not be called before user join");
            const t2 = this._key;
            this._key = e2, this._joinInfo && (this._joinInfo.token = e2);
            const i2 = await this._renewTokenMutex.lock();
            try {
              if (kC("USE_NEW_TOKEN")) {
                KC.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
                const t3 = await mP(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || JT);
                KC.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e2, ticket: t3 });
              } else
                KC.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e2 });
              KC.debug("[".concat(this._clientId, "] renewToken success"));
            } catch (e3) {
              throw this._key = t2, this._joinInfo.token = t2, KC.error("[".concat(this._clientId, "] renewToken failed"), e3.toString()), e3;
            } finally {
              i2();
            }
          }
          enableAudioVolumeIndicator() {
            this._audioVolumeIndicationInterval ? KC.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
              const e2 = this._p2pChannel.getAudioLevels();
              this.safeEmit(dT.VOLUME_INDICATOR, e2);
            }, kC("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
          }
          getRTCStats() {
            const e2 = this._statsCollector.getRTCStats(), t2 = this._gateway.getInChannelInfo();
            return e2.Duration = Math.round(t2.duration / 1e3), e2;
          }
          async startLiveStreaming(e2, t2) {
            if (!t2) {
              if ("h264" !== this.codec)
                throw new xv(xg.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
              if (!this._p2pChannel.hasLocalMedia())
                throw new xv(xg.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
            }
            if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e2) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e2))
              throw new xv(xg.LIVE_STREAMING_TASK_CONFLICT);
            const i2 = t2 ? yv.TRANSCODE : yv.RAW;
            return this._createLiveStreamingClient(i2).startLiveStreamingTask(e2, i2);
          }
          setLiveTranscoding(e2) {
            return this._createLiveStreamingClient(yv.TRANSCODE).setTranscodingConfig(e2);
          }
          async stopLiveStreaming(e2) {
            const t2 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t3) => t3 && t3.hasUrl(e2));
            if (!t2.length)
              throw new xv(xg.INVALID_PARAMS, "can not find live streaming url to stop");
            await tg.all(t2.map((t3) => t3 && t3.stopLiveStreamingTask(e2)));
          }
          async addInjectStreamUrl(e2, t2) {
            if (!this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo");
            const i2 = this._createLiveStreamingClient(yv.INJECT);
            i2.setInjectStreamConfig(t2, 0), await i2.startLiveStreamingTask(e2, yv.INJECT);
          }
          async removeInjectStreamUrl() {
            var e2;
            const t2 = this._createLiveStreamingClient(yv.INJECT), i2 = Array.from(kv(e2 = t2.streamingTasks).call(e2)).find((e3) => e3.mode === yv.INJECT);
            if (!this._joinInfo || !i2)
              throw new xv(xg.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task");
            await t2.stopLiveStreamingTask(i2.url);
          }
          async startChannelMediaRelay(e2) {
            bP(e2);
            const t2 = this._createChannelMediaRelayClient();
            await t2.startChannelMediaRelay(e2);
          }
          async updateChannelMediaRelay(e2) {
            bP(e2);
            const t2 = this._createChannelMediaRelayClient();
            await t2.updateChannelMediaRelay(e2);
          }
          async stopChannelMediaRelay() {
            const e2 = this._createChannelMediaRelayClient();
            await e2.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
          }
          sendStreamMessage(e2) {
            let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (!this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "can not send data stream, not joined");
            if (("string" == typeof e2 || e2 instanceof Uint8Array) && (e2 = { payload: e2 }), "string" == typeof e2.payload) {
              const t3 = new TextEncoder();
              e2.payload = t3.encode(e2.payload);
            }
            if (new Blob([e2.payload]).size > 1024)
              throw new xv(xg.INVALID_PARAMS, "stream message out of range.");
            return this._gateway.signal.request(Tv.DATA_STREAM, { payload: PT(e2.payload), syncWithAudio: e2.syncWithAudio, sendTs: Date.now() - UM }, !t2);
          }
          sendMetadata(e2) {
            if (!this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "can not send metadata, not joined");
            if (new Blob([e2]).size > 1024)
              throw new xv(xg.METADATA_OUT_OF_RANGE);
            return this._gateway.signal.request(Tv.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: PT(e2) });
          }
          async sendCustomReportMessage(e2) {
            if (Array.isArray(e2) || (e2 = [e2]), e2.forEach(JC), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "can not send custom report, not joined");
            await rv.sendCustomReportMessage(this._joinInfo.sid, e2);
          }
          getLocalAudioStats() {
            return this._statsCollector.getLocalAudioTrackStats();
          }
          getRemoteAudioStats() {
            return this._statsCollector.getRemoteAudioTrackStats();
          }
          getLocalVideoStats() {
            return this._statsCollector.getLocalVideoTrackStats();
          }
          getRemoteVideoStats() {
            return this._statsCollector.getRemoteVideoTrackStats();
          }
          getRemoteNetworkQuality() {
            return this._statsCollector.getRemoteNetworkQualityStats();
          }
          async pickSVCLayer(e2, t2) {
            Bg(t2.spatialLayer, "spatialLayer", [0, 1, 2, 3]), Bg(t2.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
            try {
              await this._gateway.pickSVCLayer(e2, t2);
            } catch (e3) {
              throw KC.error("[".concat(this._clientId, "] pick SVC layer failed"), e3.toString()), e3;
            }
          }
          setRTM2Flag(e2) {
            if (Bg(e2, "flag", [0, 1]), !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "Can't setRtm2Flag, not joined");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "Can't setRtm2Flag in ".concat(this.connectionState, " state"));
            return this._gateway.setRTM2Flag(e2);
          }
          _reset() {
            if (KC.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = EC.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._pendingPublishedUsers = [], this._users.forEach((e2) => {
              e2._audioTrack && e2._audioTrack._destroy(), e2._videoTrack && e2._videoTrack._destroy(), e2._dataChannels && (e2._dataChannels.forEach((e3) => e3._close()), e2._dataChannels.length = 0);
            }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new YT("client-publish"), this._subscribeMutex = new YT("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect)
              try {
                this._inspect.close(), this._inspect = void 0;
              } catch (e2) {
              }
            if (this._moderation)
              try {
                this.setImageModeration(false);
              } catch (e2) {
              }
          }
          _startSession(e2, t2) {
            const i2 = e2 || VT();
            e2 ? KC.debug("[".concat(this._clientId, "] new Session ").concat(i2)) : KC.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(i2)), this._sessionId = i2, this.store.sessionId = i2, t2 ? rv.sessionInit(this._sessionId, { lts: (/* @__PURE__ */ new Date()).getTime(), cname: t2.channel, appid: t2.appId, mode: this.mode }) : this._joinInfo ? rv.sessionInit(this._sessionId, { lts: (/* @__PURE__ */ new Date()).getTime(), cname: this._joinInfo.cname, appid: this._joinInfo.appId, mode: this.mode }) : this._gateway.joinInfo && rv.sessionInit(this._sessionId, { lts: (/* @__PURE__ */ new Date()).getTime(), cname: this._gateway.joinInfo.cname, appid: this._gateway.joinInfo.appId, mode: this.mode }), this._joinInfo && (this._joinInfo.sid = i2), this._gateway.joinInfo && (this._gateway.joinInfo.sid = i2);
          }
          async _publishHighStream(e2) {
            if (!this._joinInfo || void 0 === this._uid)
              throw new xv(xg.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
            if ("auto" === this._turnServer.mode && kC("FORCE_TURN") && !kC("TURN_ENABLE_TCP") && !kC("TURN_ENABLE_UDP"))
              throw new xv(xg.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
            KC.debug("[".concat(this._clientId, "] publish high stream"));
            try {
              if (this._p2pChannel instanceof PM) {
                const t3 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter);
                if (t3)
                  try {
                    await this._gateway.sendExtensionMessage(wI.PUBLISH, t3);
                  } catch (t4) {
                    throw this._p2pChannel.unpublish(e2), t4;
                  }
              } else {
                const i2 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter), n2 = (await i2.next()).value;
                if (n2) {
                  var t2;
                  let e3;
                  try {
                    e3 = await this._gateway.publish(this._uid, n2, true);
                  } catch (e4) {
                    if (e4.code !== xg.DISCONNECT_P2P)
                      throw i2.throw(e4), e4;
                  }
                  await i2.next((null === (t2 = e3) || void 0 === t2 ? void 0 : t2.ortc) || []);
                }
                this._p2pChannel.reportPublishEvent(true, null);
                for (const t3 of e2)
                  t3 instanceof Sb && t3._encoderConfig && this._gateway.setVideoProfile(t3._encoderConfig), !t3.muted && t3.enabled || await this._p2pChannel.muteLocalTrack(t3);
              }
            } catch (t3) {
              if (this._p2pChannel.reportPublishEvent(false, null == t3 ? void 0 : t3.code, e2), (null == t3 ? void 0 : t3.code) === xg.WS_ABORT)
                return;
              throw t3;
            }
          }
          async _publishLowStream() {
            if (!this._joinInfo || void 0 === this._uid)
              throw new xv(xg.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
              throw new xv(xg.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
            KC.debug("[".concat(this._clientId, "] publish low stream"));
            const e2 = this._configDistribute.getLowStreamConfigDistribute();
            e2 && e2.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e2.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e2.bitrate));
            try {
              const e3 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i2 = (await e3.next()).value;
              if (i2) {
                var t2;
                let n2;
                try {
                  n2 = await this._gateway.publish(this._uid, i2, true);
                } catch (t3) {
                  if (t3.code !== xg.DISCONNECT_P2P)
                    throw e3.throw(t3), t3;
                }
                e3.next((null === (t2 = n2) || void 0 === t2 ? void 0 : t2.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
              }
            } catch (e3) {
              if (this._p2pChannel.reportPublishEvent(false, null == e3 ? void 0 : e3.code, void 0, true), (null == e3 ? void 0 : e3.code) === xg.WS_ABORT)
                return;
              throw e3;
            }
          }
          _createLiveStreamingClient(e2) {
            if (!this._joinInfo || !this._appId) {
              return new xv(xg.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
            }
            const t2 = () => new yP(this._joinInfo, this._config.websocketRetryConfig || JT, this._config.httpRetryConfig || JT), i2 = (e3) => {
              e3.onLiveStreamError = (e4, t3) => {
                rv.reportApiInvoke(this._sessionId, { name: sT.ON_LIVE_STREAM_ERROR, options: [e4, t3], tag: oT.TRACER }).onSuccess(), this.safeEmit(dT.LIVE_STREAMING_ERROR, e4, t3);
              }, e3.onLiveStreamWarning = (e4, t3) => {
                rv.reportApiInvoke(this._sessionId, { name: sT.ON_LIVE_STREAM_WARNING, options: [e4, t3], tag: oT.TRACER }).onSuccess(), this.safeEmit(dT.LIVE_STREAMING_WARNING, e4, t3);
              }, e3.on(Yv.REQUEST_WORKER_MANAGER_LIST, (e4, t3, i3) => {
                if (!this._joinInfo)
                  return i3(new xv(xg.INVALID_OPERATION, "can not find join info to get worker manager"));
                _P(e4, this._joinInfo, this._axiosCancelSource.token, JT).then(t3).catch(i3);
              });
            };
            switch (e2) {
              case yv.RAW:
                return this._liveRawStreamingClient || (this._liveRawStreamingClient = t2(), i2(this._liveRawStreamingClient)), this._liveRawStreamingClient;
              case yv.TRANSCODE:
                return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t2(), i2(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;
              case yv.INJECT:
                return this._injectStreamingClient || (this._injectStreamingClient = t2(), this._injectStreamingClient.on(Yv.REQUEST_WORKER_MANAGER_LIST, (e3, t3, i3) => {
                  if (!this._joinInfo)
                    return i3(new xv(xg.INVALID_OPERATION, "can not find join info to get worker manager"));
                  _P(e3, this._joinInfo, this._axiosCancelSource.token, JT).then(t3).catch(i3);
                }), this._injectStreamingClient.onInjectStatusChange = (e3, t3, i3) => {
                  this.safeEmit(dT.INJECT_STREAM_STATUS, e3, t3, i3);
                }), this._injectStreamingClient;
            }
          }
          _createChannelMediaRelayClient() {
            if (!this._joinInfo) {
              return new xv(xg.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
            }
            if (!this._channelMediaRelayClient) {
              const { sendResolutionWidth: e2, sendResolutionHeight: t2 } = this.getLocalVideoStats(), i2 = { width: e2, height: t2 };
              this._channelMediaRelayClient = new OP(this._joinInfo, this._clientId, this._config.websocketRetryConfig || JT, this._config.httpRetryConfig || JT, i2), this._channelMediaRelayClient.on("state", (e3) => {
                e3 === Qv.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.safeEmit(dT.CHANNEL_MEDIA_RELAY_STATE, e3);
              }), this._channelMediaRelayClient.on("event", (e3) => {
                this.safeEmit(dT.CHANNEL_MEDIA_RELAY_EVENT, e3);
              }), this._statsCollector.onStatsChanged = (e3, t3) => {
                var i3;
                "resolution" === e3 && (null === (i3 = this._channelMediaRelayClient) || void 0 === i3 || i3.setVideoProfile(t3));
              };
            }
            return this._channelMediaRelayClient;
          }
          _handleUpdateDataChannel(e2, t2) {
            const { added: i2, deleted: n2 } = e2, r2 = [];
            Array.isArray(i2) && i2.length > 0 && i2.forEach((e3) => {
              const { uid: i3, stream_id: n3, ordered: s2, max_retrans_times: o2, metadata: a2 } = e3, c2 = this._users.find((e4) => e4._uintid === i3);
              if (!c2)
                return void KC.error("[".concat(this._clientId, "] can not find target user!(on_add_data_channel)"));
              KC.debug("[".concat(this._clientId, "] data_channel added with uid ").concat(i3)), Pr(r2).call(r2, c2) || r2.push(c2), c2._uintid || (c2._uintid = i3);
              if (!(-1 !== c2._dataChannels.findIndex((t3) => t3.id === e3.stream_id))) {
                const e4 = { id: n3, ordered: !!s2, maxRetransmits: o2, metadata: a2 }, i4 = new rD(e4);
                c2._dataChannels.push(i4), KC.info("[".concat(this._clientId, "] remote user ").concat(c2.uid, " published datachannel")), t2 || this.safeEmit(dT.USER_PUBLISHED, c2, "datachannel", e4);
              }
              this._p2pChannel.hasPendingRemoteDataChannel(c2, e3.stream_id) && (KC.debug("[".concat(this._clientId, "] resubscribe datachannel for user ").concat(c2.uid, " after reconnect.")), this._subscribeDataChannel(c2, e3.stream_id).catch((e4) => {
                KC.error("[".concat(this._clientId, "] resubscribe datachannel error"), e4.toString());
              }));
            }), t2 && (this.safeEmit(dT.PUBLISHED_USER_LIST, this._pendingPublishedUsers), this._pendingPublishedUsers = []), Array.isArray(n2) && n2.length > 0 && n2.forEach((e3) => {
              const { uid: t3, stream_id: i3 } = e3, n3 = this._users.find((e4) => e4._uintid === t3);
              if (!n3)
                return void KC.error("[".concat(this._clientId, "] can not find target user!(on_delete_data_channel)"));
              const r3 = n3._dataChannels.find((t4) => t4.id === e3.stream_id);
              r3 && (KC.debug("[".concat(this._clientId, "] data_stream delete with uid ").concat(t3)), this._p2pChannel.unsubscribeDataChannel(n3, [r3]).then((e4) => {
                if (e4)
                  return n3._dataChannels = n3._dataChannels.filter((e5) => e5 !== r3), this._gateway.unsubscribeDataChannel(e4, n3.uid);
              }), KC.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished datachannel ,id:").concat(r3.id)), this.safeEmit(dT.USER_UNPUBLISHED, n3, "datachannel", r3._config));
            });
          }
          _handleRemoveDataChannels(e2) {
            const t2 = this._users.find((t3) => t3.uid === e2.uid);
            if (t2) {
              if (void 0 !== t2._dataChannels && t2._dataChannels.length > 0) {
                KC.debug("[".concat(this._clientId, "] datachannel removed with uid ").concat(e2.uid));
                const i2 = () => {
                  KC.info("[".concat(this._clientId, "] remote user ").concat(t2.uid, " unpublished datachannel")), t2._dataChannels.forEach((e3) => {
                    this.safeEmit(dT.USER_UNPUBLISHED, t2, "datachannel", e3._config);
                  });
                };
                this._p2pChannel.unsubscribeDataChannel(t2, t2._dataChannels).then((e3) => {
                  if (e3)
                    return this._gateway.unsubscribeDataChannel(e3, t2.uid);
                }), i2();
              }
            } else
              KC.warning("[".concat(this._clientId, "] can not find target user!(on_remove_datachannel)"));
          }
          _handleGatewayEvents() {
            this._gateway.on(eI.DISCONNECT_P2P, async () => {
              await this._p2pChannel.disconnectForReconnect();
            }), this._gateway.on(eI.CONNECTION_STATE_CHANGE, (e2, t2, i2) => {
              var n2;
              if (i2 === cT.FALLBACK)
                return;
              const r2 = () => {
                this.safeEmit(dT.CONNECTION_STATE_CHANGE, e2, t2, i2);
              };
              if (rv.reportApiInvoke(this._sessionId || (null === (n2 = this._gateway.joinInfo) || void 0 === n2 ? void 0 : n2.sid) || null, { name: sT.CONNECTION_STATE_CHANGE, options: [e2, t2, i2], tag: oT.TRACER }).onSuccess(JSON.stringify({ cur: e2, prev: t2, reason: i2 })), KC.info("[".concat(this._clientId, "] connection state change: ").concat(t2, " -> ").concat(e2)), "DISCONNECTED" === e2)
                return this._reset(), void r2();
              if ("RECONNECTING" === e2)
                this._users.forEach((e3) => {
                  e3._trust_in_room_ = false, e3._trust_audio_enabled_state_ = false, e3._trust_video_enabled_state_ = false, e3._trust_audio_mute_state_ = false, e3._trust_video_mute_state_ = false, e3._trust_audio_stream_added_state_ = false, e3._trust_video_stream_added_state_ = false, e3._audioSSRC = void 0, e3._videoSSRC = void 0, e3._videoOrtc = void 0, e3._audioOrtc = void 0, e3._cname = void 0, e3._rtxSsrcId = void 0;
                }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
              else if ("CONNECTED" === e2) {
                var s2;
                this._streamFallbackTypeCacheMap.forEach((e3, t3) => {
                  this._gateway.setStreamFallbackOption(t3, e3).catch((e4) => {
                    KC.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e4);
                  });
                }), this._remoteStreamTypeCacheMap.forEach((e3, t3) => {
                  this._gateway.setRemoteVideoStreamType(t3, e3).catch((e4) => {
                    KC.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e4);
                  });
                }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (s2 = this._joinInfo) || void 0 === s2 ? void 0 : s2.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
                  KC.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
                }).catch((e3) => {
                  KC.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e3));
                }), this.store.useP2P || (this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
                  if ("CONNECTED" !== this.connectionState)
                    return;
                  this._userOfflineTimeout = void 0;
                  this._users.filter((e3) => !e3._trust_in_room_).forEach((e3) => {
                    KC.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e3.uid)), this._handleUserOffline({ uid: e3.uid });
                  });
                }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
                  "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e3) => {
                    e3._trust_audio_mute_state_ || (KC.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, hI.AUDIO, false)), e3._trust_video_mute_state_ || (KC.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, hI.VIDEO, false)), e3._trust_audio_enabled_state_ || (KC.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e3.uid)), this._handleSetStreamLocalEnable("audio", e3.uid, true)), e3._trust_video_enabled_state_ || (KC.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e3.uid)), this._handleSetStreamLocalEnable("video", e3.uid, true)), e3._trust_video_stream_added_state_ || (KC.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "video")), e3._trust_audio_stream_added_state_ || (KC.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "audio")), e3._video_added_ || e3._audio_added_ || (KC.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e3.uid)), this._handleRemoveStream({ uid: e3.uid, uint_id: e3._uintid }));
                  }));
                }, 1e3));
              }
              r2();
            }), this._gateway.on(eI.REQUEST_NEW_GATEWAY_LIST, (e2, t2) => {
              if (!this._joinInfo)
                return t2(new xv(xg.UNEXPECTED_ERROR, "can not recover, no join info"));
              dP(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || JT, this.store).then((t3) => {
                this._joinInfo && (this._joinInfo.apResponse = t3.gatewayInfo.res, this._joinInfo.gatewayAddrs = t3.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t3.gatewayInfo.uni_lbs_ip);
                const i2 = [];
                t3.gatewayInfo.gatewayAddrs.forEach((e3) => {
                  let { address: t4 } = e3;
                  const [n2, r2] = t4.split(":");
                  this._joinInfo && this._joinInfo.proxyServer ? i2.push({ proxy: this._joinInfo.proxyServer, host: n2, port: r2 }) : i2.push({ host: n2, port: r2 });
                }), e2(i2);
              }).catch(t2);
            }), this._gateway.on(eI.NETWORK_QUALITY, (e2) => {
              "normal" === this._networkQualitySensitivity && this.safeEmit(dT.NETWORK_QUALITY, e2);
            }), this._gateway.on(eI.STREAM_TYPE_CHANGE, (e2, t2) => {
              this.safeEmit(dT.STREAM_TYPE_CHANGED, e2, t2);
              rv.reportApiInvoke(this._sessionId, { name: sT.STREAM_TYPE_CHANGE, options: [e2, t2], tag: oT.TRACER }).onSuccess(JSON.stringify({ uid: e2, streamType: t2 }));
            }), this._gateway.on(eI.IS_P2P_DISCONNECTED, (e2) => {
              this._p2pChannel.isP2PDisconnected() ? e2(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e2(false) : e2(true);
            }), this._gateway.on(eI.NEED_RENEW_SESSION, () => {
              this._startSession();
            }), this._gateway.on(eI.REQUEST_P2P_CONNECTION_PARAMS, async (e2, t2, i2) => {
              try {
                t2(await this._p2pChannel.startP2PConnection(e2));
              } catch (e3) {
                i2(e3);
              }
            }), this._gateway.on(eI.JOIN_RESPONSE, (e2, t2) => {
              if (this.store.useP2P)
                return;
              const { dtlsParameters: i2, iceParameters: n2, candidates: r2, rtpCapabilities: s2, setup: o2, cname: a2 } = QP(e2.ortc, t2);
              this._p2pChannel.connect(n2, i2, r2, s2, o2, a2);
            }), this._gateway.on(eI.REQUEST_DC_CONNECTION_PARAMS, (e2) => {
              e2(this._p2pChannel.getEstablishParams());
            }), this._gateway.on(eI.RESET_SIGNAL, (e2) => {
              this._p2pChannel.resetConnection(e2), this._handleGatewaySignalEvents();
            }), this._gateway.on(eI.DATACHANNEL_FAILBACK, () => {
              this._joinGateway();
            }), this._gateway.on(eI.DATACHANNEL_PRECONNECT, async (e2, t2, i2, n2) => {
              var r2, s2, o2, a2, c2, d2;
              await this._p2pChannel.startP2PConnection({ turnServer: null === (r2 = this._joinInfo) || void 0 === r2 ? void 0 : r2.turnServer }, true);
              const l2 = function(e3, t3) {
                let i3;
                return t3 && t3.ip && "number" == typeof t3.port ? (i3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip, port: t3.port.toString(), type: "host", extension: {} }], KC.debug("Using remote candidate from AP ".concat(t3.ip, ":").concat(t3.port)), t3.ip6 && (i3.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip6, port: t3.port.toString(), type: "host", extension: {} }), KC.debug("Using IPV6 remote candidate from AP ".concat(t3.ip6, ":").concat(t3.port)))) : i3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e3.ip, port: e3.port.toString(), type: "host", extension: {} }], i3;
              }(e2, t2);
              return this._p2pChannel.preConnect({ iceUfrag: "".concat(null === (s2 = this._joinInfo) || void 0 === s2 ? void 0 : s2.apResponse.cid, "_").concat(null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.apResponse.cert), icePwd: "".concat(null === (a2 = this._joinInfo) || void 0 === a2 ? void 0 : a2.apResponse.cid, "_").concat(null === (c2 = this._joinInfo) || void 0 === c2 ? void 0 : c2.apResponse.cert) }, { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (d2 = kC("FINGERPRINT")) && void 0 !== d2 ? d2 : e2.fingerprint }] }, l2, { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, "active", "o/i14u9pJrxRKAsu").then(i2).catch(n2);
            });
          }
          _handleGatewaySignalEvents() {
            this._gateway.signal.on(Rv.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(Rv.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(Rv.ON_ADD_AUDIO_STREAM, (e2) => this._handleAddAudioOrVideoStream("audio", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc)), this._gateway.signal.on(Rv.ON_ADD_VIDEO_STREAM, (e2) => this._handleAddAudioOrVideoStream("video", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc, e2.rtxSsrcId)), this._gateway.signal.on(Rv.ON_REMOTE_DATASTREAM_UPDATE, (e2) => {
              this._handleUpdateDataChannel(e2);
            }), this._gateway.signal.on(Rv.ON_REMOTE_FULL_DATASTREAM_INFO, (e2) => {
              this._handleUpdateDataChannel({ added: e2.datastreams, deleted: [] }, true);
            }), this._gateway.signal.on(Rv.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(Rv.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(Rv.MUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, hI.AUDIO, true)), this._gateway.signal.on(Rv.UNMUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, hI.AUDIO, false)), this._gateway.signal.on(Rv.MUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, hI.VIDEO, true)), this._gateway.signal.on(Rv.UNMUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, hI.VIDEO, false)), this._gateway.signal.on(Rv.RECEIVE_METADATA, (e2) => {
              const t2 = DT(e2.metadata);
              this.safeEmit(dT.RECEIVE_METADATA, e2.uid, t2);
            }), this._gateway.signal.on(Rv.ON_DATA_STREAM, async (e2) => {
              if (!e2)
                return;
              let t2 = 0;
              if (e2.ordered || e2.syncWithAudio) {
                const i2 = this._p2pChannel.getStats(), n2 = this.remoteUsers.find((t3) => t3.uid === e2.uid), r2 = null == i2 ? void 0 : i2.audioRecv.find((e3) => e3.ssrc === (null == n2 ? void 0 : n2._audioSSRC));
                t2 = null == r2 ? void 0 : r2.jitterBufferMs;
              }
              null == t2 && (t2 = 0), GM(e2, t2, { id: this._clientId, onStreamMessage: "function" == typeof this.onStreamMessage ? this.onStreamMessage.bind(this) : void 0, safeEmit: this.safeEmit.bind(this) });
            }), this._gateway.signal.on(Rv.ON_CRYPT_ERROR, () => {
              NT(() => {
                KC.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(dT.CRYPT_ERROR);
              }, this._sessionId);
            }), this._gateway.signal.on(Rv.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(Rv.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
              KC.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true, cT.TOKEN_EXPIRE), this.safeEmit(dT.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
            }), this._gateway.signal.on(Rv.ON_STREAM_FALLBACK_UPDATE, (e2) => {
              KC.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e2.stream_id, ", attr: ").concat(e2.stream_type)), this.safeEmit(dT.STREAM_FALLBACK, e2.stream_id, 1 === e2.stream_type ? "fallback" : "recover");
            }), this._gateway.signal.on(Rv.ON_PUBLISH_STREAM, (e2) => {
              this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e2.proxy })), KC.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e2))));
            }), this._gateway.signal.on(Rv.ENABLE_LOCAL_VIDEO, (e2) => {
              this._handleSetStreamLocalEnable("video", e2.uid, true);
            }), this._gateway.signal.on(Rv.DISABLE_LOCAL_VIDEO, (e2) => {
              this._handleSetStreamLocalEnable("video", e2.uid, false);
            }), this._gateway.signal.on(gv.REQUEST_TIMEOUT, (e2, t2) => {
              if (this._joinInfo)
                switch (e2) {
                  case Tv.PUBLISH: {
                    if (!t2)
                      return;
                    const e3 = t2.ortc;
                    if (e3) {
                      var i2, n2;
                      const r2 = e3.some((e4) => {
                        let { stream_type: t3 } = e4;
                        return t3 === $v.Audio;
                      }), s2 = e3.some((e4) => {
                        let { stream_type: t3 } = e4;
                        return t3 !== $v.Audio;
                      }), o2 = e3.some((e4) => {
                        let { stream_type: t3 } = e4;
                        return t3 === $v.Screen || t3 === $v.ScreenLow;
                      });
                      "offer" === t2.state && rv.publish(this._joinInfo.sid, { eventElapse: cD.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: xg.TIMEOUT, audio: r2, video: s2, p2pid: t2.p2p_id, publishRequestid: this.store.pubId, screenshare: o2, audioName: r2 ? null === (i2 = e3.find((e4) => {
                        let { stream_type: t3 } = e4;
                        return t3 === $v.Audio;
                      })) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId.toString() : void 0, videoName: s2 ? null === (n2 = e3.find((e4) => {
                        let { stream_type: t3 } = e4;
                        return t3 !== $v.Audio;
                      })) || void 0 === n2 || null === (n2 = n2.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId.toString() : void 0 });
                    }
                    break;
                  }
                  case Tv.SUBSCRIBE:
                    t2 && rv.subscribe(this._joinInfo.sid, { succ: false, ec: xg.TIMEOUT, audio: t2.stream_type === hI.AUDIO, video: t2.stream_type === hI.VIDEO, peerid: t2.stream_id, subscribeRequestid: t2.ssrcId, p2pid: this.store.p2pId, eventElapse: cD.measureFromSubscribeStart(this.store.clientId, t2.ssrcId) });
                }
            }), this._gateway.signal.on(Rv.ON_P2P_OK, (e2) => {
              this.uid, this._uid;
            }), this._gateway.signal.on(Rv.ON_PUBLISHED_USER_LIST, (e2) => {
              if (null == e2 || !e2.users)
                return;
              kC("BLOCK_LOCAL_CLIENT") && (e2.users = e2.users.filter((e3) => !dv(e3.string_id || e3.stream_id, this.channelName)));
              const t2 = [], i2 = [];
              for (const n2 of e2.users) {
                let e3 = this._users.find((e4) => e4._uintid === n2.stream_id);
                e3 ? e3._trust_in_room_ = true : (e3 = new NP(n2.string_id || n2.stream_id, n2.stream_id), this._users.push(e3), 0 === this.getListeners(dT.PUBLISHED_USER_LIST).length && (KC.debug("[".concat(this._clientId, "] user online"), n2.stream_id), this.safeEmit(dT.USER_JOINED, e3)));
                const r2 = iI.Audio & n2.stream_type, s2 = (iI.Video | iI.LwoVideo) & n2.stream_type, o2 = 0 != (65280 & n2.stream_type), a2 = r2 && e3.hasAudio, c2 = s2 && e3.hasVideo;
                s2 && (e3._trust_video_stream_added_state_ = true, e3._video_added_ = true, e3._videoSSRC = n2.video_ssrc, e3._rtxSsrcId = n2.video_rtx), r2 && (e3._trust_audio_stream_added_state_ = true, e3._audio_added_ = true, e3._audioSSRC = n2.audio_ssrc), r2 && !a2 && 0 === this.getListeners(dT.PUBLISHED_USER_LIST).length && (KC.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published audio")), this.safeEmit(dT.USER_PUBLISHED, e3, "audio")), s2 && !c2 && 0 === this.getListeners(dT.PUBLISHED_USER_LIST).length && (KC.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published video")), this.safeEmit(dT.USER_PUBLISHED, e3, "video")), (r2 && !a2 || s2 && !c2 || o2) && t2.push(e3), s2 && this._p2pChannel.hasPendingRemoteMedia(e3, "video") && i2.push({ user: e3, mediaType: "video" }), r2 && this._p2pChannel.hasPendingRemoteMedia(e3, "audio") && i2.push({ user: e3, mediaType: "audio" });
              }
              i2.length > 0 && (KC.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i2.map((e3) => "user: ".concat(e3.user.uid, ", mediaType: ").concat(e3.mediaType)).join("; "), " ")), this.massSubscribe(i2).catch((e3) => {
                KC.error("[".concat(this._clientId, "] mass resubscribe error"), e3.toString());
              })), this.getListeners(dT.PUBLISHED_USER_LIST).length > 0 ? kC("ENABLE_DATASTREAM_2") ? this._pendingPublishedUsers = t2 : (KC.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t2.map((e3) => e3.uid).join(", "))), this.safeEmit(dT.PUBLISHED_USER_LIST, t2)) : KC.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t2.map((e3) => e3.uid).join(", ")));
            }), this._gateway.signal.on(Rv.ON_RTP_CAPABILITY_CHANGE, (e2) => {
              const { video_codec: t2 } = e2;
              this._p2pChannel instanceof _k && this._p2pChannel.updateRemoteRTPCapabilities(t2.map((e3) => e3.toLowerCase()).filter((e3) => {
                var t3;
                return Pr(t3 = Object.keys(UC)).call(t3, e3);
              }));
            });
          }
          _handleP2PEvents() {
            this._gateway.signal.on(Rv.ON_USER_OFFLINE, () => {
              this._p2pChannel.disconnectForReconnect();
            }), this._gateway.signal.on(wI.PUBLISH, async (e2, t2) => {
              e2.forEach((e3) => e3.kind === hI.VIDEO ? (this._handleP2PAddAudioOrVideoStream("video", t2), e3.isMuted ? this._handleMuteStream(t2, hI.VIDEO, true) : this._handleMuteStream(t2, hI.VIDEO, false)) : (this._handleP2PAddAudioOrVideoStream("audio", t2), e3.isMuted ? this._handleMuteStream(t2, hI.AUDIO, true) : this._handleMuteStream(t2, hI.AUDIO, false)));
            }), this._gateway.signal.on(gv.P2P_START, async (e2, t2) => {
              if (this._p2pChannel instanceof PM) {
                var i2;
                t2(await this._p2pChannel.startP2P({ turnServer: null === (i2 = this._joinInfo) || void 0 === i2 ? void 0 : i2.turnServer }, e2));
              }
            }), this._gateway.signal.on(gv.P2P_CONNECTION, async (e2) => {
              this._p2pChannel instanceof PM && await this._p2pChannel.p2pConnect(e2);
            }), this._gateway.signal.on(gv.P2P_REMOTE_CANDIDATE_UPDATE, (e2) => {
              this._p2pChannel instanceof PM && this._p2pChannel.addRemoteCandidate(JSON.parse(e2));
            }), this._gateway.signal.on(wI.SUBSCRIBE, async (e2, t2, i2) => {
              if (this._p2pChannel instanceof PM) {
                const { trackType: n2 } = JSON.parse(e2);
                try {
                  await this._p2pChannel.dopublish(n2), t2();
                } catch (e3) {
                  i2(e3);
                }
              }
            }), this._gateway.signal.on(wI.UNSUBSCRIBE, async (e2, t2, i2) => {
              if (this._p2pChannel instanceof PM) {
                const { mediaType: n2 } = JSON.parse(e2);
                try {
                  await this._p2pChannel.doUnpublish(n2), t2();
                } catch (e3) {
                  i2(e3);
                }
              }
            }), this._gateway.signal.on(wI.EXCHANGE_SDP, async (e2, t2, i2) => {
              if (this._p2pChannel instanceof PM) {
                const { type: n2, sdp: r2 } = JSON.parse(e2);
                try {
                  t2(await this._p2pChannel.setDescription(n2, r2));
                } catch (e3) {
                  i2(e3);
                }
              }
            }), this._gateway.signal.on(wI.UNPUBLISH, async (e2, t2, i2) => {
              if (this._p2pChannel instanceof PM) {
                const { unpubMsg: n2, uid: r2 } = e2;
                if (1 === n2.length) {
                  const s2 = n2[0].stream_type === $v.Audio ? hI.AUDIO : hI.VIDEO;
                  this._handleMuteStream(r2, s2, true);
                  const { sdp: o2 } = e2;
                  if (this._p2pChannel instanceof PM && o2) {
                    const e3 = this._users.find((e4) => e4.uid === r2);
                    if (!e3)
                      return KC.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(r2)), void t2();
                    this._p2pChannel.unsubscribe(e3, o2, s2).then((e4) => {
                      e4 && t2(e4);
                    }).catch(i2);
                  } else
                    t2();
                } else
                  this._handleRemoveStream(e2, t2, i2);
              }
            }), this._gateway.signal.on(wI.CONTROL, async (e2, t2, i2) => {
              const { action: n2, sdp: r2, isMuteAll: s2, uid: o2 } = e2;
              switch (n2) {
                case OI.MUTE_LOCAL_VIDEO:
                  this._handleMuteStream(o2, hI.VIDEO, true, r2, t2, i2);
                  break;
                case OI.MUTE_LOCAL_AUDIO:
                  t2(), this._handleMuteStream(o2, hI.AUDIO, true);
                  break;
                case OI.UNMUTE_LOCAL_VIDEO:
                  t2(), this._handleP2PAddAudioOrVideoStream("video", o2), this._handleMuteStream(o2, hI.VIDEO, false);
                  break;
                case OI.UNMUTE_LOCAL_AUDIO:
                  t2(), this._handleP2PAddAudioOrVideoStream("audio", o2), this._handleMuteStream(o2, hI.AUDIO, false);
              }
              s2 && this._handleRemoveStream(e2, t2, i2);
            }), this._gateway.signal.on(wI.DO_SUBSCRIBE, async (e2, t2, i2) => {
              if (this._p2pChannel instanceof PM) {
                const { kind: n2, sdp: r2, ssrcId: s2, uid: o2 } = e2, a2 = this._users.find((e3) => e3.uid === o2);
                if (!a2)
                  return KC.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)")), void t2();
                try {
                  t2(await this._p2pChannel.subscribe(a2, n2, r2, s2));
                } catch (e3) {
                  i2(e3);
                }
              }
            }), this._gateway.signal.on(wI.DO_UNSUBSCRIBE, async (e2, t2, i2) => {
              if (this._p2pChannel instanceof PM) {
                const { uid: n2, kind: r2, sdp: s2 } = e2, o2 = this._users.find((e3) => e3.uid === n2);
                if (!o2)
                  return KC.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)")), void t2();
                try {
                  t2(await this._p2pChannel.unsubscribe(o2, s2, r2));
                } catch (e3) {
                  i2(e3);
                }
              }
            }), this._gateway.signal.on(wI.RESTART_ICE, async (e2, t2, i2) => {
              if (this._p2pChannel instanceof PM)
                try {
                  t2(await this._p2pChannel.setDescription("remote", e2));
                } catch (e3) {
                  i2(e3);
                }
            }), this._p2pChannel.on(mI.RequestP2PRestartICE, async (e2, t2, i2) => {
              try {
                t2(await this._gateway.sendExtensionMessage(wI.RESTART_ICE, e2));
              } catch (e3) {
                i2(e3);
              }
            }), this._p2pChannel.on(mI.LocalCandidate, (e2) => {
              this._gateway.sendExtensionMessage(wI.CANDIDATE, JSON.stringify(e2));
            }), this._p2pChannel.on(mI.RequestP2PMuteLocal, async (e2, t2, i2) => {
              try {
                t2(await this._gateway.sendExtensionMessage(wI.CONTROL, e2));
              } catch (e3) {
                i2(e3);
              }
            }), this._p2pChannel.on(mI.RequestP2PPublish, async (e2, t2, i2) => {
              try {
                t2(await this._gateway.sendExtensionMessage(wI.DO_SUBSCRIBE, e2));
              } catch (e3) {
                i2(e3);
              }
            }), this._p2pChannel.on(mI.RequestP2PUnPublish, async (e2, t2, i2) => {
              try {
                t2(await this._gateway.sendExtensionMessage(wI.DO_UNSUBSCRIBE, e2));
              } catch (e3) {
                i2(e3);
              }
            }), this._p2pChannel.on(mI.RequestP2PUnmuteRemote, async (e2, t2, i2) => {
              if (this._joinInfo)
                try {
                  await this._gateway.unmuteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
                } catch (e3) {
                  e3.code === xg.DISCONNECT_P2P ? t2() : i2(e3);
                }
              else
                t2();
            }), this._p2pChannel.on(mI.RequestP2PMuteRemote, async (e2, t2, i2) => {
              if (this._joinInfo)
                try {
                  await this._gateway.muteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
                } catch (e3) {
                  e3.code === xg.DISCONNECT_P2P ? t2() : i2(e3);
                }
              else
                t2();
            }), this._p2pChannel.on(mI.StateChange, (e2, t2) => {
              t2 === EI.Connected && this._p2pChannel.republish();
            });
          }
          _handleP2PChannelEvents() {
            this._p2pChannel.on(mI.RequestMuteLocal, async (e2, t2, i2) => {
              if (this._joinInfo)
                try {
                  await this._gateway.muteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
                } catch (e3) {
                  e3.code === xg.DISCONNECT_P2P ? t2() : i2(e3);
                }
              else
                t2();
            }), this._p2pChannel.on(mI.RequestUnmuteLocal, async (e2, t2, i2) => {
              if (this._joinInfo)
                try {
                  await this._gateway.unmuteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
                } catch (e3) {
                  e3.code === xg.DISCONNECT_P2P ? t2() : i2(e3);
                }
              else
                t2();
            }), this._p2pChannel.on(mI.RequestRePublish, (e2, t2, i2) => {
              this.publish(e2, false).then(t2).catch(i2);
            }), this._p2pChannel.on(mI.RequestRePublishDataChannel, (e2, t2, i2) => {
              tg.all(e2.map(async (e3) => {
                await this._p2pChannel.publishDataChannel([e3]);
                const t3 = { streamId: e3.id, ordered: e3.ordered, maxRetransmits: e3.maxRetransmits, metadata: e3.metadata, channelId: e3._originDataChannelId };
                try {
                  await this._gateway.publishDataChannel(this._uid, t3, true);
                } catch (e4) {
                  if (e4.code !== xg.DISCONNECT_P2P)
                    throw e4;
                }
              })).then(t2).catch(i2);
            }), this._p2pChannel.on(mI.RequestReSubscribe, async (e2, t2, i2) => {
              try {
                for (const { user: t3, kind: i3 } of e2)
                  i3 === hI.VIDEO ? await this.subscribe(t3, "video") : await this.subscribe(t3, "audio");
                t2();
              } catch (e3) {
                i2(e3);
              }
            }), this._p2pChannel.on(mI.RequestUploadStats, (e2, t2) => {
              this._gateway.uploadStats(e2, t2);
            }), this._p2pChannel.on(mI.MediaReconnectStart, (e2) => {
              this.safeEmit(dT.MEDIA_RECONNECT_START, e2);
            }), this._p2pChannel.on(mI.MediaReconnectEnd, (e2) => {
              this.safeEmit(dT.MEDIA_RECONNECT_END, e2);
            }), this._p2pChannel.on(mI.NeedSignalRTT, (e2) => {
              e2(this._gateway.getSignalRTT());
            }), this._p2pChannel.on(mI.RequestRestartICE, async (e2) => {
              if (this._p2pChannel instanceof PM)
                return;
              const t2 = await this._p2pChannel.restartICE(e2), i2 = await t2.next();
              if (i2.done)
                return;
              const n2 = i2.value;
              let r2;
              try {
                r2 = await this._gateway.restartICE({ iceParameters: n2 });
              } catch (e3) {
                return void t2.throw(e3);
              }
              const { iceParameters: s2 } = function(e3) {
                const t3 = e3.iceParameters;
                return { iceParameters: { iceUfrag: t3.iceUfrag, icePwd: t3.icePwd } };
              }(r2);
              await t2.next({ remoteIceParameters: s2 });
            }), this._p2pChannel.on(mI.RequestReconnect, async () => {
              this._gateway.reconnect();
            }), this._p2pChannel.on(mI.RequestReconnectPC, async () => {
              var e2;
              const { iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e2 = this._joinInfo) || void 0 === e2 ? void 0 : e2.turnServer }), { gatewayEstablishParams: r2, gatewayAddress: s2 } = await this._gateway.reconnectPC({ iceParameters: t2, dtlsParameters: i2, rtpCapabilities: n2 }), { dtlsParameters: o2, iceParameters: a2, candidates: c2, rtpCapabilities: d2, setup: l2, cname: h2 } = QP(r2, s2);
              await this._p2pChannel.connect(a2, o2, c2, d2, l2, h2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
            }), this._p2pChannel.on(mI.RequestUnpublishForReconnectPC, async (e2, t2, i2) => {
              this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e2, this._uid), t2()) : i2();
            }), this._p2pChannel.on(mI.P2PLost, () => {
              this.safeEmit(dT.P2P_LOST, this.store.uid);
            }), this._p2pChannel.on(mI.UpdateVideoEncoder, (e2) => {
              e2._encoderConfig && this._gateway.setVideoProfile(e2._encoderConfig);
            }), this._p2pChannel.on(mI.ConnectionTypeChange, (e2) => {
              this.safeEmit(dT.IS_USING_CLOUD_PROXY, e2);
            }), this._p2pChannel.on(mI.RequestLowStreamParameter, (e2) => {
              e2(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
            }), this._p2pChannel.on(mI.QueryClientConnectionState, (e2) => {
              e2(this.connectionState);
            });
          }
          getKeyMetrics() {
            return this.store.keyMetrics;
          }
          async enableContentInspect(e2) {
            if ("CONNECTED" !== this.connectionState || !this._joinInfo)
              throw new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, "] Client did not join channel"));
            if (this._inspect)
              throw new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
            if (!e2)
              throw new xv(xg.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig is necessary"));
            if (!e2.inspectType || !Array.isArray(e2.inspectType))
              throw new xv(xg.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.inspectType is necessary and is an instance of Array."));
            {
              const t2 = [...new Set(e2.inspectType)];
              t2.forEach((e3) => {
                var t3;
                if (!Pr(t3 = ["supervise", "moderation"]).call(t3, e3))
                  throw new xv(xg.INVALID_PARAMS, "[".concat(this._clientId, "] ").concat(e3, " is not a valid inspect type."));
              }), e2.inspectType = t2;
            }
            if (e2 && e2.extraInfo && e2.extraInfo.length > 1024)
              throw new xv(xg.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.extraInfo length cannot exceed 1024 bytes"));
            try {
              const t2 = new Kk(e2);
              this._inspect = t2, this.handleVideoInspectEvents(this._inspect), await t2.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, JT);
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          }
          async disableContentInspect() {
            if (!this._inspect)
              throw new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
            try {
              this._inspect.close(), this._inspect = void 0;
            } catch (e2) {
              throw Array.isArray(e2) ? e2[0] : e2;
            }
          }
          async setImageModeration(e2, t2) {
            if (Fg(e2, "enabled"), e2) {
              if (!t2)
                throw new xv(xg.INVALID_PARAMS, "[".concat(this._clientId, "] config is necessary"));
              if (jg(t2.interval, "interval", 1e3, 1 / 0), "CONNECTED" !== this.connectionState || !this._joinInfo)
                throw new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, '] can not enable image moderation, not joined"'));
              try {
                if (this._moderation)
                  return void this._moderation.updateConfig(t2);
                const e3 = new IM(t2);
                this._moderation = e3, this.handleImageModerationEvents(this._moderation), await e3.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, JT);
              } catch (e3) {
                throw Array.isArray(e3) ? e3[0] : e3;
              }
            } else {
              if (!this._moderation)
                throw new xv(xg.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
              try {
                this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
              } catch (e3) {
                throw Array.isArray(e3) ? e3[0] : e3;
              }
            }
          }
          handleImageModerationEvents(e2) {
            e2.on(AI.CONNECTION_STATE_CHANGE, (t2, i2) => {
              if (this.safeEmit(dT.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t2, i2), t2 === yI.CONNECTED) {
                if ("CONNECTED" !== this.connectionState)
                  throw this.setImageModeration(false), new xv(xg.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
                e2.inspectImage();
              }
            }), e2.on(AI.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
              e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
            });
          }
          handleVideoInspectEvents(e2) {
            e2.on(SI.CONNECTION_STATE_CHANGE, (t2, i2) => {
              if (this.safeEmit(dT.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t2, i2), i2 === gI.CONNECTED) {
                if ("CONNECTED" !== this.connectionState)
                  return void this.safeEmit(dT.CONTENT_INSPECT_ERROR, new xv(xg.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
                e2.inspectImage();
              }
            }), e2.on(SI.INSPECT_RESULT, (e3, t2) => {
              var i2;
              if ((null == t2 ? void 0 : t2.code) === xg.INVALID_OPERATION && "DISCONNECTED" === this.connectionState)
                return KC.debug("Stop inspect content because that has left channel"), null == this || null === (i2 = this._inspect) || void 0 === i2 || i2.close(), void (this._inspect = void 0);
              this.safeEmit(dT.CONTENT_INSPECT_RESULT, e3, t2);
            }), e2.on(SI.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
              e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
            });
          }
          getJoinChannelServiceRecords() {
            return KC.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
          }
          async setPublishAudioFilterEnabled(e2) {
            Fg(e2, "enabled"), LC("ENABLE_PUBLISH_AUDIO_FILTER", e2), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e2);
          }
          _handleResetAddStream(e2, t2) {
            switch (t2) {
              case "audio":
                e2._audio_added_ = false, e2._trust_audio_stream_added_state_ = true;
                break;
              case "video":
                e2._video_added_ = false, e2._trust_video_stream_added_state_ = true;
            }
          }
        }
        Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], qM.prototype, "leave", null), Mv([nv({ argsMap: (e2, t2) => {
          if (!Array.isArray(t2)) {
            if (!(t2 instanceof iA))
              return [t2];
            t2 = [t2];
          }
          return t2.map((e3) => e3 ? Object(e3).toString() : "null");
        } }), Uv("design:type", Function), Uv("design:paramtypes", [Object, Boolean]), Uv("design:returntype", tg)], qM.prototype, "publish", null), Mv([nv({ argsMap: (e2, t2) => (t2 || (t2 = []), t2 instanceof sD ? [t2.getChannelId()] : (Array.isArray(t2) || (t2 = [t2]), t2.map((e3) => e3.getTrackId()))) }), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], qM.prototype, "unpublish", null), Mv([nv({ argsMap: (e2, t2, i2, n2) => [t2.uid, i2, n2] }), Uv("design:type", Function), Uv("design:paramtypes", [NP, String, Number]), Uv("design:returntype", tg)], qM.prototype, "subscribe", null), Mv([nv({ argsMap: (e2, t2) => t2.map((e3) => {
          let { user: t3, mediaType: i2 } = e3;
          return [null == t3 ? void 0 : t3.uid, i2];
        }) }), Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], qM.prototype, "massSubscribe", null), Mv([nv({ argsMap: (e2, t2, i2, n2) => [t2.uid, i2, n2] }), Uv("design:type", Function), Uv("design:paramtypes", [NP, String, Number]), Uv("design:returntype", tg)], qM.prototype, "unsubscribe", null), Mv([nv({ argsMap: (e2, t2) => t2.map((e3) => {
          let { user: t3, mediaType: i2 } = e3;
          return { uid: null == t3 ? void 0 : t3.uid, mediaType: i2 };
        }) }), Uv("design:type", Function), Uv("design:paramtypes", [Array]), Uv("design:returntype", tg)], qM.prototype, "massUnsubscribe", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], qM.prototype, "setLowStreamParameter", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], qM.prototype, "enableDualStream", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], qM.prototype, "disableDualStream", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [String, Object]), Uv("design:returntype", tg)], qM.prototype, "setClientRole", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [String, Boolean]), Uv("design:returntype", void 0)], qM.prototype, "setProxyServer", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Object, Boolean]), Uv("design:returntype", void 0)], qM.prototype, "setTurnServer", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", void 0)], qM.prototype, "setLicense", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Number]), Uv("design:returntype", void 0)], qM.prototype, "startProxyServer", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], qM.prototype, "stopProxyServer", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", void 0)], qM.prototype, "setLocalAccessPointsV2", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Array, String]), Uv("design:returntype", void 0)], qM.prototype, "setLocalAccessPoints", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Number]), Uv("design:returntype", tg)], qM.prototype, "setRemoteDefaultVideoStreamType", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Object, Number]), Uv("design:returntype", tg)], qM.prototype, "setRemoteVideoStreamType", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Object, Number]), Uv("design:returntype", tg)], qM.prototype, "setStreamFallbackOption", null), Mv([nv({ argsMap: (e2, t2) => [t2] }), Uv("design:type", Function), Uv("design:paramtypes", [String, String, Uint8Array]), Uv("design:returntype", void 0)], qM.prototype, "setEncryptionConfig", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], qM.prototype, "renewToken", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", void 0)], qM.prototype, "enableAudioVolumeIndicator", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [String, Boolean]), Uv("design:returntype", tg)], qM.prototype, "startLiveStreaming", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], qM.prototype, "setLiveTranscoding", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [String]), Uv("design:returntype", tg)], qM.prototype, "stopLiveStreaming", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [String, Object]), Uv("design:returntype", tg)], qM.prototype, "addInjectStreamUrl", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], qM.prototype, "removeInjectStreamUrl", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [AP]), Uv("design:returntype", tg)], qM.prototype, "startChannelMediaRelay", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [AP]), Uv("design:returntype", tg)], qM.prototype, "updateChannelMediaRelay", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], qM.prototype, "stopChannelMediaRelay", null), Mv([nv({ argsMap: (e2, t2) => (Array.isArray(t2) || (t2 = [t2]), [JSON.stringify(t2)]) }), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], qM.prototype, "sendCustomReportMessage", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Object, Object]), Uv("design:returntype", tg)], qM.prototype, "pickSVCLayer", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Number]), Uv("design:returntype", tg)], qM.prototype, "setRTM2Flag", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Object]), Uv("design:returntype", tg)], qM.prototype, "enableContentInspect", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", tg)], qM.prototype, "disableContentInspect", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean, Object]), Uv("design:returntype", tg)], qM.prototype, "setImageModeration", null), Mv([nv({ reportResult: true }), Uv("design:type", Function), Uv("design:paramtypes", []), Uv("design:returntype", Array)], qM.prototype, "getJoinChannelServiceRecords", null), Mv([nv(), Uv("design:type", Function), Uv("design:paramtypes", [Boolean]), Uv("design:returntype", tg)], qM.prototype, "setPublishAudioFilterEnabled", null);
        class JM {
          constructor(e2, t2) {
            nu(this, "id", 0), nu(this, "element", void 0), nu(this, "peerPair", void 0), nu(this, "context", void 0), nu(this, "audioPlayerElement", void 0), nu(this, "audioTrack", void 0), JM.count += 1, this.id = JM.count, this.element = e2, this.context = t2;
          }
          initPeers() {
            this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e2) => {
              const t2 = document.createElement("audio");
              t2.srcObject = new MediaStream([e2.track]), t2.play(), this.audioPlayerElement = t2;
            };
          }
          async switchSdp() {
            if (!this.peerPair)
              return;
            const e2 = async (e3, t3) => {
              const i2 = "offer" === t3 ? await e3.createOffer() : await e3.createAnswer();
              return await e3.setLocalDescription(i2), "complete" === e3.iceGatheringState ? e3.localDescription : new tg((t4) => {
                e3.onicegatheringstatechange = () => {
                  "complete" === e3.iceGatheringState && t4(e3.localDescription);
                };
              });
            }, t2 = async (e3, t3) => await e3.setRemoteDescription(t3);
            try {
              const i2 = await e2(this.peerPair[0], "offer");
              await t2(this.peerPair[1], i2);
              const n2 = await e2(this.peerPair[1], "answer");
              await t2(this.peerPair[0], n2);
            } catch (e3) {
              throw new xv(xg.LOCAL_AEC_ERROR, e3.toString()).print();
            }
          }
          async getTracksFromMediaElement(e2) {
            if (this.audioTrack)
              return this.audioTrack;
            let t2;
            try {
              e2 instanceof HTMLVideoElement && (e2.captureStream ? e2.captureStream() : e2.mozCaptureStream()), t2 = this.context.createMediaStreamDestination();
              this.context.createMediaElementSource(e2).connect(t2);
            } catch (e3) {
              throw new xv(xg.LOCAL_AEC_ERROR, e3.toString()).print();
            }
            if (!t2) {
              throw new xv(xg.LOCAL_AEC_ERROR, "no dest node when local aec").print();
            }
            const i2 = t2.stream.getAudioTracks()[0];
            return this.audioTrack = i2, i2;
          }
          getElement() {
            return this.element;
          }
          async startEchoCancellation() {
            this.context.resume(), this.peerPair && this.close(), this.initPeers();
            const e2 = this.element, t2 = await this.getTracksFromMediaElement(e2);
            this.peerPair && this.peerPair[0].addTrack(t2), await this.switchSdp();
          }
          close() {
            KC.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e2) => {
              e2.close();
            }), this.peerPair = void 0, this.audioPlayerElement = void 0;
          }
        }
        nu(JM, "count", 0);
        const zM = window.AudioContext || window.webkitAudioContext;
        class XM {
          constructor() {
            nu(this, "units", []), nu(this, "context", void 0);
          }
          processExternalMediaAEC(e2) {
            if (!this._doesEnvironmentNeedAEC())
              return KC.debug("the system does not need to process local aec"), -1;
            this.context || (this.context = new zM());
            let t2 = this.units.find((t3) => t3 && t3.getElement() === e2);
            return t2 || (t2 = new JM(e2, this.context), this.units.push(t2)), t2.startEchoCancellation(), KC.debug("start processing local audio echo cancellation, id is", t2.id), t2.id;
          }
          _doesEnvironmentNeedAEC() {
            return pg().name !== cg.SAFARI;
          }
        }
        Mv([nv({ report: rv }), Uv("design:type", Function), Uv("design:paramtypes", [HTMLAudioElement]), Uv("design:returntype", Number)], XM.prototype, "processExternalMediaAEC", null);
        const QM = new XM();
        function ZM(e2, t2) {
          var i2 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(e2);
            t2 && (n2 = n2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
            })), i2.push.apply(i2, n2);
          }
          return i2;
        }
        function $M(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var i2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? ZM(Object(i2), true).forEach(function(t3) {
              nu(e2, t3, i2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ZM(Object(i2)).forEach(function(t3) {
              Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
            });
          }
          return e2;
        }
        const eU = window || document;
        function tU(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (!eU)
            return;
          const i2 = iU._cspEventHandlerPointer;
          if (i2 && t2)
            return void console.error(i2, t2);
          const n2 = (e3) => {
            if (!(e3 && e3.blockedURI && (iU.onSecurityPolicyViolation || iU.getListeners(vI.SECURITY_POLICY_VIOLATION).length > 0)))
              return;
            const t3 = e3.blockedURI;
            kC("CSP_DETECTED_HOSTNAME_LIST").some((e4) => Pr(t3).call(t3, e4)) && (iU.onSecurityPolicyViolation && "function" == typeof iU.onSecurityPolicyViolation && iU.onSecurityPolicyViolation(e3), iU.getListeners(vI.SECURITY_POLICY_VIOLATION).length > 0 && iU.safeEmit(vI.SECURITY_POLICY_VIOLATION, e3));
          };
          i2 && eU.removeEventListener("securitypolicyviolation", i2), (t2 || e2 && "function" == typeof e2 || iU.getListeners(vI.SECURITY_POLICY_VIOLATION).length > 0) && eU.addEventListener("securitypolicyviolation", n2), iU._cspEventHandlerPointer = n2;
        }
        LC("PROCESS_ID", "process-".concat(xT(8, ""), "-").concat(xT(4, ""), "-").concat(xT(4, ""), "-").concat(xT(4, ""), "-").concat(xT(12, ""))), function() {
          const e2 = pg();
          pA.getDisplayMedia = function(e3) {
            if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia)
              return true;
            return false;
          }(), pA.getStreamFromExtension = e2.name === cg.CHROME && Number(e2.version) > 34, pA.supportUnifiedPlan = function() {
            if (!window.RTCRtpTransceiver)
              return false;
            if (!("currentDirection" in RTCRtpTransceiver.prototype))
              return false;
            const e3 = new RTCPeerConnection();
            let t2 = false;
            try {
              e3.addTransceiver("audio"), t2 = true;
            } catch (e4) {
            }
            return e3.close(), t2;
          }(), pA.supportMinBitrate = e2.name === cg.CHROME || e2.name === cg.EDGE, pA.supportSetRtpSenderParameters = function() {
            const e3 = pg();
            if (!window.RTCRtpSender || !window.RTCRtpSender.prototype.setParameters || !window.RTCRtpSender.prototype.getParameters)
              return false;
            return !!kg() || (!(!Sg() && !mg()) || e3.name === cg.FIREFOX && Number(e3.version) >= 64);
          }(), e2.name === cg.SAFARI && (Number(e2.version) >= 14 ? pA.supportDualStream = true : pA.supportDualStream = false), pA.webAudioMediaStreamDest = function() {
            const e3 = pg();
            if (e3.name === cg.SAFARI && Number(e3.version) < 12)
              return false;
            return true;
          }(), pA.supportReplaceTrack = function() {
            if (!window.RTCRtpSender)
              return false;
            if ("function" == typeof RTCRtpSender.prototype.replaceTrack)
              return true;
            return false;
          }(), pA.supportWebGL = "undefined" != typeof WebGLRenderingContext, pA.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, kg() || (pA.webAudioWithAEC = true), pA.supportShareAudio = function() {
            const e3 = pg();
            if ((e3.os === ag.WIN_10 || e3.os === ag.WIN_81 || e3.os === ag.WIN_7 || e3.os === ag.LINUX || e3.os === ag.MAC_OS) && e3.name === cg.CHROME && Number(e3.version) >= 74)
              return true;
            return false;
          }(), pA.supportDataChannel = function() {
            if (vg(76) || function(e3) {
              const t2 = pg();
              return !(t2.name !== cg.FIREFOX || !t2.osVersion) && Number(t2.version) >= e3;
            }(68) || function(e3) {
              const t2 = pg();
              return !(t2.name !== cg.SAFARI || !t2.osVersion) && Number(t2.version) >= e3;
            }(14))
              return true;
            return false;
          }(), pA.supportPCSetConfiguration = function() {
            const e3 = window.RTCPeerConnection;
            return !Rg() && !!e3 && e3.prototype.setConfiguration instanceof Function;
          }(), pA.supportWebRTCEncodedTransform = function() {
            const e3 = pg();
            return "Chrome" === e3.name && Number(e3.version) >= 86;
          }(), pA.supportWebRTCInsertableStream = function() {
            const e3 = pg();
            return (e3.name === cg.CHROME || e3.name === cg.EDGE) && Number(e3.version) >= 94 && "MediaStreamTrackGenerator" in window && "MediaStreamTrackProcessor" in window;
          }(), AT(() => {
            pA.supportDualStreamEncoding = function() {
              const e3 = pg();
              if (kC("DISABLE_WEBAUDIO"))
                return true;
              return "Safari" === e3.name && Number(e3.version) >= 14 || !!("Chrome" === e3.name && /Windows/i.test(e3.os || "") && Number(e3.version) >= 100 && kC("CHROME_DUAL_STREAM_USE_ENCODING"));
            }(), KC.info("browser compatibility", JSON.stringify(pA), JSON.stringify(e2));
          });
        }(), function() {
          let e2;
          try {
            e2 = window.localStorage.getItem("websdk_ng_global_parameter");
          } catch (e3) {
            return void KC.error("Error loading sdk config", e3.message);
          }
          if (e2)
            try {
              const t2 = JSON.parse(window.atob(e2)), i2 = Date.now();
              KC.debug("Loading global parameters from cache", t2), Object.keys(t2).forEach((e3) => {
                if (Object.prototype.hasOwnProperty.call(PC, e3)) {
                  const { value: n2, expires: r2 } = t2[e3];
                  if (r2 && r2 <= i2)
                    return;
                  MC[e3] = n2, PC[e3] = n2;
                }
              });
            } catch (t2) {
              KC.error("Error loading mutableParamsCache: ".concat(e2), t2.message);
            }
        }(), Array.isArray(MC.AREAS) && MC.AREAS.length > 0 && qD(MC.AREAS, true);
        const iU = function(e2) {
          const t2 = new iT(), i2 = e2, n2 = { getListeners: t2.getListeners.bind(t2), on: (e3, i3) => (function(e4, t3) {
            e4 === vI.SECURITY_POLICY_VIOLATION && tU(t3, true);
          }(e3, i3), t2.on.bind(t2)(e3, i3)), addListener: t2.addListener.bind(t2), once: t2.once.bind(t2), off: t2.off.bind(t2), removeAllListeners: t2.removeAllListeners.bind(t2), emit: t2.emit.bind(t2), safeEmit: t2.safeEmit.bind(t2) };
          return $M($M({}, i2), n2);
        }({ __TRACK_LIST__: Dy, VERSION: OC, BUILD: DC, ESM_BUNDLER: false, ESM: false, UMD: true, DEV: false, setParameter: (e2, t2, i2) => {
          KC.debug("setParameter key:".concat(e2, ", value:").concat(JSON.stringify(t2))), LC(e2, t2, i2);
        }, getParameter: kC, getSupportedCodec: async function() {
          let e2 = { audio: [], video: [] };
          try {
            let t2 = new RTCPeerConnection();
            t2.addTransceiver("video", { direction: "recvonly" }), t2.addTransceiver("audio", { direction: "recvonly" });
            const i2 = (await t2.createOffer()).sdp;
            if (!i2)
              return e2;
            t2.close(), t2 = null, e2 = function(e3) {
              const t3 = { video: [], audio: [] };
              return e3.match(/ VP8/i) && t3.video.push("VP8"), e3.match(/ VP9/i) && t3.video.push("VP9"), e3.match(/ AV1/i) && t3.video.push("AV1"), e3.match(/ H264/i) && t3.video.push("H264"), e3.match(/ H265/i) && t3.video.push("H265"), e3.match(/ opus/i) && t3.audio.push("OPUS"), e3.match(/ PCMU/i) && t3.audio.push("PCMU"), e3.match(/ PCMA/i) && t3.audio.push("PCMA"), e3.match(/ G722/i) && t3.audio.push("G722"), t3;
            }(i2);
          } catch (e3) {
            throw new xv(xg.CREATE_OFFER_FAILED, e3.toString && e3.toString()).print();
          }
          return e2;
        }, checkSystemRequirements: function() {
          const e2 = rv.reportApiInvoke(null, { name: sT.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: oT.TRACER });
          let t2 = false;
          try {
            const e3 = window.RTCPeerConnection, i3 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, n3 = window.WebSocket;
            t2 = !!(e3 && i3 && n3);
          } catch (e3) {
            return KC.error("check system requirement failed: ", e3), false;
          }
          let i2 = false;
          const n2 = pg();
          n2.name === cg.CHROME && Number(n2.version) >= 58 && (!gg() || fg()) && (i2 = true), n2.name === cg.FIREFOX && Number(n2.version) >= 56 && (i2 = true), n2.name === cg.OPERA && Number(n2.version) >= 45 && (i2 = true), n2.name === cg.SAFARI && Number(n2.version) >= 11 && (i2 = true), (Pg() || pg().name === cg.QQ) && (i2 = true), KC.debug("checkSystemRequirements, api:", t2, "browser", i2);
          const r2 = t2 && i2;
          return e2.onSuccess(r2), r2;
        }, getDevices: function(e2) {
          return OA.enumerateDevices(true, true, e2);
        }, getMicrophones: function(e2) {
          return OA.getRecordingDevices(e2);
        }, getCameras: function(e2) {
          return OA.getCamerasDevices(e2);
        }, getElectronScreenSources: SA, getPlaybackDevices: function(e2) {
          return OA.getSpeakers(e2);
        }, createClient: function() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
          const t2 = rv.reportApiInvoke(null, { name: sT.CREATE_CLIENT, options: [e2], tag: oT.TRACER });
          try {
            !function(e3) {
              Bg(e3.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), Bg(e3.mode, "config.mode", ["rtc", "live"]), void 0 !== e3.audioCodec && Bg(e3.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e3.proxyServer && Wg(e3.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e3.turnServer && ET(e3.turnServer), void 0 !== e3.httpRetryConfig && pT(e3.httpRetryConfig), void 0 !== e3.websocketRetryConfig && pT(e3.websocketRetryConfig);
            }(e2);
          } catch (e3) {
            throw t2.onError(e3), e3;
          }
          return HM() || ("vp9" === e2.codec && (e2.codec = "vp8", KC.debug("browser not support vp9, force use vp8")), LC("UNSUPPORTED_VIDEO_CODEC", ["vp9"])), void 0 === e2.audioCodec && (e2.audioCodec = "opus"), t2.onSuccess(), new qM(YM(YM({ forceWaitGatewayResponse: true }, e2), {}, { role: "rtc" === e2.mode ? "host" : e2.role || "audience" }));
        }, createCameraVideoTrack: async function() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          const t2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CREATE_CAM_VIDEO_TRACK, options: [vb({}, e2)] }), i2 = ib(e2), n2 = xT(8, "track-cam-");
          let r2 = null;
          const s2 = "720p_auto" === e2.encoderConfig;
          KC.info("start create camera video track with config", JSON.stringify(e2), "trackId", n2);
          try {
            r2 = (await yA({ video: i2 }, n2)).getVideoTracks()[0] || null;
          } catch (e3) {
            throw t2.onError(e3), e3;
          }
          if (!r2) {
            const e3 = new Vg(xg.UNEXPECTED_ERROR, "can not find track in media stream");
            return t2.onError(e3), e3.throw(KC);
          }
          e2.optimizationMode && Ib(n2, r2, e2, Ay(e2.encoderConfig));
          const o2 = new Rb(r2, e2, i2, e2.scalabiltyMode ? wy(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, n2);
          return s2 && o2.startMonitorStats(), t2.onSuccess(o2.getTrackId()), KC.info("create camera video success, trackId:", n2), o2;
        }, createCustomVideoTrack: function(e2) {
          const t2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CREATE_CUSTOM_VIDEO_TRACK, options: [e2] }), i2 = new Sb(e2.mediaStreamTrack, { width: e2.width, height: e2.height, frameRate: e2.frameRate, bitrateMax: e2.bitrateMax, bitrateMin: e2.bitrateMin }, e2.scalabiltyMode ? wy(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, xT(8, "track-cus-"), [ky.CUSTOM_TRACK]);
          return t2.onSuccess(i2.getTrackId()), KC.info("create custom video track success with config", e2, "trackId", i2.getTrackId()), i2;
        }, createScreenVideoTrack: async function() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
          const i2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CREATE_SCREEN_VIDEO_TRACK, options: [vb({}, e2), t2] }), n2 = "720p_auto" === e2.encoderConfig;
          e2.encoderConfig ? "string" == typeof e2.encoderConfig || e2.encoderConfig.width && e2.encoderConfig.height || (e2.encoderConfig.width = { max: 1920 }, e2.encoderConfig.height = { max: 1080 }) : e2.encoderConfig = "1080p_2";
          const r2 = function(e3) {
            const t3 = {};
            e3.screenSourceType && (t3.mediaSource = e3.screenSourceType), e3.extensionId && Tg() && (t3.extensionId = e3.extensionId);
            const { displaySurface: i3, selfBrowserSurface: n3, surfaceSwitching: r3, systemAudio: s3 } = e3;
            (vg(107) || Ig(107) || yg(93)) && (i3 && (Bg(i3, "displaySurface", ["browser", "window", "monitor"]), t3.displaySurface = i3), n3 ? (Bg(n3, "selfBrowserSurface", ["exclude", "include"]), t3.selfBrowserSurface = n3) : t3.selfBrowserSurface = "include", r3 && (Bg(r3, "surfaceSwitching", ["exclude", "include"]), t3.surfaceSwitching = r3)), (vg(105) || Ig(105) || yg(91)) && s3 && (Bg(s3, "systemAudio", ["exclude", "include"]), t3.systemAudio = s3), e3.electronScreenSourceId && (t3.sourceId = e3.electronScreenSourceId);
            const o3 = e3.encoderConfig ? by(e3.encoderConfig) : null;
            return t3.mandatory = { chromeMediaSource: "desktop", maxWidth: o3 ? o3.width : void 0, maxHeight: o3 ? o3.height : void 0 }, o3 && (o3.frameRate && ("number" == typeof o3.frameRate ? (t3.mandatory.maxFrameRate = o3.frameRate, t3.mandatory.minFrameRate = o3.frameRate) : (t3.mandatory.maxFrameRate = o3.frameRate.max || o3.frameRate.ideal || o3.frameRate.exact || void 0, t3.mandatory.minFrameRate = o3.frameRate.min || o3.frameRate.ideal || o3.frameRate.exact || void 0), t3.frameRate = o3.frameRate), o3.width && (t3.width = o3.width), o3.height && (t3.height = o3.height)), t3;
          }(e2), s2 = xT(8, "track-scr-v-");
          let o2 = null, a2 = null;
          const c2 = _A();
          if (!c2.supportShareAudio && "enable" === t2) {
            const e3 = new Vg(xg.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
            return i2.onError(e3), e3.throw(KC);
          }
          KC.info("start create screen video track with config", e2, "withAudio", t2, "trackId", s2);
          try {
            const e3 = await yA({ screen: r2, screenAudio: "auto" === t2 ? c2.supportShareAudio : "enable" === t2 }, s2);
            o2 = e3.getVideoTracks()[0] || null, a2 = e3.getAudioTracks()[0] || null;
          } catch (e3) {
            throw i2.onError(e3), e3;
          }
          if (!o2) {
            const e3 = new Vg(xg.UNEXPECTED_ERROR, "can not find track in media stream");
            return i2.onError(e3), e3.throw(KC);
          }
          if (!a2 && "enable" === t2) {
            o2 && o2.stop();
            const e3 = new Vg(xg.SHARE_AUDIO_NOT_ALLOWED);
            return i2.onError(e3), e3.throw(KC);
          }
          if (e2.optimizationMode || (e2.optimizationMode = "detail"), e2.optimizationMode) {
            Ib(s2, o2, e2, e2.encoderConfig && by(e2.encoderConfig) || void 0), e2.encoderConfig && "string" != typeof e2.encoderConfig && (e2.encoderConfig.bitrateMin = e2.encoderConfig.bitrateMax);
          }
          const d2 = new Sb(o2, e2.encoderConfig ? by(e2.encoderConfig) : {}, e2.scalabiltyMode ? wy(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, s2, [ky.SCREEN_TRACK]);
          if (n2 && d2.startMonitorStats(), !a2)
            return i2.onSuccess(d2.getTrackId()), KC.info("create screen video track success", "video:", d2.getTrackId()), d2;
          const l2 = new ZA(a2, void 0, xT(8, "track-scr-a-"), false, true);
          return i2.onSuccess([d2.getTrackId(), l2.getTrackId()]), KC.info("create screen video track success", "video:", d2.getTrackId(), "audio:", l2.getTrackId()), [d2, l2];
        }, createMicrophoneAndCameraTracks: async function() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          const i2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CREATE_MIC_AND_CAM_TRACKS, options: [e2, t2] }), n2 = "720p_auto" === t2.encoderConfig, r2 = ib(t2), s2 = nb(e2), o2 = xT(8, "track-mic-"), a2 = xT(8, "track-cam-");
          let c2 = null, d2 = null;
          KC.info("start create camera video track(".concat(a2, ") and microphone audio track(").concat(o2, ") with config, audio: ").concat(JSON.stringify(e2), ", video: ").concat(JSON.stringify(t2)));
          try {
            const e3 = await yA({ audio: s2, video: r2 }, "".concat(o2, "-").concat(a2));
            c2 = e3.getAudioTracks()[0], d2 = e3.getVideoTracks()[0];
          } catch (e3) {
            throw i2.onError(e3), e3;
          }
          if (!c2 || !d2) {
            const e3 = new Vg(xg.UNEXPECTED_ERROR, "can not find tracks in media stream");
            return i2.onError(e3), e3.throw(KC);
          }
          t2.optimizationMode && Ib(a2, d2, t2, Ay(t2.encoderConfig));
          const l2 = new $A(c2, e2, s2, o2), h2 = new Rb(d2, t2, r2, t2.scalabiltyMode ? wy(t2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t2.optimizationMode, a2);
          return n2 && h2.startMonitorStats(), i2.onSuccess([l2.getTrackId(), h2.getTrackId()]), KC.info("create camera video track(".concat(a2, ") and microphone audio track(").concat(o2, ") success")), [l2, h2];
        }, createMicrophoneAudioTrack: async function() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          const t2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CREATE_MIC_AUDIO_TRACK, options: [e2] }), i2 = nb(e2), n2 = xT(8, "track-mic-");
          let r2 = null;
          KC.info("start create microphone audio track with config", JSON.stringify(e2), "trackId", n2);
          try {
            r2 = (await yA({ audio: i2 }, n2)).getAudioTracks()[0] || null;
          } catch (e3) {
            throw t2.onError(e3), e3;
          }
          if (!r2) {
            const e3 = new Vg(xg.UNEXPECTED_ERROR, "can not find track in media stream");
            return t2.onError(e3), e3.throw(KC);
          }
          const s2 = new $A(r2, e2, i2, n2);
          return t2.onSuccess(s2.getTrackId()), KC.info("create microphone audio track success, trackId:", n2), s2;
        }, createCustomAudioTrack: function(e2) {
          const t2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CREATE_CUSTOM_AUDIO_TRACK, options: [e2] }), i2 = new ZA(e2.mediaStreamTrack, e2.encoderConfig ? Ny(e2.encoderConfig) : {}, xT(8, "track-cus-"), false, true);
          return KC.info("create custom audio track success with config", e2, "trackId", i2.getTrackId()), t2.onSuccess(i2.getTrackId()), i2;
        }, createBufferSourceAudioTrack: async function(e2) {
          var t2;
          const { cacheOnlineFile: i2, encoderConfig: n2 } = e2;
          let { source: r2 } = e2;
          const s2 = { source: r2 instanceof AudioBuffer ? "AudioBuffer" : r2 instanceof File ? null !== (t2 = File.name) && void 0 !== t2 ? t2 : "File" : r2, cacheOnlineFile: i2, encoderConfig: n2 }, o2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CREATE_BUFFER_AUDIO_TRACK, options: [s2] });
          if (kC("DISABLE_WEBAUDIO"))
            throw new Vg(xg.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
          const a2 = xT(8, "track-buf-");
          KC.info("start create buffer source audio track with config", JSON.stringify(s2), "trackId", a2);
          const c2 = r2;
          if (!(r2 instanceof AudioBuffer))
            try {
              r2 = await ob(r2, i2);
            } catch (e3) {
              return o2.onError(e3), e3.throw(KC);
            }
          const d2 = new rb(r2), l2 = new eb(c2, d2, n2 ? Ny(n2) : {}, a2);
          return KC.info("create buffer source audio track success, trackId:", a2), o2.onSuccess(l2.getTrackId()), l2;
        }, setAppType: function(e2) {
          if (KC.debug("setAppType: ".concat(e2)), !(Number.isInteger(e2) && e2 >= 0))
            throw KC.debug("Invalid appType"), new xv(xg.INVALID_PARAMS, "invalid app type", e2);
          LC("APP_TYPE", Math.floor(e2));
        }, setLogLevel: function(e2) {
          KC.setLogLevel(e2);
        }, enableLogUpload: function() {
          kC("USE_NEW_LOG") ? LC("UPLOAD_LOG", true) : KC.enableLogUpload();
        }, disableLogUpload: function() {
          kC("USE_NEW_LOG") ? LC("UPLOAD_LOG", false) : KC.disableLogUpload();
        }, createChannelMediaRelayConfiguration: function() {
          return new AP();
        }, checkAudioTrackIsActive: async function(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          const i2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t2] });
          if (!(e2 instanceof ZA || e2 instanceof Ob)) {
            const e3 = new xv(xg.INVALID_TRACK, "the parameter is not a audio track");
            return i2.onError(e3), e3.throw();
          }
          t2 && t2 < 1e3 && (t2 = 1e3);
          const n2 = e2 instanceof ZA ? e2.getTrackLabel() : "remote_track", r2 = e2.getVolumeLevel();
          let s2 = r2, o2 = r2;
          const a2 = Date.now();
          return new tg((r3) => {
            const c2 = setInterval(() => {
              const d2 = e2.getVolumeLevel();
              s2 = d2 > s2 ? d2 : s2, o2 = d2 < o2 ? d2 : o2;
              const l2 = s2 - o2 > 1e-4, h2 = Date.now() - a2;
              if (l2 || h2 > t2) {
                clearInterval(c2);
                const t3 = l2, o3 = { duration: h2, deviceLabel: n2, maxVolumeLevel: s2, result: t3 };
                KC.info("[track-".concat(e2.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(o3))), i2.onSuccess(o3), r3(t3);
              }
            }, 200);
          });
        }, checkVideoTrackIsActive: async function(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          const i2 = rv.reportApiInvoke(null, { tag: oT.TRACER, name: sT.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t2] });
          if (!(e2 instanceof Sb || e2 instanceof wb)) {
            const e3 = new xv(xg.INVALID_TRACK, "the parameter is not a video track");
            return i2.onError(e3), e3.throw();
          }
          t2 && t2 < 1e3 && (t2 = 1e3);
          const n2 = e2 instanceof Sb ? e2.getTrackLabel() : "remote_track", r2 = e2.getMediaStreamTrack(true), s2 = document.createElement("video");
          s2.style.width = "1px", s2.style.height = "1px", s2.setAttribute("muted", ""), s2.muted = true, s2.setAttribute("playsinline", ""), s2.controls = false, (Sg() || mg()) && (s2.style.opacity = "0.01", s2.style.position = "fixed", s2.style.left = "0", s2.style.top = "0", document.body.appendChild(s2)), s2.srcObject = new MediaStream([r2]), s2.play();
          const o2 = document.createElement("canvas");
          o2.width = 160, o2.height = 120;
          let a2 = 0, c2 = 0;
          try {
            const e3 = Date.now();
            a2 = await function(e4, t3, i3, n3) {
              let r3, s3 = 0, o3 = null;
              return new tg((a3, c3) => {
                function d3() {
                  s3 > n3 && r3 && (r3(), a3(s3));
                  const t4 = i3.getContext("2d");
                  if (!t4) {
                    const e5 = new xv(xg.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                    return KC.error(e5.toString()), void c3(e5);
                  }
                  t4.drawImage(e4, 0, 0, 160, 120);
                  const d4 = t4.getImageData(0, 0, i3.width, i3.height), l3 = Math.floor(d4.data.length / 3);
                  if (o3) {
                    for (let e5 = 0; e5 < l3; e5 += 3)
                      if (d4.data[e5] !== o3[e5])
                        return s3 += 1, void (o3 = d4.data);
                    o3 = d4.data;
                  } else
                    o3 = d4.data;
                }
                setTimeout(() => {
                  r3 && (r3(), a3(s3));
                }, t3), r3 = uA(() => {
                  d3();
                }, 30);
              });
            }(s2, t2, o2, 4), c2 = Date.now() - e3;
          } catch (e3) {
            throw i2.onError(e3), e3;
          }
          WM === cg.SAFARI && (s2.pause(), s2.remove()), s2.srcObject = null;
          const d2 = a2 > 4, l2 = { duration: c2, changedPicNum: a2, deviceLabel: n2, result: d2 };
          return KC.info("[track-".concat(e2.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l2))), i2.onSuccess(l2), d2;
        }, setArea: qD, audioElementPlayCenter: xA, processExternalMediaAEC: function(e2) {
          QM.processExternalMediaAEC(e2);
        }, registerExtensions: function(e2) {
          e2.forEach((e3) => {
            const t2 = e3;
            t2.__registered__ = true, t2.logger.hookLog = KC.extLog, t2.reporter.hookApiInvoke = rv.extApiInvoke, t2.parameters && Object.keys(t2.parameters).forEach((e4) => {
              t2.parameters[e4] = kC(e4);
            });
          });
        }, ChannelMediaRelayError: Zv, ChannelMediaRelayEvent: Xv, ChannelMediaRelayState: Qv, RemoteStreamFallbackType: xy, RemoteStreamType: Uy, ConnectionDisconnectedReason: cT, AudienceLatencyLevelType: aT, AREAS: rI });
        return Object.defineProperties(iU, { onAudioAutoplayFailed: { get: () => DA.onAudioAutoplayFailed, set: (e2) => {
          DA.onAudioAutoplayFailed = e2;
        } }, onAutoplayFailed: { get: () => DA.onAutoplayFailed, set: (e2) => {
          DA.onAutoplayFailed = e2;
        } }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => iU._onSecurityPolicyViolation, set(e2) {
          iU._onSecurityPolicyViolation = e2, tU(e2);
        } }, __CLIENT_LIST__: { get: () => kC("SHOW_GLOBAL_CLIENT_LIST") ? cv : [] } }), OA.on(Qy.CAMERA_DEVICE_CHANGED, (e2) => {
          KC.info("camera device changed", JSON.stringify(e2)), iU.onCameraChanged && iU.onCameraChanged(e2), iU.safeEmit(vI.CAMERA_CHANGED, e2);
        }), OA.on(Qy.RECORDING_DEVICE_CHANGED, (e2) => {
          KC.info("microphone device changed", JSON.stringify(e2)), iU.onMicrophoneChanged && iU.onMicrophoneChanged(e2), iU.safeEmit(vI.MICROPHONE_CHANGED, e2);
        }), OA.on(Qy.PLAYOUT_DEVICE_CHANGED, (e2) => {
          KC.debug("playout device changed", JSON.stringify(e2)), iU.onPlaybackDeviceChanged && iU.onPlaybackDeviceChanged(e2), iU.safeEmit(vI.PLAYBACK_DEVICE_CHANGED, e2);
        }), xA.onAutoplayFailed = () => {
          KC.info("detect audio element autoplay failed"), DA.onAudioAutoplayFailed && DA.onAudioAutoplayFailed();
        }, oA.on("autoplay-failed", () => {
          KC.info("detect webaudio autoplay failed"), DA.onAudioAutoplayFailed && DA.onAudioAutoplayFailed(), iU.safeEmit(vI.AUTOPLAY_FAILED);
        }), RT.on(uT.NETWORK_STATE_CHANGE, (e2, t2) => {
          KC.info("[network-indicator] network state changed, ".concat(t2, " => ").concat(e2));
        }), window && (window.__ARTC__ = iU), iU;
      });
    }
  });

  // node_modules/alpinejs/dist/module.esm.js
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
  var __commonJS2 = (callback, module) => () => {
    if (!module) {
      module = { exports: {} };
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __exportStar = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames2(module))
        if (!__hasOwnProp2.call(target, key) && key !== "default")
          __defProp2(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc2(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __exportStar(__markAsModule(__defProp2(module != null ? __create2(__getProtoOf2(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };
  var require_shared_cjs = __commonJS2((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeMap(str, expectsLowerCase) {
      const map = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
      }
      return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
    }
    var PatchFlagNames = {
      [1]: `TEXT`,
      [2]: `CLASS`,
      [4]: `STYLE`,
      [8]: `PROPS`,
      [16]: `FULL_PROPS`,
      [32]: `HYDRATE_EVENTS`,
      [64]: `STABLE_FRAGMENT`,
      [128]: `KEYED_FRAGMENT`,
      [256]: `UNKEYED_FRAGMENT`,
      [512]: `NEED_PATCH`,
      [1024]: `DYNAMIC_SLOTS`,
      [2048]: `DEV_ROOT_FRAGMENT`,
      [-1]: `HOISTED`,
      [-2]: `BAIL`
    };
    var slotFlagsText = {
      [1]: "STABLE",
      [2]: "DYNAMIC",
      [3]: "FORWARDED"
    };
    var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
    var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
    var range2 = 2;
    function generateCodeFrame(source, start2 = 0, end = source.length) {
      const lines = source.split(/\r?\n/);
      let count = 0;
      const res = [];
      for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start2) {
          for (let j = i - range2; j <= i + range2 || end > count; j++) {
            if (j < 0 || j >= lines.length)
              continue;
            const line = j + 1;
            res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
            const lineLength = lines[j].length;
            if (j === i) {
              const pad = start2 - (count - lineLength) + 1;
              const length = Math.max(1, end > count ? lineLength - pad : end - start2);
              res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
            } else if (j > i) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + 1;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
    var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    var attrValidationCache = {};
    function isSSRSafeAttrName(name) {
      if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
      }
      const isUnsafe = unsafeAttrCharRE.test(name);
      if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
      }
      return attrValidationCache[name] = !isUnsafe;
    }
    var propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
    var isKnownAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
    function normalizeStyle(value) {
      if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isObject4(value)) {
        return value;
      }
    }
    var listDelimiterRE = /;(?![^(]*\))/g;
    var propertyDelimiterRE = /:(.+)/;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function stringifyStyle(styles) {
      let ret = "";
      if (!styles) {
        return ret;
      }
      for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
          ret += `${normalizedKey}:${value};`;
        }
      }
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject4(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
    var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
    var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
    var escapeRE = /["'&<>]/;
    function escapeHtml(string) {
      const str = "" + string;
      const match = escapeRE.exec(str);
      if (!match) {
        return str;
      }
      let html = "";
      let escaped;
      let index;
      let lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escaped = "&quot;";
            break;
          case 38:
            escaped = "&amp;";
            break;
          case 39:
            escaped = "&#39;";
            break;
          case 60:
            escaped = "&lt;";
            break;
          case 62:
            escaped = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
    var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    function escapeHtmlComment(src) {
      return src.replace(commentStripRE, "");
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isArray(a);
      bValidType = isArray(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject4(a);
      bValidType = isObject4(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    var toDisplayString = (val) => {
      return val == null ? "" : isObject4(val) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    var replacer = (_key, val) => {
      if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject4(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
      }
      return val;
    };
    var babelParserDefaultPlugins = [
      "bigInt",
      "optionalChaining",
      "nullishCoalescingOperator"
    ];
    var EMPTY_OBJ = Object.freeze({});
    var EMPTY_ARR = Object.freeze([]);
    var NOOP = () => {
    };
    var NO = () => false;
    var onRE = /^on[^a-z]/;
    var isOn = (key) => onRE.test(key);
    var isModelListener = (key) => key.startsWith("onUpdate:");
    var extend3 = Object.assign;
    var remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var hasOwn = (val, key) => hasOwnProperty.call(val, key);
    var isArray = Array.isArray;
    var isMap = (val) => toTypeString(val) === "[object Map]";
    var isSet = (val) => toTypeString(val) === "[object Set]";
    var isDate = (val) => val instanceof Date;
    var isFunction = (val) => typeof val === "function";
    var isString = (val) => typeof val === "string";
    var isSymbol = (val) => typeof val === "symbol";
    var isObject4 = (val) => val !== null && typeof val === "object";
    var isPromise = (val) => {
      return isObject4(val) && isFunction(val.then) && isFunction(val.catch);
    };
    var objectToString = Object.prototype.toString;
    var toTypeString = (value) => objectToString.call(value);
    var toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    var isPlainObject = (val) => toTypeString(val) === "[object Object]";
    var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    var isReservedProp = /* @__PURE__ */ makeMap(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
    var cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
    var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
    var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
    var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
    var invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    var def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    var toNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    var _globalThis;
    var getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    exports.EMPTY_ARR = EMPTY_ARR;
    exports.EMPTY_OBJ = EMPTY_OBJ;
    exports.NO = NO;
    exports.NOOP = NOOP;
    exports.PatchFlagNames = PatchFlagNames;
    exports.babelParserDefaultPlugins = babelParserDefaultPlugins;
    exports.camelize = camelize;
    exports.capitalize = capitalize;
    exports.def = def;
    exports.escapeHtml = escapeHtml;
    exports.escapeHtmlComment = escapeHtmlComment;
    exports.extend = extend3;
    exports.generateCodeFrame = generateCodeFrame;
    exports.getGlobalThis = getGlobalThis;
    exports.hasChanged = hasChanged;
    exports.hasOwn = hasOwn;
    exports.hyphenate = hyphenate;
    exports.invokeArrayFns = invokeArrayFns;
    exports.isArray = isArray;
    exports.isBooleanAttr = isBooleanAttr2;
    exports.isDate = isDate;
    exports.isFunction = isFunction;
    exports.isGloballyWhitelisted = isGloballyWhitelisted;
    exports.isHTMLTag = isHTMLTag;
    exports.isIntegerKey = isIntegerKey;
    exports.isKnownAttr = isKnownAttr;
    exports.isMap = isMap;
    exports.isModelListener = isModelListener;
    exports.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;
    exports.isObject = isObject4;
    exports.isOn = isOn;
    exports.isPlainObject = isPlainObject;
    exports.isPromise = isPromise;
    exports.isReservedProp = isReservedProp;
    exports.isSSRSafeAttrName = isSSRSafeAttrName;
    exports.isSVGTag = isSVGTag;
    exports.isSet = isSet;
    exports.isSpecialBooleanAttr = isSpecialBooleanAttr;
    exports.isString = isString;
    exports.isSymbol = isSymbol;
    exports.isVoidTag = isVoidTag;
    exports.looseEqual = looseEqual;
    exports.looseIndexOf = looseIndexOf;
    exports.makeMap = makeMap;
    exports.normalizeClass = normalizeClass;
    exports.normalizeStyle = normalizeStyle;
    exports.objectToString = objectToString;
    exports.parseStringStyle = parseStringStyle;
    exports.propsToAttrMap = propsToAttrMap;
    exports.remove = remove;
    exports.slotFlagsText = slotFlagsText;
    exports.stringifyStyle = stringifyStyle;
    exports.toDisplayString = toDisplayString;
    exports.toHandlerKey = toHandlerKey;
    exports.toNumber = toNumber;
    exports.toRawType = toRawType;
    exports.toTypeString = toTypeString;
  });
  var require_shared = __commonJS2((exports, module) => {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_shared_cjs();
    }
  });
  var require_reactivity_cjs = __commonJS2((exports) => {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared = require_shared();
    var targetMap = /* @__PURE__ */ new WeakMap();
    var effectStack = [];
    var activeEffect;
    var ITERATE_KEY = Symbol("iterate");
    var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
    function isEffect(fn) {
      return fn && fn._isEffect === true;
    }
    function effect3(fn, options = shared.EMPTY_OBJ) {
      if (isEffect(fn)) {
        fn = fn.raw;
      }
      const effect4 = createReactiveEffect(fn, options);
      if (!options.lazy) {
        effect4();
      }
      return effect4;
    }
    function stop2(effect4) {
      if (effect4.active) {
        cleanup2(effect4);
        if (effect4.options.onStop) {
          effect4.options.onStop();
        }
        effect4.active = false;
      }
    }
    var uid = 0;
    function createReactiveEffect(fn, options) {
      const effect4 = function reactiveEffect() {
        if (!effect4.active) {
          return fn();
        }
        if (!effectStack.includes(effect4)) {
          cleanup2(effect4);
          try {
            enableTracking();
            effectStack.push(effect4);
            activeEffect = effect4;
            return fn();
          } finally {
            effectStack.pop();
            resetTracking();
            activeEffect = effectStack[effectStack.length - 1];
          }
        }
      };
      effect4.id = uid++;
      effect4.allowRecurse = !!options.allowRecurse;
      effect4._isEffect = true;
      effect4.active = true;
      effect4.raw = fn;
      effect4.deps = [];
      effect4.options = options;
      return effect4;
    }
    function cleanup2(effect4) {
      const { deps } = effect4;
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].delete(effect4);
        }
        deps.length = 0;
      }
    }
    var shouldTrack = true;
    var trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function enableTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = true;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function track(target, type, key) {
      if (!shouldTrack || activeEffect === void 0) {
        return;
      }
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = /* @__PURE__ */ new Set());
      }
      if (!dep.has(activeEffect)) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (activeEffect.options.onTrack) {
          activeEffect.options.onTrack({
            effect: activeEffect,
            target,
            type,
            key
          });
        }
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      const effects = /* @__PURE__ */ new Set();
      const add2 = (effectsToAdd) => {
        if (effectsToAdd) {
          effectsToAdd.forEach((effect4) => {
            if (effect4 !== activeEffect || effect4.allowRecurse) {
              effects.add(effect4);
            }
          });
        }
      };
      if (type === "clear") {
        depsMap.forEach(add2);
      } else if (key === "length" && shared.isArray(target)) {
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 >= newValue) {
            add2(dep);
          }
        });
      } else {
        if (key !== void 0) {
          add2(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!shared.isArray(target)) {
              add2(depsMap.get(ITERATE_KEY));
              if (shared.isMap(target)) {
                add2(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (shared.isIntegerKey(key)) {
              add2(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!shared.isArray(target)) {
              add2(depsMap.get(ITERATE_KEY));
              if (shared.isMap(target)) {
                add2(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (shared.isMap(target)) {
              add2(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      const run = (effect4) => {
        if (effect4.options.onTrigger) {
          effect4.options.onTrigger({
            effect: effect4,
            target,
            key,
            type,
            newValue,
            oldValue,
            oldTarget
          });
        }
        if (effect4.options.scheduler) {
          effect4.options.scheduler(effect4);
        } else {
          effect4();
        }
      };
      effects.forEach(run);
    }
    var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);
    var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(shared.isSymbol));
    var get2 = /* @__PURE__ */ createGetter();
    var shallowGet = /* @__PURE__ */ createGetter(false, true);
    var readonlyGet = /* @__PURE__ */ createGetter(true);
    var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
    var arrayInstrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      const method = Array.prototype[key];
      arrayInstrumentations[key] = function(...args) {
        const arr = toRaw2(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = method.apply(arr, args);
        if (res === -1 || res === false) {
          return method.apply(arr, args.map(toRaw2));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      const method = Array.prototype[key];
      arrayInstrumentations[key] = function(...args) {
        pauseTracking();
        const res = method.apply(this, args);
        resetTracking();
        return res;
      };
    });
    function createGetter(isReadonly2 = false, shallow = false) {
      return function get3(target, key, receiver) {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
          return target;
        }
        const targetIsArray = shared.isArray(target);
        if (!isReadonly2 && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          const shouldUnwrap = !targetIsArray || !shared.isIntegerKey(key);
          return shouldUnwrap ? res.value : res;
        }
        if (shared.isObject(res)) {
          return isReadonly2 ? readonly(res) : reactive3(res);
        }
        return res;
      };
    }
    var set2 = /* @__PURE__ */ createSetter();
    var shallowSet = /* @__PURE__ */ createSetter(true);
    function createSetter(shallow = false) {
      return function set3(target, key, value, receiver) {
        let oldValue = target[key];
        if (!shallow) {
          value = toRaw2(value);
          oldValue = toRaw2(oldValue);
          if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          }
        }
        const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw2(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (shared.hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
        }
        return result;
      };
    }
    function deleteProperty(target, key) {
      const hadKey = shared.hasOwn(target, key);
      const oldValue = target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    function has(target, key) {
      const result = Reflect.has(target, key);
      if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    function ownKeys(target) {
      track(target, "iterate", shared.isArray(target) ? "length" : ITERATE_KEY);
      return Reflect.ownKeys(target);
    }
    var mutableHandlers = {
      get: get2,
      set: set2,
      deleteProperty,
      has,
      ownKeys
    };
    var readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
        {
          console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
      },
      deleteProperty(target, key) {
        {
          console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
      }
    };
    var shallowReactiveHandlers = shared.extend({}, mutableHandlers, {
      get: shallowGet,
      set: shallowSet
    });
    var shallowReadonlyHandlers = shared.extend({}, readonlyHandlers, {
      get: shallowReadonlyGet
    });
    var toReactive = (value) => shared.isObject(value) ? reactive3(value) : value;
    var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;
    var toShallow = (value) => value;
    var getProto = (v) => Reflect.getPrototypeOf(v);
    function get$1(target, key, isReadonly2 = false, isShallow = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw2(target);
      const rawKey = toRaw2(key);
      if (key !== rawKey) {
        !isReadonly2 && track(rawTarget, "get", key);
      }
      !isReadonly2 && track(rawTarget, "get", rawKey);
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has$1(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw2(target);
      const rawKey = toRaw2(key);
      if (key !== rawKey) {
        !isReadonly2 && track(rawTarget, "has", key);
      }
      !isReadonly2 && track(rawTarget, "has", rawKey);
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw2(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw2(value);
      const target = toRaw2(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$1(key, value) {
      value = toRaw2(value);
      const target = toRaw2(this);
      const { has: has2, get: get3 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw2(key);
        hadKey = has2.call(target, key);
      } else {
        checkIdentityKeys(target, has2, key);
      }
      const oldValue = get3.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (shared.hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw2(this);
      const { has: has2, get: get3 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw2(key);
        hadKey = has2.call(target, key);
      } else {
        checkIdentityKeys(target, has2, key);
      }
      const oldValue = get3 ? get3.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    function clear() {
      const target = toRaw2(this);
      const hadItems = target.size !== 0;
      const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0, oldTarget);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw2(target);
        const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw2(target);
        const targetIsMap = shared.isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        {
          const key = args[0] ? `on key "${args[0]}" ` : ``;
          console.warn(`${shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw2(this));
        }
        return type === "delete" ? false : this;
      };
    }
    var mutableInstrumentations = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    var shallowInstrumentations = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    var readonlyInstrumentations = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    var shallowReadonlyInstrumentations = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    var iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations[method] = createIterableMethod(method, true, false);
      shallowInstrumentations[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
    });
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
      };
    }
    var mutableCollectionHandlers = {
      get: createInstrumentationGetter(false, false)
    };
    var shallowCollectionHandlers = {
      get: createInstrumentationGetter(false, true)
    };
    var readonlyCollectionHandlers = {
      get: createInstrumentationGetter(true, false)
    };
    var shallowReadonlyCollectionHandlers = {
      get: createInstrumentationGetter(true, true)
    };
    function checkIdentityKeys(target, has2, key) {
      const rawKey = toRaw2(key);
      if (rawKey !== key && has2.call(target, rawKey)) {
        const type = shared.toRawType(target);
        console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
      }
    }
    var reactiveMap = /* @__PURE__ */ new WeakMap();
    var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    var readonlyMap = /* @__PURE__ */ new WeakMap();
    var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));
    }
    function reactive3(target) {
      if (target && target["__v_isReadonly"]) {
        return target;
      }
      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
    }
    function shallowReactive(target) {
      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
    }
    function readonly(target) {
      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
    }
    function shallowReadonly(target) {
      return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!shared.isObject(target)) {
        {
          console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive2(value) {
      if (isReadonly(value)) {
        return isReactive2(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isProxy(value) {
      return isReactive2(value) || isReadonly(value);
    }
    function toRaw2(observed) {
      return observed && toRaw2(observed["__v_raw"]) || observed;
    }
    function markRaw(value) {
      shared.def(value, "__v_skip", true);
      return value;
    }
    var convert = (val) => shared.isObject(val) ? reactive3(val) : val;
    function isRef(r) {
      return Boolean(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    var RefImpl = class {
      constructor(_rawValue, _shallow = false) {
        this._rawValue = _rawValue;
        this._shallow = _shallow;
        this.__v_isRef = true;
        this._value = _shallow ? _rawValue : convert(_rawValue);
      }
      get value() {
        track(toRaw2(this), "get", "value");
        return this._value;
      }
      set value(newVal) {
        if (shared.hasChanged(toRaw2(newVal), this._rawValue)) {
          this._rawValue = newVal;
          this._value = this._shallow ? newVal : convert(newVal);
          trigger(toRaw2(this), "set", "value", newVal);
        }
      }
    };
    function createRef(rawValue, shallow = false) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    function triggerRef(ref2) {
      trigger(toRaw2(ref2), "set", "value", ref2.value);
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    var shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive2(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    var CustomRefImpl = class {
      constructor(factory) {
        this.__v_isRef = true;
        const { get: get3, set: set3 } = factory(() => track(this, "get", "value"), () => trigger(this, "set", "value"));
        this._get = get3;
        this._set = set3;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    };
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    function toRefs(object) {
      if (!isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
      }
      const ret = shared.isArray(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = toRef(object, key);
      }
      return ret;
    }
    var ObjectRefImpl = class {
      constructor(_object, _key) {
        this._object = _object;
        this._key = _key;
        this.__v_isRef = true;
      }
      get value() {
        return this._object[this._key];
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
    };
    function toRef(object, key) {
      return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);
    }
    var ComputedRefImpl = class {
      constructor(getter, _setter, isReadonly2) {
        this._setter = _setter;
        this._dirty = true;
        this.__v_isRef = true;
        this.effect = effect3(getter, {
          lazy: true,
          scheduler: () => {
            if (!this._dirty) {
              this._dirty = true;
              trigger(toRaw2(this), "set", "value");
            }
          }
        });
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw2(this);
        if (self2._dirty) {
          self2._value = this.effect();
          self2._dirty = false;
        }
        track(self2, "get", "value");
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    };
    function computed(getterOrOptions) {
      let getter;
      let setter;
      if (shared.isFunction(getterOrOptions)) {
        getter = getterOrOptions;
        setter = () => {
          console.warn("Write operation failed: computed value is readonly");
        };
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      return new ComputedRefImpl(getter, setter, shared.isFunction(getterOrOptions) || !getterOrOptions.set);
    }
    exports.ITERATE_KEY = ITERATE_KEY;
    exports.computed = computed;
    exports.customRef = customRef;
    exports.effect = effect3;
    exports.enableTracking = enableTracking;
    exports.isProxy = isProxy;
    exports.isReactive = isReactive2;
    exports.isReadonly = isReadonly;
    exports.isRef = isRef;
    exports.markRaw = markRaw;
    exports.pauseTracking = pauseTracking;
    exports.proxyRefs = proxyRefs;
    exports.reactive = reactive3;
    exports.readonly = readonly;
    exports.ref = ref;
    exports.resetTracking = resetTracking;
    exports.shallowReactive = shallowReactive;
    exports.shallowReadonly = shallowReadonly;
    exports.shallowRef = shallowRef;
    exports.stop = stop2;
    exports.toRaw = toRaw2;
    exports.toRef = toRef;
    exports.toRefs = toRefs;
    exports.track = track;
    exports.trigger = trigger;
    exports.triggerRef = triggerRef;
    exports.unref = unref;
  });
  var require_reactivity = __commonJS2((exports, module) => {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_reactivity_cjs();
    }
  });
  var flushPending = false;
  var flushing = false;
  var queue = [];
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i = 0; i < queue.length; i++) {
      queue[i]();
    }
    queue.length = 0;
    flushing = false;
  }
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i) => i());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(callback) {
    onElRemoveds.push(callback);
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      (names === void 0 || names.includes(name)) && value.forEach((i) => i());
      delete el._x_attributeCleanups[name];
    });
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    observer.disconnect();
    currentlyObserving = false;
  }
  var recordQueue = [];
  var willProcessRecordQueue = false;
  function flushObserver() {
    recordQueue = recordQueue.concat(observer.takeRecords());
    if (recordQueue.length && !willProcessRecordQueue) {
      willProcessRecordQueue = true;
      queueMicrotask(() => {
        processRecordQueue();
        willProcessRecordQueue = false;
      });
    }
  }
  function processRecordQueue() {
    onMutate(recordQueue);
    recordQueue.length = 0;
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    flushObserver();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  function onMutate(mutations) {
    let addedNodes = [];
    let removedNodes = [];
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i = 0; i < mutations.length; i++) {
      if (mutations[i].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i].type === "childList") {
        mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));
        mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));
      }
      if (mutations[i].type === "attributes") {
        let el = mutations[i].target;
        let name = mutations[i].attributeName;
        let oldValue = mutations[i].oldValue;
        let add = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add();
        } else if (el.hasAttribute(name)) {
          remove();
          add();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i) => i(el, attrs));
    });
    for (let node of addedNodes) {
      if (removedNodes.includes(node))
        continue;
      onElAddeds.forEach((i) => i(node));
    }
    for (let node of removedNodes) {
      if (addedNodes.includes(node))
        continue;
      onElRemoveds.forEach((i) => i(node));
    }
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);
    };
  }
  function refreshScope(element, scope) {
    let existingScope = element._x_dataStack[0];
    Object.entries(scope).forEach(([key, value]) => {
      existingScope[key] = value;
    });
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    return new Proxy({}, {
      ownKeys: () => {
        return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));
      },
      has: (target, name) => {
        return objects.some((obj) => obj.hasOwnProperty(name));
      },
      get: (target, name) => {
        return (objects.find((obj) => obj.hasOwnProperty(name)) || {})[name];
      },
      set: (target, name, value) => {
        let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));
        if (closestObjectWithKey) {
          closestObjectWithKey[name] = value;
        } else {
          objects[objects.length - 1][name] = value;
        }
        return true;
      }
    });
  }
  function initInterceptors(data2) {
    let isObject4 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(obj).forEach(([key, value]) => {
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject4(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    Object.entries(magics).forEach(([name, callback]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          return callback(el, { Alpine: alpine_default, interceptor });
        },
        enumerable: false
      });
    });
    return obj;
  }
  function evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    if (typeof expression === "function") {
      return generateEvaluatorFromFunction(dataStack, expression);
    }
    let evaluator = generateEvaluatorFromString(dataStack, expression);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope = {}, params = [] } = {}) => {
      let result = func.apply(mergeProxies([scope, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression) || /^(let|const)/.test(expression) ? `(() => { ${expression} })()` : expression;
    let func = new AsyncFunction(["__self", "scope"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression) {
    let func = generateFunctionFromString(expression);
    return (receiver = () => {
    }, { scope = {}, params = [] } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope, ...dataStack]);
      let promise = func(func, completeScope);
      if (func.finished) {
        runIfTypeOfFunction(receiver, func.result, completeScope, params);
      } else {
        promise.then((result) => {
          runIfTypeOfFunction(receiver, result, completeScope, params);
        });
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope, params) {
    if (typeof value === "function") {
      let result = value.apply(scope, params);
      if (result instanceof Promise) {
        result.then((i) => runIfTypeOfFunction(receiver, i, scope, params));
      } else {
        receiver(result);
      }
    } else {
      receiver(value);
    }
  }
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e) {
      console.warn(`Alpine Expression Error: ${e.message}

Expression: "${expression}"

`, el);
      throw e;
    }
  }
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
  }
  function directives(el, attributes, originalAttributeOverride) {
    let transformedAttributeMap = {};
    let directives2 = Array.from(attributes).map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  var isDeferringHandlers = false;
  var directiveHandlerStack = [];
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let flushHandlers = () => {
      while (directiveHandlerStack.length)
        directiveHandlerStack.shift()();
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getDirectiveHandler(el, directive2) {
    let noop2 = () => {
    };
    let handler3 = directiveHandlers[directive2.type] || noop2;
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate.bind(evaluate, el)
    };
    let doCleanup = () => cleanups.forEach((i) => i());
    onAttributeRemoved(el, directive2.original, doCleanup);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler3.inline && handler3.inline(el, directive2, utilities);
      handler3 = handler3.bind(handler3, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStack.push(handler3) : handler3();
    };
    fullHandler.runCleanups = doCleanup;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i) => i;
  function toTransformedAttributes(callback) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i) => i.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "bind",
    "init",
    "for",
    "model",
    "transition",
    "show",
    "if",
    DEFAULT,
    "element"
  ];
  function byPriority(a, b) {
    let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;
    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(new CustomEvent(name, {
      detail,
      bubbles: true,
      composed: true,
      cancelable: true
    }));
  }
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback) {
    tickStack.push(callback);
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  function walk(el, callback) {
    if (el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback, false);
      node = node.nextElementSibling;
    }
  }
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  function start() {
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => nextTick(() => destroyTree(el)));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentNode || closestRoot(el));
    Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el) {
    if (rootSelectors().some((selector) => el.matches(selector)))
      return el;
    if (!el.parentElement)
      return;
    return closestRoot(el.parentElement);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  function initTree(el, walker = walk) {
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        directives(el2, el2.attributes).forEach((handle) => handle());
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root) {
    walk(root, (el) => cleanupAttributes(el));
  }
  function plugin(callback) {
    callback(alpine_default);
  }
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
  }
  function getStores() {
    return stores;
  }
  var isCloning = false;
  function skipDuringClone(callback) {
    return (...args) => isCloning || callback(...args);
  }
  function clone(oldEl, newEl) {
    newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  var Alpine = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.2.2",
    disableEffectScheduling,
    setReactivityEngine,
    addRootSelector,
    mapAttributes,
    evaluateLater,
    setEvaluator,
    closestRoot,
    interceptor,
    mutateDom,
    directive,
    evaluate,
    initTree,
    nextTick,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    data
  };
  var alpine_default = Alpine;
  var import_reactivity9 = __toModule(require_reactivity());
  magic("nextTick", () => nextTick);
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  magic("watch", (el) => (key, callback) => {
    let evaluate2 = evaluateLater(el, key);
    let firstTime = true;
    let oldValue;
    effect(() => evaluate2((value) => {
      let div = document.createElement("div");
      div.dataset.throwAway = value;
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    }));
  });
  magic("store", getStores);
  magic("refs", (el) => closestRoot(el)._x_refs || {});
  magic("el", (el) => el);
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let split = (classString2) => classString2.split(" ").filter(Boolean);
    let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
    let addClassesAndReturnUndo = (classes2) => {
      el.classList.add(...classes2);
      return () => {
        el.classList.remove(...classes2);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i) => {
      if (el.classList.contains(i)) {
        el.classList.remove(i);
        removed.push(i);
      }
    });
    forAdd.forEach((i) => {
      if (!el.classList.contains(i)) {
        el.classList.add(i);
        added.push(i);
      }
    });
    return () => {
      removed.forEach((i) => el.classList.add(i));
      added.forEach((i) => el.classList.remove(i));
    };
  }
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      el.style[key] = value2;
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache);
    };
  }
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (!expression) {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      enter: (classes2) => {
        el._x_transition.enter.during = classes2;
      },
      "enter-start": (classes2) => {
        el._x_transition.enter.start = classes2;
      },
      "enter-end": (classes2) => {
        el._x_transition.enter.end = classes2;
      },
      leave: (classes2) => {
        el._x_transition.leave.during = classes2;
      },
      "leave-start": (classes2) => {
        el._x_transition.leave.start = classes2;
      },
      "leave-end": (classes2) => {
        el._x_transition.leave.end = classes2;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
    let delay = modifierValue(modifiers, "delay", 0);
    let origin = modifierValue(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: delay,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: delay,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end,
            entering: true
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end,
            entering: false
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    let clickAwayCompatibleShow = () => requestAnimationFrame(show);
    if (value) {
      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        queueMicrotask(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i]) => i());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e) => {
            if (!e.isFromCancelledTransition)
              throw e;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start2, end, entering } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    }, entering);
  }
  function performTransition(el, stages, entering) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        ;
        finish();
      }),
      finish,
      entering
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay);
        reachedEnd = true;
      });
    });
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  directive("effect", (el, { expression }, { effect: effect3 }) => effect3(evaluateLater(el, expression)));
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (el.type === "radio") {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        el.checked = checkedAttrLooseCompare(el.value, value);
      }
    } else if (el.type === "checkbox") {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function isBooleanAttr(attrName) {
    const booleanAttributes = [
      "disabled",
      "checked",
      "required",
      "readonly",
      "hidden",
      "open",
      "selected",
      "autofocus",
      "itemscope",
      "multiple",
      "novalidate",
      "allowfullscreen",
      "allowpaymentrequest",
      "formnovalidate",
      "autoplay",
      "controls",
      "loop",
      "muted",
      "playsinline",
      "default",
      "ismap",
      "reversed",
      "async",
      "defer",
      "nomodule"
    ];
    return booleanAttributes.includes(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked"].includes(name);
  }
  function on(el, event2, modifiers, callback) {
    let listenerTarget = el;
    let handler3 = (e) => callback(e);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
    if (modifiers.includes("camel"))
      event2 = camelCase2(event2);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("prevent"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.preventDefault();
        next(e);
      });
    if (modifiers.includes("stop"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.stopPropagation();
        next(e);
      });
    if (modifiers.includes("self"))
      handler3 = wrapHandler(handler3, (next, e) => {
        e.target === el && next(e);
      });
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler3 = wrapHandler(handler3, (next, e) => {
        if (el.contains(e.target))
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        next(e);
      });
    }
    handler3 = wrapHandler(handler3, (next, e) => {
      if (isKeyEvent(event2)) {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
          return;
        }
      }
      next(e);
    });
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler3 = debounce(handler3, wait, this);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler3 = throttle(handler3, wait, this);
    }
    if (modifiers.includes("once")) {
      handler3 = wrapHandler(handler3, (next, e) => {
        next(e);
        listenerTarget.removeEventListener(event2, handler3, options);
      });
    }
    listenerTarget.addEventListener(event2, handler3, options);
    return () => {
      listenerTarget.removeEventListener(event2, handler3, options);
    };
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function debounce(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event2) {
    return ["keydown", "keyup"].includes(event2);
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
    let keyModifiers = modifiers.filter((i) => {
      return !["window", "document", "prevent", "stop", "once"].includes(i);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyModifiers[0] === keyToModifier(e.key))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (keyModifiers[0] === keyToModifier(e.key))
          return false;
      }
    }
    return true;
  }
  function keyToModifier(key) {
    switch (key) {
      case "/":
        return "slash";
      case " ":
      case "Spacebar":
        return "space";
      default:
        return key && kebabCase(key);
    }
  }
  directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater(el, expression);
    let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`;
    let evaluateAssignment = evaluateLater(el, assignmentExpression);
    var event2 = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let assigmentFunction = generateAssignmentFunction(el, modifiers, expression);
    let removeListener = on(el, event2, modifiers, (e) => {
      evaluateAssignment(() => {
      }, { scope: {
        $event: e,
        rightSideOfExpression: assigmentFunction
      } });
    });
    cleanup2(() => removeListener());
    el._x_forceModelUpdate = () => {
      evaluate2((value) => {
        if (value === void 0 && expression.match(/\./))
          value = "";
        window.fromModel = true;
        mutateDom(() => bind(el, "value", value));
        delete window.fromModel;
      });
    };
    effect3(() => {
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate();
    });
  });
  function generateAssignmentFunction(el, modifiers, expression) {
    if (el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    return (event2, currentValue) => {
      return mutateDom(() => {
        if (event2 instanceof CustomEvent && event2.detail !== void 0) {
          return event2.detail;
        } else if (el.type === "checkbox") {
          if (Array.isArray(currentValue)) {
            let newValue = modifiers.includes("number") ? safeParseNumber(event2.target.value) : event2.target.value;
            return event2.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
          } else {
            return event2.target.checked;
          }
        } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
          return modifiers.includes("number") ? Array.from(event2.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          }) : Array.from(event2.target.selectedOptions).map((option) => {
            return option.value || option.text;
          });
        } else {
          let rawValue = event2.target.value;
          return modifiers.includes("number") ? safeParseNumber(rawValue) : modifiers.includes("trim") ? rawValue.trim() : rawValue;
        }
      });
    };
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }) => evaluate(el, expression, {}, false)));
  directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        el.innerHTML = value;
      });
    });
  });
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  directive("bind", (el, { value, modifiers, expression, original }, { effect: effect3 }) => {
    if (!value)
      return applyBindingsObject(el, expression, original, effect3);
    if (value === "key")
      return storeKeyForXFor(el, expression);
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && expression.match(/\./))
        result = "";
      mutateDom(() => bind(el, value, result, modifiers));
    }));
  });
  function applyBindingsObject(el, expression, original, effect3) {
    let getBindings = evaluateLater(el, expression);
    let cleanupRunners = [];
    effect3(() => {
      while (cleanupRunners.length)
        cleanupRunners.pop()();
      getBindings((bindings) => {
        let attributes = Object.entries(bindings).map(([name, value]) => ({ name, value }));
        directives(el, attributes, original).map((handle) => {
          cleanupRunners.push(handle.runCleanups);
          handle();
        });
      });
    });
  }
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", skipDuringClone((el, { expression }, { cleanup: cleanup2 }) => {
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate(el, expression, { scope: dataProviderContext });
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    if (reactiveData["init"])
      reactiveData["init"]();
    cleanup2(() => {
      undo();
      reactiveData["destroy"] && reactiveData["destroy"]();
    });
  }));
  directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
    let evaluate2 = evaluateLater(el, expression);
    let hide = () => mutateDom(() => {
      el.style.display = "none";
      el._x_isShown = false;
    });
    let show = () => mutateDom(() => {
      if (el.style.length === 1 && el.style.display === "none") {
        el.removeAttribute("style");
      } else {
        el.style.removeProperty("display");
      }
      el._x_isShown = true;
    });
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once((value) => value ? show() : hide(), (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    });
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(el, el._x_keyExpression || "index");
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => el2.remove());
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject4 = (i) => typeof i === "object" && !Array.isArray(i);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i) => i + 1);
      }
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject4(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => keys.push(value2), { scope: __spreadValues({ index: key }, scope) });
          scopes.push(scope);
        });
      } else {
        for (let i = 0; i < items.length; i++) {
          let scope = getIterationScopeVariables(iteratorNames, items[i], i, items);
          evaluateKey((value) => keys.push(value), { scope: __spreadValues({ index: i }, scope) });
          scopes.push(scope);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i = 0; i < prevKeys.length; i++) {
        let key = prevKeys[i];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i = 0; i < keys.length; i++) {
        let key = keys[i];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i, 0, key);
          adds.push([lastKey, i]);
        } else if (prevIndex !== i) {
          let keyInSpot = prevKeys.splice(i, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i = 0; i < removes.length; i++) {
        let key = removes[i];
        lookup[key].remove();
        lookup[key] = null;
        delete lookup[key];
      }
      for (let i = 0; i < moves.length; i++) {
        let [keyInSpot, keyForSpot] = moves[i];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          marker.before(elInSpot);
          marker.remove();
        });
        refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i = 0; i < adds.length; i++) {
        let [lastKey2, index] = adds[i];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        let scope = scopes[index];
        let key = keys[index];
        let clone22 = document.importNode(templateEl.content, true).firstElementChild;
        addScopeToNode(clone22, reactive(scope), templateEl);
        mutateDom(() => {
          lastEl.after(clone22);
          initTree(clone22);
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone22;
      }
      for (let i = 0; i < sames.length; i++) {
        refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
      names.forEach((name, i) => {
        scopeVariables[name] = item[i];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function handler2() {
  }
  handler2.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler2);
  directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone22 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone22, {}, el);
      mutateDom(() => {
        el.after(clone22);
        initTree(clone22);
      });
      el._x_currentIfEl = clone22;
      el._x_undoIf = () => {
        clone22.remove();
        delete el._x_currentIfEl;
      };
      return clone22;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    let removeListener = on(el, value, modifiers, (e) => {
      evaluate2(() => {
      }, { scope: { $event: e }, params: [e] });
    });
    cleanup2(() => removeListener());
  }));
  alpine_default.setEvaluator(normalEvaluator);
  alpine_default.setReactivityEngine({ reactive: import_reactivity9.reactive, effect: import_reactivity9.effect, release: import_reactivity9.stop, raw: import_reactivity9.toRaw });
  var src_default = alpine_default;
  var module_default = src_default;

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent3(event2, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event2, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent3.prototype = window.Event.prototype;
      return CustomEvent3;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), submit = document.createElement("input"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to;
      form.style.display = "none";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      submit.type = "submit";
      form.appendChild(submit);
      submit.click();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global2 = globalSelf || phxWindow || global2;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event2, payload, timeout) {
      this.channel = channel;
      this.event = event2;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    /**
     *
     * @param {number} timeout
     */
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    /**
     *
     */
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    /**
     *
     * @param {*} status
     * @param {*} callback
     */
    receive(status, callback) {
      if (this.hasReceived(status)) {
        callback(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    /**
     * @private
     */
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    /**
     * @private
     */
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    /**
     * @private
     */
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    /**
     * @private
     */
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    /**
     * @private
     */
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    /**
     * @private
     */
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    /**
     * @private
     */
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    /**
     * Cancels any previous scheduleTimeout and schedules callback
     */
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(
        this.socket.onOpen(() => {
          this.rejoinTimer.reset();
          if (this.isErrored()) {
            this.rejoin();
          }
        })
      );
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    /**
     * Join the channel
     * @param {integer} timeout
     * @returns {Push}
     */
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    /**
     * Hook into channel close
     * @param {Function} callback
     */
    onClose(callback) {
      this.on(CHANNEL_EVENTS.close, callback);
    }
    /**
     * Hook into channel errors
     * @param {Function} callback
     */
    onError(callback) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    /**
     * Subscribes on channel events
     *
     * Subscription returns a ref counter, which can be used later to
     * unsubscribe the exact event listener
     *
     * @example
     * const ref1 = channel.on("event", do_stuff)
     * const ref2 = channel.on("event", do_other_stuff)
     * channel.off("event", ref1)
     * // Since unsubscription, do_stuff won't fire,
     * // while do_other_stuff will keep firing on the "event"
     *
     * @param {string} event
     * @param {Function} callback
     * @returns {integer} ref
     */
    on(event2, callback) {
      let ref = this.bindingRef++;
      this.bindings.push({ event: event2, ref, callback });
      return ref;
    }
    /**
     * Unsubscribes off of channel events
     *
     * Use the ref returned from a channel.on() to unsubscribe one
     * handler, or pass nothing for the ref to unsubscribe all
     * handlers for the given event.
     *
     * @example
     * // Unsubscribe the do_stuff handler
     * const ref1 = channel.on("event", do_stuff)
     * channel.off("event", ref1)
     *
     * // Unsubscribe all handlers from event
     * channel.off("event")
     *
     * @param {string} event
     * @param {integer} ref
     */
    off(event2, ref) {
      this.bindings = this.bindings.filter((bind2) => {
        return !(bind2.event === event2 && (typeof ref === "undefined" || ref === bind2.ref));
      });
    }
    /**
     * @private
     */
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    /**
     * Sends a message `event` to phoenix with the payload `payload`.
     * Phoenix receives this in the `handle_in(event, payload, socket)`
     * function. if phoenix replies or it times out (default 10000ms),
     * then optionally the reply can be received.
     *
     * @example
     * channel.push("event")
     *   .receive("ok", payload => console.log("phoenix replied:", payload))
     *   .receive("error", err => console.log("phoenix errored", err))
     *   .receive("timeout", () => console.log("timed out pushing"))
     * @param {string} event
     * @param {Object} payload
     * @param {number} [timeout]
     * @returns {Push}
     */
    push(event2, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event2}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event2, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    /** Leaves the channel
     *
     * Unsubscribes from server events, and
     * instructs channel to terminate on server
     *
     * Triggers onClose() hooks
     *
     * To receive leave acknowledgements, use the `receive`
     * hook to bind to the server ack, ie:
     *
     * @example
     * channel.leave().receive("ok", () => alert("left!") )
     *
     * @param {integer} timeout
     * @returns {Push}
     */
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling
     * before dispatching to the channel callbacks.
     *
     * Must return the payload, modified or unmodified
     * @param {string} event
     * @param {Object} payload
     * @param {integer} ref
     * @returns {Object}
     */
    onMessage(_event, payload, _ref) {
      return payload;
    }
    /**
     * @private
     */
    isMember(topic, event2, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event: event2, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    /**
     * @private
     */
    joinRef() {
      return this.joinPush.ref;
    }
    /**
     * @private
     */
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    /**
     * @private
     */
    trigger(event2, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event2, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind2) => bind2.event === event2);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind2 = eventBindings[i];
        bind2.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    /**
     * @private
     */
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    /**
     * @private
     */
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    /**
     * @private
     */
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    /**
     * @private
     */
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    /**
     * @private
     */
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    /**
     * @private
     */
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
      if (global2.XDomainRequest) {
        let req = new global2.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
      } else {
        let req = new global2.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback && callback(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback && callback(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback) {
          let response = this.parseJSON(req.responseText);
          callback(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix2 = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix2}${this.serialize(params)}`;
    }
  };
  var arrayBufferToBase64 = (buffer) => {
    let binary = "";
    let bytes = new Uint8Array(buffer);
    let len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.awaitingBatchAck = false;
      this.currentBatch = null;
      this.currentBatchTimer = null;
      this.batchBuffer = [];
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      this.poll();
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", "application/json", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    // we collect all pushes within the current event loop by
    // setTimeout 0, which optimizes back-to-back procedural
    // pushes against an empty buffer
    send(body) {
      if (typeof body !== "string") {
        body = arrayBufferToBase64(body);
      }
      if (this.currentBatch) {
        this.currentBatch.push(body);
      } else if (this.awaitingBatchAck) {
        this.batchBuffer.push(body);
      } else {
        this.currentBatch = [body];
        this.currentBatchTimer = setTimeout(() => {
          this.batchSend(this.currentBatch);
          this.currentBatch = null;
        }, 0);
      }
    }
    batchSend(messages) {
      this.awaitingBatchAck = true;
      this.ajax("POST", "application/x-ndjson", messages.join("\n"), () => this.onerror("timeout"), (resp) => {
        this.awaitingBatchAck = false;
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        } else if (this.batchBuffer.length > 0) {
          this.batchSend(this.batchBuffer);
          this.batchBuffer = [];
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      this.batchBuffer = [];
      clearTimeout(this.currentBatchTimer);
      this.currentBatchTimer = null;
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, contentType, body, onCallerTimeout, callback) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event2, payload] = JSON.parse(rawPayload);
        return callback({ join_ref, ref, topic, event: event2, payload });
      }
    },
    // private
    binaryEncode(message) {
      let { join_ref, ref, event: event2, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event2.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event2.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event2, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event2 = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data2 = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event: event2, payload: data2 };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event2 = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data2 = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event2, response: data2 };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event2 = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data2 = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event: event2, payload: data2 };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global2.WebSocket || LongPoll;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimeoutTimer = null;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    /**
     * Returns the LongPoll transport reference
     */
    getLongPollTransport() {
      return LongPoll;
    }
    /**
     * Disconnects and replaces the active transport
     *
     * @param {Function} newTransport - The new transport class to instantiate
     *
     */
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.sendBuffer = [];
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    /**
     * Returns the socket protocol
     *
     * @returns {string}
     */
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    /**
     * The fully qualified socket url
     *
     * @returns {string}
     */
    endPointURL() {
      let uri = Ajax.appendParams(
        Ajax.appendParams(this.endPoint, this.params()),
        { vsn: this.vsn }
      );
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    /**
     * Disconnects the socket
     *
     * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
     *
     * @param {Function} callback - Optional callback which is called after socket is disconnected.
     * @param {integer} code - A status code for disconnection (Optional).
     * @param {string} reason - A textual description of the reason to disconnect. (Optional)
     */
    disconnect(callback, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.teardown(callback, code, reason);
    }
    /**
     *
     * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
     *
     * Passing params to connect is deprecated; pass them in the Socket constructor instead:
     * `new Socket("/socket", {params: {user_id: userToken}})`.
     */
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error2) => this.onConnError(error2);
      this.conn.onmessage = (event2) => this.onConnMessage(event2);
      this.conn.onclose = (event2) => this.onConnClose(event2);
    }
    /**
     * Logs the message. Override `this.logger` for specialized logging. noops by default
     * @param {string} kind
     * @param {string} msg
     * @param {Object} data
     */
    log(kind, msg, data2) {
      this.logger(kind, msg, data2);
    }
    /**
     * Returns true if a logger has been set on this socket.
     */
    hasLogger() {
      return this.logger !== null;
    }
    /**
     * Registers callbacks for connection open events
     *
     * @example socket.onOpen(function(){ console.info("the socket was opened") })
     *
     * @param {Function} callback
     */
    onOpen(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback]);
      return ref;
    }
    /**
     * Registers callbacks for connection close events
     * @param {Function} callback
     */
    onClose(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback]);
      return ref;
    }
    /**
     * Registers callbacks for connection error events
     *
     * @example socket.onError(function(error){ alert("An error occurred") })
     *
     * @param {Function} callback
     */
    onError(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback]);
      return ref;
    }
    /**
     * Registers callbacks for connection message events
     * @param {Function} callback
     */
    onMessage(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback]);
      return ref;
    }
    /**
     * Pings the server and invokes the callback with the RTT in milliseconds
     * @param {Function} callback
     *
     * Returns true if the ping was pushed or false if unable to be pushed.
     */
    ping(callback) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback(Date.now() - startTime);
        }
      });
      return true;
    }
    /**
     * @private
     */
    clearHeartbeats() {
      clearTimeout(this.heartbeatTimer);
      clearTimeout(this.heartbeatTimeoutTimer);
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
    }
    /**
     * @private
     */
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.triggerChanError();
        this.closeWasClean = false;
        this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      this.clearHeartbeats();
      this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback, code, reason) {
      if (!this.conn) {
        return callback && callback();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onopen = function() {
            };
            this.conn.onerror = function() {
            };
            this.conn.onmessage = function() {
            };
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback && callback();
        });
      });
    }
    waitForBufferDone(callback, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event2) {
      let closeCode = event2 && event2.code;
      if (this.hasLogger())
        this.log("transport", "close", event2);
      this.triggerChanError();
      this.clearHeartbeats();
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event2));
    }
    /**
     * @private
     */
    onConnError(error2) {
      if (this.hasLogger())
        this.log("transport", error2);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback]) => {
        callback(error2, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    /**
     * @private
     */
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    /**
     * @returns {string}
     */
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    /**
     * @returns {boolean}
     */
    isConnected() {
      return this.connectionState() === "open";
    }
    /**
     * @private
     *
     * @param {Channel}
     */
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    /**
     * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
     *
     * @param {refs} - list of refs returned by calls to
     *                 `onOpen`, `onClose`, `onError,` and `onMessage`
     */
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    /**
     * Initiates a new channel for the given topic
     *
     * @param {string} topic
     * @param {Object} chanParams - Parameters for the channel
     * @returns {Channel}
     */
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    /**
     * @param {Object} data
     */
    push(data2) {
      if (this.hasLogger()) {
        let { topic, event: event2, payload, ref, join_ref } = data2;
        this.log("push", `${topic} ${event2} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data2, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data2, (result) => this.conn.send(result)));
      }
    }
    /**
     * Return the next message ref, accounting for overflows
     * @returns {string}
     */
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event: event2, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          this.clearHeartbeats();
          this.pendingHeartbeatRef = null;
          this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event2} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event2, payload, join_ref)) {
            continue;
          }
          channel.trigger(event2, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback] = this.stateChangeCallbacks.message[i];
          callback(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // js/app.js
  var import_topbar = __toESM(require_topbar_min());

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_LOADING_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_CLIENT_ERROR_CLASS = "phx-client-error";
  var PHX_SERVER_ERROR_CLASS = "phx-server-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_VIEWPORT_TOP = "viewport-top";
  var PHX_VIEWPORT_BOTTOM = "viewport-bottom";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_STREAM = "stream";
  var PHX_STREAM_REF = "data-phx-stream";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var PHX_MOUNTED = "mounted";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var STREAM = "stream";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.errored = false;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      if (this.errored) {
        return;
      }
      this.errored = true;
      clearTimeout(this.chunkTimer);
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      }).receive("error", ({ reason }) => this.error(reason));
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone2 = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`) && !el.disabled) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback) => el && callback(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to) {
      if (this.canPushState()) {
        if (to !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback ? array.forEach(callback) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    findUploadInputs(node) {
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    wantsNewTab(e) {
      let wantsNewTab = e.ctrlKey || e.shiftKey || e.metaKey || e.button && e.button === 1;
      let isDownload = e.target instanceof HTMLAnchorElement && e.target.hasAttribute("download");
      let isTargetBlank = e.target.hasAttribute("target") && e.target.getAttribute("target").toLowerCase() === "_blank";
      return wantsNewTab || isTargetBlank || isDownload;
    },
    isUnloadableFormSubmit(e) {
      return !e.defaultPrevented && !this.wantsNewTab(e);
    },
    isNewPageClick(e, currentLocation) {
      let href = e.target instanceof HTMLAnchorElement ? e.target.getAttribute("href") : null;
      let url;
      if (e.defaultPrevented || href === null || this.wantsNewTab(e)) {
        return false;
      }
      if (href.startsWith("mailto:") || href.startsWith("tel:")) {
        return false;
      }
      try {
        url = new URL(href);
      } catch (e2) {
        try {
          url = new URL(href, currentLocation);
        } catch (e3) {
          return true;
        }
      }
      if (url.host === currentLocation.host && url.protocol === currentLocation.protocol) {
        if (url.pathname === currentLocation.pathname && url.search === currentLocation.search) {
          return url.hash === "" && !url.href.endsWith("#");
        }
      }
      return url.protocol.startsWith("http");
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findParentCIDs(node, cids) {
      let initial = new Set(cids);
      let parentCids = cids.reduce((acc, cid) => {
        let selector = `[${PHX_COMPONENT}="${cid}"] [${PHX_COMPONENT}]`;
        this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));
        return acc;
      }, initial);
      return parentCids.size === 0 ? new Set(cids) : parentCids;
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      if (titleEl) {
        let { prefix: prefix2, suffix } = titleEl.dataset;
        document.title = `${prefix2 || ""}${str}${suffix || ""}`;
      } else {
        document.title = str;
      }
    },
    debounce(el, event2, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback) {
      let debounce2 = el.getAttribute(phxDebounce);
      let throttle2 = el.getAttribute(phxThrottle);
      if (debounce2 === "") {
        debounce2 = defaultDebounce;
      }
      if (throttle2 === "") {
        throttle2 = defaultThrottle;
      }
      let value = debounce2 || throttle2;
      switch (value) {
        case null:
          return callback();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle2 ? this.deletePrivate(el, THROTTLED) : callback();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle2) {
            let newKeyDown = false;
            if (event2.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event2.key);
              newKeyDown = prevKey !== event2.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback();
              this.putPrivate(el, THROTTLED, true);
              setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el, DEBOUNCE_TRIGGER);
                }
              }, timeout);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    maybeAddPrivateHooks(el, phxViewportTop, phxViewportBottom) {
      if (el.hasAttribute && (el.hasAttribute(phxViewportTop) || el.hasAttribute(phxViewportBottom))) {
        el.setAttribute("data-phx-hook", "Phoenix.InfiniteScroll");
      }
    },
    maybeHideFeedback(container, input, phxFeedbackFor) {
      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input, PHX_HAS_SUBMITTED))) {
        let feedbacks = [input.name];
        if (input.name.endsWith("[]")) {
          feedbacks.push(input.name.slice(0, -2));
        }
        let selector = feedbacks.map((f) => `[${phxFeedbackFor}="${f}"]`).join(", ");
        DOM.all(container, selector, (el) => el.classList.add(PHX_NO_FEEDBACK_CLASS));
      }
    },
    resetForm(form, phxFeedbackFor) {
      Array.from(form.elements).forEach((input) => {
        let query = `[${phxFeedbackFor}="${input.id}"],
                   [${phxFeedbackFor}="${input.name}"],
                   [${phxFeedbackFor}="${input.name.replace(/\[\]$/, "")}"]`;
        this.deletePrivate(input, PHX_HAS_FOCUSED);
        this.deletePrivate(input, PHX_HAS_SUBMITTED);
        this.all(document, query, (feedbackEl) => {
          feedbackEl.classList.add(PHX_NO_FEEDBACK_CLASS);
        });
      });
    },
    showError(inputEl, phxFeedbackFor) {
      if (inputEl.id || inputEl.name) {
        this.all(inputEl.form, `[${phxFeedbackFor}="${inputEl.id}"], [${phxFeedbackFor}="${inputEl.name}"]`, (el) => {
          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let bubbles = opts.bubbles === void 0 ? true : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event2 = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event2);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = opts.exclude || [];
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (exclude.indexOf(name) < 0) {
          target.setAttribute(name, source.getAttribute(name));
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    constructor(fileEl, file, view) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    cancel() {
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      LiveUploader.clearFiles(this.fileEl);
    }
    onDone(callback) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        relative_path: this.file.webkitRelativePath,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.last_modified = file.lastModified;
        entry.name = file.name || entry.ref;
        entry.relative_path = file.webkitRelativePath;
        entry.type = file.type;
        entry.size = file.size;
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files, dataTransfer) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.putPrivate(inputEl, "files", this.activeFiles(inputEl).concat(newFiles));
        inputEl.value = null;
      } else {
        if (dataTransfer && dataTransfer.files.length > 0) {
          inputEl.files = dataTransfer.files;
        }
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));
    }
    constructor(inputEl, view, onComplete) {
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));
      this.numEntriesInProgress = this._entries.length;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        entry.zipPostFlight(resp);
        entry.onDone(() => {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        });
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        let { name, callback } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback, entries } = groupedEntries[name];
        callback(entries, onError, resp, liveSocket2);
      }
    }
  };
  var ARIA = {
    focusMain() {
      let target = document.querySelector("main h1, main, h1");
      if (target) {
        let origTabIndex = target.tabIndex;
        target.tabIndex = -1;
        target.focus();
        target.tabIndex = origTabIndex;
      }
    },
    anyOf(instance, classes2) {
      return classes2.find((name) => instance instanceof name);
    },
    isFocusable(el, interactiveOnly) {
      return el instanceof HTMLAnchorElement && el.rel !== "ignore" || el instanceof HTMLAreaElement && el.href !== void 0 || !el.disabled && this.anyOf(el, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLButtonElement]) || el instanceof HTMLIFrameElement || (el.tabIndex > 0 || !interactiveOnly && el.tabIndex === 0 && el.getAttribute("tabindex") !== null && el.getAttribute("aria-hidden") !== "true");
    },
    attemptFocus(el, interactiveOnly) {
      if (this.isFocusable(el, interactiveOnly)) {
        try {
          el.focus();
        } catch (e) {
        }
      }
      return !!document.activeElement && document.activeElement.isSameNode(el);
    },
    focusFirstInteractive(el) {
      let child = el.firstElementChild;
      while (child) {
        if (this.attemptFocus(child, true) || this.focusFirstInteractive(child, true)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusFirst(el) {
      let child = el.firstElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusFirst(child)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusLast(el) {
      let child = el.lastElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusLast(child)) {
          return true;
        }
        child = child.previousElementSibling;
      }
    }
  };
  var aria_default = ARIA;
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    },
    FocusWrap: {
      mounted() {
        this.focusStart = this.el.firstElementChild;
        this.focusEnd = this.el.lastElementChild;
        this.focusStart.addEventListener("focus", () => aria_default.focusLast(this.el));
        this.focusEnd.addEventListener("focus", () => aria_default.focusFirst(this.el));
        this.el.addEventListener("phx:show-end", () => this.el.focus());
        if (window.getComputedStyle(this.el).display !== "none") {
          aria_default.focusFirst(this.el);
        }
      }
    }
  };
  var scrollTop = () => document.documentElement.scrollTop || document.body.scrollTop;
  var winHeight = () => window.innerHeight || document.documentElement.clientHeight;
  var isAtViewportTop = (el) => {
    let rect = el.getBoundingClientRect();
    return rect.top >= 0 && rect.left >= 0 && rect.top <= winHeight();
  };
  var isAtViewportBottom = (el) => {
    let rect = el.getBoundingClientRect();
    return rect.right >= 0 && rect.left >= 0 && rect.bottom <= winHeight();
  };
  var isWithinViewport = (el) => {
    let rect = el.getBoundingClientRect();
    return rect.top >= 0 && rect.left >= 0 && rect.top <= winHeight();
  };
  Hooks.InfiniteScroll = {
    mounted() {
      let scrollBefore = scrollTop();
      let topOverran = false;
      let throttleInterval = 500;
      let pendingOp = null;
      let onTopOverrun = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => true;
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id, _overran: true }, () => {
          pendingOp = null;
        });
      });
      let onFirstChildAtTop = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => firstChild.scrollIntoView({ block: "start" });
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id }, () => {
          pendingOp = null;
          if (!isWithinViewport(firstChild)) {
            firstChild.scrollIntoView({ block: "start" });
          }
        });
      });
      let onLastChildAtBottom = this.throttle(throttleInterval, (bottomEvent, lastChild) => {
        pendingOp = () => lastChild.scrollIntoView({ block: "end" });
        this.liveSocket.execJSHookPush(this.el, bottomEvent, { id: lastChild.id }, () => {
          pendingOp = null;
          if (!isWithinViewport(lastChild)) {
            lastChild.scrollIntoView({ block: "end" });
          }
        });
      });
      this.onScroll = (e) => {
        let scrollNow = scrollTop();
        if (pendingOp) {
          scrollBefore = scrollNow;
          return pendingOp();
        }
        let rect = this.el.getBoundingClientRect();
        let topEvent = this.el.getAttribute(this.liveSocket.binding("viewport-top"));
        let bottomEvent = this.el.getAttribute(this.liveSocket.binding("viewport-bottom"));
        let lastChild = this.el.lastElementChild;
        let firstChild = this.el.firstElementChild;
        let isScrollingUp = scrollNow < scrollBefore;
        let isScrollingDown = scrollNow > scrollBefore;
        if (isScrollingUp && topEvent && !topOverran && rect.top >= 0) {
          topOverran = true;
          onTopOverrun(topEvent, firstChild);
        } else if (isScrollingDown && topOverran && rect.top <= 0) {
          topOverran = false;
        }
        if (topEvent && isScrollingUp && isAtViewportTop(firstChild)) {
          onFirstChildAtTop(topEvent, firstChild);
        } else if (bottomEvent && isScrollingDown && isAtViewportBottom(lastChild)) {
          onLastChildAtBottom(bottomEvent, lastChild);
        }
        scrollBefore = scrollNow;
      };
      window.addEventListener("scroll", this.onScroll);
    },
    destroyed() {
      window.removeEventListener("scroll", this.onScroll);
    },
    throttle(interval, callback) {
      let lastCallAt = 0;
      let timer;
      return (...args) => {
        let now2 = Date.now();
        let remainingTime = interval - (now2 - lastCallAt);
        if (remainingTime <= 0 || remainingTime > interval) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          lastCallAt = now2;
          callback(...args);
        } else if (!timer) {
          timer = setTimeout(() => {
            lastCallAt = Date.now();
            timer = null;
            callback(...args);
          }, remainingTime);
        }
      };
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
        toNode = toNode.firstElementChild;
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var skipFromChildren = options.skipFromChildren || noop;
      var addChild = options.addChild || function(parent, child) {
        return parent.appendChild(child);
      };
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var skipFrom = skipFromChildren(fromEl);
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (!skipFrom && curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              if (!skipFrom) {
                addChild(fromEl, matchingFromEl);
              }
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                addChild(fromEl, curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, streams, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.streams = streams;
      this.streamInserts = {};
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.pendingRemoves = [];
      this.phxRemove = this.liveSocket.binding("remove");
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback) {
      this.callbacks[`before${kind}`].push(callback);
    }
    after(kind, callback) {
      this.callbacks[`after${kind}`].push(callback);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
    }
    markPrunableContentForRemoval() {
      let phxUpdate = this.liveSocket.binding(PHX_UPDATE);
      dom_default.all(this.container, `[${phxUpdate}=${PHX_STREAM}]`, (el) => el.innerHTML = "");
      dom_default.all(this.container, `[${phxUpdate}=append] > *, [${phxUpdate}=prepend] > *`, (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform() {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxViewportTop = liveSocket2.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = liveSocket2.binding(PHX_VIEWPORT_BOTTOM);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let added = [];
      let trackedInputs = [];
      let updates = [];
      let appendPrependUpdates = [];
      let externalFormTriggered = null;
      let diffHTML = liveSocket2.time("premorph container prep", () => {
        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);
      });
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        this.streams.forEach(([ref, inserts, deleteIds, reset]) => {
          Object.entries(inserts).forEach(([key, [streamAt, limit]]) => {
            this.streamInserts[key] = { ref, streamAt, limit };
          });
          if (reset !== void 0) {
            dom_default.all(container, `[${PHX_STREAM_REF}="${ref}"]`, (child) => {
              this.removeStreamChildElement(child);
            });
          }
          deleteIds.forEach((id) => {
            let child = container.querySelector(`[id="${id}"]`);
            if (child) {
              this.removeStreamChildElement(child);
            }
          });
        });
        morphdom_esm_default(targetContainer, diffHTML, {
          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            return dom_default.isPhxDestroyed(node) ? null : node.id;
          },
          skipFromChildren: (from) => {
            return from.getAttribute(phxUpdate) === PHX_STREAM;
          },
          addChild: (parent, child) => {
            let { ref, streamAt, limit } = this.getStreamInsert(child);
            if (ref === void 0) {
              return parent.appendChild(child);
            }
            dom_default.putSticky(child, PHX_STREAM_REF, (el) => el.setAttribute(PHX_STREAM_REF, ref));
            if (streamAt === 0) {
              parent.insertAdjacentElement("afterbegin", child);
            } else if (streamAt === -1) {
              parent.appendChild(child);
            } else if (streamAt > 0) {
              let sibling = Array.from(parent.children)[streamAt];
              parent.insertBefore(child, sibling);
            }
            let children = limit !== null && Array.from(parent.children);
            let childrenToRemove = [];
            if (limit && limit < 0 && children.length > limit * -1) {
              childrenToRemove = children.slice(0, children.length + limit);
            } else if (limit && limit >= 0 && children.length > limit) {
              childrenToRemove = children.slice(limit);
            }
            childrenToRemove.forEach((removeChild) => {
              if (!this.streamInserts[removeChild.id]) {
                this.removeStreamChildElement(removeChild);
              }
            });
          },
          onBeforeNodeAdded: (el) => {
            dom_default.maybeAddPrivateHooks(el, phxViewportTop, phxViewportBottom);
            this.trackBefore("added", el);
            return el;
          },
          onNodeAdded: (el) => {
            if (el.getAttribute) {
              this.maybeReOrderStream(el);
            }
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            if (el.getAttribute && el.getAttribute("name") && dom_default.isFormInput(el)) {
              trackedInputs.push(el);
            }
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => this.onNodeDiscarded(el),
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentElement !== null && el.id && dom_default.isPhxUpdate(el.parentElement, phxUpdate, [PHX_STREAM, "append", "prepend"])) {
              return false;
            }
            if (this.maybePendingRemove(el)) {
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
            this.maybeReOrderStream(el);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.maybeAddPrivateHooks(toEl, phxViewportTop, phxViewportBottom);
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate) || fromEl.form && fromEl.form.isSameNode(externalFormTriggered)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            if (isFocusedFormEl && fromEl.type !== "hidden") {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              trackedInputs.push(fromEl);
              return false;
            } else {
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              if (toEl.getAttribute("name") && dom_default.isFormInput(toEl)) {
                trackedInputs.push(toEl);
              }
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update2) => update2.perform());
        });
      }
      trackedInputs.forEach((input) => {
        dom_default.maybeHideFeedback(targetContainer, input, phxFeedbackFor);
      });
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      this.transitionPendingRemoves();
      if (externalFormTriggered) {
        liveSocket2.unload();
        externalFormTriggered.submit();
      }
      return true;
    }
    onNodeDiscarded(el) {
      if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
        this.liveSocket.destroyViewByEl(el);
      }
      this.trackAfter("discarded", el);
    }
    maybePendingRemove(node) {
      if (node.getAttribute && node.getAttribute(this.phxRemove) !== null) {
        this.pendingRemoves.push(node);
        return true;
      } else {
        return false;
      }
    }
    removeStreamChildElement(child) {
      if (!this.maybePendingRemove(child)) {
        child.remove();
        this.onNodeDiscarded(child);
      }
    }
    getStreamInsert(el) {
      let insert = el.id ? this.streamInserts[el.id] : {};
      return insert || {};
    }
    maybeReOrderStream(el) {
      let { ref, streamAt, limit } = this.getStreamInsert(el);
      if (streamAt === void 0) {
        return;
      }
      dom_default.putSticky(el, PHX_STREAM_REF, (el2) => el2.setAttribute(PHX_STREAM_REF, ref));
      if (streamAt === 0) {
        el.parentElement.insertBefore(el, el.parentElement.firstElementChild);
      } else if (streamAt > 0) {
        let children = Array.from(el.parentElement.children);
        let oldIndex = children.indexOf(el);
        if (streamAt >= children.length - 1) {
          el.parentElement.appendChild(el);
        } else {
          let sibling = children[streamAt];
          if (oldIndex > streamAt) {
            el.parentElement.insertBefore(el, sibling);
          } else {
            el.parentElement.insertBefore(el, sibling.nextElementSibling);
          }
        }
      }
    }
    transitionPendingRemoves() {
      let { pendingRemoves, liveSocket: liveSocket2 } = this;
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    buildDiffHTML(container, html, phxUpdate, targetContainer) {
      let isCIDPatch = this.isCIDPatch();
      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();
      if (!isCIDPatch || isCIDWithSingleRoot) {
        return html;
      } else {
        let diffContainer = null;
        let template = document.createElement("template");
        diffContainer = dom_default.cloneNode(targetContainer);
        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);
        template.innerHTML = html;
        rest.forEach((el) => el.remove());
        Array.from(diffContainer.childNodes).forEach((child) => {
          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
        });
        Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));
        firstComponent.remove();
        return diffContainer.outerHTML;
      }
    }
    indexOf(parent, child) {
      return Array.from(parent.children).indexOf(child);
    }
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events2, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events2 || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      let [str, streams] = this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);
      return [str, streams];
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids, streams: /* @__PURE__ */ new Set() };
      this.toOutputBuffer(rendered, null, output);
      return [output.buffer, output.streams];
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        let isObjVal = isObject(val);
        if (isObjVal && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
    }
    cloneMerge(target, source) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val);
        }
      }
      return merged;
    }
    componentToString(cid) {
      let [str, streams] = this.recursiveCIDToString(this.rendered[COMPONENTS], cid);
      return [str, streams];
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    toOutputBuffer(rendered, templates, output) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output);
        output.buffer += statics[i];
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics, [STREAM]: stream } = rendered;
      let [_ref, _inserts, deleteIds, reset] = stream || [null, {}, [], null];
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);
          output.buffer += statics[i];
        }
      }
      if (stream !== void 0 && (rendered[DYNAMICS].length > 0 || deleteIds.length > 0 || reset)) {
        delete rendered[STREAM];
        output.streams.add(stream);
      }
    }
    dynamicToBuffer(rendered, templates, output) {
      if (typeof rendered === "number") {
        let [str, streams] = this.recursiveCIDToString(output.components, rendered, output.onlyCids);
        output.buffer += str;
        output.streams = /* @__PURE__ */ new Set([...output.streams, ...streams]);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output);
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let template = document.createElement("template");
      let [html, streams] = this.recursiveToString(component, components, onlyCids);
      template.innerHTML = html;
      let container = template.content;
      let skip = onlyCids && !onlyCids.has(cid);
      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          if (child.getAttribute(PHX_COMPONENT)) {
            return [hasNodes, true];
          }
          child.setAttribute(PHX_COMPONENT, cid);
          if (!child.id) {
            child.id = `${this.parentViewId()}-${cid}-${i}`;
          }
          if (skip) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
          return [true, hasComponents];
        } else {
          if (child.nodeValue.trim() !== "") {
            logError(`only HTML element tags are allowed at the root of components.

got: "${child.nodeValue.trim()}"

within:
`, template.innerHTML.trim());
            child.replaceWith(this.createSpan(child.nodeValue, cid));
            return [true, hasComponents];
          } else {
            child.remove();
            return [hasNodes, hasComponents];
          }
        }
      }, [false, false]);
      if (!hasChildNodes && !hasChildComponents) {
        logError("expected at least one HTML element tag inside a component, but the component is empty:\n", template.innerHTML.trim());
        return [this.createSpan("", cid).outerHTML, streams];
      } else if (!hasChildNodes && hasChildComponents) {
        logError("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", template.innerHTML.trim());
        return [template.innerHTML, streams];
      } else {
        return [template.innerHTML, streams];
      }
    }
    createSpan(text, cid) {
      let span = document.createElement("span");
      span.innerText = text;
      span.setAttribute(PHX_COMPONENT, cid);
      return span;
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event2, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(this.el, null, event2, payload, onReply);
    }
    pushEventTo(phxTarget, event2, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(this.el, targetCtx, event2, payload, onReply);
      });
    }
    handleEvent(event2, callback) {
      let callbackRef = (customEvent, bypass) => bypass ? event2 : callback(customEvent.detail);
      window.addEventListener(`phx:${event2}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event2 = callbackRef(null, true);
      window.removeEventListener(`phx:${event2}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var focusStack = null;
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults2) {
      let [defaultKind, defaultArgs] = defaults2 || [null, { callback: defaults2 && defaults2.callback }];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
          args.callback = args.callback || defaultArgs.callback;
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    exec_exec(eventType, phxEvent, view, sourceEl, el, [attr, to]) {
      let nodes = to ? dom_default.all(document, to) : [sourceEl];
      nodes.forEach((node) => {
        let encodedJS = node.getAttribute(attr);
        if (!encodedJS) {
          throw new Error(`expected ${attr} to contain JS command on "${to}"`);
        }
        view.liveSocket.execJS(node, encodedJS, eventType);
      });
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event: event2, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event2, { detail, bubbles });
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      if (!view.isConnected()) {
        return;
      }
      let { event: event2, data: data2, target, page_loading, loading, value, dispatcher, callback } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (eventType === "change") {
          let { newCid, _target } = args;
          _target = _target || (dom_default.isFormInput(sourceEl) ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event2 || phxEvent, pushOpts, callback);
        } else if (eventType === "submit") {
          let { submitter } = args;
          targetView.submitForm(sourceEl, targetCtx, event2 || phxEvent, submitter, pushOpts, callback);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event2 || phxEvent, data2, pushOpts, callback);
        }
      });
    },
    exec_navigate(eventType, phxEvent, view, sourceEl, el, { href, replace }) {
      view.liveSocket.historyRedirect(href, replace ? "replace" : "push");
    },
    exec_patch(eventType, phxEvent, view, sourceEl, el, { href, replace }) {
      view.liveSocket.pushHistoryPatch(href, replace ? "replace" : "push", sourceEl);
    },
    exec_focus(eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => aria_default.attemptFocus(el));
    },
    exec_focus_first(eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el));
    },
    exec_push_focus(eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => focusStack = el || sourceEl);
    },
    exec_pop_focus(eventType, phxEvent, view, sourceEl, el) {
      window.requestAnimationFrame(() => {
        if (focusStack) {
          focusStack.focus();
        }
        focusStack = null;
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition: transition3, time }) {
      this.addOrRemoveClasses(el, names, [], transition3, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition: transition3, time }) {
      this.addOrRemoveClasses(el, [], names, transition3, time, view);
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition: transition3 }) {
      this.addOrRemoveClasses(el, [], [], transition3, time, view);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition: transition3, time }) {
      this.show(eventType, view, el, display, transition3, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition: transition3, time }) {
      this.hide(eventType, view, el, display, transition3, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition3, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition3, null, time);
      }
    },
    hide(eventType, view, el, display, transition3, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition3, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            let stickyDisplay = display || this.defaultDisplay(el);
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            let stickyDisplay = display || this.defaultDisplay(el);
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    addOrRemoveClasses(el, adds, removes, transition3, time, view) {
      let [transition_run, transition_start, transition_end] = transition3 || [[], [], []];
      if (transition_run.length > 0) {
        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes2) {
      return classes2.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to }) {
      return to ? dom_default.all(document, to) : [sourceEl];
    },
    defaultDisplay(el) {
      return { tr: "table-row", td: "table-cell" }[el.tagName.toLowerCase()] || "block";
    }
  };
  var js_default = JS;
  var serializeForm = (form, metadata, onlyNames = []) => {
    let _a = metadata, { submitter } = _a, meta = __objRest(_a, ["submitter"]);
    let formData = new FormData(form);
    if (submitter && submitter.hasAttribute("name") && submitter.form && submitter.form === form) {
      formData.append(submitter.name, submitter.value);
    }
    let toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    let params = new URLSearchParams();
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        params.append(key, val);
      }
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash, liveReferer) {
      this.isDead = false;
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pruningCIDs = [];
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.uploaders = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        return {
          redirect: this.redirect ? this.href : void 0,
          url: this.redirect ? void 0 : this.href || void 0,
          params: this.connectParams(liveReferer),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.hasAttribute(PHX_MAIN);
    }
    connectParams(liveReferer) {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      params["_live_referer"] = liveReferer;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes2) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_CLIENT_ERROR_CLASS, PHX_SERVER_ERROR_CLASS);
      this.el.classList.add(...classes2);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_LOADING_CLASS);
      }
    }
    execAll(binding) {
      dom_default.all(this.el, `[${binding}]`, (el) => this.liveSocket.execJS(el, el.getAttribute(binding)));
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
      this.execAll(this.binding("connected"));
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback) {
      this.log(type, () => ["", clone2(rawDiff)]);
      let { diff, reply, events: events2, title } = Rendered.extract(rawDiff);
      callback({ diff, reply, events: events2 });
      if (title) {
        window.requestAnimationFrame(() => dom_default.putTitle(title));
      }
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events: events2 }) => {
        this.rendered = new Rendered(this.id, diff);
        let [html, streams] = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html);
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pushFormRecovery(form, newCid, (resp2) => {
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, streams, events2);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, streams, events2);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, streams, events2) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, streams, events2);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events2)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, streams, events2);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events2)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    execNewMounted() {
      let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
      dom_default.all(this.el, `[${phxViewportTop}], [${phxViewportBottom}]`, (hookEl) => {
        dom_default.maybeAddPrivateHooks(hookEl, phxViewportTop, phxViewportBottom);
        this.maybeAddNewHook(hookEl);
      });
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        this.maybeAddNewHook(hookEl);
      });
      dom_default.all(this.el, `[${this.binding(PHX_MOUNTED)}]`, (el) => this.maybeMounted(el));
    }
    applyJoinPatch(live_patch, html, streams, events2) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false);
      this.joinNewChildren();
      this.execNewMounted();
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events2);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to } = live_patch;
        this.liveSocket.historyPatch(to, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    maybeMounted(el) {
      let phxMounted = el.getAttribute(this.binding(PHX_MOUNTED));
      let hasBeenInvoked = phxMounted && dom_default.private(el, "mounted");
      if (phxMounted && !hasBeenInvoked) {
        this.liveSocket.execJS(el, phxMounted);
        dom_default.putPrivate(el, "mounted", true);
      }
    }
    maybeAddNewHook(el, force) {
      let newHook = this.addHook(el);
      if (newHook) {
        newHook.__mounted();
      }
    }
    performPatch(patch, pruneCids) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        this.maybeAddNewHook(el);
        if (el.getAttribute) {
          this.maybeMounted(el);
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform();
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements, pruneCids) {
      let destroyedCIDs = [];
      elements.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks2 = dom_default.all(parent, `[${this.binding(PHX_HOOK)}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks2.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events2) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && this.root.isMain()) {
        return this.pendingDiffs.push({ diff, events: events2 });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let [html, streams] = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events2);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;
        let [html, streams] = this.rendered.toString(cids);
        return [`<${tag}>${html}</${tag}>`, streams];
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let [html, streams] = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, streams, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events: events2 }) => this.update(diff, events2));
      this.pendingDiffs = [];
      this.eachChild((child) => child.applyPendingUpdates());
    }
    eachChild(callback) {
      let children = this.root.children[this.id] || {};
      for (let id in children) {
        callback(this.getChildById(id));
      }
    }
    onChannel(event2, cb) {
      this.liveSocket.onChannel(this.channel, event2, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events: events2 }) => this.update(diff, events2));
        });
      });
      this.onChannel("redirect", ({ to, flash }) => this.onRedirect({ to, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      this.eachChild((child) => child.destroy());
    }
    onLiveRedirect(redir) {
      let { to, kind, flash } = redir;
      let url = this.expandURL(to);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to, kind } = redir;
      this.href = this.expandURL(to);
      this.liveSocket.historyPatch(to, kind);
    }
    expandURL(to) {
      return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
    }
    onRedirect({ to, flash }) {
      this.liveSocket.redirect(to, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    joinDead() {
      this.isDead = true;
    }
    join(callback) {
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback ? callback(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data2) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data2));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "reload") {
        this.log("error", () => [`failed mount with ${resp.status}. Falling back to page request`, resp]);
        return this.onRedirect({ to: this.href });
      } else if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        return this.onRedirect({ to: this.href });
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
      this.log("error", () => ["unable to join", resp]);
      if (this.liveSocket.isConnected()) {
        this.liveSocket.reloadWithJitter(this);
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        if (this.liveSocket.isConnected()) {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
        } else {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_CLIENT_ERROR_CLASS]);
        }
      }
    }
    displayError(classes2) {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(...classes2);
      this.execAll(this.binding("disconnected"));
    }
    pushWithReply(refGenerator, event2, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event2, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              this.applyDiff("update", resp.diff, ({ diff, reply, events: events2 }) => {
                if (ref !== null) {
                  this.undoRefs(ref);
                }
                this.update(diff, events2);
                finish(reply);
              });
            });
          } else {
            if (ref !== null) {
              this.undoRefs(ref);
            }
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      if (!this.isConnected()) {
        return;
      }
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (el.getAttribute(PHX_READONLY) !== null) {
          el.readOnly = false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements, event2, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements = elements.concat(dom_default.all(document, opts.loading));
      }
      elements.forEach((el) => {
        el.classList.add(`phx-${event2}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(el, targetCtx, event2, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event2, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([el], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event: event2,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix2 = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix2)) {
          meta[name.replace(prefix2, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0 && !(el instanceof HTMLFormElement)) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}, onReply) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      }, (resp, reply) => onReply && onReply(reply));
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData;
      let meta = this.extractMeta(inputEl.form);
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, __spreadValues({ _target: opts._target }, meta), [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, __spreadValues({ _target: opts._target }, meta));
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event2 = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event2, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));
        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute("data-phx-auto-upload") !== null) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback && callback(resp);
              this.triggerAwaitingSubmit(inputEl.form);
            });
          }
        } else {
          callback && callback(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    disableForm(formEl, opts = {}) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let formElements = Array.from(formEl.elements);
      let disables = formElements.filter(filterDisables);
      let buttons = formElements.filter(filterButton).filter(filterIgnored);
      let inputs = formElements.filter(filterInput).filter(filterIgnored);
      buttons.forEach((button) => {
        button.setAttribute(PHX_DISABLED, button.disabled);
        button.disabled = true;
      });
      inputs.forEach((input) => {
        input.setAttribute(PHX_READONLY, input.readOnly);
        input.readOnly = true;
        if (input.files) {
          input.setAttribute(PHX_DISABLED, input.disabled);
          input.disabled = true;
        }
      });
      formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
      return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply) {
      let refGenerator = () => this.disableForm(formEl, opts);
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, submitter, targetCtx, phxEvent, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {
          let meta = this.extractMeta(formEl);
          let formData = serializeForm(formEl, __spreadValues({ submitter }, meta));
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else if (!(formEl.hasAttribute(PHX_REF) && formEl.classList.contains("phx-submit-loading"))) {
        let meta = this.extractMeta(formEl);
        let formData = serializeForm(formEl, __spreadValues({ submitter }, meta));
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        this.uploaders[inputEl] = uploader;
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          if (resp.error) {
            this.undoRefs(ref);
            let [entry_ref, reason] = resp.error;
            this.log("upload", () => [`error for entry ${entry_ref}`, reason]);
          } else {
            let onError = (callback) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    dispatchUploads(name, filesOrBlobs) {
      let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    pushFormRecovery(form, newCid, callback) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let phxChange = this.binding("change");
        let inputs = Array.from(form.elements).filter((el) => dom_default.isFormInput(el) && el.name && !el.hasAttribute(phxChange));
        if (inputs.length === 0) {
          return;
        }
        let input = inputs.find((el) => el.type !== "hidden") || input[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback }]);
      });
    }
    pushLinkPatch(href, targetEl, callback) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let url = href.startsWith("/") ? `${location.protocol}//${location.host}${href}` : href;
      let push = this.pushWithReply(refGen, "live_patch", { url }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback && callback(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${form.getAttribute(phxChange)}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, form, this.targetComponentID(form)];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        this.pruningCIDs.push(...willDestroyCIDs);
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      let parentViewEl = el.closest(PHX_VIEW_SELECTOR);
      return el.getAttribute(PHX_PARENT_ID) === this.id || parentViewEl && parentViewEl.id === this.id || !parentViewEl && this.isDead;
    }
    submitForm(form, targetCtx, phxEvent, submitter, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      let inputs = Array.from(form.elements);
      inputs.forEach((input) => dom_default.putPrivate(input, PHX_HAS_SUBMITTED, true));
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, submitter, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedback));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone2(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone2(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        } else {
          this.bindTopLevelEvents({ dead: true });
        }
        this.joinDeadView();
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.disconnect(callback);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    execJSHookPush(el, phxEvent, data2, callback) {
      this.withinOwners(el, (view) => {
        js_default.exec("hook", phxEvent, view, el, ["push", { data: data2, callback }]);
      });
    }
    unload() {
      if (this.unloaded) {
        return;
      }
      if (this.main && this.isConnected()) {
        this.log(this.main, "socket", () => ["disconnect for page nav"]);
      }
      this.unloaded = true;
      this.destroyAllViews();
      this.disconnect();
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback) {
      this.transitions.after(callback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event2, cb) {
      channel.on(event2, (data2) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data2);
        } else {
          setTimeout(() => cb(data2), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (this.isConnected() && opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries > this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries > this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinDeadView() {
      let body = document.body;
      if (body && !this.isPhxView(body) && !this.isPhxView(document.firstElementChild)) {
        let view = this.newRootView(body);
        view.setHref(this.getHref());
        view.joinDead();
        if (!this.main) {
          this.main = view;
        }
        window.requestAnimationFrame(() => view.execNewMounted());
      }
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.hasAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to, flash) {
      this.unload();
      browser_default.redirect(to, flash);
    }
    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
      let liveReferer = this.currentLocation.href;
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      let newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash, liveReferer);
      this.main.setRedirect(href);
      this.transitionRemoves();
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback && requestAnimationFrame(() => callback(linkRef));
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements) {
      let removeAttr = this.binding("remove");
      elements = elements || dom_default.all(document, `[${removeAttr}]`);
      elements.forEach((el) => {
        this.execJS(el, el.getAttribute(removeAttr), "remove");
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash, liveReferer) {
      let view = new View(el, this, null, flash, liveReferer);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback(view);
      }
    }
    withinOwners(childEl, callback) {
      this.owner(childEl, (view) => callback(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents({ dead } = {}) {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event2) => {
        if (event2 && event2.code === 1e3 && this.main) {
          return this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      if (!dead) {
        this.bindNav();
      }
      this.bindClicks();
      if (!dead) {
        this.bindForms();
      }
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data2 = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data: data2 }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        if (!eventTarget) {
          let data2 = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data: data2 }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data2 = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data: data2 }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files, e.dataTransfer);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback = this.metadataCallbacks[eventName];
      return callback ? callback(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events2, callback) {
      for (let event2 in events2) {
        let browserEventName = events2[event2];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event2);
          let windowBinding = this.binding(`window-${event2}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, browserEventName, () => {
              this.withinOwners(e.target, (view) => {
                callback(e, event2, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, browserEventName, () => {
                this.withinOwners(el, (view) => {
                  callback(e, event2, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      window.addEventListener("click", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
          target = closestPhxBinding(clickStartedAtTarget, click);
          this.dispatchClickAway(e, clickStartedAtTarget);
          this.clickStartedAtTarget = null;
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          if (!capture && dom_default.isNewPageClick(e, window.location)) {
            this.unload();
          }
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        if (target.hasAttribute(PHX_REF)) {
          return;
        }
        this.debounce(target, e, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(e.target, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el)) {
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state2) => Object.assign(state2, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event2) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll } = event2.state || {};
        let href = window.location.href;
        dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: type === "patch", pop: true } });
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null, () => {
              this.maybeScroll(scroll);
            });
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              this.maybeScroll(scroll);
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        if (!type || !this.isConnected() || !this.main || dom_default.wantsNewTab(e)) {
          return;
        }
        let href = target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
          let phxClick = target.getAttribute(this.binding("click"));
          if (phxClick) {
            this.requestDOMUpdate(() => this.execJS(target, phxClick, "click"));
          }
        });
      }, false);
    }
    maybeScroll(scroll) {
      if (typeof scroll === "number") {
        requestAnimationFrame(() => {
          window.scrollTo(0, scroll);
        });
      }
    }
    dispatchEvent(event2, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event2}`, { detail: payload });
    }
    dispatchEvents(events2) {
      events2.forEach(([event2, payload]) => this.dispatchEvent(event2, payload));
    }
    withPageLoading(info, callback) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback ? callback(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      if (!this.isConnected()) {
        return browser_default.redirect(href);
      }
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      dom_default.dispatchEvent(window, "phx:navigate", { detail: { patch: true, href, pop: false } });
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      if (!this.isConnected()) {
        return browser_default.redirect(href, flash);
      }
      if (/^\/$|^\/[^\/]+.*$/.test(href)) {
        let { protocol, host } = window.location;
        href = `${protocol}//${host}${href}`;
      }
      let scroll = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, (linkRef) => {
          if (linkRef === this.linkRef) {
            browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll }, href);
            dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: false, pop: false } });
            this.registerNewLocation(window.location);
          }
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone2(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      let externalFormSubmitted = false;
      this.on("submit", (e) => {
        let phxSubmit = e.target.getAttribute(this.binding("submit"));
        let phxChange = e.target.getAttribute(this.binding("change"));
        if (!externalFormSubmitted && phxChange && !phxSubmit) {
          externalFormSubmitted = true;
          e.preventDefault();
          this.withinOwners(e.target, (view) => {
            view.disableForm(e.target);
            window.requestAnimationFrame(() => {
              if (dom_default.isUnloadableFormSubmit(e)) {
                this.unload();
              }
              e.target.submit();
            });
          });
        }
      }, true);
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          if (dom_default.isUnloadableFormSubmit(e)) {
            this.unload();
          }
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", { submitter: e.submitter }]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let phxChange = this.binding("change");
          let input = e.target;
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type !== lastType) {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        }, false);
      }
      this.on("reset", (e) => {
        let form = e.target;
        dom_default.resetForm(form, this.binding(PHX_FEEDBACK_FOR));
        let input = Array.from(form.elements).find((el) => el.type === "reset");
        window.requestAnimationFrame(() => {
          input.dispatchEvent(new Event("input", { bubbles: true, cancelable: false }));
        });
      });
    }
    debounce(el, event2, eventType, callback) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
        dom_default.debounce(el, event2, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback();
        });
      });
    }
    silenceEvents(callback) {
      this.silenced = true;
      callback();
      this.silenced = false;
    }
    on(event2, callback) {
      window.addEventListener(event2, (e) => {
        if (!this.silenced) {
          callback(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
    }
    reset() {
      this.transitions.forEach((timer) => {
        clearTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback) {
      if (this.size() === 0) {
        callback();
      } else {
        this.pushPendingOp(callback);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        this.flushPendingOps();
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      if (this.size() > 0) {
        return;
      }
      let op = this.pendingOps.shift();
      if (op) {
        op();
        this.flushPendingOps();
      }
    }
  };

  // node_modules/@ryangjchandler/alpine-clipboard/src/index.js
  var onCopy = () => {
  };
  function Clipboard(Alpine2) {
    Alpine2.magic("clipboard", () => {
      return function(target) {
        if (typeof target === "function") {
          target = target();
        }
        if (typeof target === "object") {
          target = JSON.stringify(target);
        }
        return window.navigator.clipboard.writeText(target).then(onCopy);
      };
    });
  }
  Clipboard.configure = (config) => {
    if (config.hasOwnProperty("onCopy") && typeof config.onCopy === "function") {
      onCopy = config.onCopy;
    }
    return Clipboard;
  };
  var src_default2 = Clipboard;

  // node_modules/swiper/shared/ssr-window.esm.mjs
  function isObject2(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
  }
  function extend(target, src) {
    if (target === void 0) {
      target = {};
    }
    if (src === void 0) {
      src = {};
    }
    Object.keys(src).forEach((key) => {
      if (typeof target[key] === "undefined")
        target[key] = src[key];
      else if (isObject2(src[key]) && isObject2(target[key]) && Object.keys(src[key]).length > 0) {
        extend(target[key], src[key]);
      }
    });
  }
  var ssrDocument = {
    body: {},
    addEventListener() {
    },
    removeEventListener() {
    },
    activeElement: {
      blur() {
      },
      nodeName: ""
    },
    querySelector() {
      return null;
    },
    querySelectorAll() {
      return [];
    },
    getElementById() {
      return null;
    },
    createEvent() {
      return {
        initEvent() {
        }
      };
    },
    createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {
        },
        getElementsByTagName() {
          return [];
        }
      };
    },
    createElementNS() {
      return {};
    },
    importNode() {
      return null;
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function getDocument() {
    const doc2 = typeof document !== "undefined" ? document : {};
    extend(doc2, ssrDocument);
    return doc2;
  }
  var ssrWindow = {
    document: ssrDocument,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {
      },
      pushState() {
      },
      go() {
      },
      back() {
      }
    },
    CustomEvent: function CustomEvent2() {
      return this;
    },
    addEventListener() {
    },
    removeEventListener() {
    },
    getComputedStyle() {
      return {
        getPropertyValue() {
          return "";
        }
      };
    },
    Image() {
    },
    Date() {
    },
    screen: {},
    setTimeout() {
    },
    clearTimeout() {
    },
    matchMedia() {
      return {};
    },
    requestAnimationFrame(callback) {
      if (typeof setTimeout === "undefined") {
        callback();
        return null;
      }
      return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
      if (typeof setTimeout === "undefined") {
        return;
      }
      clearTimeout(id);
    }
  };
  function getWindow() {
    const win = typeof window !== "undefined" ? window : {};
    extend(win, ssrWindow);
    return win;
  }

  // node_modules/swiper/shared/utils.mjs
  function classesToTokens(classes2) {
    if (classes2 === void 0) {
      classes2 = "";
    }
    return classes2.trim().split(" ").filter((c) => !!c.trim());
  }
  function deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
      }
      try {
        delete object[key];
      } catch (e) {
      }
    });
  }
  function nextTick2(callback, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return setTimeout(callback, delay);
  }
  function now() {
    return Date.now();
  }
  function getComputedStyle2(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) {
      style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
      style = el.currentStyle;
    }
    if (!style) {
      style = el.style;
    }
    return style;
  }
  function getTranslate(el, axis) {
    if (axis === void 0) {
      axis = "x";
    }
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle2(el);
    if (window2.WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(",").length > 6) {
        curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
      }
      transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
      matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
      if (window2.WebKitCSSMatrix)
        curTransform = transformMatrix.m41;
      else if (matrix.length === 16)
        curTransform = parseFloat(matrix[12]);
      else
        curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
      if (window2.WebKitCSSMatrix)
        curTransform = transformMatrix.m42;
      else if (matrix.length === 16)
        curTransform = parseFloat(matrix[13]);
      else
        curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  }
  function isObject3(o) {
    return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
  }
  function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
      return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
  }
  function extend2() {
    const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
    const noExtend = ["__proto__", "constructor", "prototype"];
    for (let i = 1; i < arguments.length; i += 1) {
      const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
      if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
        const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            if (isObject3(to[nextKey]) && isObject3(nextSource[nextKey])) {
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else if (!isObject3(to[nextKey]) && isObject3(nextSource[nextKey])) {
              to[nextKey] = {};
              if (nextSource[nextKey].__swiper__) {
                to[nextKey] = nextSource[nextKey];
              } else {
                extend2(to[nextKey], nextSource[nextKey]);
              }
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  }
  function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
  }
  function animateCSSModeScroll(_ref) {
    let {
      swiper,
      targetPosition,
      side
    } = _ref;
    const window2 = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target) => {
      return dir === "next" && current >= target || dir === "prev" && current <= target;
    };
    const animate = () => {
      time = (/* @__PURE__ */ new Date()).getTime();
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
      if (isOutOfBound(currentPosition, targetPosition)) {
        currentPosition = targetPosition;
      }
      swiper.wrapperEl.scrollTo({
        [side]: currentPosition
      });
      if (isOutOfBound(currentPosition, targetPosition)) {
        swiper.wrapperEl.style.overflow = "hidden";
        swiper.wrapperEl.style.scrollSnapType = "";
        setTimeout(() => {
          swiper.wrapperEl.style.overflow = "";
          swiper.wrapperEl.scrollTo({
            [side]: currentPosition
          });
        });
        window2.cancelAnimationFrame(swiper.cssModeFrameID);
        return;
      }
      swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
  }
  function getSlideTransformEl(slideEl) {
    return slideEl.querySelector(".swiper-slide-transform") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(".swiper-slide-transform") || slideEl;
  }
  function elementChildren(element, selector) {
    if (selector === void 0) {
      selector = "";
    }
    return [...element.children].filter((el) => el.matches(selector));
  }
  function showWarning(text) {
    try {
      console.warn(text);
      return;
    } catch (err) {
    }
  }
  function createElement(tag, classes2) {
    if (classes2 === void 0) {
      classes2 = [];
    }
    const el = document.createElement(tag);
    el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
    return el;
  }
  function elementPrevAll(el, selector) {
    const prevEls = [];
    while (el.previousElementSibling) {
      const prev = el.previousElementSibling;
      if (selector) {
        if (prev.matches(selector))
          prevEls.push(prev);
      } else
        prevEls.push(prev);
      el = prev;
    }
    return prevEls;
  }
  function elementNextAll(el, selector) {
    const nextEls = [];
    while (el.nextElementSibling) {
      const next = el.nextElementSibling;
      if (selector) {
        if (next.matches(selector))
          nextEls.push(next);
      } else
        nextEls.push(next);
      el = next;
    }
    return nextEls;
  }
  function elementStyle(el, prop) {
    const window2 = getWindow();
    return window2.getComputedStyle(el, null).getPropertyValue(prop);
  }
  function elementIndex(el) {
    let child = el;
    let i;
    if (child) {
      i = 0;
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1)
          i += 1;
      }
      return i;
    }
    return void 0;
  }
  function elementParents(el, selector) {
    const parents = [];
    let parent = el.parentElement;
    while (parent) {
      if (selector) {
        if (parent.matches(selector))
          parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentElement;
    }
    return parents;
  }
  function elementTransitionEnd(el, callback) {
    function fireCallBack(e) {
      if (e.target !== el)
        return;
      callback.call(el, e);
      el.removeEventListener("transitionend", fireCallBack);
    }
    if (callback) {
      el.addEventListener("transitionend", fireCallBack);
    }
  }
  function elementOuterSize(el, size, includeMargins) {
    const window2 = getWindow();
    if (includeMargins) {
      return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
    }
    return el.offsetWidth;
  }

  // node_modules/swiper/shared/swiper-core.mjs
  var support;
  function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
      smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
      touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
    };
  }
  function getSupport() {
    if (!support) {
      support = calcSupport();
    }
    return support;
  }
  var deviceCached;
  function calcDevice(_temp) {
    let {
      userAgent
    } = _temp === void 0 ? {} : _temp;
    const support2 = getSupport();
    const window2 = getWindow();
    const platform = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
      ios: false,
      android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform === "Win32";
    let macos = platform === "MacIntel";
    const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      if (!ipad)
        ipad = [0, 1, "13_0_0"];
      macos = false;
    }
    if (android && !windows) {
      device.os = "android";
      device.android = true;
    }
    if (ipad || iphone || ipod) {
      device.os = "ios";
      device.ios = true;
    }
    return device;
  }
  function getDevice(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }
    if (!deviceCached) {
      deviceCached = calcDevice(overrides);
    }
    return deviceCached;
  }
  var browser;
  function calcBrowser() {
    const window2 = getWindow();
    let needPerspectiveFix = false;
    function isSafari() {
      const ua = window2.navigator.userAgent.toLowerCase();
      return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    if (isSafari()) {
      const ua = String(window2.navigator.userAgent);
      if (ua.includes("Version/")) {
        const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
        needPerspectiveFix = major < 16 || major === 16 && minor < 2;
      }
    }
    return {
      isSafari: needPerspectiveFix || isSafari(),
      needPerspectiveFix,
      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
    };
  }
  function getBrowser() {
    if (!browser) {
      browser = calcBrowser();
    }
    return browser;
  }
  function Resize(_ref) {
    let {
      swiper,
      on: on2,
      emit
    } = _ref;
    const window2 = getWindow();
    let observer2 = null;
    let animationFrame = null;
    const resizeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      emit("beforeResize");
      emit("resize");
    };
    const createObserver = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      observer2 = new ResizeObserver((entries) => {
        animationFrame = window2.requestAnimationFrame(() => {
          const {
            width,
            height
          } = swiper;
          let newWidth = width;
          let newHeight = height;
          entries.forEach((_ref2) => {
            let {
              contentBoxSize,
              contentRect,
              target
            } = _ref2;
            if (target && target !== swiper.el)
              return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });
          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
      });
      observer2.observe(swiper.el);
    };
    const removeObserver = () => {
      if (animationFrame) {
        window2.cancelAnimationFrame(animationFrame);
      }
      if (observer2 && observer2.unobserve && swiper.el) {
        observer2.unobserve(swiper.el);
        observer2 = null;
      }
    };
    const orientationChangeHandler = () => {
      if (!swiper || swiper.destroyed || !swiper.initialized)
        return;
      emit("orientationchange");
    };
    on2("init", () => {
      if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
        createObserver();
        return;
      }
      window2.addEventListener("resize", resizeHandler);
      window2.addEventListener("orientationchange", orientationChangeHandler);
    });
    on2("destroy", () => {
      removeObserver();
      window2.removeEventListener("resize", resizeHandler);
      window2.removeEventListener("orientationchange", orientationChangeHandler);
    });
  }
  function Observer(_ref) {
    let {
      swiper,
      extendParams,
      on: on2,
      emit
    } = _ref;
    const observers = [];
    const window2 = getWindow();
    const attach = function(target, options) {
      if (options === void 0) {
        options = {};
      }
      const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
      const observer2 = new ObserverFunc((mutations) => {
        if (swiper.__preventObserver__)
          return;
        if (mutations.length === 1) {
          emit("observerUpdate", mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate2() {
          emit("observerUpdate", mutations[0]);
        };
        if (window2.requestAnimationFrame) {
          window2.requestAnimationFrame(observerUpdate);
        } else {
          window2.setTimeout(observerUpdate, 0);
        }
      });
      observer2.observe(target, {
        attributes: typeof options.attributes === "undefined" ? true : options.attributes,
        childList: typeof options.childList === "undefined" ? true : options.childList,
        characterData: typeof options.characterData === "undefined" ? true : options.characterData
      });
      observers.push(observer2);
    };
    const init = () => {
      if (!swiper.params.observer)
        return;
      if (swiper.params.observeParents) {
        const containerParents = elementParents(swiper.hostEl);
        for (let i = 0; i < containerParents.length; i += 1) {
          attach(containerParents[i]);
        }
      }
      attach(swiper.hostEl, {
        childList: swiper.params.observeSlideChildren
      });
      attach(swiper.wrapperEl, {
        attributes: false
      });
    };
    const destroy = () => {
      observers.forEach((observer2) => {
        observer2.disconnect();
      });
      observers.splice(0, observers.length);
    };
    extendParams({
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    });
    on2("init", init);
    on2("destroy", destroy);
  }
  var eventsEmitter = {
    on(events2, handler3, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler3 !== "function")
        return self2;
      const method = priority ? "unshift" : "push";
      events2.split(" ").forEach((event2) => {
        if (!self2.eventsListeners[event2])
          self2.eventsListeners[event2] = [];
        self2.eventsListeners[event2][method](handler3);
      });
      return self2;
    },
    once(events2, handler3, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler3 !== "function")
        return self2;
      function onceHandler() {
        self2.off(events2, onceHandler);
        if (onceHandler.__emitterProxy) {
          delete onceHandler.__emitterProxy;
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        handler3.apply(self2, args);
      }
      onceHandler.__emitterProxy = handler3;
      return self2.on(events2, onceHandler, priority);
    },
    onAny(handler3, priority) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (typeof handler3 !== "function")
        return self2;
      const method = priority ? "unshift" : "push";
      if (self2.eventsAnyListeners.indexOf(handler3) < 0) {
        self2.eventsAnyListeners[method](handler3);
      }
      return self2;
    },
    offAny(handler3) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsAnyListeners)
        return self2;
      const index = self2.eventsAnyListeners.indexOf(handler3);
      if (index >= 0) {
        self2.eventsAnyListeners.splice(index, 1);
      }
      return self2;
    },
    off(events2, handler3) {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsListeners)
        return self2;
      events2.split(" ").forEach((event2) => {
        if (typeof handler3 === "undefined") {
          self2.eventsListeners[event2] = [];
        } else if (self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler, index) => {
            if (eventHandler === handler3 || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler3) {
              self2.eventsListeners[event2].splice(index, 1);
            }
          });
        }
      });
      return self2;
    },
    emit() {
      const self2 = this;
      if (!self2.eventsListeners || self2.destroyed)
        return self2;
      if (!self2.eventsListeners)
        return self2;
      let events2;
      let data2;
      let context;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        events2 = args[0];
        data2 = args.slice(1, args.length);
        context = self2;
      } else {
        events2 = args[0].events;
        data2 = args[0].data;
        context = args[0].context || self2;
      }
      data2.unshift(context);
      const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
      eventsArray.forEach((event2) => {
        if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
          self2.eventsAnyListeners.forEach((eventHandler) => {
            eventHandler.apply(context, [event2, ...data2]);
          });
        }
        if (self2.eventsListeners && self2.eventsListeners[event2]) {
          self2.eventsListeners[event2].forEach((eventHandler) => {
            eventHandler.apply(context, data2);
          });
        }
      });
      return self2;
    }
  };
  function updateSize() {
    const swiper = this;
    let width;
    let height;
    const el = swiper.el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
      width = swiper.params.width;
    } else {
      width = el.clientWidth;
    }
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
      height = swiper.params.height;
    } else {
      height = el.clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    }
    width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
    height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
    if (Number.isNaN(width))
      width = 0;
    if (Number.isNaN(height))
      height = 0;
    Object.assign(swiper, {
      width,
      height,
      size: swiper.isHorizontal() ? width : height
    });
  }
  function updateSlides() {
    const swiper = this;
    function getDirectionPropertyValue(node, label) {
      return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const {
      wrapperEl,
      slidesEl,
      size: swiperSize,
      rtlTranslate: rtl,
      wrongRTL
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;
    if (typeof swiperSize === "undefined") {
      return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    swiper.virtualSize = -spaceBetween;
    slides.forEach((slideEl) => {
      if (rtl) {
        slideEl.style.marginLeft = "";
      } else {
        slideEl.style.marginRight = "";
      }
      slideEl.style.marginBottom = "";
      slideEl.style.marginTop = "";
    });
    if (params.centeredSlides && params.cssMode) {
      setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
      setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) {
      swiper.grid.initSlides(slides);
    } else if (swiper.grid) {
      swiper.grid.unsetSlides();
    }
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
      return typeof params.breakpoints[key].slidesPerView !== "undefined";
    }).length > 0;
    for (let i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      let slide2;
      if (slides[i])
        slide2 = slides[i];
      if (gridEnabled) {
        swiper.grid.updateSlide(i, slide2, slides);
      }
      if (slides[i] && elementStyle(slide2, "display") === "none")
        continue;
      if (params.slidesPerView === "auto") {
        if (shouldResetSlideSize) {
          slides[i].style[swiper.getDirectionLabel("width")] = ``;
        }
        const slideStyles = getComputedStyle(slide2);
        const currentTransform = slide2.style.transform;
        const currentWebKitTransform = slide2.style.webkitTransform;
        if (currentTransform) {
          slide2.style.transform = "none";
        }
        if (currentWebKitTransform) {
          slide2.style.webkitTransform = "none";
        }
        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
        } else {
          const width = getDirectionPropertyValue(slideStyles, "width");
          const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
          const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
          const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
          const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
          const boxSizing = slideStyles.getPropertyValue("box-sizing");
          if (boxSizing && boxSizing === "border-box") {
            slideSize = width + marginLeft + marginRight;
          } else {
            const {
              clientWidth,
              offsetWidth
            } = slide2;
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
          }
        }
        if (currentTransform) {
          slide2.style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide2.style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths)
          slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
        if (params.roundLengths)
          slideSize = Math.floor(slideSize);
        if (slides[i]) {
          slides[i].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
        }
      }
      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);
      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
        if (prevSlideSize === 0 && i !== 0)
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (i === 0)
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1e3)
          slidePosition = 0;
        if (params.roundLengths)
          slidePosition = Math.floor(slidePosition);
        if (index % params.slidesPerGroup === 0)
          snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths)
          slidePosition = Math.floor(slidePosition);
        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0)
          snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }
      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
      wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (params.setWrapperSize) {
      wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (gridEnabled) {
      swiper.grid.updateWrapperSize(slideSize, snapGrid);
    }
    if (!params.centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths)
          slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }
    if (isVirtual && params.loop) {
      const size = slidesSizesGrid[0] + spaceBetween;
      if (params.slidesPerGroup > 1) {
        const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
        const groupSize = size * params.slidesPerGroup;
        for (let i = 0; i < groups; i += 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
        }
      }
      for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
        if (params.slidesPerGroup === 1) {
          snapGrid.push(snapGrid[snapGrid.length - 1] + size);
        }
        slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
        swiper.virtualSize += size;
      }
    }
    if (snapGrid.length === 0)
      snapGrid = [0];
    if (spaceBetween !== 0) {
      const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
      slides.filter((_, slideIndex) => {
        if (!params.cssMode || params.loop)
          return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }).forEach((slideEl) => {
        slideEl.style[key] = `${spaceBetween}px`;
      });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map((snap) => {
        if (snap <= 0)
          return -offsetBefore;
        if (snap > maxSnap)
          return maxSnap + offsetAfter;
        return snap;
      });
    }
    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (spaceBetween || 0);
      });
      allSlidesSize -= spaceBetween;
      if (allSlidesSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach((snap, snapIndex) => {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach((snap, snapIndex) => {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }
    Object.assign(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
      setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
      setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
      const addToSnapGrid = -swiper.snapGrid[0];
      const addToSlidesGrid = -swiper.slidesGrid[0];
      swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);
      swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
      swiper.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow)
        swiper.checkOverflow();
      swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    swiper.emit("slidesUpdated");
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
      const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
      if (slidesLength <= params.maxBackfaceHiddenSlides) {
        if (!hasClassBackfaceClassAdded)
          swiper.el.classList.add(backFaceHiddenClass);
      } else if (hasClassBackfaceClassAdded) {
        swiper.el.classList.remove(backFaceHiddenClass);
      }
    }
  }
  function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i;
    if (typeof speed === "number") {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }
    const getSlideByIndex = (index) => {
      if (isVirtual) {
        return swiper.slides[swiper.getSlideIndexByData(index)];
      }
      return swiper.slides[index];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        (swiper.visibleSlides || []).forEach((slide2) => {
          activeSlides.push(slide2);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
          const index = swiper.activeIndex + i;
          if (index > swiper.slides.length && !isVirtual)
            break;
          activeSlides.push(getSlideByIndex(index));
        }
      }
    } else {
      activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== "undefined") {
        const height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    }
    if (newHeight || newHeight === 0)
      swiper.wrapperEl.style.height = `${newHeight}px`;
  }
  function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
    for (let i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
    }
  }
  function updateSlidesProgress(translate2) {
    if (translate2 === void 0) {
      translate2 = this && this.translate || 0;
    }
    const swiper = this;
    const params = swiper.params;
    const {
      slides,
      rtlTranslate: rtl,
      snapGrid
    } = swiper;
    if (slides.length === 0)
      return;
    if (typeof slides[0].swiperSlideOffset === "undefined")
      swiper.updateSlidesOffset();
    let offsetCenter = -translate2;
    if (rtl)
      offsetCenter = translate2;
    slides.forEach((slideEl) => {
      slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass);
    });
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    let spaceBetween = params.spaceBetween;
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
    } else if (typeof spaceBetween === "string") {
      spaceBetween = parseFloat(spaceBetween);
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slide2 = slides[i];
      let slideOffset = slide2.swiperSlideOffset;
      if (params.cssMode && params.centeredSlides) {
        slideOffset -= slides[0].swiperSlideOffset;
      }
      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
      const slideBefore = -(offsetCenter - slideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
      if (isVisible) {
        swiper.visibleSlides.push(slide2);
        swiper.visibleSlidesIndexes.push(i);
        slides[i].classList.add(params.slideVisibleClass);
      }
      if (isFullyVisible) {
        slides[i].classList.add(params.slideFullyVisibleClass);
      }
      slide2.progress = rtl ? -slideProgress : slideProgress;
      slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
  }
  function updateProgress(translate2) {
    const swiper = this;
    if (typeof translate2 === "undefined") {
      const multiplier = swiper.rtlTranslate ? -1 : 1;
      translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let {
      progress,
      isBeginning,
      isEnd,
      progressLoop
    } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate2 - swiper.minTranslate()) / translatesDiff;
      const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
      const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
      isBeginning = isBeginningRounded || progress <= 0;
      isEnd = isEndRounded || progress >= 1;
      if (isBeginningRounded)
        progress = 0;
      if (isEndRounded)
        progress = 1;
    }
    if (params.loop) {
      const firstSlideIndex = swiper.getSlideIndexByData(0);
      const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
      const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
      const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
      const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
      const translateAbs = Math.abs(translate2);
      if (translateAbs >= firstSlideTranslate) {
        progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
      } else {
        progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
      }
      if (progressLoop > 1)
        progressLoop -= 1;
    }
    Object.assign(swiper, {
      progress,
      progressLoop,
      isBeginning,
      isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
      swiper.updateSlidesProgress(translate2);
    if (isBeginning && !wasBeginning) {
      swiper.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
      swiper.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit("fromEdge");
    }
    swiper.emit("progress", progress);
  }
  function updateSlidesClasses() {
    const swiper = this;
    const {
      slides,
      params,
      slidesEl,
      activeIndex
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const getFilteredSlide = (selector) => {
      return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
    };
    slides.forEach((slideEl) => {
      slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
    });
    let activeSlide;
    let prevSlide;
    let nextSlide;
    if (isVirtual) {
      if (params.loop) {
        let slideIndex = activeIndex - swiper.virtual.slidesBefore;
        if (slideIndex < 0)
          slideIndex = swiper.virtual.slides.length + slideIndex;
        if (slideIndex >= swiper.virtual.slides.length)
          slideIndex -= swiper.virtual.slides.length;
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
      } else {
        activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
      }
    } else {
      if (gridEnabled) {
        activeSlide = slides.filter((slideEl) => slideEl.column === activeIndex)[0];
        nextSlide = slides.filter((slideEl) => slideEl.column === activeIndex + 1)[0];
        prevSlide = slides.filter((slideEl) => slideEl.column === activeIndex - 1)[0];
      } else {
        activeSlide = slides[activeIndex];
      }
    }
    if (activeSlide) {
      activeSlide.classList.add(params.slideActiveClass);
      if (gridEnabled) {
        if (nextSlide) {
          nextSlide.classList.add(params.slideNextClass);
        }
        if (prevSlide) {
          prevSlide.classList.add(params.slidePrevClass);
        }
      } else {
        nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !nextSlide) {
          nextSlide = slides[0];
        }
        if (nextSlide) {
          nextSlide.classList.add(params.slideNextClass);
        }
        prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !prevSlide === 0) {
          prevSlide = slides[slides.length - 1];
        }
        if (prevSlide) {
          prevSlide.classList.add(params.slidePrevClass);
        }
      }
    }
    swiper.emitSlidesClasses();
  }
  var processLazyPreloader = (swiper, imageEl) => {
    if (!swiper || swiper.destroyed || !swiper.params)
      return;
    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    const slideEl = imageEl.closest(slideSelector());
    if (slideEl) {
      let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      if (!lazyEl && swiper.isElement) {
        if (slideEl.shadowRoot) {
          lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
        } else {
          requestAnimationFrame(() => {
            if (slideEl.shadowRoot) {
              lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
              if (lazyEl)
                lazyEl.remove();
            }
          });
        }
      }
      if (lazyEl)
        lazyEl.remove();
    }
  };
  var unlazy = (swiper, index) => {
    if (!swiper.slides[index])
      return;
    const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
    if (imageEl)
      imageEl.removeAttribute("loading");
  };
  var preload = (swiper) => {
    if (!swiper || swiper.destroyed || !swiper.params)
      return;
    let amount = swiper.params.lazyPreloadPrevNext;
    const len = swiper.slides.length;
    if (!len || !amount || amount < 0)
      return;
    amount = Math.min(amount, len);
    const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
    const activeIndex = swiper.activeIndex;
    if (swiper.params.grid && swiper.params.grid.rows > 1) {
      const activeColumn = activeIndex;
      const preloadColumns = [activeColumn - amount];
      preloadColumns.push(...Array.from({
        length: amount
      }).map((_, i) => {
        return activeColumn + slidesPerView + i;
      }));
      swiper.slides.forEach((slideEl, i) => {
        if (preloadColumns.includes(slideEl.column))
          unlazy(swiper, i);
      });
      return;
    }
    const slideIndexLastInView = activeIndex + slidesPerView - 1;
    if (swiper.params.rewind || swiper.params.loop) {
      for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
        const realIndex = (i % len + len) % len;
        if (realIndex < activeIndex || realIndex > slideIndexLastInView)
          unlazy(swiper, realIndex);
      }
    } else {
      for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
        if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
          unlazy(swiper, i);
        }
      }
    }
  };
  function getActiveIndexByTranslate(swiper) {
    const {
      slidesGrid,
      params
    } = swiper;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    let activeIndex;
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate2 >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === "undefined")
        activeIndex = 0;
    }
    return activeIndex;
  }
  function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      snapGrid,
      params,
      activeIndex: previousIndex,
      realIndex: previousRealIndex,
      snapIndex: previousSnapIndex
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    const getVirtualRealIndex = (aIndex) => {
      let realIndex2 = aIndex - swiper.virtual.slidesBefore;
      if (realIndex2 < 0) {
        realIndex2 = swiper.virtual.slides.length + realIndex2;
      }
      if (realIndex2 >= swiper.virtual.slides.length) {
        realIndex2 -= swiper.virtual.slides.length;
      }
      return realIndex2;
    };
    if (typeof activeIndex === "undefined") {
      activeIndex = getActiveIndexByTranslate(swiper);
    }
    if (snapGrid.indexOf(translate2) >= 0) {
      snapIndex = snapGrid.indexOf(translate2);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length)
      snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex && !swiper.params.loop) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit("snapIndexChange");
      }
      return;
    }
    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.realIndex = getVirtualRealIndex(activeIndex);
      return;
    }
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    let realIndex;
    if (swiper.virtual && params.virtual.enabled && params.loop) {
      realIndex = getVirtualRealIndex(activeIndex);
    } else if (gridEnabled) {
      const firstSlideInColumn = swiper.slides.filter((slideEl) => slideEl.column === activeIndex)[0];
      let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
      if (Number.isNaN(activeSlideIndex)) {
        activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
      }
      realIndex = Math.floor(activeSlideIndex / params.grid.rows);
    } else if (swiper.slides[activeIndex]) {
      const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
      if (slideIndex) {
        realIndex = parseInt(slideIndex, 10);
      } else {
        realIndex = activeIndex;
      }
    } else {
      realIndex = activeIndex;
    }
    Object.assign(swiper, {
      previousSnapIndex,
      snapIndex,
      previousRealIndex,
      realIndex,
      previousIndex,
      activeIndex
    });
    if (swiper.initialized) {
      preload(swiper);
    }
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      if (previousRealIndex !== realIndex) {
        swiper.emit("realIndexChange");
      }
      swiper.emit("slideChange");
    }
  }
  function updateClickedSlide(el, path) {
    const swiper = this;
    const params = swiper.params;
    let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
    if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) {
      [...path.slice(path.indexOf(el) + 1, path.length)].forEach((pathEl) => {
        if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
          slide2 = pathEl;
        }
      });
    }
    let slideFound = false;
    let slideIndex;
    if (slide2) {
      for (let i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide2) {
          slideFound = true;
          slideIndex = i;
          break;
        }
      }
    }
    if (slide2 && slideFound) {
      swiper.clickedSlide = slide2;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
      } else {
        swiper.clickedIndex = slideIndex;
      }
    } else {
      swiper.clickedSlide = void 0;
      swiper.clickedIndex = void 0;
      return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }
  var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
  };
  function getSwiperTranslate(axis) {
    if (axis === void 0) {
      axis = this.isHorizontal() ? "x" : "y";
    }
    const swiper = this;
    const {
      params,
      rtlTranslate: rtl,
      translate: translate2,
      wrapperEl
    } = swiper;
    if (params.virtualTranslate) {
      return rtl ? -translate2 : translate2;
    }
    if (params.cssMode) {
      return translate2;
    }
    let currentTranslate = getTranslate(wrapperEl, axis);
    currentTranslate += swiper.cssOverflowAdjustment();
    if (rtl)
      currentTranslate = -currentTranslate;
    return currentTranslate || 0;
  }
  function setTranslate(translate2, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl,
      params,
      wrapperEl,
      progress
    } = swiper;
    let x = 0;
    let y = 0;
    const z = 0;
    if (swiper.isHorizontal()) {
      x = rtl ? -translate2 : translate2;
    } else {
      y = translate2;
    }
    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y;
    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      if (swiper.isHorizontal()) {
        x -= swiper.cssOverflowAdjustment();
      } else {
        y -= swiper.cssOverflowAdjustment();
      }
      wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
    }
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
      swiper.updateProgress(translate2);
    }
    swiper.emit("setTranslate", swiper.translate, byController);
  }
  function minTranslate() {
    return -this.snapGrid[0];
  }
  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }
  function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
    if (translate2 === void 0) {
      translate2 = 0;
    }
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (translateBounds === void 0) {
      translateBounds = true;
    }
    const swiper = this;
    const {
      params,
      wrapperEl
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }
    const minTranslate2 = swiper.minTranslate();
    const maxTranslate2 = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate2 > minTranslate2)
      newTranslate = minTranslate2;
    else if (translateBounds && translate2 < maxTranslate2)
      newTranslate = maxTranslate2;
    else
      newTranslate = translate2;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: -newTranslate,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: -newTranslate,
          behavior: "smooth"
        });
      }
      return true;
    }
    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionEnd");
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit("beforeTransitionStart", speed, internal);
        swiper.emit("transitionStart");
      }
      if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {
            if (!swiper || swiper.destroyed)
              return;
            if (e.target !== this)
              return;
            swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;
            if (runCallbacks) {
              swiper.emit("transitionEnd");
            }
          };
        }
        swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
      }
    }
    return true;
  }
  var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
  };
  function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
      swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
      swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
    }
    swiper.emit("setTransition", duration, byController);
  }
  function transitionEmit(_ref) {
    let {
      swiper,
      runCallbacks,
      direction,
      step
    } = _ref;
    const {
      activeIndex,
      previousIndex
    } = swiper;
    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex)
        dir = "next";
      else if (activeIndex < previousIndex)
        dir = "prev";
      else
        dir = "reset";
    }
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === "reset") {
        swiper.emit(`slideResetTransition${step}`);
        return;
      }
      swiper.emit(`slideChangeTransition${step}`);
      if (dir === "next") {
        swiper.emit(`slideNextTransition${step}`);
      } else {
        swiper.emit(`slidePrevTransition${step}`);
      }
    }
  }
  function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params
    } = swiper;
    if (params.cssMode)
      return;
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "Start"
    });
  }
  function transitionEnd(runCallbacks, direction) {
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.animating = false;
    if (params.cssMode)
      return;
    swiper.setTransition(0);
    transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step: "End"
    });
  }
  var transition2 = {
    setTransition,
    transitionStart,
    transitionEnd
  };
  function slideTo(index, speed, runCallbacks, internal, initial) {
    if (index === void 0) {
      index = 0;
    }
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (typeof index === "string") {
      index = parseInt(index, 10);
    }
    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0)
      slideIndex = 0;
    const {
      params,
      snapGrid,
      slidesGrid,
      previousIndex,
      activeIndex,
      rtlTranslate: rtl,
      wrapperEl,
      enabled
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
      return false;
    }
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length)
      snapIndex = snapGrid.length - 1;
    const translate2 = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        const normalizedTranslate = -Math.floor(translate2 * 100);
        const normalizedGrid = Math.floor(slidesGrid[i] * 100);
        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
        if (typeof slidesGrid[i + 1] !== "undefined") {
          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
            slideIndex = i;
          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
            slideIndex = i + 1;
          }
        } else if (normalizedTranslate >= normalizedGrid) {
          slideIndex = i;
        }
      }
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {
        return false;
      }
      if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) {
          return false;
        }
      }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
      swiper.emit("beforeSlideChangeStart");
    }
    swiper.updateProgress(translate2);
    let direction;
    if (slideIndex > activeIndex)
      direction = "next";
    else if (slideIndex < activeIndex)
      direction = "prev";
    else
      direction = "reset";
    if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
      swiper.updateActiveIndex(slideIndex);
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      swiper.updateSlidesClasses();
      if (params.effect !== "slide") {
        swiper.setTranslate(translate2);
      }
      if (direction !== "reset") {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      const t = rtl ? translate2 : -translate2;
      if (speed === 0) {
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        if (isVirtual) {
          swiper.wrapperEl.style.scrollSnapType = "none";
          swiper._immediateVirtual = true;
        }
        if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
          swiper._cssModeVirtualInitialSet = true;
          requestAnimationFrame(() => {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
          });
        } else {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
        }
        if (isVirtual) {
          requestAnimationFrame(() => {
            swiper.wrapperEl.style.scrollSnapType = "";
            swiper._immediateVirtual = false;
          });
        }
      } else {
        if (!swiper.support.smoothScroll) {
          animateCSSModeScroll({
            swiper,
            targetPosition: t,
            side: isH ? "left" : "top"
          });
          return true;
        }
        wrapperEl.scrollTo({
          [isH ? "left" : "top"]: t,
          behavior: "smooth"
        });
      }
      return true;
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate2);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) {
      swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {
          if (!swiper || swiper.destroyed)
            return;
          if (e.target !== this)
            return;
          swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
  }
  function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) {
      index = 0;
    }
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (typeof index === "string") {
      const indexAsNumber = parseInt(index, 10);
      index = indexAsNumber;
    }
    const swiper = this;
    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
    let newIndex = index;
    if (swiper.params.loop) {
      if (swiper.virtual && swiper.params.virtual.enabled) {
        newIndex = newIndex + swiper.virtual.slidesBefore;
      } else {
        let targetSlideIndex;
        if (gridEnabled) {
          const slideIndex = newIndex * swiper.params.grid.rows;
          targetSlideIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
        } else {
          targetSlideIndex = swiper.getSlideIndexByData(newIndex);
        }
        const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
        const {
          centeredSlides
        } = swiper.params;
        let slidesPerView = swiper.params.slidesPerView;
        if (slidesPerView === "auto") {
          slidesPerView = swiper.slidesPerViewDynamic();
        } else {
          slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
          if (centeredSlides && slidesPerView % 2 === 0) {
            slidesPerView = slidesPerView + 1;
          }
        }
        let needLoopFix = cols - targetSlideIndex < slidesPerView;
        if (centeredSlides) {
          needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
        }
        if (needLoopFix) {
          const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
          swiper.loopFix({
            direction,
            slideTo: true,
            activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
            slideRealIndex: direction === "next" ? swiper.realIndex : void 0
          });
        }
        if (gridEnabled) {
          const slideIndex = newIndex * swiper.params.grid.rows;
          newIndex = swiper.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
        } else {
          newIndex = swiper.getSlideIndexByData(newIndex);
        }
      }
    }
    requestAnimationFrame(() => {
      swiper.slideTo(newIndex, speed, runCallbacks, internal);
    });
    return swiper;
  }
  function slideNext(speed, runCallbacks, internal) {
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      enabled,
      params,
      animating
    } = swiper;
    if (!enabled)
      return swiper;
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
    }
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding)
        return false;
      swiper.loopFix({
        direction: "next"
      });
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
      if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
        requestAnimationFrame(() => {
          swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        });
        return true;
      }
    }
    if (params.rewind && swiper.isEnd) {
      return swiper.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }
  function slidePrev(speed, runCallbacks, internal) {
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    const {
      params,
      snapGrid,
      slidesGrid,
      rtlTranslate,
      enabled,
      animating
    } = swiper;
    if (!enabled)
      return swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
      if (animating && !isVirtual && params.loopPreventsSliding)
        return false;
      swiper.loopFix({
        direction: "prev"
      });
      swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize(val) {
      if (val < 0)
        return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }
    const normalizedTranslate = normalize(translate2);
    const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
      let prevSnapIndex;
      snapGrid.forEach((snap, snapIndex) => {
        if (normalizedTranslate >= snap) {
          prevSnapIndex = snapIndex;
        }
      });
      if (typeof prevSnapIndex !== "undefined") {
        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
      }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0)
        prevIndex = swiper.activeIndex - 1;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
        prevIndex = Math.max(prevIndex, 0);
      }
    }
    if (params.rewind && swiper.isBeginning) {
      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(prevIndex, speed, runCallbacks, internal);
      });
      return true;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }
  function slideReset(speed, runCallbacks, internal) {
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    const swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }
  function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (speed === void 0) {
      speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
      runCallbacks = true;
    }
    if (threshold === void 0) {
      threshold = 0.5;
    }
    const swiper = this;
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate2 >= swiper.snapGrid[snapIndex]) {
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];
      if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];
      if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }
    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
  }
  function slideToClickedSlide() {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
    if (params.loop) {
      if (swiper.animating)
        return;
      realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
          nextTick2(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick2(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
  };
  function loopCreate(slideRealIndex) {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
      return;
    const initSlides = () => {
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      slides.forEach((el, index) => {
        el.setAttribute("data-swiper-slide-index", index);
      });
    };
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
    const addBlankSlides = (amountOfSlides) => {
      for (let i = 0; i < amountOfSlides; i += 1) {
        const slideEl = swiper.isElement ? createElement("swiper-slide", [params.slideBlankClass]) : createElement("div", [params.slideClass, params.slideBlankClass]);
        swiper.slidesEl.append(slideEl);
      }
    };
    if (shouldFillGroup) {
      if (params.loopAddBlankSlides) {
        const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
        addBlankSlides(slidesToAdd);
        swiper.recalcSlides();
        swiper.updateSlides();
      } else {
        showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      }
      initSlides();
    } else if (shouldFillGrid) {
      if (params.loopAddBlankSlides) {
        const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
        addBlankSlides(slidesToAdd);
        swiper.recalcSlides();
        swiper.updateSlides();
      } else {
        showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      }
      initSlides();
    } else {
      initSlides();
    }
    swiper.loopFix({
      slideRealIndex,
      direction: params.centeredSlides ? void 0 : "next"
    });
  }
  function loopFix(_temp) {
    let {
      slideRealIndex,
      slideTo: slideTo2 = true,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController,
      byMousewheel
    } = _temp === void 0 ? {} : _temp;
    const swiper = this;
    if (!swiper.params.loop)
      return;
    swiper.emit("beforeLoopFix");
    const {
      slides,
      allowSlidePrev,
      allowSlideNext,
      slidesEl,
      params
    } = swiper;
    const {
      centeredSlides
    } = params;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    if (swiper.virtual && params.virtual.enabled) {
      if (slideTo2) {
        if (!params.centeredSlides && swiper.snapIndex === 0) {
          swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
        } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
          swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
        } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
          swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit("loopFix");
      return;
    }
    let slidesPerView = params.slidesPerView;
    if (slidesPerView === "auto") {
      slidesPerView = swiper.slidesPerViewDynamic();
    } else {
      slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
      if (centeredSlides && slidesPerView % 2 === 0) {
        slidesPerView = slidesPerView + 1;
      }
    }
    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
    let loopedSlides = slidesPerGroup;
    if (loopedSlides % slidesPerGroup !== 0) {
      loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
    }
    loopedSlides += params.loopAdditionalSlides;
    swiper.loopedSlides = loopedSlides;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    if (slides.length < slidesPerView + loopedSlides) {
      showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters");
    } else if (gridEnabled && params.grid.fill === "row") {
      showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    }
    const prependSlidesIndexes = [];
    const appendSlidesIndexes = [];
    let activeIndex = swiper.activeIndex;
    if (typeof activeSlideIndex === "undefined") {
      activeSlideIndex = swiper.getSlideIndex(slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]);
    } else {
      activeIndex = activeSlideIndex;
    }
    const isNext = direction === "next" || !direction;
    const isPrev = direction === "prev" || !direction;
    let slidesPrepended = 0;
    let slidesAppended = 0;
    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + 0.5 : 0);
    if (activeColIndexWithShift < loopedSlides) {
      slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
      for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
        const index = i - Math.floor(i / cols) * cols;
        if (gridEnabled) {
          const colIndexToPrepend = cols - index - 1;
          for (let i2 = slides.length - 1; i2 >= 0; i2 -= 1) {
            if (slides[i2].column === colIndexToPrepend)
              prependSlidesIndexes.push(i2);
          }
        } else {
          prependSlidesIndexes.push(cols - index - 1);
        }
      }
    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
      slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
      for (let i = 0; i < slidesAppended; i += 1) {
        const index = i - Math.floor(i / cols) * cols;
        if (gridEnabled) {
          slides.forEach((slide2, slideIndex) => {
            if (slide2.column === index)
              appendSlidesIndexes.push(slideIndex);
          });
        } else {
          appendSlidesIndexes.push(index);
        }
      }
    }
    swiper.__preventObserver__ = true;
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
    if (isPrev) {
      prependSlidesIndexes.forEach((index) => {
        slides[index].swiperLoopMoveDOM = true;
        slidesEl.prepend(slides[index]);
        slides[index].swiperLoopMoveDOM = false;
      });
    }
    if (isNext) {
      appendSlidesIndexes.forEach((index) => {
        slides[index].swiperLoopMoveDOM = true;
        slidesEl.append(slides[index]);
        slides[index].swiperLoopMoveDOM = false;
      });
    }
    swiper.recalcSlides();
    if (params.slidesPerView === "auto") {
      swiper.updateSlides();
    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
      swiper.slides.forEach((slide2, slideIndex) => {
        swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
      });
    }
    if (params.watchSlidesProgress) {
      swiper.updateSlidesOffset();
    }
    if (slideTo2) {
      if (prependSlidesIndexes.length > 0 && isPrev) {
        if (typeof slideRealIndex === "undefined") {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
            if (setTranslate2) {
              swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
              swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
          }
        } else {
          if (setTranslate2) {
            const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
            swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
            swiper.touchEventsData.currentTranslate = swiper.translate;
          }
        }
      } else if (appendSlidesIndexes.length > 0 && isNext) {
        if (typeof slideRealIndex === "undefined") {
          const currentSlideTranslate = swiper.slidesGrid[activeIndex];
          const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
          const diff = newSlideTranslate - currentSlideTranslate;
          if (byMousewheel) {
            swiper.setTranslate(swiper.translate - diff);
          } else {
            swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
            if (setTranslate2) {
              swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
              swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
            }
          }
        } else {
          const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
        }
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.controller && swiper.controller.control && !byController) {
      const loopParams = {
        slideRealIndex,
        direction,
        setTranslate: setTranslate2,
        activeSlideIndex,
        byController: true
      };
      if (Array.isArray(swiper.controller.control)) {
        swiper.controller.control.forEach((c) => {
          if (!c.destroyed && c.params.loop)
            c.loopFix(__spreadProps(__spreadValues({}, loopParams), {
              slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo2 : false
            }));
        });
      } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
        swiper.controller.control.loopFix(__spreadProps(__spreadValues({}, loopParams), {
          slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
        }));
      }
    }
    swiper.emit("loopFix");
  }
  function loopDestroy() {
    const swiper = this;
    const {
      params,
      slidesEl
    } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled)
      return;
    swiper.recalcSlides();
    const newSlidesOrder = [];
    swiper.slides.forEach((slideEl) => {
      const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
      newSlidesOrder[index] = slideEl;
    });
    swiper.slides.forEach((slideEl) => {
      slideEl.removeAttribute("data-swiper-slide-index");
    });
    newSlidesOrder.forEach((slideEl) => {
      slidesEl.append(slideEl);
    });
    swiper.recalcSlides();
    swiper.slideTo(swiper.realIndex, 0);
  }
  var loop2 = {
    loopCreate,
    loopFix,
    loopDestroy
  };
  function setGrabCursor(moving) {
    const swiper = this;
    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
      return;
    const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }
  function unsetGrabCursor() {
    const swiper = this;
    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }
    if (swiper.isElement) {
      swiper.__preventObserver__ = true;
    }
    swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
    if (swiper.isElement) {
      requestAnimationFrame(() => {
        swiper.__preventObserver__ = false;
      });
    }
  }
  var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
  };
  function closestElement(selector, base) {
    if (base === void 0) {
      base = this;
    }
    function __closestFrom(el) {
      if (!el || el === getDocument() || el === getWindow())
        return null;
      if (el.assignedSlot)
        el = el.assignedSlot;
      const found = el.closest(selector);
      if (!found && !el.getRootNode) {
        return null;
      }
      return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
  }
  function preventEdgeSwipe(swiper, event2, startX) {
    const window2 = getWindow();
    const {
      params
    } = swiper;
    const edgeSwipeDetection = params.edgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
      if (edgeSwipeDetection === "prevent") {
        event2.preventDefault();
        return true;
      }
      return false;
    }
    return true;
  }
  function onTouchStart(event2) {
    const swiper = this;
    const document2 = getDocument();
    let e = event2;
    if (e.originalEvent)
      e = e.originalEvent;
    const data2 = swiper.touchEventsData;
    if (e.type === "pointerdown") {
      if (data2.pointerId !== null && data2.pointerId !== e.pointerId) {
        return;
      }
      data2.pointerId = e.pointerId;
    } else if (e.type === "touchstart" && e.targetTouches.length === 1) {
      data2.touchId = e.targetTouches[0].identifier;
    }
    if (e.type === "touchstart") {
      preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
      return;
    }
    const {
      params,
      touches,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && e.pointerType === "mouse")
      return;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }
    if (!swiper.animating && params.cssMode && params.loop) {
      swiper.loopFix();
    }
    let targetEl = e.target;
    if (params.touchEventsTarget === "wrapper") {
      if (!swiper.wrapperEl.contains(targetEl))
        return;
    }
    if ("which" in e && e.which === 3)
      return;
    if ("button" in e && e.button > 0)
      return;
    if (data2.isTouched && data2.isMoved)
      return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = e.composedPath ? e.composedPath() : e.path;
    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
      targetEl = eventPath[0];
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e.target && e.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
      swiper.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!targetEl.closest(params.swipeHandler))
        return;
    }
    touches.currentX = e.pageX;
    touches.currentY = e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    if (!preventEdgeSwipe(swiper, e, startX)) {
      return;
    }
    Object.assign(data2, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: void 0,
      startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data2.touchStartTime = now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0)
      data2.allowThresholdMove = false;
    let preventDefault = true;
    if (targetEl.matches(data2.focusableElements)) {
      preventDefault = false;
      if (targetEl.nodeName === "SELECT") {
        data2.isTouched = false;
      }
    }
    if (document2.activeElement && document2.activeElement.matches(data2.focusableElements) && document2.activeElement !== targetEl) {
      document2.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
      e.preventDefault();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
      swiper.freeMode.onTouchStart();
    }
    swiper.emit("touchStart", e);
  }
  function onTouchMove(event2) {
    const document2 = getDocument();
    const swiper = this;
    const data2 = swiper.touchEventsData;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && event2.pointerType === "mouse")
      return;
    let e = event2;
    if (e.originalEvent)
      e = e.originalEvent;
    if (e.type === "pointermove") {
      if (data2.touchId !== null)
        return;
      const id = e.pointerId;
      if (id !== data2.pointerId)
        return;
    }
    let targetTouch;
    if (e.type === "touchmove") {
      targetTouch = [...e.changedTouches].filter((t) => t.identifier === data2.touchId)[0];
      if (!targetTouch || targetTouch.identifier !== data2.touchId)
        return;
    } else {
      targetTouch = e;
    }
    if (!data2.isTouched) {
      if (data2.startMoving && data2.isScrolling) {
        swiper.emit("touchMoveOpposite", e);
      }
      return;
    }
    const pageX = targetTouch.pageX;
    const pageY = targetTouch.pageY;
    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper.allowTouchMove) {
      if (!e.target.matches(data2.focusableElements)) {
        swiper.allowClick = false;
      }
      if (data2.isTouched) {
        Object.assign(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data2.touchStartTime = now();
      }
      return;
    }
    if (params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data2.isTouched = false;
          data2.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }
    if (document2.activeElement) {
      if (e.target === document2.activeElement && e.target.matches(data2.focusableElements)) {
        data2.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }
    if (data2.allowTouchCallbacks) {
      swiper.emit("touchMove", e);
    }
    touches.previousX = touches.currentX;
    touches.previousY = touches.currentY;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
      return;
    if (typeof data2.isScrolling === "undefined") {
      let touchAngle;
      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data2.isScrolling = false;
      } else {
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data2.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }
    if (data2.isScrolling) {
      swiper.emit("touchMoveOpposite", e);
    }
    if (typeof data2.startMoving === "undefined") {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data2.startMoving = true;
      }
    }
    if (data2.isScrolling) {
      data2.isTouched = false;
      return;
    }
    if (!data2.startMoving) {
      return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e.cancelable) {
      e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }
    let diff = swiper.isHorizontal() ? diffX : diffY;
    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
    if (params.oneWayMovement) {
      diff = Math.abs(diff) * (rtl ? 1 : -1);
      touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
    }
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) {
      diff = -diff;
      touchesDiff = -touchesDiff;
    }
    const prevTouchesDirection = swiper.touchesDirection;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
    const isLoop = swiper.params.loop && !params.cssMode;
    const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
    if (!data2.isMoved) {
      if (isLoop && allowLoopFix) {
        swiper.loopFix({
          direction: swiper.swipeDirection
        });
      }
      data2.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);
      if (swiper.animating) {
        const evt = new window.CustomEvent("transitionend", {
          bubbles: true,
          cancelable: true
        });
        swiper.wrapperEl.dispatchEvent(evt);
      }
      data2.allowMomentumBounce = false;
      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }
      swiper.emit("sliderFirstMove", e);
    }
    let loopFixed;
    (/* @__PURE__ */ new Date()).getTime();
    if (data2.isMoved && data2.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
        startTranslate: data2.currentTranslate
      });
      data2.loopSwapReset = true;
      data2.startTranslate = data2.currentTranslate;
      return;
    }
    swiper.emit("sliderMove", e);
    data2.isMoved = true;
    data2.currentTranslate = diff + data2.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if (diff > 0) {
      if (isLoop && allowLoopFix && !loopFixed && data2.allowThresholdMove && data2.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {
        swiper.loopFix({
          direction: "prev",
          setTranslate: true,
          activeSlideIndex: 0
        });
      }
      if (data2.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data2.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data2.startTranslate + diff) ** resistanceRatio;
        }
      }
    } else if (diff < 0) {
      if (isLoop && allowLoopFix && !loopFixed && data2.allowThresholdMove && data2.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {
        swiper.loopFix({
          direction: "next",
          setTranslate: true,
          activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
        });
      }
      if (data2.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) {
          data2.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data2.startTranslate - diff) ** resistanceRatio;
        }
      }
    }
    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    }
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data2.currentTranslate < data2.startTranslate) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data2.currentTranslate > data2.startTranslate) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
      data2.currentTranslate = data2.startTranslate;
    }
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data2.allowThresholdMove) {
        if (!data2.allowThresholdMove) {
          data2.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data2.currentTranslate = data2.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data2.currentTranslate = data2.startTranslate;
        return;
      }
    }
    if (!params.followFinger || params.cssMode)
      return;
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
      swiper.freeMode.onTouchMove();
    }
    swiper.updateProgress(data2.currentTranslate);
    swiper.setTranslate(data2.currentTranslate);
  }
  function onTouchEnd(event2) {
    const swiper = this;
    const data2 = swiper.touchEventsData;
    let e = event2;
    if (e.originalEvent)
      e = e.originalEvent;
    let targetTouch;
    const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
    if (!isTouchEvent) {
      if (data2.touchId !== null)
        return;
      if (e.pointerId !== data2.pointerId)
        return;
      targetTouch = e;
    } else {
      targetTouch = [...e.changedTouches].filter((t) => t.identifier === data2.touchId)[0];
      if (!targetTouch || targetTouch.identifier !== data2.touchId)
        return;
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e.type)) {
      const proceed = ["pointercancel", "contextmenu"].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
      if (!proceed) {
        return;
      }
    }
    data2.pointerId = null;
    data2.touchId = null;
    const {
      params,
      touches,
      rtlTranslate: rtl,
      slidesGrid,
      enabled
    } = swiper;
    if (!enabled)
      return;
    if (!params.simulateTouch && e.pointerType === "mouse")
      return;
    if (data2.allowTouchCallbacks) {
      swiper.emit("touchEnd", e);
    }
    data2.allowTouchCallbacks = false;
    if (!data2.isTouched) {
      if (data2.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }
      data2.isMoved = false;
      data2.startMoving = false;
      return;
    }
    if (params.grabCursor && data2.isMoved && data2.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    }
    const touchEndTime = now();
    const timeDiff = touchEndTime - data2.touchStartTime;
    if (swiper.allowClick) {
      const pathTree = e.path || e.composedPath && e.composedPath();
      swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
      swiper.emit("tap click", e);
      if (timeDiff < 300 && touchEndTime - data2.lastClickTime < 300) {
        swiper.emit("doubleTap doubleClick", e);
      }
    }
    data2.lastClickTime = now();
    nextTick2(() => {
      if (!swiper.destroyed)
        swiper.allowClick = true;
    });
    if (!data2.isTouched || !data2.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data2.loopSwapReset || data2.currentTranslate === data2.startTranslate && !data2.loopSwapReset) {
      data2.isTouched = false;
      data2.isMoved = false;
      data2.startMoving = false;
      return;
    }
    data2.isTouched = false;
    data2.isMoved = false;
    data2.startMoving = false;
    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data2.currentTranslate;
    }
    if (params.cssMode) {
      return;
    }
    if (params.freeMode && params.freeMode.enabled) {
      swiper.freeMode.onTouchEnd({
        currentPos
      });
      return;
    }
    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (typeof slidesGrid[i + increment2] !== "undefined") {
        if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment2] - slidesGrid[i];
        }
      } else if (swipeToLast || currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
      if (swiper.isBeginning) {
        rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
      } else if (swiper.isEnd) {
        rewindFirstIndex = 0;
      }
    }
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (swiper.swipeDirection === "next") {
        if (ratio >= params.longSwipesRatio)
          swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
        else
          swiper.slideTo(stopIndex);
      }
      if (swiper.swipeDirection === "prev") {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
          swiper.slideTo(rewindLastIndex);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === "next") {
          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
        }
        if (swiper.swipeDirection === "prev") {
          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
        }
      } else if (e.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }
  function onResize() {
    const swiper = this;
    const {
      params,
      el
    } = swiper;
    if (el && el.offsetWidth === 0)
      return;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    const {
      allowSlideNext,
      allowSlidePrev,
      snapGrid
    } = swiper;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    const isVirtualLoop = isVirtual && params.loop;
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      if (swiper.params.loop && !isVirtual) {
        swiper.slideToLoop(swiper.realIndex, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      clearTimeout(swiper.autoplay.resizeTimeout);
      swiper.autoplay.resizeTimeout = setTimeout(() => {
        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
          swiper.autoplay.resume();
        }
      }, 500);
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }
  function onClick(e) {
    const swiper = this;
    if (!swiper.enabled)
      return;
    if (!swiper.allowClick) {
      if (swiper.params.preventClicks)
        e.preventDefault();
      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }
  function onScroll() {
    const swiper = this;
    const {
      wrapperEl,
      rtlTranslate,
      enabled
    } = swiper;
    if (!enabled)
      return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
      swiper.translate = -wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    }
    if (swiper.translate === 0)
      swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit("setTranslate", swiper.translate, false);
  }
  function onLoad(e) {
    const swiper = this;
    processLazyPreloader(swiper, e.target);
    if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
      return;
    }
    swiper.update();
  }
  function onDocumentTouchStart() {
    const swiper = this;
    if (swiper.documentTouchHandlerProceeded)
      return;
    swiper.documentTouchHandlerProceeded = true;
    if (swiper.params.touchReleaseOnEdges) {
      swiper.el.style.touchAction = "auto";
    }
  }
  var events = (swiper, method) => {
    const document2 = getDocument();
    const {
      params,
      el,
      wrapperEl,
      device
    } = swiper;
    const capture = !!params.nested;
    const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method;
    document2[domMethod]("touchstart", swiper.onDocumentTouchStart, {
      passive: false,
      capture
    });
    el[domMethod]("touchstart", swiper.onTouchStart, {
      passive: false
    });
    el[domMethod]("pointerdown", swiper.onTouchStart, {
      passive: false
    });
    document2[domMethod]("touchmove", swiper.onTouchMove, {
      passive: false,
      capture
    });
    document2[domMethod]("pointermove", swiper.onTouchMove, {
      passive: false,
      capture
    });
    document2[domMethod]("touchend", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerup", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointercancel", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("touchcancel", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerout", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("pointerleave", swiper.onTouchEnd, {
      passive: true
    });
    document2[domMethod]("contextmenu", swiper.onTouchEnd, {
      passive: true
    });
    if (params.preventClicks || params.preventClicksPropagation) {
      el[domMethod]("click", swiper.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl[domMethod]("scroll", swiper.onScroll);
    }
    if (params.updateOnWindowResize) {
      swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
      swiper[swiperMethod]("observerUpdate", onResize, true);
    }
    el[domMethod]("load", swiper.onLoad, {
      capture: true
    });
  };
  function attachEvents() {
    const swiper = this;
    const {
      params
    } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    swiper.onLoad = onLoad.bind(swiper);
    events(swiper, "on");
  }
  function detachEvents() {
    const swiper = this;
    events(swiper, "off");
  }
  var events$1 = {
    attachEvents,
    detachEvents
  };
  var isGridEnabled = (swiper, params) => {
    return swiper.grid && params.grid && params.grid.rows > 1;
  };
  function setBreakpoint() {
    const swiper = this;
    const {
      realIndex,
      initialized,
      params,
      el
    } = swiper;
    const breakpoints2 = params.breakpoints;
    if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
      return;
    const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint)
      return;
    const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      el.classList.add(`${params.containerModifierClass}grid`);
      if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
        el.classList.add(`${params.containerModifierClass}grid-column`);
      }
      swiper.emitContainerClasses();
    }
    ["navigation", "pagination", "scrollbar"].forEach((prop) => {
      if (typeof breakpointParams[prop] === "undefined")
        return;
      const wasModuleEnabled = params[prop] && params[prop].enabled;
      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
      if (wasModuleEnabled && !isModuleEnabled) {
        swiper[prop].disable();
      }
      if (!wasModuleEnabled && isModuleEnabled) {
        swiper[prop].enable();
      }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    const wasLoop = params.loop;
    if (directionChanged && initialized) {
      swiper.changeDirection();
    }
    extend2(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    const hasLoop = swiper.params.loop;
    Object.assign(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
      swiper.disable();
    } else if (!wasEnabled && isEnabled) {
      swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (initialized) {
      if (needsReLoop) {
        swiper.loopDestroy();
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
      } else if (!wasLoop && hasLoop) {
        swiper.loopCreate(realIndex);
        swiper.updateSlides();
      } else if (wasLoop && !hasLoop) {
        swiper.loopDestroy();
      }
    }
    swiper.emit("breakpoint", breakpointParams);
  }
  function getBreakpoint(breakpoints2, base, containerEl) {
    if (base === void 0) {
      base = "window";
    }
    if (!breakpoints2 || base === "container" && !containerEl)
      return void 0;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints2).map((point) => {
      if (typeof point === "string" && point.indexOf("@") === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = currentHeight * minRatio;
        return {
          value,
          point
        };
      }
      return {
        value: point,
        point
      };
    });
    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
    for (let i = 0; i < points.length; i += 1) {
      const {
        point,
        value
      } = points[i];
      if (base === "window") {
        if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
          breakpoint = point;
        }
      } else if (value <= containerEl.clientWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || "max";
  }
  var breakpoints = {
    setBreakpoint,
    getBreakpoint
  };
  function prepareClasses(entries, prefix2) {
    const resultClasses = [];
    entries.forEach((item) => {
      if (typeof item === "object") {
        Object.keys(item).forEach((classNames) => {
          if (item[classNames]) {
            resultClasses.push(prefix2 + classNames);
          }
        });
      } else if (typeof item === "string") {
        resultClasses.push(prefix2 + item);
      }
    });
    return resultClasses;
  }
  function addClasses() {
    const swiper = this;
    const {
      classNames,
      params,
      rtl,
      el,
      device
    } = swiper;
    const suffixes = prepareClasses(["initialized", params.direction, {
      "free-mode": swiper.params.freeMode && params.freeMode.enabled
    }, {
      "autoheight": params.autoHeight
    }, {
      "rtl": rtl
    }, {
      "grid": params.grid && params.grid.rows > 1
    }, {
      "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
    }, {
      "android": device.android
    }, {
      "ios": device.ios
    }, {
      "css-mode": params.cssMode
    }, {
      "centered": params.cssMode && params.centeredSlides
    }, {
      "watch-progress": params.watchSlidesProgress
    }], params.containerModifierClass);
    classNames.push(...suffixes);
    el.classList.add(...classNames);
    swiper.emitContainerClasses();
  }
  function removeClasses() {
    const swiper = this;
    const {
      el,
      classNames
    } = swiper;
    el.classList.remove(...classNames);
    swiper.emitContainerClasses();
  }
  var classes = {
    addClasses,
    removeClasses
  };
  function checkOverflow() {
    const swiper = this;
    const {
      isLocked: wasLocked,
      params
    } = swiper;
    const {
      slidesOffsetBefore
    } = params;
    if (slidesOffsetBefore) {
      const lastSlideIndex = swiper.slides.length - 1;
      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
      swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
      swiper.allowSlideNext = !swiper.isLocked;
    }
    if (params.allowSlidePrev === true) {
      swiper.allowSlidePrev = !swiper.isLocked;
    }
    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
    }
    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? "lock" : "unlock");
    }
  }
  var checkOverflow$1 = {
    checkOverflow
  };
  var defaults = {
    init: true,
    direction: "horizontal",
    oneWayMovement: false,
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    eventsPrefix: "swiper",
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 5,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // loop
    loop: false,
    loopAddBlankSlides: true,
    loopAdditionalSlides: 0,
    loopPreventsSliding: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
  };
  function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj) {
      if (obj === void 0) {
        obj = {};
      }
      const moduleParamName = Object.keys(obj)[0];
      const moduleParams = obj[moduleParamName];
      if (typeof moduleParams !== "object" || moduleParams === null) {
        extend2(allModulesParams, obj);
        return;
      }
      if (params[moduleParamName] === true) {
        params[moduleParamName] = {
          enabled: true
        };
      }
      if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
        params[moduleParamName].auto = true;
      }
      if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
        params[moduleParamName].auto = true;
      }
      if (!(moduleParamName in params && "enabled" in moduleParams)) {
        extend2(allModulesParams, obj);
        return;
      }
      if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
        params[moduleParamName].enabled = true;
      }
      if (!params[moduleParamName])
        params[moduleParamName] = {
          enabled: false
        };
      extend2(allModulesParams, obj);
    };
  }
  var prototypes = {
    eventsEmitter,
    update,
    translate,
    transition: transition2,
    slide,
    loop: loop2,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
  };
  var extendedDefaults = {};
  var Swiper = class {
    constructor() {
      let el;
      let params;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params)
        params = {};
      params = extend2({}, params);
      if (el && !params.el)
        params.el = el;
      const document2 = getDocument();
      if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
        const swipers = [];
        document2.querySelectorAll(params.el).forEach((containerEl) => {
          const newParams = extend2({}, params, {
            el: containerEl
          });
          swipers.push(new Swiper(newParams));
        });
        return swipers;
      }
      const swiper = this;
      swiper.__swiper__ = true;
      swiper.support = getSupport();
      swiper.device = getDevice({
        userAgent: params.userAgent
      });
      swiper.browser = getBrowser();
      swiper.eventsListeners = {};
      swiper.eventsAnyListeners = [];
      swiper.modules = [...swiper.__modules__];
      if (params.modules && Array.isArray(params.modules)) {
        swiper.modules.push(...params.modules);
      }
      const allModulesParams = {};
      swiper.modules.forEach((mod) => {
        mod({
          params,
          swiper,
          extendParams: moduleExtendParams(params, allModulesParams),
          on: swiper.on.bind(swiper),
          once: swiper.once.bind(swiper),
          off: swiper.off.bind(swiper),
          emit: swiper.emit.bind(swiper)
        });
      });
      const swiperParams = extend2({}, defaults, allModulesParams);
      swiper.params = extend2({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = extend2({}, swiper.params);
      swiper.passedParams = extend2({}, params);
      if (swiper.params && swiper.params.on) {
        Object.keys(swiper.params.on).forEach((eventName) => {
          swiper.on(eventName, swiper.params.on[eventName]);
        });
      }
      if (swiper.params && swiper.params.onAny) {
        swiper.onAny(swiper.params.onAny);
      }
      Object.assign(swiper, {
        enabled: swiper.params.enabled,
        el,
        // Classes
        classNames: [],
        // Slides
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal() {
          return swiper.params.direction === "horizontal";
        },
        isVertical() {
          return swiper.params.direction === "vertical";
        },
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          // Form elements to match
          focusableElements: swiper.params.focusableElements,
          // Last click time
          lastClickTime: 0,
          clickTimeout: void 0,
          // Velocities
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      });
      swiper.emit("_swiper");
      if (swiper.params.init) {
        swiper.init();
      }
      return swiper;
    }
    getDirectionLabel(property) {
      if (this.isHorizontal()) {
        return property;
      }
      return {
        "width": "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        "marginRight": "marginBottom"
      }[property];
    }
    getSlideIndex(slideEl) {
      const {
        slidesEl,
        params
      } = this;
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      const firstSlideIndex = elementIndex(slides[0]);
      return elementIndex(slideEl) - firstSlideIndex;
    }
    getSlideIndexByData(index) {
      return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index)[0]);
    }
    recalcSlides() {
      const swiper = this;
      const {
        slidesEl,
        params
      } = swiper;
      swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    }
    enable() {
      const swiper = this;
      if (swiper.enabled)
        return;
      swiper.enabled = true;
      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }
      swiper.emit("enable");
    }
    disable() {
      const swiper = this;
      if (!swiper.enabled)
        return;
      swiper.enabled = false;
      if (swiper.params.grabCursor) {
        swiper.unsetGrabCursor();
      }
      swiper.emit("disable");
    }
    setProgress(progress, speed) {
      const swiper = this;
      progress = Math.min(Math.max(progress, 0), 1);
      const min = swiper.minTranslate();
      const max = swiper.maxTranslate();
      const current = (max - min) * progress + min;
      swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el)
        return;
      const cls = swiper.el.className.split(" ").filter((className) => {
        return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
      });
      swiper.emit("_containerClasses", cls.join(" "));
    }
    getSlideClasses(slideEl) {
      const swiper = this;
      if (swiper.destroyed)
        return "";
      return slideEl.className.split(" ").filter((className) => {
        return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
      }).join(" ");
    }
    emitSlidesClasses() {
      const swiper = this;
      if (!swiper.params._emitClasses || !swiper.el)
        return;
      const updates = [];
      swiper.slides.forEach((slideEl) => {
        const classNames = swiper.getSlideClasses(slideEl);
        updates.push({
          slideEl,
          classNames
        });
        swiper.emit("_slideClass", slideEl, classNames);
      });
      swiper.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view, exact) {
      if (view === void 0) {
        view = "current";
      }
      if (exact === void 0) {
        exact = false;
      }
      const swiper = this;
      const {
        params,
        slides,
        slidesGrid,
        slidesSizesGrid,
        size: swiperSize,
        activeIndex
      } = swiper;
      let spv = 1;
      if (typeof params.slidesPerView === "number")
        return params.slidesPerView;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;
        let breakLoop;
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize)
              breakLoop = true;
          }
        }
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize)
              breakLoop = true;
          }
        }
      } else {
        if (view === "current") {
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        } else {
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
            if (slideInView) {
              spv += 1;
            }
          }
        }
      }
      return spv;
    }
    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed)
        return;
      const {
        snapGrid,
        params
      } = swiper;
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
      [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        }
      });
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      function setTranslate2() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      let translated;
      if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
        setTranslate2();
        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
          const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
          translated = swiper.slideTo(slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate2();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
      swiper.emit("update");
    }
    changeDirection(newDirection, needUpdate) {
      if (needUpdate === void 0) {
        needUpdate = true;
      }
      const swiper = this;
      const currentDirection = swiper.params.direction;
      if (!newDirection) {
        newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
      }
      if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
        return swiper;
      }
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
      swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
      swiper.emitContainerClasses();
      swiper.params.direction = newDirection;
      swiper.slides.forEach((slideEl) => {
        if (newDirection === "vertical") {
          slideEl.style.width = "";
        } else {
          slideEl.style.height = "";
        }
      });
      swiper.emit("changeDirection");
      if (needUpdate)
        swiper.update();
      return swiper;
    }
    changeLanguageDirection(direction) {
      const swiper = this;
      if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr")
        return;
      swiper.rtl = direction === "rtl";
      swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
      if (swiper.rtl) {
        swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "rtl";
      } else {
        swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
        swiper.el.dir = "ltr";
      }
      swiper.update();
    }
    mount(element) {
      const swiper = this;
      if (swiper.mounted)
        return true;
      let el = element || swiper.params.el;
      if (typeof el === "string") {
        el = document.querySelector(el);
      }
      if (!el) {
        return false;
      }
      el.swiper = swiper;
      if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === "SWIPER-CONTAINER") {
        swiper.isElement = true;
      }
      const getWrapperSelector = () => {
        return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
      };
      const getWrapper = () => {
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          const res = el.shadowRoot.querySelector(getWrapperSelector());
          return res;
        }
        return elementChildren(el, getWrapperSelector())[0];
      };
      let wrapperEl = getWrapper();
      if (!wrapperEl && swiper.params.createElements) {
        wrapperEl = createElement("div", swiper.params.wrapperClass);
        el.append(wrapperEl);
        elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl) => {
          wrapperEl.append(slideEl);
        });
      }
      Object.assign(swiper, {
        el,
        wrapperEl,
        slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
        hostEl: swiper.isElement ? el.parentNode.host : el,
        mounted: true,
        // RTL
        rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
        rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
        wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
      });
      return true;
    }
    init(el) {
      const swiper = this;
      if (swiper.initialized)
        return swiper;
      const mounted = swiper.mount(el);
      if (mounted === false)
        return swiper;
      swiper.emit("beforeInit");
      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      }
      swiper.addClasses();
      swiper.updateSize();
      swiper.updateSlides();
      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }
      if (swiper.params.grabCursor && swiper.enabled) {
        swiper.setGrabCursor();
      }
      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
      }
      if (swiper.params.loop) {
        swiper.loopCreate();
      }
      swiper.attachEvents();
      const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
      if (swiper.isElement) {
        lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
      }
      lazyElements.forEach((imageEl) => {
        if (imageEl.complete) {
          processLazyPreloader(swiper, imageEl);
        } else {
          imageEl.addEventListener("load", (e) => {
            processLazyPreloader(swiper, e.target);
          });
        }
      });
      preload(swiper);
      swiper.initialized = true;
      preload(swiper);
      swiper.emit("init");
      swiper.emit("afterInit");
      return swiper;
    }
    destroy(deleteInstance, cleanStyles) {
      if (deleteInstance === void 0) {
        deleteInstance = true;
      }
      if (cleanStyles === void 0) {
        cleanStyles = true;
      }
      const swiper = this;
      const {
        params,
        el,
        wrapperEl,
        slides
      } = swiper;
      if (typeof swiper.params === "undefined" || swiper.destroyed) {
        return null;
      }
      swiper.emit("beforeDestroy");
      swiper.initialized = false;
      swiper.detachEvents();
      if (params.loop) {
        swiper.loopDestroy();
      }
      if (cleanStyles) {
        swiper.removeClasses();
        el.removeAttribute("style");
        wrapperEl.removeAttribute("style");
        if (slides && slides.length) {
          slides.forEach((slideEl) => {
            slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            slideEl.removeAttribute("style");
            slideEl.removeAttribute("data-swiper-slide-index");
          });
        }
      }
      swiper.emit("destroy");
      Object.keys(swiper.eventsListeners).forEach((eventName) => {
        swiper.off(eventName);
      });
      if (deleteInstance !== false) {
        swiper.el.swiper = null;
        deleteProps(swiper);
      }
      swiper.destroyed = true;
      return null;
    }
    static extendDefaults(newDefaults) {
      extend2(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
      return extendedDefaults;
    }
    static get defaults() {
      return defaults;
    }
    static installModule(mod) {
      if (!Swiper.prototype.__modules__)
        Swiper.prototype.__modules__ = [];
      const modules = Swiper.prototype.__modules__;
      if (typeof mod === "function" && modules.indexOf(mod) < 0) {
        modules.push(mod);
      }
    }
    static use(module) {
      if (Array.isArray(module)) {
        module.forEach((m) => Swiper.installModule(m));
        return Swiper;
      }
      Swiper.installModule(module);
      return Swiper;
    }
  };
  Object.keys(prototypes).forEach((prototypeGroup) => {
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
  });
  Swiper.use([Resize, Observer]);

  // node_modules/swiper/shared/effect-init.mjs
  function effectInit(params) {
    const {
      effect: effect2,
      swiper,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      overwriteParams,
      perspective,
      recreateShadows,
      getEffectParams
    } = params;
    on2("beforeInit", () => {
      if (swiper.params.effect !== effect2)
        return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}${effect2}`);
      if (perspective && perspective()) {
        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      }
      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
      Object.assign(swiper.params, overwriteParamsResult);
      Object.assign(swiper.originalParams, overwriteParamsResult);
    });
    on2("setTranslate", () => {
      if (swiper.params.effect !== effect2)
        return;
      setTranslate2();
    });
    on2("setTransition", (_s, duration) => {
      if (swiper.params.effect !== effect2)
        return;
      setTransition2(duration);
    });
    on2("transitionEnd", () => {
      if (swiper.params.effect !== effect2)
        return;
      if (recreateShadows) {
        if (!getEffectParams || !getEffectParams().slideShadows)
          return;
        swiper.slides.forEach((slideEl) => {
          slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl) => shadowEl.remove());
        });
        recreateShadows();
      }
    });
    let requireUpdateOnVirtual;
    on2("virtualUpdate", () => {
      if (swiper.params.effect !== effect2)
        return;
      if (!swiper.slides.length) {
        requireUpdateOnVirtual = true;
      }
      requestAnimationFrame(() => {
        if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
          setTranslate2();
          requireUpdateOnVirtual = false;
        }
      });
    });
  }

  // node_modules/swiper/shared/effect-target.mjs
  function effectTarget(effectParams, slideEl) {
    const transformEl = getSlideTransformEl(slideEl);
    if (transformEl !== slideEl) {
      transformEl.style.backfaceVisibility = "hidden";
      transformEl.style["-webkit-backface-visibility"] = "hidden";
    }
    return transformEl;
  }

  // node_modules/swiper/shared/effect-virtual-transition-end.mjs
  function effectVirtualTransitionEnd(_ref) {
    let {
      swiper,
      duration,
      transformElements,
      allSlides
    } = _ref;
    const {
      activeIndex
    } = swiper;
    const getSlide = (el) => {
      if (!el.parentElement) {
        const slide2 = swiper.slides.filter((slideEl) => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];
        return slide2;
      }
      return el.parentElement;
    };
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      let transitionEndTarget;
      if (allSlides) {
        transitionEndTarget = transformElements;
      } else {
        transitionEndTarget = transformElements.filter((transformEl) => {
          const el = transformEl.classList.contains("swiper-slide-transform") ? getSlide(transformEl) : transformEl;
          return swiper.getSlideIndex(el) === activeIndex;
        });
      }
      transitionEndTarget.forEach((el) => {
        elementTransitionEnd(el, () => {
          if (eventTriggered)
            return;
          if (!swiper || swiper.destroyed)
            return;
          eventTriggered = true;
          swiper.animating = false;
          const evt = new window.CustomEvent("transitionend", {
            bubbles: true,
            cancelable: true
          });
          swiper.wrapperEl.dispatchEvent(evt);
        });
      });
    }
  }

  // node_modules/swiper/shared/create-shadow.mjs
  function createShadow(suffix, slideEl, side) {
    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ""}${suffix ? ` swiper-slide-shadow-${suffix}` : ""}`;
    const shadowContainer = getSlideTransformEl(slideEl);
    let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(" ").join(".")}`);
    if (!shadowEl) {
      shadowEl = createElement("div", shadowClass.split(" "));
      shadowContainer.append(shadowEl);
    }
    return shadowEl;
  }

  // node_modules/swiper/modules/effect-cards.mjs
  function EffectCards(_ref) {
    let {
      swiper,
      extendParams,
      on: on2
    } = _ref;
    extendParams({
      cardsEffect: {
        slideShadows: true,
        rotate: true,
        perSlideRotate: 2,
        perSlideOffset: 8
      }
    });
    const setTranslate2 = () => {
      const {
        slides,
        activeIndex,
        rtlTranslate: rtl
      } = swiper;
      const params = swiper.params.cardsEffect;
      const {
        startTranslate,
        isTouched
      } = swiper.touchEventsData;
      const currentTranslate = rtl ? -swiper.translate : swiper.translate;
      for (let i = 0; i < slides.length; i += 1) {
        const slideEl = slides[i];
        const slideProgress = slideEl.progress;
        const progress = Math.min(Math.max(slideProgress, -4), 4);
        let offset = slideEl.swiperSlideOffset;
        if (swiper.params.centeredSlides && !swiper.params.cssMode) {
          swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
        }
        if (swiper.params.centeredSlides && swiper.params.cssMode) {
          offset -= slides[0].swiperSlideOffset;
        }
        let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
        let tY = 0;
        const tZ = -100 * Math.abs(progress);
        let scale = 1;
        let rotate = -params.perSlideRotate * progress;
        let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
        const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
        const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
        const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
        if (isSwipeToNext || isSwipeToPrev) {
          const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
          rotate += -28 * progress * subProgress;
          scale += -0.5 * subProgress;
          tXAdd += 96 * subProgress;
          tY = `${-25 * subProgress * Math.abs(progress)}%`;
        }
        if (progress < 0) {
          tX = `calc(${tX}px ${rtl ? "-" : "+"} (${tXAdd * Math.abs(progress)}%))`;
        } else if (progress > 0) {
          tX = `calc(${tX}px ${rtl ? "-" : "+"} (-${tXAdd * Math.abs(progress)}%))`;
        } else {
          tX = `${tX}px`;
        }
        if (!swiper.isHorizontal()) {
          const prevY = tY;
          tY = tX;
          tX = prevY;
        }
        const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
        const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
        if (params.slideShadows) {
          let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
          if (!shadowEl) {
            shadowEl = createShadow("cards", slideEl);
          }
          if (shadowEl)
            shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
        }
        slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
        const targetEl = effectTarget(params, slideEl);
        targetEl.style.transform = transform;
      }
    };
    const setTransition2 = (duration) => {
      const transformElements = swiper.slides.map((slideEl) => getSlideTransformEl(slideEl));
      transformElements.forEach((el) => {
        el.style.transitionDuration = `${duration}ms`;
        el.querySelectorAll(".swiper-slide-shadow").forEach((shadowEl) => {
          shadowEl.style.transitionDuration = `${duration}ms`;
        });
      });
      effectVirtualTransitionEnd({
        swiper,
        duration,
        transformElements
      });
    };
    effectInit({
      effect: "cards",
      swiper,
      on: on2,
      setTranslate: setTranslate2,
      setTransition: setTransition2,
      perspective: () => true,
      overwriteParams: () => ({
        watchSlidesProgress: true,
        virtualTranslate: !swiper.params.cssMode
      })
    });
  }

  // js/agora.js
  var import_agora_rtc_sdk_ng = __toESM(require_AgoraRTC_N_production());
  var DEFAULT_STATE = {
    channel: {
      localAudioTrack: null,
      remoteAudioTrack: null,
      remoteUid: null
    },
    isMuted: true,
    joined: false,
    agoraEngine: null,
    currentView: null,
    isConnecting: false
  };
  var state = __spreadValues({}, DEFAULT_STATE);
  function validateAgoraOptions(options) {
    const required = ["appId", "channel", "uid"];
    for (const field of required) {
      if (!options[field]) {
        throw new Error(`Missing required field: ${field}`);
      }
    }
  }
  function updateMuteUI(isMuted) {
    const mutedElement = document.getElementById("muted");
    const unmutedElement = document.getElementById("unmuted");
    const toggleMuteButton = document.getElementById("toggle-mute");
    if (!toggleMuteButton || !mutedElement || !unmutedElement)
      return;
    toggleMuteButton.classList.toggle("bg-gray-100", isMuted);
    toggleMuteButton.classList.toggle("bg-white", !isMuted);
    mutedElement.style.display = isMuted ? "block" : "none";
    unmutedElement.style.display = isMuted ? "none" : "block";
  }
  async function joinChannelAsListener() {
    if (state.joined)
      return;
    try {
      validateAgoraOptions(agoraOptions);
      await state.agoraEngine.join(
        agoraOptions.appId,
        agoraOptions.channel,
        null,
        agoraOptions.uid
      );
      state.joined = true;
      console.log("Joined channel as listener");
    } catch (error2) {
      console.error("Error joining channel as listener:", error2);
      state.joined = false;
      throw error2;
    }
  }
  async function publishAudio() {
    if (!state.joined) {
      throw new Error("Must join channel before publishing");
    }
    try {
      state.channel.localAudioTrack = await import_agora_rtc_sdk_ng.default.createMicrophoneAudioTrack();
      state.channel.localAudioTrack.setEnabled(true);
      await state.agoraEngine.publish(state.channel.localAudioTrack);
      console.log("Published audio track successfully");
    } catch (error2) {
      console.error("Error publishing audio:", error2);
      throw error2;
    }
  }
  async function setupVoiceChannel() {
    if (state.isConnecting)
      return;
    state.isConnecting = true;
    try {
      await initializeAgoraEngine();
      if (!state.joined) {
        await joinChannelAsListener();
      }
      await publishAudio();
      state.isMuted = false;
      updateMuteUI(false);
    } catch (error2) {
      console.error("Error setting up voice channel:", error2);
      state.isMuted = true;
      updateMuteUI(true);
      await cleanup();
    } finally {
      state.isConnecting = false;
    }
  }
  function setupMuteToggle() {
    const toggleMuteButton = document.getElementById("toggle-mute");
    console.log("setupMuteToggle", toggleMuteButton);
    if (!toggleMuteButton)
      return;
    updateMuteUI(state.isMuted);
    toggleMuteButton.onclick = async function() {
      var _a;
      if (state.isConnecting)
        return;
      console.log();
      try {
        if (state.isMuted) {
          if (!state.channel.localAudioTrack) {
            await setupVoiceChannel();
          } else {
            state.isMuted = false;
            updateMuteUI(false);
            await state.channel.localAudioTrack.setEnabled(true);
          }
        } else {
          state.isMuted = true;
          updateMuteUI(true);
          await ((_a = state.channel.localAudioTrack) == null ? void 0 : _a.setEnabled(false));
        }
      } catch (error2) {
        console.error("Error toggling mute:", error2);
        state.isMuted = true;
        updateMuteUI(true);
      }
    };
  }
  async function handleUserPublished(user, mediaType) {
    try {
      await state.agoraEngine.subscribe(user, mediaType);
      console.log("subscribe success");
      if (mediaType === "audio") {
        state.channel.remoteUid = user.uid;
        state.channel.remoteAudioTrack = user.audioTrack;
        state.channel.remoteAudioTrack.play();
      }
    } catch (error2) {
      console.error("Error handling user published:", error2);
    }
  }
  function handleUserUnpublished(user) {
    var _a;
    if (state.channel.remoteUid === user.uid) {
      (_a = state.channel.remoteAudioTrack) == null ? void 0 : _a.stop();
      state.channel.remoteAudioTrack = null;
      state.channel.remoteUid = null;
    }
    console.log(`${user.uid} has left the channel`);
  }
  function initializeAgoraEngine() {
    if (state.agoraEngine) {
      return;
    }
    try {
      state.agoraEngine = import_agora_rtc_sdk_ng.default.createClient({ mode: "rtc", codec: "vp9" });
      state.agoraEngine.on("user-published", handleUserPublished);
      state.agoraEngine.on("user-unpublished", handleUserUnpublished);
    } catch (error2) {
      console.error("Error initializing Agora engine:", error2);
      throw error2;
    }
  }
  async function cleanup() {
    console.log("cleanup");
    try {
      if (state.channel.localAudioTrack) {
        await state.channel.localAudioTrack.setEnabled(false);
        state.channel.localAudioTrack.close();
      }
      if (state.channel.remoteAudioTrack) {
        state.channel.remoteAudioTrack.stop();
      }
      if (state.joined && state.agoraEngine) {
        await state.agoraEngine.leave();
      }
      if (state.agoraEngine) {
        state.agoraEngine.removeAllListeners();
      }
      Object.assign(state, DEFAULT_STATE);
      updateMuteUI(true);
    } catch (error2) {
      console.error("Error during cleanup:", error2);
      Object.assign(state, DEFAULT_STATE);
    }
  }
  function startBasicCall(view) {
    if (!view) {
      console.error("View parameter is required");
      return;
    }
    if (state.currentView === view)
      return;
    try {
      if (state.currentView) {
        cleanup();
      }
      state.currentView = view;
      setupMuteToggle();
      initializeAgoraEngine();
      joinChannelAsListener().catch((error2) => {
        console.error("Error joining as listener:", error2);
      });
    } catch (error2) {
      console.error("Error starting basic call:", error2);
      cleanup();
    }
  }

  // js/app.js
  module_default.plugin(src_default2);
  var hooks = {
    VoiceCall: {
      mounted() {
        const view = this.el.dataset.view;
        console.log(`VoiceCall mounted for ${view}`);
        startBasicCall(view);
      },
      destroyed() {
        cleanup();
      }
    },
    Swiper: {
      mounted() {
        console.log("Swiper mounted");
        this.initializeSwiper();
      },
      updated() {
        this.swiper.destroy(true, true);
        this.initializeSwiper();
      },
      destroyed() {
        if (this.swiper) {
          this.swiper.destroy(true, true);
        }
      },
      initializeSwiper() {
        this.swiper = new Swiper(".deck", {
          modules: [EffectCards],
          effect: "cards",
          cardsEffect: {
            perSlideOffset: 8,
            perSlideRotate: 2
          },
          slidesPerView: 1,
          centeredSlides: true,
          loop: false,
          navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev"
          }
        });
      }
    }
  };
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, {
    params: { _csrf_token: csrfToken },
    dom: {
      onBeforeElUpdated(from, to) {
        if (from._x_dataStack) {
          window.Alpine.clone(from, to);
        }
      }
    },
    hooks
  });
  window.Alpine = module_default;
  module_default.start();
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (info) => import_topbar.default.show());
  window.addEventListener("phx:page-loading-stop", (info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/*! Bundled license information:

topbar/topbar.min.js:
  (**
   * @license MIT
   * topbar 1.0.0, 2021-01-06
   * http://buunguyen.github.io/topbar
   * Copyright (c) 2021 Buu Nguyen
   *)

agora-rtc-sdk-ng/AgoraRTC_N-production.js:
  (*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> *)
*/
